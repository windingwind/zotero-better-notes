<?xml version="1.0"?>
<!-- prettier-ignore -->
<!DOCTYPE html>
<html
  lang="en"
  xmlns="http://www.w3.org/1999/xhtml"
  xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
  xmlns:html="http://www.w3.org/1999/xhtml"
>
  <head>
    <meta charset="utf-8" />
    <style>
      html,
      body,
      browser {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
      }
    </style>
    <script>
      var browser;
      var { Services } = ChromeUtils.import(
        "resource://gre/modules/Services.jsm",
      );
      var { XPCOMUtils } = ChromeUtils.import(
        "resource://gre/modules/XPCOMUtils.jsm",
      );
      window.XPCOMUtils = XPCOMUtils;

      const scope = {};
      Services.scriptloader.loadSubScript(
        // Borrowed from https://github.com/mozilla/releases-comm-central/commit/32a80889f13918c8776e2a3cf42abb85f6d84cdd#diff-6bebd8bc8a129ee1f12c757394ed9d549f3a20296277cd95b9cc0c3c5d75b739
        "chrome://__addonRef__/content/lib/js/printUtils.js",
        scope,
      );
      window.PrintUtils = scope.PrintUtils;

      const args = window.arguments[0];
      let loaded = false;
      document.addEventListener("DOMContentLoaded", async (ev) => {
        if (loaded) {
          return;
        }
        browser = PrintUtils.createBrowser();
        document.body.appendChild(browser);
        browser.contentWindow.location.href = args.url;
        console.log("loading");
        loaded = true;
        await waitUtilAsync(() => {
          console.log(browser, browser.contentWindow);
          return browser.contentWindow?.document.readyState === "complete";
        });
        console.log("loaded");
        args.browser = browser;
        args._initPromise.resolve();
      });
      async function waitUtilAsync(condition, interval = 100, timeout = 10000) {
        return new Promise((resolve, reject) => {
          const start = Date.now();
          const intervalId = setInterval(() => {
            if (condition()) {
              clearInterval(intervalId);
              resolve();
            } else if (Date.now() - start > timeout) {
              clearInterval(intervalId);
              reject();
            }
          }, interval);
        });
      }
      window.print = async () => {
        scope.PrintUtils.startPrintWindow(browser.browsingContext);
      };
    </script>
  </head>
  <body></body>
</html>
