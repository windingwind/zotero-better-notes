




// Type definitions for Zotero
// Project: https://github.com/windingwind/zotero-types#readme
// Definitions by: windingwind <https://github.com/windingwind>
//                 volatile-static <https://github.com/volatile-static>
// Definitions:



declare namespace _ZoteroTypes {
  type anyObj = { [key: string]: any };
  type MaybePromise<T> = T | Promise<T>;
  type MaybeArray<T> = T | Array<T>;
  type ZoteroObjectURI = string;
  type RelationsPredicate = "dc:relation" | "owl:sameAs" | "dc:replaces";
  type ObjectRelations = Record<
    _ZoteroTypes.RelationsPredicate,
    _ZoteroTypes.ZoteroObjectURI[]
  >;
  type IconURI = `chrome://zotero/skin/${string}`;
  // TODO: Add more specific types for icon URIs
  enum IconFile {}

  type React = typeof import("react");

  interface MainWindow extends Window {
    readonly Zotero: Zotero;
    readonly ZoteroPane: ZoteroPane;
    readonly ZoteroPane_Local: ZoteroPane;
    readonly Zotero_Tabs: _ZoteroTypes.Zotero_Tabs;
    readonly ZoteroContextPane: ZoteroContextPane;
    readonly Zotero_File_Interface: Zotero_File_Interface;

    readonly Components: nsIXPCComponents;
    readonly Cc: nsIXPCComponents_Classes;
    readonly Ci: nsIXPCComponents_Interfaces;
    readonly Cr: nsIXPCComponents_Results;
    readonly Cu: nsIXPCComponents_Utils;

    readonly Services: JSServices;
    readonly NetUtil: anyObj;

    readonly document: Document;
  }
}


declare namespace _ZoteroTypes {
  interface CollectionTree extends LibraryTree {
    [attr: string]: any;
    /**
     * Return a reference to the tree row at a given row
     *
     * @return {TreeRow}
     */
    getRow(index: number): Zotero.CollectionTreeRow;
  }
}


declare namespace _ZoteroTypes {
  class XULElementBase extends HTMLElement {
    initialized: false;
    get content(): null | DocumentFragment;
    init(): void;
    destroy(): void;
    connectedCallback(): void;
    disconnectedCallback(): void;
    _handleWindowUnload(): void;
  }
}



declare namespace _ZoteroTypes {
  class ItemPane extends XULElementBase {
    get content(): DocumentFragment;
    collectionTreeRow: any;
    itemsView: any;
    editable: boolean;
    mode: "message" | "item" | "note" | "duplicates";
    render(): boolean;
    notify(action: "modify", type: "item"): void;
    renderNoteEditor(item: Zotero.Item): void;
    renderItemPane(item: Zotero.Item): true;
    renderMessage(): boolean;
    setItemPaneMessage(message: string): void;

    /**
     * Display buttons at top of item pane depending on context
     */
    updateItemPaneButtons(): void;

    renderPublicationsHead(data: {
      doc: Document;
      append: Document["append"];
    }): void;
    renderTrashHead(data: { doc: Document; append: Document["append"] }): void;
    renderFeedHead(data: { doc: Document; append: Document["append"] }): void;
    updateReadLabel(): void;
    setReadLabel(isRead: boolean): void;
    translateSelectedItems(): Promise<void>;
    buildTranslateSelectContextMenu(event: Event): void;
    setTranslateButton(): void;
    setTranslationTarget(translationTarget: unknown): void;
    static get observedAttributes():
      | "collapsed"
      | "width"
      | "height"
      | "view-type";
    attributeChangedCallback(
      name: "collapsed" | "width" | "height" | "view-type",
      oldValue?: string,
      newValue?: string,
    ): void;
    handleBlur(): Promise<void>;
    handleResize(): void;
  }
}


declare namespace _ZoteroTypes {
  class ItemPaneSectionElementBase extends XULElementBase {
    initCollapsibleSection(): void;
  }
  class ItemPaneCustomSection extends ItemPaneSectionElementBase {
    _hooks: {
      [hook in keyof ItemPaneManagerSection.SectionHook]?: ItemPaneManagerSection.SectionHook[hook];
    };
    _sectionButtons: Record<
      string,
      Omit<ItemPaneManagerSection.SectionButton, "type">
    >;
    _refreshDisabled: boolean;
    paneID: string;
    bodyXHTML: string;
    setL10nID(id: string): void;
    setL10nArgs(args: string): void;
    registerSectionIcon(icon: { icon: string; darkIcon?: string }): void;
    updateSectionIcon(): void;
    registerSectionButton(button: ItemPaneManagerSection.SectionButton): void;
    registerHook<T extends keyof ItemPaneManagerSection.SectionHook>(options: {
      type: T;
      callback: ItemPaneManagerSection.SectionHook[T];
    }): void;
    render(): false | void;
    asyncRender(): Promise<void | false>;
  }
}

// @ts-nocheck
/**
 * NOTE: Do not modify this file by hand.
 * Content was generated from source XPCOM .idl files.
 * If you're updating some of the sources, see README for instructions.
 */

declare global {

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleMacInterface.idl

interface nsIAccessibleMacNSObjectWrapper extends nsISupports {
}

interface nsIAccessibleMacInterface extends nsISupports {
  readonly attributeNames: string[];
  readonly parameterizedAttributeNames: string[];
  readonly actionNames: string[];
  getAttributeValue(attributeName: string): any;
  getParameterizedAttributeValue(attributeName: string, parameter: any): any;
  performAction(actionName: string): void;
  isAttributeSettable(attributeName: string): boolean;
  setAttributeValue(attributeName: string, attributeValue: any): void;
}

interface nsIAccessibleMacEvent extends nsISupports {
  readonly macIface: nsIAccessibleMacInterface;
  readonly data: any;
}

// https://searchfox.org/mozilla-central/source/browser/components/migration/nsIKeychainMigrationUtils.idl

interface nsIKeychainMigrationUtils extends nsISupports {
  getGenericPassword(aServiceName: string, aAccountName: string): string;
}

// https://searchfox.org/mozilla-central/source/browser/components/shell/nsIMacShellService.idl

interface nsIMacShellService extends nsIShellService {
  showDesktopPreferences(): void;
  showSecurityPreferences(aPaneID: string): void;
  getAvailableApplicationsForProtocol(protocol: string): string[][];
}

// https://searchfox.org/mozilla-central/source/widget/nsIMacDockSupport.idl

interface nsIAppBundleLaunchOptions extends nsISupports {
  readonly addsToRecentItems: boolean;
}

interface nsIMacDockSupport extends nsISupports {
  dockMenu: nsIStandaloneNativeMenu;
  activateApplication(aIgnoreOtherApplications: boolean): void;
  badgeText: string;
  setBadgeImage(aBadgeImage: imgIContainer, aPaintContext?: nsISVGPaintContext): void;
  readonly isAppInDock: boolean;
  ensureAppIsPinnedToDock(aAppPath?: string, aAppToReplacePath?: string): boolean;
  launchAppBundle(aAppBundle: nsIFile, aArgs: string[], aLaunchOptions?: nsIAppBundleLaunchOptions): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIMacFinderProgress.idl

type nsIMacFinderProgressCanceledCallback = Callable<{
  canceled(): void;
}>

interface nsIMacFinderProgress extends nsISupports {
  init(path: string, canceledCallback: nsIMacFinderProgressCanceledCallback): void;
  updateProgress(currentProgress: u64, totalProgress: u64): void;
  end(): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIMacSharingService.idl

interface nsIMacSharingService extends nsISupports {
  getSharingProviders(pageUrl: string): any;
  shareUrl(serviceName: string, pageUrl: string, pageTitle: string): void;
  openSharingPreferences(): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIMacUserActivityUpdater.idl

interface nsIMacUserActivityUpdater extends nsISupports {
  updateLocation(pageUrl: string, pageTitle: string, window: nsIBaseWindow): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIMacWebAppUtils.idl

type nsITrashAppCallback = Callable<{
  trashAppFinished(rv: nsresult): void;
}>

interface nsIMacWebAppUtils extends nsISupports {
  pathForAppWithIdentifier(bundleIdentifier: string): string;
  launchAppWithIdentifier(bundleIdentifier: string): void;
  trashApp(path: string, callback: nsITrashAppCallback): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIStandaloneNativeMenu.idl

interface nsIStandaloneNativeMenu extends nsISupports {
  init(aElement: Element): void;
  menuWillOpen(): boolean;
  activateNativeMenuItemAt(anIndexString: string): void;
  forceUpdateNativeMenuAt(anIndexString: string): void;
  dump(): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsITaskbarProgress.idl

interface nsITaskbarProgress extends nsISupports {
  readonly STATE_NO_PROGRESS?: 0;
  readonly STATE_INDETERMINATE?: 1;
  readonly STATE_NORMAL?: 2;
  readonly STATE_ERROR?: 3;
  readonly STATE_PAUSED?: 4;

  setProgressState(state: nsTaskbarProgressState, currentValue?: u64, maxValue?: u64): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsITouchBarHelper.idl

interface nsITouchBarHelper extends nsISupports {
  readonly activeUrl: string;
  readonly activeTitle: string;
  readonly isUrlbarFocused: boolean;
  toggleFocusUrlbar(): void;
  unfocusUrlbar(): void;
  allItems: nsIArray;
  readonly document: Document;
  getTouchBarInput(aInputName: string): nsITouchBarInput;
  insertRestrictionInUrlbar(aToken: string): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsITouchBarInput.idl

type nsITouchBarInputCallback = Callable<{
  onCommand(): void;
}>

interface nsITouchBarInput extends nsISupports {
  readonly key: string;
  title: string;
  image: nsIURI;
  type: string;
  callback: nsITouchBarInputCallback;
  color: u32;
  disabled: boolean;
  children: nsIArray;
}

// https://searchfox.org/mozilla-central/source/widget/nsITouchBarUpdater.idl

interface nsITouchBarUpdater extends nsISupports {
  updateTouchBarInputs(aWindow: nsIBaseWindow, aInputs: nsITouchBarInput[]): void;
  enterCustomizeMode(): void;
  isTouchBarInitialized(): boolean;
  setTouchBarInitialized(aIsInitialized: boolean): void;
  showPopover(aWindow: nsIBaseWindow, aPopover: nsITouchBarInput, aShowing: boolean): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsIMacPreferencesReader.idl

interface nsIMacPreferencesReader extends nsISupports {
  policiesEnabled(): boolean;
  readPreferences(): any;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsILocalFileMac.idl

interface nsILocalFileMac extends nsIFile {
  readonly fileSizeWithResFork: i64;
  launchWithDoc(aDocToLoad: nsIFile, aLaunchInBackground: boolean): void;
  openDocWithApp(aAppToOpenWith: nsIFile, aLaunchInBackground: boolean): void;
  isPackage(): boolean;
  readonly bundleDisplayName: string;
  readonly bundleIdentifier: string;
  readonly bundleContentsLastModifiedTime: i64;
  hasXAttr(aAttrName: string): boolean;
  getXAttr(aAttrName: string): u8[];
  setXAttr(aAttrName: string, aAttrValue: u8[]): void;
  delXAttr(aAttrName: string): void;
}

interface nsIXPCComponents_Interfaces {
  nsIAccessibleMacNSObjectWrapper: nsJSIID<nsIAccessibleMacNSObjectWrapper>;
  nsIAccessibleMacInterface: nsJSIID<nsIAccessibleMacInterface>;
  nsIAccessibleMacEvent: nsJSIID<nsIAccessibleMacEvent>;
  nsIKeychainMigrationUtils: nsJSIID<nsIKeychainMigrationUtils>;
  nsIMacShellService: nsJSIID<nsIMacShellService>;
  nsIAppBundleLaunchOptions: nsJSIID<nsIAppBundleLaunchOptions>;
  nsIMacDockSupport: nsJSIID<nsIMacDockSupport>;
  nsIMacFinderProgressCanceledCallback: nsJSIID<nsIMacFinderProgressCanceledCallback>;
  nsIMacFinderProgress: nsJSIID<nsIMacFinderProgress>;
  nsIMacSharingService: nsJSIID<nsIMacSharingService>;
  nsIMacUserActivityUpdater: nsJSIID<nsIMacUserActivityUpdater>;
  nsITrashAppCallback: nsJSIID<nsITrashAppCallback>;
  nsIMacWebAppUtils: nsJSIID<nsIMacWebAppUtils>;
  nsIStandaloneNativeMenu: nsJSIID<nsIStandaloneNativeMenu>;
  nsITaskbarProgress: nsJSIID<nsITaskbarProgress>;
  nsITouchBarHelper: nsJSIID<nsITouchBarHelper>;
  nsITouchBarInputCallback: nsJSIID<nsITouchBarInputCallback>;
  nsITouchBarInput: nsJSIID<nsITouchBarInput>;
  nsITouchBarUpdater: nsJSIID<nsITouchBarUpdater>;
  nsIMacPreferencesReader: nsJSIID<nsIMacPreferencesReader>;
  nsILocalFileMac: nsJSIID<nsILocalFileMac>;
}

}  // global

// Typedefs from xpidl.
type PRTime = i64;
type nsTaskbarProgressState = i32;

// XPCOM internal utility types.

/** XPCOM inout param is passed in as a js object with a value property. */
type InOutParam<T> = { value: T };

/** XPCOM out param is written to the passed in object's value property. */
type OutParam<T> = { value?: T };

/** Enable interfaces to inherit from enums: pick variants as optional. */
type Enums<enums> = Partial<Pick<enums, keyof enums>>;

/** Callable accepts either form of a [function] interface. */
type Callable<iface> = iface | Extract<iface[keyof iface], Function>


// @ts-nocheck
/**
 * NOTE: Do not modify this file by hand.
 * Content was generated from source .webidl files.
 * If you're updating some of the sources, see README for instructions.
 */


type HTMLCollectionOf<T> = any;
type IsInstance<T> = (obj: any) => obj is T;
type NodeListOf<T> = any;
interface WindowProxy extends Window {}

/////////////////////////////
/////////////////////////////

interface ActivateMenuItemOptions {
    altKey?: boolean;
    button?: number;
    ctrlKey?: boolean;
    metaKey?: boolean;
    shiftKey?: boolean;
}

interface AddEventListenerOptions extends EventListenerOptions {
    once?: boolean;
    passive?: boolean;
    signal?: AbortSignal;
    wantUntrusted?: boolean;
}

interface AddonEventInit extends EventInit {
    id: string;
}

interface AddressErrors {
    addressLine?: string;
    city?: string;
    country?: string;
    dependentLocality?: string;
    organization?: string;
    phone?: string;
    postalCode?: string;
    recipient?: string;
    region?: string;
    regionCode?: string;
    sortingCode?: string;
}

interface AnalyserOptions extends AudioNodeOptions {
    fftSize?: number;
    maxDecibels?: number;
    minDecibels?: number;
    smoothingTimeConstant?: number;
}

interface AnimationEventInit extends EventInit {
    animationName?: string;
    elapsedTime?: number;
    pseudoElement?: string;
}

interface AnimationPlaybackEventInit extends EventInit {
    currentTime?: number | null;
    timelineTime?: number | null;
}

interface AnimationPropertyDetails {
    property: string;
    runningOnCompositor: boolean;
    values: AnimationPropertyValueDetails[];
    warning?: string;
}

interface AnimationPropertyValueDetails {
    composite: CompositeOperation;
    easing?: string;
    offset: number;
    value?: string;
}

interface AssignedNodesOptions {
    flatten?: boolean;
}

interface AttributeNameValue {
    name: string;
    value: string;
}

interface AudioBufferOptions {
    length: number;
    numberOfChannels?: number;
    sampleRate: number;
}

interface AudioBufferSourceOptions {
    buffer?: AudioBuffer | null;
    detune?: number;
    loop?: boolean;
    loopEnd?: number;
    loopStart?: number;
    playbackRate?: number;
}

interface AudioConfiguration {
    bitrate?: number;
    channels?: string;
    contentType: string;
    samplerate?: number;
}

interface AudioContextOptions {
    sampleRate?: number;
}

interface AudioDataCopyToOptions {
    format?: AudioSampleFormat;
    frameCount?: number;
    frameOffset?: number;
    planeIndex: number;
}

interface AudioDataInit {
    data: AllowSharedBufferSource;
    format: AudioSampleFormat;
    numberOfChannels: number;
    numberOfFrames: number;
    sampleRate: number;
    timestamp: number;
    transfer?: ArrayBuffer[];
}

interface AudioDecoderConfig {
    codec: string;
    description?: AllowSharedBufferSource;
    numberOfChannels: number;
    sampleRate: number;
}

interface AudioDecoderInit {
    error: WebCodecsErrorCallback;
    output: AudioDataOutputCallback;
}

interface AudioDecoderSupport {
    config?: AudioDecoderConfig;
    supported?: boolean;
}

interface AudioEncoderConfig {
    bitrate?: number;
    bitrateMode?: BitrateMode;
    codec: string;
    numberOfChannels?: number;
    opus?: OpusEncoderConfig;
    sampleRate?: number;
}

interface AudioEncoderInit {
    error: WebCodecsErrorCallback;
    output: EncodedAudioChunkOutputCallback;
}

interface AudioEncoderSupport {
    config?: AudioEncoderConfig;
    supported?: boolean;
}

interface AudioNodeOptions {
    channelCount?: number;
    channelCountMode?: ChannelCountMode;
    channelInterpretation?: ChannelInterpretation;
}

interface AudioOutputOptions {
    deviceId?: string;
}

interface AudioSinkDebugInfo {
    audioEnded?: boolean;
    hasErrored?: boolean;
    isPlaying?: boolean;
    isStarted?: boolean;
    lastGoodPosition?: number;
    outputRate?: number;
    playbackComplete?: boolean;
    startTime?: number;
    written?: number;
}

interface AudioSinkWrapperDebugInfo {
    audioEnded?: boolean;
    audioSink?: AudioSinkDebugInfo;
    isPlaying?: boolean;
    isStarted?: boolean;
}

interface AudioTimestamp {
    contextTime?: number;
    performanceTime?: DOMHighResTimeStamp;
}

interface AudioWorkletNodeOptions extends AudioNodeOptions {
    numberOfInputs?: number;
    numberOfOutputs?: number;
    outputChannelCount?: number[];
    parameterData?: Record<string, number>;
    processorOptions?: any;
}

interface AuthenticationExtensionsClientInputs {
    appid?: string;
    credProps?: boolean;
    credentialProtectionPolicy?: CredentialProtectionPolicy;
    enforceCredentialProtectionPolicy?: boolean;
    hmacCreateSecret?: boolean;
    largeBlob?: AuthenticationExtensionsLargeBlobInputs;
    minPinLength?: boolean;
    prf?: AuthenticationExtensionsPRFInputs;
}

interface AuthenticationExtensionsClientInputsJSON {
    appid?: string;
    credProps?: boolean;
    credentialProtectionPolicy?: CredentialProtectionPolicy;
    enforceCredentialProtectionPolicy?: boolean;
    hmacCreateSecret?: boolean;
    largeBlob?: AuthenticationExtensionsLargeBlobInputsJSON;
    minPinLength?: boolean;
    prf?: AuthenticationExtensionsPRFInputsJSON;
}

interface AuthenticationExtensionsClientOutputs {
    appid?: boolean;
    credProps?: CredentialPropertiesOutput;
    hmacCreateSecret?: boolean;
    largeBlob?: AuthenticationExtensionsLargeBlobOutputs;
    prf?: AuthenticationExtensionsPRFOutputs;
}

interface AuthenticationExtensionsLargeBlobInputs {
    read?: boolean;
    support?: string;
    write?: BufferSource;
}

interface AuthenticationExtensionsLargeBlobInputsJSON {
    read?: boolean;
    support?: string;
    write?: Base64URLString;
}

interface AuthenticationExtensionsLargeBlobOutputs {
    blob?: ArrayBuffer;
    supported?: boolean;
    written?: boolean;
}

interface AuthenticationExtensionsPRFInputs {
    eval?: AuthenticationExtensionsPRFValues;
    evalByCredential?: Record<string, AuthenticationExtensionsPRFValues>;
}

interface AuthenticationExtensionsPRFInputsJSON {
    eval?: AuthenticationExtensionsPRFValuesJSON;
    evalByCredential?: Record<string, AuthenticationExtensionsPRFValuesJSON>;
}

interface AuthenticationExtensionsPRFOutputs {
    enabled?: boolean;
    results?: AuthenticationExtensionsPRFValues;
}

interface AuthenticationExtensionsPRFValues {
    first: BufferSource;
    second?: BufferSource;
}

interface AuthenticationExtensionsPRFValuesJSON {
    first: Base64URLString;
    second?: Base64URLString;
}

interface AuthenticatorSelectionCriteria {
    authenticatorAttachment?: string;
    requireResidentKey?: boolean;
    residentKey?: string;
    userVerification?: string;
}

interface AutocompleteInfo {
    addressType?: string;
    canAutomaticallyPersist?: boolean;
    contactType?: string;
    credentialType?: string;
    fieldName?: string;
    section?: string;
}

interface AvcEncoderConfig {
    format?: AvcBitstreamFormat;
}

interface Base64URLDecodeOptions {
    padding: Base64URLDecodePadding;
}

interface Base64URLEncodeOptions {
    pad: boolean;
}

interface BiquadFilterOptions extends AudioNodeOptions {
    Q?: number;
    detune?: number;
    frequency?: number;
    gain?: number;
    type?: BiquadFilterType;
}

interface BlobEventInit extends EventInit {
    data: Blob;
}

interface BlobPropertyBag {
    endings?: EndingType;
    type?: string;
}

interface BlockParsingOptions {
    blockScriptCreated?: boolean;
}

interface BoxQuadOptions extends GeometryUtilsOptions {
    box?: CSSBoxType;
    ignoreTransforms?: boolean;
    relativeTo?: GeometryNode;
}

interface BufferRange {
    end?: number;
    start?: number;
}

interface CDMInformation {
    capabilities: string;
    clearlead: boolean;
    isHDCP22Compatible: boolean;
    isHardwareDecryption: boolean;
    keySystemName: string;
}

interface CSSCustomPropertyRegisteredEventInit extends EventInit {
    propertyDefinition: InspectorCSSPropertyDefinition;
}

interface CSSStyleSheetInit {
    baseURL?: string;
    disabled?: boolean;
    media?: MediaList | string;
}

interface CacheQueryOptions {
    ignoreMethod?: boolean;
    ignoreSearch?: boolean;
    ignoreVary?: boolean;
}

interface CanvasRenderingContext2DDebugInfo {
    backendType: number;
    drawTargetType: number;
    isAccelerated: boolean;
    isShared: boolean;
}

interface CanvasRenderingContext2DSettings {
    alpha?: boolean;
    colorSpace?: PredefinedColorSpace;
    desynchronized?: boolean;
    forceSoftwareRendering?: boolean;
    willReadFrequently?: boolean;
}

interface CaretPositionFromPointOptions {
    shadowRoots?: ShadowRoot[];
}

interface CaretStateChangedEventInit extends EventInit {
    boundingClientRect?: DOMRectReadOnly | null;
    caretVisible?: boolean;
    caretVisuallyVisible?: boolean;
    clientX?: number;
    clientY?: number;
    collapsed?: boolean;
    reason?: CaretChangedReason;
    selectedTextContent?: string;
    selectionEditable?: boolean;
    selectionVisible?: boolean;
}

interface ChannelMergerOptions extends AudioNodeOptions {
    numberOfInputs?: number;
}

interface ChannelSplitterOptions extends AudioNodeOptions {
    numberOfOutputs?: number;
}

interface CheckVisibilityOptions {
    checkOpacity?: boolean;
    checkVisibilityCSS?: boolean;
    contentVisibilityAuto?: boolean;
    flush?: boolean;
    opacityProperty?: boolean;
    visibilityProperty?: boolean;
}

interface CheckerboardReport {
    log?: string;
    reason?: CheckerboardReason;
    severity?: number;
    timestamp?: DOMTimeStamp;
}

interface ChildProcInfoDictionary {
    childID?: number;
    cpuCycleCount?: number;
    cpuTime?: number;
    memory?: number;
    origin?: string;
    pid?: number;
    threads?: ThreadInfoDictionary[];
    type?: WebIDLProcType;
    utilityActors?: UtilityActorsDictionary[];
    windows?: WindowInfoDictionary[];
}

interface ChromeFilePropertyBag extends FilePropertyBag {
    existenceCheck?: boolean;
    name?: string;
}

interface ClearResourceCacheOptions {
    pattern?: OriginAttributesPatternDictionary;
    principal?: Principal;
    schemelessSite?: string;
    target?: ResourceCacheTarget;
    types?: ResourceCacheType[];
    url?: string;
}

interface ClientRectsAndTexts {
    rectList: DOMRectList;
    textList: string[];
}

interface ClipboardEventInit extends EventInit {
    data?: string;
    dataType?: string;
}

interface ClipboardItemOptions {
    presentationStyle?: PresentationStyle;
}

interface CloseEventInit extends EventInit {
    code?: number;
    reason?: string;
    wasClean?: boolean;
}

interface CloseWatcherOptions {
    signal?: AbortSignal;
}

interface CollectedData {
    children?: any[];
    id?: Record<string, CollectedFormDataValue>;
    innerHTML?: string;
    scroll?: string;
    url?: string;
    xpath?: Record<string, CollectedFormDataValue>;
}

interface CompileScriptOptionsDictionary {
    charset?: string;
    filename?: string;
    hasReturnValue?: boolean;
    lazilyParse?: boolean;
}

interface CompositionEventInit extends UIEventInit {
    data?: string;
}

interface ComputedEffectTiming extends EffectTiming {
    activeDuration?: number;
    currentIteration?: number | null;
    endTime?: number;
    localTime?: number | null;
    progress?: number | null;
}

interface ConsoleInstanceOptions {
    consoleID?: string;
    dump?: ConsoleInstanceDumpCallback;
    innerID?: string;
    maxLogLevel?: ConsoleLogLevel;
    maxLogLevelPref?: string;
    prefix?: string;
}

interface ConstantSourceOptions {
    offset?: number;
}

interface ConstrainBooleanParameters {
    exact?: boolean;
    ideal?: boolean;
}

interface ConstrainDOMStringParameters {
    exact?: string | string[];
    ideal?: string | string[];
}

interface ConstrainDoubleRange {
    exact?: number;
    ideal?: number;
    max?: number;
    min?: number;
}

interface ConstrainLongRange {
    exact?: number;
    ideal?: number;
    max?: number;
    min?: number;
}

interface ContentVisibilityAutoStateChangeEventInit extends EventInit {
    skipped?: boolean;
}

interface ConvertCoordinateOptions extends GeometryUtilsOptions {
    fromBox?: CSSBoxType;
    toBox?: CSSBoxType;
}

interface ConvolverOptions extends AudioNodeOptions {
    buffer?: AudioBuffer | null;
    disableNormalization?: boolean;
}

interface CookieChangeEventInit extends EventInit {
    changed?: CookieList;
    deleted?: CookieList;
}

interface CookieInit {
    domain?: string | null;
    expires?: DOMHighResTimeStamp | null;
    name: string;
    partitioned?: boolean;
    path?: string;
    sameSite?: CookieSameSite;
    value: string;
}

interface CookieListItem {
    domain?: string | null;
    expires?: DOMHighResTimeStamp | null;
    name?: string;
    partitioned?: boolean;
    path?: string;
    sameSite?: CookieSameSite;
    secure?: boolean;
    value?: string;
}

interface CookieStoreDeleteOptions {
    domain?: string | null;
    name: string;
    partitioned?: boolean;
    path?: string;
}

interface CookieStoreGetOptions {
    name?: string;
    url?: string;
}

interface CopyOptions {
    noOverwrite?: boolean;
    recursive?: boolean;
}

interface CredentialCreationOptions {
    identity?: IdentityCredentialInit;
    publicKey?: PublicKeyCredentialCreationOptions;
    signal?: AbortSignal;
}

interface CredentialPropertiesOutput {
    rk?: boolean;
}

interface CredentialRequestOptions {
    identity?: IdentityCredentialRequestOptions;
    mediation?: CredentialMediationRequirement;
    publicKey?: PublicKeyCredentialRequestOptions;
    signal?: AbortSignal;
}

interface CustomEventInit extends EventInit {
    detail?: any;
}

interface DOMMatrix2DInit {
    a?: number;
    b?: number;
    c?: number;
    d?: number;
    e?: number;
    f?: number;
    m11?: number;
    m12?: number;
    m21?: number;
    m22?: number;
    m41?: number;
    m42?: number;
}

interface DOMMatrixInit extends DOMMatrix2DInit {
    is2D?: boolean;
    m13?: number;
    m14?: number;
    m23?: number;
    m24?: number;
    m31?: number;
    m32?: number;
    m33?: number;
    m34?: number;
    m43?: number;
    m44?: number;
}

interface DOMPointInit {
    w?: number;
    x?: number;
    y?: number;
    z?: number;
}

interface DOMQuadInit {
    p1?: DOMPointInit;
    p2?: DOMPointInit;
    p3?: DOMPointInit;
    p4?: DOMPointInit;
}

interface DOMRectInit {
    height?: number;
    width?: number;
    x?: number;
    y?: number;
}

interface DateTimeValue {
    day?: number;
    hour?: number;
    minute?: number;
    month?: number;
    year?: number;
}

interface DecodedStreamDataDebugInfo {
    audioFramesWritten?: number;
    haveSentFinishAudio?: boolean;
    haveSentFinishVideo?: boolean;
    instance?: string;
    lastVideoEndTime?: number;
    lastVideoStartTime?: number;
    nextAudioTime?: number;
    streamAudioWritten?: number;
    streamVideoWritten?: number;
}

interface DecodedStreamDebugInfo {
    audioQueueFinished?: boolean;
    audioQueueSize?: number;
    data?: DecodedStreamDataDebugInfo;
    instance?: string;
    lastAudio?: number;
    lastOutputTime?: number;
    playing?: number;
    startTime?: number;
}

interface DelayOptions extends AudioNodeOptions {
    delayTime?: number;
    maxDelayTime?: number;
}

interface DeviceAccelerationInit {
    x?: number | null;
    y?: number | null;
    z?: number | null;
}

interface DeviceLightEventInit extends EventInit {
    value?: number;
}

interface DeviceMotionEventInit extends EventInit {
    acceleration?: DeviceAccelerationInit;
    accelerationIncludingGravity?: DeviceAccelerationInit;
    interval?: number | null;
    rotationRate?: DeviceRotationRateInit;
}

interface DeviceOrientationEventInit extends EventInit {
    absolute?: boolean;
    alpha?: number | null;
    beta?: number | null;
    gamma?: number | null;
}

interface DeviceRotationRateInit {
    alpha?: number | null;
    beta?: number | null;
    gamma?: number | null;
}

interface DictWithAllowSharedBufferSource {
    allowSharedArrayBuffer?: ArrayBuffer;
    allowSharedArrayBufferView?: ArrayBufferView;
    arrayBuffer?: ArrayBuffer;
    arrayBufferView?: ArrayBufferView;
}

interface DisplayMediaStreamConstraints {
    audio?: boolean | MediaTrackConstraints;
    video?: boolean | MediaTrackConstraints;
}

interface DisplayNameOptions {
    calendar?: string;
    keys?: string[];
    style?: string;
    type?: string;
}

interface DisplayNameResult {
    calendar?: string;
    locale?: string;
    style?: string;
    type?: string;
    values?: string[];
}

interface DocumentTimelineOptions {
    originTime?: DOMHighResTimeStamp;
}

interface DoubleRange {
    max?: number;
    min?: number;
}

interface DragEventInit extends MouseEventInit {
    dataTransfer?: DataTransfer | null;
}

interface DynamicsCompressorOptions extends AudioNodeOptions {
    attack?: number;
    knee?: number;
    ratio?: number;
    release?: number;
    threshold?: number;
}

interface EMEDebugInfo {
    keySystem?: string;
    sessionsInfo?: string;
}

interface EffectTiming {
    delay?: number;
    direction?: PlaybackDirection;
    duration?: number | string;
    easing?: string;
    endDelay?: number;
    fill?: FillMode;
    iterationStart?: number;
    iterations?: number;
}

interface ElementCreationOptions {
    is?: string;
    pseudo?: string;
}

interface ElementDefinitionOptions {
    extends?: string;
}

interface EncodedAudioChunkInit {
    data: AllowSharedBufferSource;
    duration?: number;
    timestamp: number;
    transfer?: ArrayBuffer[];
    type: EncodedAudioChunkType;
}

interface EncodedAudioChunkMetadata {
    decoderConfig?: AudioDecoderConfig;
}

interface EncodedVideoChunkInit {
    data: AllowSharedBufferSource;
    duration?: number;
    timestamp: number;
    type: EncodedVideoChunkType;
}

interface EncodedVideoChunkMetadata {
    decoderConfig?: VideoDecoderConfig;
    svc?: SvcOutputMetadata;
}

interface ErrorEventInit extends EventInit {
    colno?: number;
    error?: any;
    filename?: string;
    lineno?: number;
    message?: string;
}

interface EventInit {
    bubbles?: boolean;
    cancelable?: boolean;
    composed?: boolean;
}

interface EventListenerOptions {
    capture?: boolean;
    mozSystemGroup?: boolean;
}

interface EventModifierInit extends UIEventInit {
    altKey?: boolean;
    ctrlKey?: boolean;
    metaKey?: boolean;
    modifierAltGraph?: boolean;
    modifierCapsLock?: boolean;
    modifierFn?: boolean;
    modifierFnLock?: boolean;
    modifierNumLock?: boolean;
    modifierOS?: boolean;
    modifierScrollLock?: boolean;
    modifierSymbol?: boolean;
    modifierSymbolLock?: boolean;
    shiftKey?: boolean;
}

interface EventSourceInit {
    withCredentials?: boolean;
}

interface ExecuteInGlobalOptions {
    reportExceptions?: boolean;
}

interface FailedCertSecurityInfo {
    certChainStrings?: string[];
    certValidityRangeNotAfter?: DOMTimeStamp;
    certValidityRangeNotBefore?: DOMTimeStamp;
    channelStatus?: number;
    errorCodeString?: string;
    errorIsOverridable?: boolean;
    errorMessage?: string;
    hasHPKP?: boolean;
    hasHSTS?: boolean;
    issuerCommonName?: string;
    overridableErrorCategory?: OverridableErrorCategory;
    validNotAfter?: DOMTimeStamp;
    validNotBefore?: DOMTimeStamp;
}

interface FileInfo {
    creationTime?: number;
    lastAccessed?: number;
    lastModified?: number;
    path?: string;
    permissions?: number;
    size?: number;
    type?: FileType;
}

interface FilePropertyBag extends BlobPropertyBag {
    lastModified?: number;
}

interface FileSourceOptions {
    addResourceOptions?: FluentBundleAddResourceOptions;
}

interface FileSystemCreateWritableOptions {
    keepExistingData?: boolean;
}

interface FileSystemFlags {
    create?: boolean;
    exclusive?: boolean;
}

interface FileSystemGetDirectoryOptions {
    create?: boolean;
}

interface FileSystemGetFileOptions {
    create?: boolean;
}

interface FileSystemRemoveOptions {
    recursive?: boolean;
}

interface FluentBundleAddResourceOptions {
    allowOverrides?: boolean;
}

interface FluentBundleIteratorResult {
    done: boolean;
    value: FluentBundle | null;
}

interface FluentBundleOptions {
    pseudoStrategy?: string;
    useIsolating?: boolean;
}

interface FluentMessage {
    attributes: Record<string, FluentPattern>;
    value?: FluentPattern | null;
}

interface FluentTextElementItem {
    attr?: string;
    id?: string;
    text?: string;
}

interface FocusEventInit extends UIEventInit {
    relatedTarget?: EventTarget | null;
}

interface FocusOptions {
    focusVisible?: boolean;
    preventScroll?: boolean;
}

interface FontFaceDescriptors {
    ascentOverride?: string;
    descentOverride?: string;
    display?: string;
    featureSettings?: string;
    lineGapOverride?: string;
    sizeAdjust?: string;
    stretch?: string;
    style?: string;
    unicodeRange?: string;
    variant?: string;
    variationSettings?: string;
    weight?: string;
}

interface FontFaceSetIteratorResult {
    done: boolean;
    value: any;
}

interface FontFaceSetLoadEventInit extends EventInit {
    fontfaces?: FontFace[];
}

interface FormAutofillConfidences {
    ccName?: number;
    ccNumber?: number;
}

interface FormDataEventInit extends EventInit {
    formData: FormData;
}

interface FrameCrashedEventInit extends EventInit {
    browsingContextId?: number;
    childID?: number;
    isTopFrame?: boolean;
}

interface GPUBindGroupDescriptor extends GPUObjectDescriptorBase {
    entries: GPUBindGroupEntry[];
    layout: GPUBindGroupLayout;
}

interface GPUBindGroupEntry {
    binding: GPUIndex32;
    resource: GPUBindingResource;
}

interface GPUBindGroupLayoutDescriptor extends GPUObjectDescriptorBase {
    entries: GPUBindGroupLayoutEntry[];
}

interface GPUBindGroupLayoutEntry {
    binding: GPUIndex32;
    buffer?: GPUBufferBindingLayout;
    sampler?: GPUSamplerBindingLayout;
    storageTexture?: GPUStorageTextureBindingLayout;
    texture?: GPUTextureBindingLayout;
    visibility: GPUShaderStageFlags;
}

interface GPUBlendComponent {
    dstFactor?: GPUBlendFactor;
    operation?: GPUBlendOperation;
    srcFactor?: GPUBlendFactor;
}

interface GPUBlendState {
    alpha: GPUBlendComponent;
    color: GPUBlendComponent;
}

interface GPUBufferBinding {
    buffer: GPUBuffer;
    offset?: GPUSize64;
    size?: GPUSize64;
}

interface GPUBufferBindingLayout {
    hasDynamicOffset?: boolean;
    minBindingSize?: GPUSize64;
    type?: GPUBufferBindingType;
}

interface GPUBufferDescriptor extends GPUObjectDescriptorBase {
    mappedAtCreation?: boolean;
    size: GPUSize64;
    usage: GPUBufferUsageFlags;
}

interface GPUCanvasConfiguration {
    alphaMode?: GPUCanvasAlphaMode;
    device: GPUDevice;
    format: GPUTextureFormat;
    usage?: GPUTextureUsageFlags;
    viewFormats?: GPUTextureFormat[];
}

interface GPUColorDict {
    a: number;
    b: number;
    g: number;
    r: number;
}

interface GPUColorTargetState {
    blend?: GPUBlendState;
    format: GPUTextureFormat;
    writeMask?: GPUColorWriteFlags;
}

interface GPUCommandBufferDescriptor extends GPUObjectDescriptorBase {
}

interface GPUCommandEncoderDescriptor extends GPUObjectDescriptorBase {
}

interface GPUComputePassDescriptor extends GPUObjectDescriptorBase {
    timestampWrites?: GPUComputePassTimestampWrites;
}

interface GPUComputePassTimestampWrites {
    beginningOfPassWriteIndex?: GPUSize32;
    endOfPassWriteIndex?: GPUSize32;
    querySet: GPUQuerySet;
}

interface GPUComputePipelineDescriptor extends GPUPipelineDescriptorBase {
    compute: GPUProgrammableStage;
}

interface GPUCopyExternalImageDestInfo extends GPUTexelCopyTextureInfo {
    premultipliedAlpha?: boolean;
}

interface GPUCopyExternalImageSourceInfo {
    flipY?: boolean;
    origin?: GPUOrigin2D;
    source: GPUCopyExternalImageSource;
}

interface GPUDepthStencilState {
    depthBias?: GPUDepthBias;
    depthBiasClamp?: number;
    depthBiasSlopeScale?: number;
    depthCompare?: GPUCompareFunction;
    depthWriteEnabled?: boolean;
    format: GPUTextureFormat;
    stencilBack?: GPUStencilFaceState;
    stencilFront?: GPUStencilFaceState;
    stencilReadMask?: GPUStencilValue;
    stencilWriteMask?: GPUStencilValue;
}

interface GPUDeviceDescriptor extends GPUObjectDescriptorBase {
    defaultQueue?: GPUQueueDescriptor;
    requiredFeatures?: GPUFeatureName[];
    requiredLimits?: Record<string, GPUSize64>;
}

interface GPUExtent3DDict {
    depthOrArrayLayers?: GPUIntegerCoordinate;
    height?: GPUIntegerCoordinate;
    width: GPUIntegerCoordinate;
}

interface GPUFragmentState extends GPUProgrammableStage {
    targets: GPUColorTargetState[];
}

interface GPUMultisampleState {
    alphaToCoverageEnabled?: boolean;
    count?: GPUSize32;
    mask?: GPUSampleMask;
}

interface GPUObjectDescriptorBase {
    label?: string;
}

interface GPUOrigin2DDict {
    x?: GPUIntegerCoordinate;
    y?: GPUIntegerCoordinate;
}

interface GPUOrigin3DDict {
    x?: GPUIntegerCoordinate;
    y?: GPUIntegerCoordinate;
    z?: GPUIntegerCoordinate;
}

interface GPUPipelineDescriptorBase extends GPUObjectDescriptorBase {
    layout: GPUPipelineLayout | GPUAutoLayoutMode;
}

interface GPUPipelineErrorInit {
    reason: GPUPipelineErrorReason;
}

interface GPUPipelineLayoutDescriptor extends GPUObjectDescriptorBase {
    bindGroupLayouts: GPUBindGroupLayout[];
}

interface GPUPrimitiveState {
    cullMode?: GPUCullMode;
    frontFace?: GPUFrontFace;
    stripIndexFormat?: GPUIndexFormat;
    topology?: GPUPrimitiveTopology;
    unclippedDepth?: boolean;
}

interface GPUProgrammableStage {
    constants?: Record<string, GPUPipelineConstantValue>;
    entryPoint?: string;
    module: GPUShaderModule;
}

interface GPUQuerySetDescriptor extends GPUObjectDescriptorBase {
    count: GPUSize32;
    type: GPUQueryType;
}

interface GPUQueueDescriptor extends GPUObjectDescriptorBase {
}

interface GPURenderBundleDescriptor extends GPUObjectDescriptorBase {
}

interface GPURenderBundleEncoderDescriptor extends GPURenderPassLayout {
    depthReadOnly?: boolean;
    stencilReadOnly?: boolean;
}

interface GPURenderPassColorAttachment {
    clearValue?: GPUColor;
    depthSlice?: GPUIntegerCoordinate;
    loadOp: GPULoadOp;
    resolveTarget?: GPUTextureView;
    storeOp: GPUStoreOp;
    view: GPUTextureView;
}

interface GPURenderPassDepthStencilAttachment {
    depthClearValue?: number;
    depthLoadOp?: GPULoadOp;
    depthReadOnly?: boolean;
    depthStoreOp?: GPUStoreOp;
    stencilClearValue?: GPUStencilValue;
    stencilLoadOp?: GPULoadOp;
    stencilReadOnly?: boolean;
    stencilStoreOp?: GPUStoreOp;
    view: GPUTextureView;
}

interface GPURenderPassDescriptor extends GPUObjectDescriptorBase {
    colorAttachments: GPURenderPassColorAttachment[];
    depthStencilAttachment?: GPURenderPassDepthStencilAttachment;
    occlusionQuerySet?: GPUQuerySet;
    timestampWrites?: GPURenderPassTimestampWrites;
}

interface GPURenderPassLayout extends GPUObjectDescriptorBase {
    colorFormats: GPUTextureFormat[];
    depthStencilFormat?: GPUTextureFormat;
    sampleCount?: GPUSize32;
}

interface GPURenderPassTimestampWrites {
    beginningOfPassWriteIndex?: GPUSize32;
    endOfPassWriteIndex?: GPUSize32;
    querySet: GPUQuerySet;
}

interface GPURenderPipelineDescriptor extends GPUPipelineDescriptorBase {
    depthStencil?: GPUDepthStencilState;
    fragment?: GPUFragmentState;
    multisample?: GPUMultisampleState;
    primitive?: GPUPrimitiveState;
    vertex: GPUVertexState;
}

interface GPURequestAdapterOptions {
    featureLevel?: string;
    forceFallbackAdapter?: boolean;
    powerPreference?: GPUPowerPreference;
    xrCompatible?: boolean;
}

interface GPUSamplerBindingLayout {
    type?: GPUSamplerBindingType;
}

interface GPUSamplerDescriptor extends GPUObjectDescriptorBase {
    addressModeU?: GPUAddressMode;
    addressModeV?: GPUAddressMode;
    addressModeW?: GPUAddressMode;
    compare?: GPUCompareFunction;
    lodMaxClamp?: number;
    lodMinClamp?: number;
    magFilter?: GPUFilterMode;
    maxAnisotropy?: number;
    minFilter?: GPUFilterMode;
    mipmapFilter?: GPUMipmapFilterMode;
}

interface GPUShaderModuleCompilationHint {
    entryPoint: string;
    layout?: GPUPipelineLayout | GPUAutoLayoutMode;
}

interface GPUShaderModuleDescriptor extends GPUObjectDescriptorBase {
    code: string;
    compilationHints?: GPUShaderModuleCompilationHint[];
}

interface GPUStencilFaceState {
    compare?: GPUCompareFunction;
    depthFailOp?: GPUStencilOperation;
    failOp?: GPUStencilOperation;
    passOp?: GPUStencilOperation;
}

interface GPUStorageTextureBindingLayout {
    access?: GPUStorageTextureAccess;
    format: GPUTextureFormat;
    viewDimension?: GPUTextureViewDimension;
}

interface GPUTexelCopyBufferInfo extends GPUTexelCopyBufferLayout {
    buffer: GPUBuffer;
}

interface GPUTexelCopyBufferLayout {
    bytesPerRow?: GPUSize32;
    offset?: GPUSize64;
    rowsPerImage?: GPUSize32;
}

interface GPUTexelCopyTextureInfo {
    aspect?: GPUTextureAspect;
    mipLevel?: GPUIntegerCoordinate;
    origin?: GPUOrigin3D;
    texture: GPUTexture;
}

interface GPUTextureBindingLayout {
    multisampled?: boolean;
    sampleType?: GPUTextureSampleType;
    viewDimension?: GPUTextureViewDimension;
}

interface GPUTextureDescriptor extends GPUObjectDescriptorBase {
    dimension?: GPUTextureDimension;
    format: GPUTextureFormat;
    mipLevelCount?: GPUIntegerCoordinate;
    sampleCount?: GPUSize32;
    size: GPUExtent3D;
    usage: GPUTextureUsageFlags;
    viewFormats?: GPUTextureFormat[];
}

interface GPUTextureViewDescriptor extends GPUObjectDescriptorBase {
    arrayLayerCount?: GPUIntegerCoordinate;
    aspect?: GPUTextureAspect;
    baseArrayLayer?: GPUIntegerCoordinate;
    baseMipLevel?: GPUIntegerCoordinate;
    dimension?: GPUTextureViewDimension;
    format?: GPUTextureFormat;
    mipLevelCount?: GPUIntegerCoordinate;
}

interface GPUUncapturedErrorEventInit extends EventInit {
    error: GPUError;
}

interface GPUVertexAttribute {
    format: GPUVertexFormat;
    offset: GPUSize64;
    shaderLocation: GPUIndex32;
}

interface GPUVertexBufferLayout {
    arrayStride: GPUSize64;
    attributes: GPUVertexAttribute[];
    stepMode?: GPUVertexStepMode;
}

interface GPUVertexState extends GPUProgrammableStage {
    buffers?: (GPUVertexBufferLayout | null)[];
}

interface GainOptions extends AudioNodeOptions {
    gain?: number;
}

interface GamepadAxisMoveEventInit extends GamepadEventInit {
    axis?: number;
    value?: number;
}

interface GamepadButtonEventInit extends GamepadEventInit {
    button?: number;
}

interface GamepadEventInit extends EventInit {
    gamepad?: Gamepad | null;
}

interface GamepadLightColor {
    blue: number;
    green: number;
    red: number;
}

interface GeometryUtilsOptions {
    createFramesForSuppressedWhitespace?: boolean;
    flush?: boolean;
}

interface GetAnimationsOptions {
    subtree?: boolean;
}

interface GetChildrenOptions {
    ignoreAbsent?: boolean;
}

interface GetHTMLOptions {
    serializableShadowRoots?: boolean;
    shadowRoots?: ShadowRoot[];
}

interface GetNotificationOptions {
    tag?: string;
}

interface GetRootNodeOptions {
    composed?: boolean;
}

interface GleanDistributionData {
    count: number;
    sum: number;
    values: Record<string, number>;
}

interface GleanEventRecord {
    category: string;
    extra?: Record<string, string>;
    name: string;
    timestamp: number;
}

interface GleanRateData {
    denominator: number;
    numerator: number;
}

interface HTMLMediaElementDebugInfo {
    EMEInfo?: EMEDebugInfo;
    compositorDroppedFrames?: number;
    decoder?: MediaDecoderDebugInfo;
}

interface HasChildrenOptions {
    ignoreAbsent?: boolean;
}

interface HashChangeEventInit extends EventInit {
    newURL?: string;
    oldURL?: string;
}

interface HeapSnapshotBoundaries {
    debugger?: any;
    globals?: any[];
    runtime?: boolean;
}

interface IDBDatabaseInfo {
    name?: string;
    version?: number;
}

interface IDBIndexParameters {
    locale?: string | null;
    multiEntry?: boolean;
    unique?: boolean;
}

interface IDBObjectStoreParameters {
    autoIncrement?: boolean;
    keyPath?: string | string[] | null;
}

interface IDBOpenDBOptions {
    version?: number;
}

interface IDBTransactionOptions {
    durability?: IDBTransactionDurability;
}

interface IDBVersionChangeEventInit extends EventInit {
    newVersion?: number | null;
    oldVersion?: number;
}

interface IIRFilterOptions extends AudioNodeOptions {
    feedback: number[];
    feedforward: number[];
}

interface IdentityCredentialDisconnectOptions extends IdentityProviderConfig {
    accountHint: string;
}

interface IdentityCredentialInit {
    effectiveOrigins?: string[];
    effectiveQueryURL?: string;
    effectiveType?: string;
    id: string;
    token?: string;
    uiHint?: IdentityCredentialUserData;
}

interface IdentityCredentialRequestOptions {
    mode?: IdentityCredentialRequestOptionsMode;
    providers: IdentityProviderRequestOptions[];
}

interface IdentityCredentialUserData {
    expiresAfter?: number;
    iconURL: string;
    name: string;
}

interface IdentityProviderConfig {
    clientId?: string;
    configURL?: string;
    effectiveQueryURL?: string;
    effectiveType?: string;
    loginTarget?: IdentityLoginTargetType;
    loginURL?: string;
    origin?: string;
}

interface IdentityProviderRequestOptions extends IdentityProviderConfig {
    domainHint?: string;
    loginHint?: string;
    nonce?: string;
}

interface IdleRequestOptions {
    timeout?: number;
}

interface ImageBitmapOptions {
    colorSpaceConversion?: ColorSpaceConversion;
    imageOrientation?: ImageOrientation;
    premultiplyAlpha?: PremultiplyAlpha;
    resizeHeight?: number;
    resizeWidth?: number;
}

interface ImageCaptureErrorEventInit extends EventInit {
    imageCaptureError?: ImageCaptureError | null;
}

interface ImageDecodeOptions {
    completeFramesOnly?: boolean;
    frameIndex?: number;
}

interface ImageDecodeResult {
    complete: boolean;
    image: VideoFrame;
}

interface ImageDecoderInit {
    colorSpaceConversion?: ColorSpaceConversion;
    data: ImageBufferSource;
    desiredHeight?: number;
    desiredWidth?: number;
    preferAnimation?: boolean;
    transfer?: ArrayBuffer[];
    type: string;
}

interface ImageEncodeOptions {
    quality?: number;
    type?: string;
}

interface ImageText {
    confidence: number;
    quad: DOMQuad;
    string: string;
}

interface ImportESModuleOptionsDictionary {
    global?: ImportESModuleTargetGlobal;
}

interface InputEventInit extends UIEventInit {
    data?: string | null;
    dataTransfer?: DataTransfer | null;
    inputType?: string;
    isComposing?: boolean;
    targetRanges?: StaticRange[];
}

interface InspectorCSSPropertyDefinition {
    fromJS: boolean;
    inherits: boolean;
    initialValue: string | null;
    name: string;
    syntax: string;
}

interface InspectorCSSToken {
    number?: number | null;
    text: string;
    tokenType: string;
    unit: string | null;
    value: string | null;
}

interface InspectorColorToResult {
    adjusted: boolean;
    color: string;
    components: number[] | Float32Array;
}

interface InspectorFontFeature {
    languageSystem: string;
    script: string;
    tag: string;
}

interface InspectorRGBATuple {
    a?: number;
    b?: number;
    g?: number;
    r?: number;
}

interface InspectorStyleSheetRuleCountAndAtRulesResult {
    atRules: CSSRule[];
    ruleCount: number;
}

interface InspectorVariationAxis {
    defaultValue: number;
    maxValue: number;
    minValue: number;
    name: string;
    tag: string;
}

interface InspectorVariationInstance {
    name: string;
    values: InspectorVariationValue[];
}

interface InspectorVariationValue {
    axis: string;
    value: number;
}

interface InstallTriggerData {
    Hash?: string | null;
    IconURL?: string | null;
    URL?: string;
}

interface InteractionData {
    interactionCount?: number;
    interactionTimeInMilliseconds?: number;
    scrollingDistanceInPixels?: number;
}

interface IntersectionObserverInit {
    root?: Element | Document | null;
    rootMargin?: string;
    threshold?: number | number[];
}

interface InvokeEventInit extends EventInit {
    action?: string;
    invoker?: Element | null;
}

interface KeySystemTrackConfiguration {
    encryptionScheme?: string | null;
    robustness?: string;
}

interface KeyboardEventInit extends EventModifierInit {
    charCode?: number;
    code?: string;
    isComposing?: boolean;
    key?: string;
    keyCode?: number;
    location?: number;
    repeat?: boolean;
    which?: number;
}

interface KeyframeAnimationOptions extends KeyframeEffectOptions {
    id?: string;
}

interface KeyframeEffectOptions extends EffectTiming {
    composite?: CompositeOperation;
    iterationComposite?: IterationCompositeOperation;
    pseudoElement?: string | null;
}

interface L10nFileSourceMockFile {
    path: string;
    source: string;
}

interface L10nIdArgs {
    args?: L10nArgs | null;
    id?: string | null;
}

interface L10nMessage {
    attributes?: AttributeNameValue[] | null;
    value?: string | null;
}

interface L10nOverlaysError {
    code?: number;
    l10nName?: string;
    sourceElementName?: string;
    translatedElementName?: string;
}

interface L10nRegistryOptions {
    bundleOptions?: FluentBundleOptions;
}

interface LibcConstants {
    AT_EACCESS?: number;
    EACCES?: number;
    EAGAIN?: number;
    EINTR?: number;
    EINVAL?: number;
    ENOSYS?: number;
    EPERM?: number;
    FD_CLOEXEC?: number;
    F_SETFD?: number;
    F_SETFL?: number;
    O_CREAT?: number;
    O_NONBLOCK?: number;
    O_WRONLY?: number;
    POLLERR?: number;
    POLLHUP?: number;
    POLLIN?: number;
    POLLNVAL?: number;
    POLLOUT?: number;
    PR_CAPBSET_READ?: number;
    WNOHANG?: number;
}

interface LoadURIOptions {
    baseURI?: URI | null;
    cancelContentJSEpoch?: number;
    csp?: ContentSecurityPolicy | null;
    hasValidUserGestureActivation?: boolean;
    headers?: InputStream | null;
    loadFlags?: number;
    postData?: InputStream | null;
    referrerInfo?: ReferrerInfo | null;
    remoteTypeOverride?: string | null;
    schemelessInput?: number;
    textDirectiveUserActivation?: boolean;
    triggeringPrincipal?: Principal | null;
    triggeringRemoteType?: string | null;
    triggeringSandboxFlags?: number;
    triggeringStorageAccess?: boolean;
    triggeringWindowId?: number;
}

interface LockInfo {
    clientId?: string;
    mode?: LockMode;
    name?: string;
}

interface LockManagerSnapshot {
    held?: LockInfo[];
    pending?: LockInfo[];
}

interface LockOptions {
    ifAvailable?: boolean;
    mode?: LockMode;
    signal?: AbortSignal;
    steal?: boolean;
}

interface MIDIConnectionEventInit extends EventInit {
    port?: MIDIPort | null;
}

interface MIDIMessageEventInit extends EventInit {
    data?: Uint8Array;
}

interface MIDIOptions {
    software?: boolean;
    sysex?: boolean;
}

interface MLSBytes {
    content: Uint8Array;
    type: MLSObjectType;
}

interface MLSCommitOutput {
    clientId?: Uint8Array;
    commit: Uint8Array;
    groupId: Uint8Array;
    groupInfo?: Uint8Array;
    ratchetTree?: Uint8Array;
    type: MLSObjectType;
    welcome?: Uint8Array;
}

interface MLSExporterOutput {
    context: Uint8Array;
    groupEpoch: Uint8Array;
    groupId: Uint8Array;
    label: Uint8Array;
    secret: Uint8Array;
    type: MLSObjectType;
}

interface MLSGroupDetails {
    groupEpoch: Uint8Array;
    groupId: Uint8Array;
    members: MLSGroupMember[];
    type: MLSObjectType;
}

interface MLSGroupMember {
    clientId: Uint8Array;
    credential: Uint8Array;
}

interface MLSReceived {
    commitOutput?: MLSCommitOutput;
    content?: Uint8Array;
    groupEpoch?: Uint8Array;
    groupId: Uint8Array;
    type: MLSObjectType;
}

interface MakeDirectoryOptions {
    createAncestors?: boolean;
    ignoreExisting?: boolean;
    permissions?: number;
}

interface MatchPatternOptions {
    ignorePath?: boolean;
    restrictSchemes?: boolean;
}

interface MediaCacheStreamDebugInfo {
    cacheSuspended?: boolean;
    channelEnded?: boolean;
    channelOffset?: number;
    loadID?: number;
    streamLength?: number;
}

interface MediaCapabilitiesDecodingInfo extends MediaCapabilitiesInfo {
    keySystemAccess: MediaKeySystemAccess | null;
}

interface MediaCapabilitiesInfo {
    powerEfficient: boolean;
    smooth: boolean;
    supported: boolean;
}

interface MediaCapabilitiesKeySystemConfiguration {
    audio?: KeySystemTrackConfiguration;
    distinctiveIdentifier?: MediaKeysRequirement;
    initDataType?: string;
    keySystem: string;
    persistentState?: MediaKeysRequirement;
    sessionTypes?: string[];
    video?: KeySystemTrackConfiguration;
}

interface MediaConfiguration {
    audio?: AudioConfiguration;
    video?: VideoConfiguration;
}

interface MediaDecoderDebugInfo {
    PlayState?: string;
    channels?: number;
    containerType?: string;
    hasAudio?: boolean;
    hasVideo?: boolean;
    instance?: string;
    rate?: number;
    reader?: MediaFormatReaderDebugInfo;
    resource?: MediaResourceDebugInfo;
    stateMachine?: MediaDecoderStateMachineDebugInfo;
}

interface MediaDecoderStateMachineDebugInfo {
    audioCompleted?: boolean;
    audioRequestStatus?: string;
    clock?: number;
    decodedAudioEndTime?: number;
    decodedVideoEndTime?: number;
    duration?: number;
    isPlaying?: boolean;
    mediaSink?: MediaSinkDebugInfo;
    mediaTime?: number;
    playState?: number;
    sentFirstFrameLoadedEvent?: boolean;
    state?: string;
    stateObj?: MediaDecoderStateMachineDecodingStateDebugInfo;
    totalBufferingTimeMs?: number;
    videoCompleted?: boolean;
    videoRequestStatus?: string;
}

interface MediaDecoderStateMachineDecodingStateDebugInfo {
    isPrerolling?: boolean;
}

interface MediaDecodingConfiguration extends MediaConfiguration {
    keySystemConfiguration?: MediaCapabilitiesKeySystemConfiguration;
    type: MediaDecodingType;
}

interface MediaElementAudioSourceOptions {
    mediaElement: HTMLMediaElement;
}

interface MediaEncodingConfiguration extends MediaConfiguration {
    type: MediaEncodingType;
}

interface MediaFormatReaderDebugInfo {
    audioChannels?: number;
    audioDecoderName?: string;
    audioFramesDecoded?: number;
    audioRate?: number;
    audioState?: MediaStateDebugInfo;
    audioType?: string;
    frameStats?: MediaFrameStats;
    totalReadMetadataTimeMs?: number;
    totalWaitingForVideoDataTimeMs?: number;
    videoDecoderName?: string;
    videoHardwareAccelerated?: boolean;
    videoHeight?: number;
    videoNumSamplesOutputTotal?: number;
    videoNumSamplesSkippedTotal?: number;
    videoRate?: number;
    videoState?: MediaStateDebugInfo;
    videoType?: string;
    videoWidth?: number;
}

interface MediaFrameStats {
    droppedCompositorFrames?: number;
    droppedDecodedFrames?: number;
    droppedSinkFrames?: number;
}

interface MediaImage {
    sizes?: string;
    src: string;
    type?: string;
}

interface MediaKeyMessageEventInit extends EventInit {
    message: ArrayBuffer;
    messageType: MediaKeyMessageType;
}

interface MediaKeyNeededEventInit extends EventInit {
    initData?: ArrayBuffer | null;
    initDataType?: string;
}

interface MediaKeySystemConfiguration {
    audioCapabilities?: MediaKeySystemMediaCapability[];
    distinctiveIdentifier?: MediaKeysRequirement;
    initDataTypes?: string[];
    label?: string;
    persistentState?: MediaKeysRequirement;
    sessionTypes?: string[];
    videoCapabilities?: MediaKeySystemMediaCapability[];
}

interface MediaKeySystemMediaCapability {
    contentType?: string;
    encryptionScheme?: string | null;
    robustness?: string;
}

interface MediaKeysPolicy {
    minHdcpVersion?: HDCPVersion;
}

interface MediaMetadataInit {
    album?: string;
    artist?: string;
    artwork?: MediaImage[];
    title?: string;
}

interface MediaPositionState {
    duration?: number;
    playbackRate?: number;
    position?: number;
}

interface MediaQueryListEventInit extends EventInit {
    matches?: boolean;
    media?: string;
}

interface MediaRecorderErrorEventInit extends EventInit {
    error: DOMException;
}

interface MediaRecorderOptions {
    audioBitsPerSecond?: number;
    bitsPerSecond?: number;
    mimeType?: string;
    videoBitsPerSecond?: number;
}

interface MediaResourceDebugInfo {
    cacheStream?: MediaCacheStreamDebugInfo;
}

interface MediaSessionActionDetails {
    action: MediaSessionAction;
    fastSeek?: boolean;
    seekOffset?: number;
    seekTime?: number;
}

interface MediaSinkDebugInfo {
    audioSinkWrapper?: AudioSinkWrapperDebugInfo;
    decodedStream?: DecodedStreamDebugInfo;
    videoSink?: VideoSinkDebugInfo;
}

interface MediaSourceDecoderDebugInfo {
    demuxer?: MediaSourceDemuxerDebugInfo;
    reader?: MediaFormatReaderDebugInfo;
}

interface MediaSourceDemuxerDebugInfo {
    audioTrack?: TrackBuffersManagerDebugInfo;
    videoTrack?: TrackBuffersManagerDebugInfo;
}

interface MediaStateDebugInfo {
    demuxEOS?: number;
    demuxQueueSize?: number;
    drainState?: number;
    hasDecoder?: boolean;
    hasDemuxRequest?: boolean;
    hasPromise?: boolean;
    lastStreamSourceID?: number;
    needInput?: boolean;
    numSamplesInput?: number;
    numSamplesOutput?: number;
    pending?: number;
    queueSize?: number;
    timeTreshold?: number;
    timeTresholdHasSeeked?: boolean;
    waitingForData?: boolean;
    waitingForKey?: boolean;
    waitingPromise?: boolean;
}

interface MediaStreamAudioSourceOptions {
    mediaStream: MediaStream;
}

interface MediaStreamConstraints {
    audio?: boolean | MediaTrackConstraints;
    fake?: boolean;
    peerIdentity?: string | null;
    picture?: boolean;
    video?: boolean | MediaTrackConstraints;
}

interface MediaStreamEventInit extends EventInit {
    stream?: MediaStream | null;
}

interface MediaStreamTrackAudioSourceOptions {
    mediaStreamTrack: MediaStreamTrack;
}

interface MediaStreamTrackEventInit extends EventInit {
    track: MediaStreamTrack;
}

interface MediaTrackCapabilities {
    autoGainControl?: boolean[];
    channelCount?: ULongRange;
    deviceId?: string;
    echoCancellation?: boolean[];
    facingMode?: string[];
    frameRate?: DoubleRange;
    groupId?: string;
    height?: ULongRange;
    noiseSuppression?: boolean[];
    width?: ULongRange;
}

interface MediaTrackConstraintSet {
    autoGainControl?: ConstrainBoolean;
    browserWindow?: number;
    channelCount?: ConstrainLong;
    deviceId?: ConstrainDOMString;
    echoCancellation?: ConstrainBoolean;
    facingMode?: ConstrainDOMString;
    frameRate?: ConstrainDouble;
    groupId?: ConstrainDOMString;
    height?: ConstrainLong;
    mediaSource?: string;
    noiseSuppression?: ConstrainBoolean;
    scrollWithPage?: boolean;
    viewportHeight?: ConstrainLong;
    viewportOffsetX?: ConstrainLong;
    viewportOffsetY?: ConstrainLong;
    viewportWidth?: ConstrainLong;
    width?: ConstrainLong;
}

interface MediaTrackConstraints extends MediaTrackConstraintSet {
    advanced?: MediaTrackConstraintSet[];
}

interface MediaTrackSettings {
    autoGainControl?: boolean;
    browserWindow?: number;
    channelCount?: number;
    deviceId?: string;
    echoCancellation?: boolean;
    facingMode?: string;
    frameRate?: number;
    groupId?: string;
    height?: number;
    mediaSource?: string;
    noiseSuppression?: boolean;
    scrollWithPage?: boolean;
    viewportHeight?: number;
    viewportOffsetX?: number;
    viewportOffsetY?: number;
    viewportWidth?: number;
    width?: number;
}

interface MediaTrackSupportedConstraints {
    aspectRatio?: boolean;
    autoGainControl?: boolean;
    browserWindow?: boolean;
    channelCount?: boolean;
    deviceId?: boolean;
    echoCancellation?: boolean;
    facingMode?: boolean;
    frameRate?: boolean;
    groupId?: boolean;
    height?: boolean;
    latency?: boolean;
    mediaSource?: boolean;
    noiseSuppression?: boolean;
    sampleRate?: boolean;
    sampleSize?: boolean;
    scrollWithPage?: boolean;
    viewportHeight?: boolean;
    viewportOffsetX?: boolean;
    viewportOffsetY?: boolean;
    viewportWidth?: boolean;
    volume?: boolean;
    width?: boolean;
}

interface MerchantValidationEventInit extends EventInit {
    methodName?: string;
    validationURL?: string;
}

interface MessageEventInit extends EventInit {
    data?: any;
    lastEventId?: string;
    origin?: string;
    ports?: MessagePort[];
    source?: MessageEventSource | null;
}

interface MouseEventInit extends EventModifierInit {
    button?: number;
    buttons?: number;
    clientX?: number;
    clientY?: number;
    movementX?: number;
    movementY?: number;
    relatedTarget?: EventTarget | null;
    screenX?: number;
    screenY?: number;
}

interface MoveOptions {
    noOverwrite?: boolean;
}

interface MozDocumentMatcherInit {
    allFrames?: boolean;
    checkPermissions?: boolean;
    excludeGlobs?: MatchGlobOrString[] | null;
    excludeMatches?: MatchPatternSetOrStringSequence | null;
    frameID?: number | null;
    hasActiveTabPermission?: boolean;
    includeGlobs?: MatchGlobOrString[] | null;
    isUserScript?: boolean;
    matchAboutBlank?: boolean;
    matchOriginAsFallback?: boolean;
    matches: MatchPatternSetOrStringSequence;
    originAttributesPatterns?: OriginAttributesPatternDictionary[] | null;
}

interface MozFrameAncestorInfo {
    frameId: number;
    url: string;
}

interface MozHTTPHeader {
    name: string;
    value: string;
}

interface MozProxyInfo {
    connectionIsolationKey?: string | null;
    failoverTimeout?: number;
    host: string;
    port: number;
    proxyAuthorizationHeader?: string | null;
    proxyDNS: boolean;
    type: string;
    username?: string | null;
}

interface MozRequestFilter {
    incognito?: boolean | null;
    types?: MozContentPolicyType[] | null;
    urls?: MatchPatternSet | null;
}

interface MozRequestMatchOptions {
    isProxy?: boolean;
}

interface MozUrlClassification {
    firstParty: MozUrlClassificationFlags[];
    thirdParty: MozUrlClassificationFlags[];
}

interface MozXMLHttpRequestParameters {
    mozAnon?: boolean;
    mozSystem?: boolean;
}

interface MultiCacheQueryOptions extends CacheQueryOptions {
    cacheName?: string;
}

interface MutationObserverInit {
    animations?: boolean;
    attributeFilter?: string[];
    attributeOldValue?: boolean;
    attributes?: boolean;
    characterData?: boolean;
    characterDataOldValue?: boolean;
    childList?: boolean;
    chromeOnlyNodes?: boolean;
    subtree?: boolean;
}

interface MutationObservingInfo extends MutationObserverInit {
    observedNode?: Node | null;
}

interface NavigateEventInit extends EventInit {
    canIntercept?: boolean;
    destination: NavigationDestination;
    downloadRequest?: string | null;
    formData?: FormData | null;
    hasUAVisualTransition?: boolean;
    hashChange?: boolean;
    info?: any;
    navigationType?: NavigationType;
    signal: AbortSignal;
    sourceElement?: Element | null;
    userInitiated?: boolean;
}

interface NavigationCurrentEntryChangeEventInit extends EventInit {
    from: NavigationHistoryEntry;
    navigationType?: NavigationType | null;
}

interface NavigationInterceptOptions {
    focusReset?: NavigationFocusReset;
    handler?: NavigationInterceptHandler;
    scroll?: NavigationScrollBehavior;
}

interface NavigationNavigateOptions extends NavigationOptions {
    history?: NavigationHistoryBehavior;
    state?: any;
}

interface NavigationOptions {
    info?: any;
}

interface NavigationPreloadState {
    enabled?: boolean;
    headerValue?: string;
}

interface NavigationReloadOptions extends NavigationOptions {
    state?: any;
}

interface NavigationResult {
    committed?: Promise<NavigationHistoryEntry>;
    finished?: Promise<NavigationHistoryEntry>;
}

interface NavigationUpdateCurrentEntryOptions {
    state: any;
}

interface NetErrorInfo {
    channelStatus?: number;
    errorCodeString?: string;
    responseStatus?: number;
    responseStatusText?: string;
}

interface NotificationAction {
    action: string;
    title: string;
}

interface NotificationOptions {
    actions?: NotificationAction[];
    body?: string;
    data?: any;
    dir?: NotificationDirection;
    icon?: string;
    lang?: string;
    requireInteraction?: boolean;
    silent?: boolean;
    tag?: string;
    vibrate?: VibratePattern;
}

interface ObservableArrayCallbacks {
    deleteBooleanCallback?: SetDeleteBooleanCallback;
    deleteInterfaceCallback?: SetDeleteInterfaceCallback;
    deleteObjectCallback?: SetDeleteObjectCallback;
    setBooleanCallback?: SetDeleteBooleanCallback;
    setInterfaceCallback?: SetDeleteInterfaceCallback;
    setObjectCallback?: SetDeleteObjectCallback;
}

interface OfflineAudioCompletionEventInit extends EventInit {
    renderedBuffer: AudioBuffer;
}

interface OfflineAudioContextOptions {
    length: number;
    numberOfChannels?: number;
    sampleRate: number;
}

interface OpenPopupOptions {
    attributesOverride?: boolean;
    isContextMenu?: boolean;
    position?: string;
    triggerEvent?: Event | null;
    x?: number;
    y?: number;
}

interface OptionalEffectTiming {
    delay?: number;
    direction?: PlaybackDirection;
    duration?: number | string;
    easing?: string;
    endDelay?: number;
    fill?: FillMode;
    iterationStart?: number;
    iterations?: number;
}

interface OpusEncoderConfig {
    complexity?: number;
    format?: OpusBitstreamFormat;
    frameDuration?: number;
    packetlossperc?: number;
    usedtx?: boolean;
    useinbandfec?: boolean;
}

interface OriginAttributesDictionary {
    firstPartyDomain?: string;
    geckoViewSessionContextId?: string;
    partitionKey?: string;
    privateBrowsingId?: number;
    userContextId?: number;
}

interface OriginAttributesPatternDictionary {
    firstPartyDomain?: string;
    geckoViewSessionContextId?: string;
    partitionKey?: string;
    partitionKeyPattern?: PartitionKeyPatternDictionary;
    privateBrowsingId?: number;
    userContextId?: number;
}

interface OscillatorOptions extends AudioNodeOptions {
    detune?: number;
    frequency?: number;
    periodicWave?: PeriodicWave;
    type?: OscillatorType;
}

interface PCErrorData {
    message: string;
    name: PCError;
}

interface PageTransitionEventInit extends EventInit {
    inFrameSwap?: boolean;
    persisted?: boolean;
}

interface PannerOptions extends AudioNodeOptions {
    coneInnerAngle?: number;
    coneOuterAngle?: number;
    coneOuterGain?: number;
    distanceModel?: DistanceModelType;
    maxDistance?: number;
    orientationX?: number;
    orientationY?: number;
    orientationZ?: number;
    panningModel?: PanningModelType;
    positionX?: number;
    positionY?: number;
    positionZ?: number;
    refDistance?: number;
    rolloffFactor?: number;
}

interface ParentProcInfoDictionary {
    children?: ChildProcInfoDictionary[];
    cpuCycleCount?: number;
    cpuTime?: number;
    memory?: number;
    pid?: number;
    threads?: ThreadInfoDictionary[];
    type?: WebIDLProcType;
}

interface PartitionKeyPatternDictionary {
    baseDomain?: string;
    foreignByAncestorContext?: boolean;
    port?: number;
    scheme?: string;
}

interface PayerErrors {
    email?: string;
    name?: string;
    phone?: string;
}

interface PaymentCurrencyAmount {
    currency: string;
    value: string;
}

interface PaymentDetailsBase {
    displayItems?: PaymentItem[];
    modifiers?: PaymentDetailsModifier[];
    shippingOptions?: PaymentShippingOption[];
}

interface PaymentDetailsInit extends PaymentDetailsBase {
    id?: string;
    total: PaymentItem;
}

interface PaymentDetailsModifier {
    additionalDisplayItems?: PaymentItem[];
    data?: any;
    supportedMethods: string;
    total?: PaymentItem;
}

interface PaymentDetailsUpdate extends PaymentDetailsBase {
    error?: string;
    payerErrors?: PayerErrors;
    paymentMethodErrors?: any;
    shippingAddressErrors?: AddressErrors;
    total?: PaymentItem;
}

interface PaymentItem {
    amount: PaymentCurrencyAmount;
    label: string;
    pending?: boolean;
}

interface PaymentMethodChangeEventInit extends PaymentRequestUpdateEventInit {
    methodDetails?: any;
    methodName?: string;
}

interface PaymentMethodData {
    data?: any;
    supportedMethods: string;
}

interface PaymentOptions {
    requestBillingAddress?: boolean;
    requestPayerEmail?: boolean;
    requestPayerName?: boolean;
    requestPayerPhone?: boolean;
    requestShipping?: boolean;
    shippingType?: PaymentShippingType;
}

interface PaymentRequestUpdateEventInit extends EventInit {
}

interface PaymentShippingOption {
    amount: PaymentCurrencyAmount;
    id: string;
    label: string;
    selected?: boolean;
}

interface PaymentValidationErrors {
    error?: string;
    payer?: PayerErrors;
    paymentMethod?: any;
    shippingAddress?: AddressErrors;
}

interface PerformanceEntryEventInit extends EventInit {
    duration?: DOMHighResTimeStamp;
    entryType?: string;
    epoch?: number;
    name?: string;
    origin?: string;
    startTime?: DOMHighResTimeStamp;
}

interface PerformanceEntryFilterOptions {
    entryType?: string;
    initiatorType?: string;
    name?: string;
}

interface PerformanceMarkOptions {
    detail?: any;
    startTime?: DOMHighResTimeStamp;
}

interface PerformanceMeasureOptions {
    detail?: any;
    duration?: DOMHighResTimeStamp;
    end?: string | DOMHighResTimeStamp;
    start?: string | DOMHighResTimeStamp;
}

interface PerformanceObserverInit {
    buffered?: boolean;
    durationThreshold?: DOMHighResTimeStamp;
    entryTypes?: string[];
    type?: string;
}

interface PeriodicWaveConstraints {
    disableNormalization?: boolean;
}

interface PeriodicWaveOptions extends PeriodicWaveConstraints {
    imag?: number[] | Float32Array;
    real?: number[] | Float32Array;
}

interface PermissionSetParameters {
    descriptor: any;
    state: PermissionState;
}

interface PlacesBookmarkAdditionInit {
    dateAdded: number;
    frecency: number;
    guid: string;
    hidden: boolean;
    id: number;
    index: number;
    isTagging: boolean;
    itemType: number;
    lastVisitDate: number | null;
    parentGuid: string;
    parentId: number;
    source: number;
    tags: string | null;
    targetFolderGuid: string | null;
    targetFolderItemId: number;
    targetFolderTitle: string | null;
    title: string;
    url: string;
    visitCount: number;
}

interface PlacesBookmarkGuidInit {
    guid: string;
    id: number;
    isTagging: boolean;
    itemType: number;
    lastModified: number;
    parentGuid: string;
    source: number;
    url?: string | null;
}

interface PlacesBookmarkKeywordInit {
    guid: string;
    id: number;
    isTagging: boolean;
    itemType: number;
    keyword: string;
    lastModified: number;
    parentGuid: string;
    source: number;
    url?: string | null;
}

interface PlacesBookmarkMovedInit {
    dateAdded: number;
    frecency: number;
    guid: string;
    hidden: boolean;
    id: number;
    index: number;
    isTagging: boolean;
    itemType: number;
    lastVisitDate: number | null;
    oldIndex: number;
    oldParentGuid: string;
    parentGuid: string;
    source: number;
    tags: string | null;
    title: string;
    url?: string | null;
    visitCount: number;
}

interface PlacesBookmarkRemovedInit {
    guid: string;
    id: number;
    index: number;
    isDescendantRemoval?: boolean;
    isTagging: boolean;
    itemType: number;
    parentGuid: string;
    parentId: number;
    source: number;
    title: string;
    url: string;
}

interface PlacesBookmarkTagsInit {
    guid: string;
    id: number;
    isTagging: boolean;
    itemType: number;
    lastModified: number;
    parentGuid: string;
    source: number;
    tags: string[];
    url?: string | null;
}

interface PlacesBookmarkTimeInit {
    dateAdded: number;
    guid: string;
    id: number;
    isTagging: boolean;
    itemType: number;
    lastModified: number;
    parentGuid: string;
    source: number;
    url?: string | null;
}

interface PlacesBookmarkTitleInit {
    guid: string;
    id: number;
    isTagging: boolean;
    itemType: number;
    lastModified: number;
    parentGuid: string;
    source: number;
    title: string;
    url?: string | null;
}

interface PlacesBookmarkUrlInit {
    guid: string;
    id: number;
    isTagging: boolean;
    itemType: number;
    lastModified: number;
    parentGuid: string;
    source: number;
    url: string;
}

interface PlacesFaviconInit {
    faviconUrl: string;
    pageGuid: string;
    url: string;
}

interface PlacesVisitRemovedInit {
    isPartialVisistsRemoval?: boolean;
    isRemovedFromStore?: boolean;
    pageGuid: string;
    reason: number;
    transitionType?: number;
    url: string;
}

interface PlacesVisitTitleInit {
    pageGuid: string;
    title: string;
    url: string;
}

interface PlaneLayout {
    offset: number;
    stride: number;
}

interface PluginCrashedEventInit extends EventInit {
    gmpPlugin?: boolean;
    pluginDumpID?: string;
    pluginFilename?: string | null;
    pluginID?: number;
    pluginName?: string;
    submittedCrashReport?: boolean;
}

interface PointerEventInit extends MouseEventInit {
    altitudeAngle?: number;
    azimuthAngle?: number;
    coalescedEvents?: PointerEvent[];
    height?: number;
    isPrimary?: boolean;
    pointerId?: number;
    pointerType?: string;
    predictedEvents?: PointerEvent[];
    pressure?: number;
    tangentialPressure?: number;
    tiltX?: number;
    tiltY?: number;
    twist?: number;
    width?: number;
}

interface PopStateEventInit extends EventInit {
    state?: any;
}

interface PopupBlockedEventInit extends EventInit {
    popupWindowFeatures?: string;
    popupWindowName?: string;
    popupWindowURI?: URI | null;
    requestingWindow?: Window | null;
}

interface PopupPositionedEventInit extends EventInit {
    alignmentOffset?: number;
    alignmentPosition?: string;
    isAnchored?: boolean;
    popupAlignment?: string;
}

interface PositionOptions {
    enableHighAccuracy?: boolean;
    maximumAge?: number;
    timeout?: number;
}

interface PositionStateEventInit extends EventInit {
    duration: number;
    playbackRate: number;
    position: number;
}

interface PrivateAttributionConversionOptions {
    ads?: string[];
    histogramSize: number;
    impression?: PrivateAttributionImpressionType;
    lookbackDays?: number;
    sources?: string[];
    task: string;
}

interface PrivateAttributionImpressionOptions {
    ad: string;
    index: number;
    target: string;
    type?: PrivateAttributionImpressionType;
}

interface ProcessActorChildOptions extends ProcessActorSidedOptions {
    observers?: string[];
}

interface ProcessActorOptions {
    child?: ProcessActorChildOptions;
    includeParent?: boolean;
    loadInDevToolsLoader?: boolean;
    parent?: ProcessActorSidedOptions;
    remoteTypes?: string[];
}

interface ProcessActorSidedOptions {
    esModuleURI?: string;
}

interface ProfilerMarkerOptions {
    captureStack?: boolean;
    category?: string;
    innerWindowId?: number;
    startTime?: DOMHighResTimeStamp;
}

interface ProgressEventInit extends EventInit {
    lengthComputable?: boolean;
    loaded?: number;
    total?: number;
}

interface PromiseDebuggingStateHolder {
    reason?: any;
    state?: PromiseDebuggingState;
    value?: any;
}

interface PromiseRejectionEventInit extends EventInit {
    promise: any;
    reason?: any;
}

interface PropertyDefinition {
    inherits: boolean;
    initialValue?: string;
    name: string;
    syntax?: string;
}

interface PropertyNamesOptions {
    includeAliases?: boolean;
    includeExperimentals?: boolean;
    includeShorthands?: boolean;
}

interface PropertyPref {
    name: string;
    pref: string;
}

interface PublicKeyCredentialCreationOptions {
    attestation?: string;
    authenticatorSelection?: AuthenticatorSelectionCriteria;
    challenge: BufferSource;
    excludeCredentials?: PublicKeyCredentialDescriptor[];
    extensions?: AuthenticationExtensionsClientInputs;
    pubKeyCredParams: PublicKeyCredentialParameters[];
    rp: PublicKeyCredentialRpEntity;
    timeout?: number;
    user: PublicKeyCredentialUserEntity;
}

interface PublicKeyCredentialCreationOptionsJSON {
    attestation?: string;
    attestationFormats?: string[];
    authenticatorSelection?: AuthenticatorSelectionCriteria;
    challenge: Base64URLString;
    excludeCredentials?: PublicKeyCredentialDescriptorJSON[];
    extensions?: AuthenticationExtensionsClientInputsJSON;
    hints?: string[];
    pubKeyCredParams: PublicKeyCredentialParameters[];
    rp: PublicKeyCredentialRpEntity;
    timeout?: number;
    user: PublicKeyCredentialUserEntityJSON;
}

interface PublicKeyCredentialDescriptor {
    id: BufferSource;
    transports?: string[];
    type: string;
}

interface PublicKeyCredentialDescriptorJSON {
    id: Base64URLString;
    transports?: string[];
    type: string;
}

interface PublicKeyCredentialEntity {
    name: string;
}

interface PublicKeyCredentialParameters {
    alg: COSEAlgorithmIdentifier;
    type: string;
}

interface PublicKeyCredentialRequestOptions {
    allowCredentials?: PublicKeyCredentialDescriptor[];
    challenge: BufferSource;
    extensions?: AuthenticationExtensionsClientInputs;
    rpId?: string;
    timeout?: number;
    userVerification?: string;
}

interface PublicKeyCredentialRequestOptionsJSON {
    allowCredentials?: PublicKeyCredentialDescriptorJSON[];
    attestation?: string;
    attestationFormats?: string[];
    challenge: Base64URLString;
    extensions?: AuthenticationExtensionsClientInputsJSON;
    hints?: string[];
    rpId?: string;
    timeout?: number;
    userVerification?: string;
}

interface PublicKeyCredentialRpEntity extends PublicKeyCredentialEntity {
    id?: string;
}

interface PublicKeyCredentialUserEntity extends PublicKeyCredentialEntity {
    displayName: string;
    id: BufferSource;
}

interface PublicKeyCredentialUserEntityJSON {
    displayName: string;
    id: Base64URLString;
    name: string;
}

interface PushSubscriptionInit {
    appServerKey?: BufferSource | null;
    authSecret?: ArrayBuffer | null;
    endpoint: string;
    expirationTime?: EpochTimeStamp | null;
    p256dhKey?: ArrayBuffer | null;
    scope: string;
}

interface PushSubscriptionJSON {
    endpoint?: string;
    expirationTime?: EpochTimeStamp | null;
    keys?: PushSubscriptionKeys;
}

interface PushSubscriptionKeys {
    auth?: string;
    p256dh?: string;
}

interface PushSubscriptionOptionsInit {
    applicationServerKey?: BufferSource | string | null;
}

interface QueuingStrategy {
    highWaterMark?: number;
    size?: QueuingStrategySize;
}

interface QueuingStrategyInit {
    highWaterMark: number;
}

interface RTCBandwidthEstimationInternal {
    maxPaddingBps?: number;
    pacerDelayMs?: number;
    receiveBandwidthBps?: number;
    rttMs?: number;
    sendBandwidthBps?: number;
    trackIdentifier: string;
}

interface RTCCodecStats extends RTCStats {
    channels?: number;
    clockRate?: number;
    codecType?: RTCCodecType;
    mimeType: string;
    payloadType: number;
    sdpFmtpLine?: string;
    transportId: string;
}

interface RTCConfiguration {
    bundlePolicy?: RTCBundlePolicy;
    certificates?: RTCCertificate[];
    iceServers?: RTCIceServer[];
    iceTransportPolicy?: RTCIceTransportPolicy;
    peerIdentity?: string | null;
    sdpSemantics?: string;
}

interface RTCConfigurationInternal {
    bundlePolicy?: RTCBundlePolicy;
    certificatesProvided: boolean;
    iceServers?: RTCIceServerInternal[];
    iceTransportPolicy?: RTCIceTransportPolicy;
    peerIdentityProvided: boolean;
    sdpSemantics?: string;
}

interface RTCDTMFToneChangeEventInit extends EventInit {
    tone?: string;
}

interface RTCDataChannelEventInit extends EventInit {
    channel: RTCDataChannel;
}

interface RTCDataChannelInit {
    id?: number;
    maxPacketLifeTime?: number;
    maxRetransmitTime?: number;
    maxRetransmits?: number;
    negotiated?: boolean;
    ordered?: boolean;
    protocol?: string;
}

interface RTCDataChannelStats extends RTCStats {
    bytesReceived?: number;
    bytesSent?: number;
    dataChannelIdentifier?: number;
    label?: string;
    messagesReceived?: number;
    messagesSent?: number;
    protocol?: string;
    state?: RTCDataChannelState;
}

interface RTCDtlsFingerprint {
    algorithm?: string;
    value?: string;
}

interface RTCEncodedAudioFrameMetadata {
    contributingSources?: number[];
    payloadType?: number;
    sequenceNumber?: number;
    synchronizationSource?: number;
}

interface RTCEncodedVideoFrameMetadata {
    contributingSources?: number[];
    dependencies?: number[];
    frameId?: number;
    height?: number;
    payloadType?: number;
    spatialIndex?: number;
    synchronizationSource?: number;
    temporalIndex?: number;
    timestamp?: number;
    width?: number;
}

interface RTCIceCandidateInit {
    candidate?: string;
    sdpMLineIndex?: number | null;
    sdpMid?: string | null;
    usernameFragment?: string | null;
}

interface RTCIceCandidatePairStats extends RTCStats {
    bytesReceived?: number;
    bytesSent?: number;
    componentId?: number;
    lastPacketReceivedTimestamp?: DOMHighResTimeStamp;
    lastPacketSentTimestamp?: DOMHighResTimeStamp;
    localCandidateId?: string;
    nominated?: boolean;
    priority?: number;
    readable?: boolean;
    remoteCandidateId?: string;
    selected?: boolean;
    state?: RTCStatsIceCandidatePairState;
    transportId?: string;
    writable?: boolean;
}

interface RTCIceCandidateStats extends RTCStats {
    address?: string;
    candidateType?: RTCIceCandidateType;
    port?: number;
    priority?: number;
    protocol?: string;
    proxied?: string;
    relayProtocol?: string;
    transportId?: string;
}

interface RTCIceServer {
    credential?: string;
    credentialType?: RTCIceCredentialType;
    url?: string;
    urls?: string | string[];
    username?: string;
}

interface RTCIceServerInternal {
    credentialProvided: boolean;
    urls?: string[];
    userNameProvided: boolean;
}

interface RTCIdentityAssertion {
    idp?: string;
    name?: string;
}

interface RTCIdentityAssertionResult {
    assertion: string;
    idp: RTCIdentityProviderDetails;
}

interface RTCIdentityProvider {
    generateAssertion: GenerateAssertionCallback;
    validateAssertion: ValidateAssertionCallback;
}

interface RTCIdentityProviderDetails {
    domain: string;
    protocol?: string;
}

interface RTCIdentityProviderOptions {
    peerIdentity?: string;
    protocol?: string;
    usernameHint?: string;
}

interface RTCIdentityValidationResult {
    contents: string;
    identity: string;
}

interface RTCInboundRtpStreamStats extends RTCReceivedRtpStreamStats {
    audioLevel?: number;
    bytesReceived?: number;
    concealedSamples?: number;
    concealmentEvents?: number;
    fecPacketsDiscarded?: number;
    fecPacketsReceived?: number;
    firCount?: number;
    frameHeight?: number;
    frameWidth?: number;
    framesDecoded?: number;
    framesDropped?: number;
    framesPerSecond?: number;
    framesReceived?: number;
    headerBytesReceived?: number;
    insertedSamplesForDeceleration?: number;
    jitterBufferDelay?: number;
    jitterBufferEmittedCount?: number;
    lastPacketReceivedTimestamp?: DOMHighResTimeStamp;
    mid?: string;
    nackCount?: number;
    pliCount?: number;
    qpSum?: number;
    remoteId?: string;
    removedSamplesForAcceleration?: number;
    silentConcealedSamples?: number;
    totalAudioEnergy?: number;
    totalDecodeTime?: number;
    totalInterFrameDelay?: number;
    totalProcessingDelay?: number;
    totalSamplesDuration?: number;
    totalSamplesReceived?: number;
    totalSquaredInterFrameDelay?: number;
    trackIdentifier: string;
}

interface RTCLocalSessionDescriptionInit {
    sdp?: string;
    type?: RTCSdpType;
}

interface RTCMediaSourceStats extends RTCStats {
    kind: string;
    trackIdentifier: string;
}

interface RTCOfferAnswerOptions {
}

interface RTCOfferOptions extends RTCOfferAnswerOptions {
    iceRestart?: boolean;
    offerToReceiveAudio?: boolean;
    offerToReceiveVideo?: boolean;
}

interface RTCOutboundRtpStreamStats extends RTCSentRtpStreamStats {
    firCount?: number;
    frameHeight?: number;
    frameWidth?: number;
    framesEncoded?: number;
    framesPerSecond?: number;
    framesSent?: number;
    headerBytesSent?: number;
    hugeFramesSent?: number;
    mid?: string;
    nackCount?: number;
    pliCount?: number;
    qpSum?: number;
    remoteId?: string;
    retransmittedBytesSent?: number;
    retransmittedPacketsSent?: number;
    rid?: string;
    totalEncodeTime?: number;
    totalEncodedBytesTarget?: number;
}

interface RTCPeerConnectionIceEventInit extends EventInit {
    candidate?: RTCIceCandidate | null;
}

interface RTCPeerConnectionStats extends RTCStats {
    dataChannelsClosed?: number;
    dataChannelsOpened?: number;
}

interface RTCRTPContributingSourceStats extends RTCStats {
    contributorSsrc?: number;
    inboundRtpStreamId?: string;
}

interface RTCReceivedRtpStreamStats extends RTCRtpStreamStats {
    discardedPackets?: number;
    jitter?: number;
    packetsDiscarded?: number;
    packetsLost?: number;
    packetsReceived?: number;
}

interface RTCRemoteInboundRtpStreamStats extends RTCReceivedRtpStreamStats {
    fractionLost?: number;
    localId?: string;
    roundTripTime?: number;
    roundTripTimeMeasurements?: number;
    totalRoundTripTime?: number;
}

interface RTCRemoteOutboundRtpStreamStats extends RTCSentRtpStreamStats {
    localId?: string;
    remoteTimestamp?: DOMHighResTimeStamp;
}

interface RTCRtcpParameters {
    cname?: string;
    reducedSize?: boolean;
}

interface RTCRtpCapabilities {
    codecs: RTCRtpCodec[];
    headerExtensions: RTCRtpHeaderExtensionCapability[];
}

interface RTCRtpCodec {
    channels?: number;
    clockRate: number;
    mimeType: string;
    sdpFmtpLine?: string;
}

interface RTCRtpCodecParameters extends RTCRtpCodec {
    payloadType: number;
}

interface RTCRtpContributingSource {
    audioLevel?: number;
    rtpTimestamp: number;
    source: number;
    timestamp: DOMHighResTimeStamp;
}

interface RTCRtpEncodingParameters {
    active?: boolean;
    maxBitrate?: number;
    maxFramerate?: number;
    priority?: RTCPriorityType;
    rid?: string;
    scaleResolutionDownBy?: number;
}

interface RTCRtpHeaderExtensionCapability {
    uri: string;
}

interface RTCRtpHeaderExtensionParameters {
    encrypted?: boolean;
    id?: number;
    uri?: string;
}

interface RTCRtpParameters {
    codecs?: RTCRtpCodecParameters[];
    headerExtensions?: RTCRtpHeaderExtensionParameters[];
    rtcp?: RTCRtcpParameters;
}

interface RTCRtpReceiveParameters extends RTCRtpParameters {
}

interface RTCRtpSendParameters extends RTCRtpParameters {
    degradationPreference?: RTCDegradationPreference;
    encodings: RTCRtpEncodingParameters[];
    transactionId?: string;
}

interface RTCRtpStreamStats extends RTCStats {
    codecId?: string;
    kind: string;
    mediaType?: string;
    ssrc: number;
    transportId?: string;
}

interface RTCRtpSynchronizationSource extends RTCRtpContributingSource {
    voiceActivityFlag?: boolean | null;
}

interface RTCRtpTransceiverInit {
    direction?: RTCRtpTransceiverDirection;
    sendEncodings?: RTCRtpEncodingParameters[];
    streams?: MediaStream[];
}

interface RTCSdpHistoryEntryInternal {
    errors?: RTCSdpParsingErrorInternal[];
    isLocal: boolean;
    sdp: string;
    timestamp: DOMHighResTimeStamp;
}

interface RTCSdpHistoryInternal {
    pcid: string;
    sdpHistory?: RTCSdpHistoryEntryInternal[];
}

interface RTCSdpParsingErrorInternal {
    error: string;
    lineNumber: number;
}

interface RTCSentRtpStreamStats extends RTCRtpStreamStats {
    bytesSent?: number;
    packetsSent?: number;
}

interface RTCSessionDescriptionInit {
    sdp?: string;
    type: RTCSdpType;
}

interface RTCStats {
    id?: string;
    timestamp?: DOMHighResTimeStamp;
    type?: RTCStatsType;
}

interface RTCStatsCollection {
    bandwidthEstimations?: RTCBandwidthEstimationInternal[];
    codecStats?: RTCCodecStats[];
    dataChannelStats?: RTCDataChannelStats[];
    iceCandidatePairStats?: RTCIceCandidatePairStats[];
    iceCandidateStats?: RTCIceCandidateStats[];
    inboundRtpStreamStats?: RTCInboundRtpStreamStats[];
    mediaSourceStats?: RTCMediaSourceStats[];
    outboundRtpStreamStats?: RTCOutboundRtpStreamStats[];
    peerConnectionStats?: RTCPeerConnectionStats[];
    rawLocalCandidates?: string[];
    rawRemoteCandidates?: string[];
    remoteInboundRtpStreamStats?: RTCRemoteInboundRtpStreamStats[];
    remoteOutboundRtpStreamStats?: RTCRemoteOutboundRtpStreamStats[];
    rtpContributingSourceStats?: RTCRTPContributingSourceStats[];
    trickledIceCandidateStats?: RTCIceCandidateStats[];
    videoFrameHistories?: RTCVideoFrameHistoryInternal[];
    videoSourceStats?: RTCVideoSourceStats[];
}

interface RTCStatsReportInternal extends RTCStatsCollection {
    browserId: number;
    callDurationMs?: number;
    closed: boolean;
    configuration?: RTCConfigurationInternal;
    iceRestarts: number;
    iceRollbacks: number;
    jsepSessionErrors?: string;
    offerer?: boolean;
    pcid: string;
    sdpHistory?: RTCSdpHistoryEntryInternal[];
    timestamp: DOMHighResTimeStamp;
}

interface RTCTrackEventInit extends EventInit {
    receiver: RTCRtpReceiver;
    streams?: MediaStream[];
    track: MediaStreamTrack;
    transceiver: RTCRtpTransceiver;
}

interface RTCVideoFrameHistoryEntryInternal {
    consecutiveFrames: number;
    firstFrameTimestamp: DOMHighResTimeStamp;
    height: number;
    lastFrameTimestamp: DOMHighResTimeStamp;
    localSsrc: number;
    remoteSsrc: number;
    rotationAngle: number;
    width: number;
}

interface RTCVideoFrameHistoryInternal {
    entries?: RTCVideoFrameHistoryEntryInternal[];
    trackIdentifier: string;
}

interface RTCVideoSourceStats extends RTCMediaSourceStats {
    frames?: number;
    framesPerSecond?: number;
    height?: number;
    width?: number;
}

interface ReadOptions extends ReadUTF8Options {
    maxBytes?: number | null;
    offset?: number;
}

interface ReadUTF8Options {
    decompress?: boolean;
}

interface ReadableStreamBYOBReaderReadOptions {
    min?: number;
}

interface ReadableStreamGetReaderOptions {
    mode?: ReadableStreamReaderMode;
}

interface ReadableStreamIteratorOptions {
    preventCancel?: boolean;
}

interface ReadableStreamReadResult {
    done?: boolean;
    value?: any;
}

interface ReadableWritablePair {
    readable: ReadableStream;
    writable: WritableStream;
}

interface ReceiveMessageArgument {
    data?: any;
    json?: any;
    name: string;
    ports?: MessagePort[];
    sync: boolean;
    target: nsISupports;
    targetFrameLoader?: FrameLoader;
}

interface RegistrationOptions {
    scope?: string;
    updateViaCache?: ServiceWorkerUpdateViaCache;
}

interface RemotenessOptions {
    pendingSwitchID?: number;
    remoteType: string | null;
    switchingInProgressLoad?: boolean;
}

interface RemoveOptions {
    ignoreAbsent?: boolean;
    recursive?: boolean;
    retryReadonly?: boolean;
}

interface ReportingObserverOptions {
    buffered?: boolean;
    types?: string[];
}

interface RequestInit {
    body?: BodyInit | null;
    cache?: RequestCache;
    credentials?: RequestCredentials;
    headers?: HeadersInit;
    integrity?: string;
    keepalive?: boolean;
    method?: string;
    mode?: RequestMode;
    mozErrors?: boolean;
    neverTaint?: boolean;
    observe?: ObserverCallback;
    priority?: RequestPriority;
    redirect?: RequestRedirect;
    referrer?: string;
    referrerPolicy?: ReferrerPolicy;
    signal?: AbortSignal | null;
    triggeringPrincipal?: Principal;
}

interface ResizeObserverOptions {
    box?: ResizeObserverBoxOptions;
}

interface ResourceId {
    optional?: boolean;
    path: string;
}

interface ResponseInit {
    headers?: HeadersInit;
    status?: number;
    statusText?: string;
}

interface SVGBoundingBoxOptions {
    clipped?: boolean;
    fill?: boolean;
    markers?: boolean;
    stroke?: boolean;
}

interface SVGPathDataSettings {
    normalize?: boolean;
}

interface SVGPathSegmentInit {
    type: string;
    values: number[] | Float32Array;
}

interface SanitizerAttributeNamespace {
    name: string;
    namespace?: string | null;
}

interface SanitizerConfig {
    attributes?: SanitizerAttribute[];
    comments?: boolean;
    dataAttributes?: boolean;
    elements?: SanitizerElementWithAttributes[];
    removeAttributes?: SanitizerAttribute[];
    removeElements?: SanitizerElement[];
    replaceWithChildrenElements?: SanitizerElement[];
}

interface SanitizerElementNamespace {
    name: string;
    namespace?: string | null;
}

interface SanitizerElementNamespaceWithAttributes extends SanitizerElementNamespace {
    attributes?: SanitizerAttribute[];
    removeAttributes?: SanitizerAttribute[];
}

interface SchedulerPostTaskOptions {
    delay?: number;
    priority?: TaskPriority;
    signal?: AbortSignal;
}

interface ScrollIntoViewOptions extends ScrollOptions {
    block?: ScrollLogicalPosition;
    inline?: ScrollLogicalPosition;
}

interface ScrollOptions {
    behavior?: ScrollBehavior;
}

interface ScrollToOptions extends ScrollOptions {
    left?: number;
    top?: number;
}

interface SecurityPolicyViolationEventInit extends EventInit {
    blockedURI?: string;
    columnNumber?: number;
    disposition?: SecurityPolicyViolationEventDisposition;
    documentURI?: string;
    effectiveDirective?: string;
    lineNumber?: number;
    originalPolicy?: string;
    referrer?: string;
    sample?: string;
    sourceFile?: string;
    statusCode?: number;
    violatedDirective?: string;
}

interface SelectorWarning {
    index: number;
    kind: SelectorWarningKind;
}

interface ServerSocketOptions {
    binaryType?: TCPSocketBinaryType;
}

interface SetHTMLOptions {
    sanitizer?: Sanitizer | SanitizerConfig | SanitizerPresets;
}

interface SetHTMLUnsafeOptions {
    sanitizer?: Sanitizer | SanitizerConfig | SanitizerPresets;
}

interface ShadowRootInit {
    clonable?: boolean;
    delegatesFocus?: boolean;
    mode: ShadowRootMode;
    serializable?: boolean;
    slotAssignment?: SlotAssignmentMode;
}

interface ShareData {
    files?: File[];
    text?: string;
    title?: string;
    url?: string;
}

interface SizeToContentConstraints {
    maxHeight?: number;
    maxWidth?: number;
    prefWidth?: number;
}

interface SocketOptions {
    binaryType?: TCPSocketBinaryType;
    useSecureTransport?: boolean;
}

interface SpeechRecognitionErrorInit extends EventInit {
    error?: SpeechRecognitionErrorCode;
    message?: string;
}

interface SpeechRecognitionEventInit extends EventInit {
    emma?: Document | null;
    interpretation?: any;
    resultIndex?: number;
    results?: SpeechRecognitionResultList | null;
}

interface SpeechSynthesisErrorEventInit extends SpeechSynthesisEventInit {
    error: SpeechSynthesisErrorCode;
}

interface SpeechSynthesisEventInit extends EventInit {
    charIndex?: number;
    charLength?: number | null;
    elapsedTime?: number;
    name?: string;
    utterance: SpeechSynthesisUtterance;
}

interface SplitRelativeOptions {
    allowCurrentDir?: boolean;
    allowEmpty?: boolean;
    allowParentDir?: boolean;
}

interface StaticRangeInit {
    endContainer: Node;
    endOffset: number;
    startContainer: Node;
    startOffset: number;
}

interface StereoPannerOptions extends AudioNodeOptions {
    pan?: number;
}

interface StorageEstimate {
    quota?: number;
    usage?: number;
}

interface StorageEventInit extends EventInit {
    key?: string | null;
    newValue?: string | null;
    oldValue?: string | null;
    storageArea?: Storage | null;
    url?: string;
}

interface StreamFilterDataEventInit extends EventInit {
    data: ArrayBuffer;
}

interface StreamPipeOptions {
    preventAbort?: boolean;
    preventCancel?: boolean;
    preventClose?: boolean;
    signal?: AbortSignal;
}

interface StructuredSerializeOptions {
    transfer?: any[];
}

interface StyleSheetApplicableStateChangeEventInit extends EventInit {
    applicable?: boolean;
    stylesheet?: CSSStyleSheet | null;
}

interface StyleSheetRemovedEventInit extends EventInit {
    stylesheet?: CSSStyleSheet | null;
}

interface SubmitEventInit extends EventInit {
    submitter?: HTMLElement | null;
}

interface SupportsOptions {
    chrome?: boolean;
    quirks?: boolean;
    userAgent?: boolean;
}

interface SvcOutputMetadata {
    temporalLayerId?: number;
}

interface TCPServerSocketEventInit extends EventInit {
    socket?: TCPSocket | null;
}

interface TCPSocketErrorEventInit extends EventInit {
    errorCode?: number;
    message?: string;
    name?: string;
}

interface TCPSocketEventInit extends EventInit {
    data?: any;
}

interface TaskControllerInit {
    priority?: TaskPriority;
}

interface TaskPriorityChangeEventInit extends EventInit {
    previousPriority: TaskPriority;
}

interface TaskSignalAnyInit {
    priority?: TaskPriority | TaskSignal;
}

interface TestInterfaceAsyncIterableSingleOptions {
    failToInit?: boolean;
}

interface TestInterfaceAsyncIteratorOptions {
    blockingPromises?: Promise<any>[];
    failNextAfter?: number;
    multiplier?: number;
    throwFromNext?: boolean;
    throwFromReturn?: TestThrowingCallback;
}

interface TestInterfaceJSDictionary {
    anyMember?: any;
    anySequenceMember?: any[];
    innerDictionary?: TestInterfaceJSDictionary2;
    objectMember?: any;
    objectOrStringMember?: any;
    objectRecordMember?: Record<string, any>;
}

interface TestInterfaceJSDictionary2 {
    innerObject?: any;
}

interface TestInterfaceJSUnionableDictionary {
    anyMember?: any;
    objectMember?: any;
}

interface TextDecodeOptions {
    stream?: boolean;
}

interface TextDecoderOptions {
    fatal?: boolean;
    ignoreBOM?: boolean;
}

interface TextEncoderEncodeIntoResult {
    read?: number;
    written?: number;
}

interface ThreadInfoDictionary {
    cpuCycleCount?: number;
    cpuTime?: number;
    name?: string;
    tid?: number;
}

interface ToggleEventInit extends EventInit {
    newState?: string;
    oldState?: string;
}

interface TouchEventInit extends EventModifierInit {
    changedTouches?: Touch[];
    targetTouches?: Touch[];
    touches?: Touch[];
}

interface TouchInit {
    clientX?: number;
    clientY?: number;
    force?: number;
    identifier: number;
    pageX?: number;
    pageY?: number;
    radiusX?: number;
    radiusY?: number;
    rotationAngle?: number;
    screenX?: number;
    screenY?: number;
    target: EventTarget;
}

interface TrackBuffersManagerDebugInfo {
    bufferSize?: number;
    evictable?: number;
    nextGetSampleIndex?: number;
    nextInsertionIndex?: number;
    nextSampleTime?: number;
    numSamples?: number;
    ranges?: BufferRange[];
    type?: string;
}

interface TrackEventInit extends EventInit {
    track?: VideoTrack | AudioTrack | TextTrack | null;
}

interface TransitionEventInit extends EventInit {
    elapsedTime?: number;
    propertyName?: string;
    pseudoElement?: string;
}

interface TreeCellInfo {
    childElt?: string;
    col?: TreeColumn | null;
    row?: number;
}

interface TrustedTypePolicyOptions {
    createHTML?: CreateHTMLCallback;
    createScript?: CreateScriptCallback;
    createScriptURL?: CreateScriptURLCallback;
}

interface UDPMessageEventInit extends EventInit {
    data?: any;
    remoteAddress?: string;
    remotePort?: number;
}

interface UDPOptions {
    addressReuse?: boolean;
    localAddress?: string;
    localPort?: number;
    loopback?: boolean;
    remoteAddress?: string;
    remotePort?: number;
}

interface UIEventInit extends EventInit {
    detail?: number;
    view?: Window | null;
}

interface ULongRange {
    max?: number;
    min?: number;
}

interface UniFFIScaffoldingCallResult {
    code: UniFFIScaffoldingCallCode;
    data?: UniFFIScaffoldingValue;
}

interface UserProximityEventInit extends EventInit {
    near?: boolean;
}

interface UtilityActorsDictionary {
    actorName?: WebIDLUtilityActorName;
}

interface VRDisplayEventInit extends EventInit {
    display: VRDisplay;
    reason?: VRDisplayEventReason;
}

interface VRLayer {
    leftBounds?: number[] | Float32Array;
    rightBounds?: number[] | Float32Array;
    source?: HTMLCanvasElement | null;
}

interface ValidityStateFlags {
    badInput?: boolean;
    customError?: boolean;
    patternMismatch?: boolean;
    rangeOverflow?: boolean;
    rangeUnderflow?: boolean;
    stepMismatch?: boolean;
    tooLong?: boolean;
    tooShort?: boolean;
    typeMismatch?: boolean;
    valueMissing?: boolean;
}

interface VideoColorSpaceInit {
    fullRange?: boolean | null;
    matrix?: VideoMatrixCoefficients | null;
    primaries?: VideoColorPrimaries | null;
    transfer?: VideoTransferCharacteristics | null;
}

interface VideoConfiguration {
    bitrate: number;
    colorGamut?: ColorGamut;
    contentType: string;
    framerate: number;
    hasAlphaChannel?: boolean;
    hdrMetadataType?: HdrMetadataType;
    height: number;
    scalabilityMode?: string;
    transferFunction?: TransferFunction;
    width: number;
}

interface VideoDecoderConfig {
    codec: string;
    codedHeight?: number;
    codedWidth?: number;
    colorSpace?: VideoColorSpaceInit;
    description?: AllowSharedBufferSource;
    displayAspectHeight?: number;
    displayAspectWidth?: number;
    hardwareAcceleration?: HardwareAcceleration;
    optimizeForLatency?: boolean;
}

interface VideoDecoderInit {
    error: WebCodecsErrorCallback;
    output: VideoFrameOutputCallback;
}

interface VideoDecoderSupport {
    config?: VideoDecoderConfig;
    supported?: boolean;
}

interface VideoEncoderConfig {
    alpha?: AlphaOption;
    avc?: AvcEncoderConfig;
    bitrate?: number;
    bitrateMode?: VideoEncoderBitrateMode;
    codec: string;
    contentHint?: string;
    displayHeight?: number;
    displayWidth?: number;
    framerate?: number;
    hardwareAcceleration?: HardwareAcceleration;
    height: number;
    latencyMode?: LatencyMode;
    scalabilityMode?: string;
    width: number;
}

interface VideoEncoderEncodeOptions {
    avc?: VideoEncoderEncodeOptionsForAvc;
    keyFrame?: boolean;
}

interface VideoEncoderEncodeOptionsForAvc {
    quantizer?: number | null;
}

interface VideoEncoderInit {
    error: WebCodecsErrorCallback;
    output: EncodedVideoChunkOutputCallback;
}

interface VideoEncoderSupport {
    config?: VideoEncoderConfig;
    supported?: boolean;
}

interface VideoFrameBufferInit {
    codedHeight: number;
    codedWidth: number;
    colorSpace?: VideoColorSpaceInit;
    displayHeight?: number;
    displayWidth?: number;
    duration?: number;
    format: VideoPixelFormat;
    layout?: PlaneLayout[];
    timestamp: number;
    visibleRect?: DOMRectInit;
}

interface VideoFrameCallbackMetadata {
    captureTime?: DOMHighResTimeStamp;
    expectedDisplayTime: DOMHighResTimeStamp;
    height: number;
    mediaTime: number;
    presentationTime: DOMHighResTimeStamp;
    presentedFrames: number;
    processingDuration?: number;
    receiveTime?: DOMHighResTimeStamp;
    rtpTimestamp?: number;
    width: number;
}

interface VideoFrameCopyToOptions {
    colorSpace?: PredefinedColorSpace;
    format?: VideoPixelFormat;
    layout?: PlaneLayout[];
    rect?: DOMRectInit;
}

interface VideoFrameInit {
    alpha?: AlphaOption;
    displayHeight?: number;
    displayWidth?: number;
    duration?: number;
    timestamp?: number;
    visibleRect?: DOMRectInit;
}

interface VideoSinkDebugInfo {
    endPromiseHolderIsEmpty?: boolean;
    finished?: boolean;
    hasVideo?: boolean;
    isPlaying?: boolean;
    isStarted?: boolean;
    size?: number;
    videoFrameEndTime?: number;
    videoSinkEndRequestExists?: boolean;
}

interface WaveShaperOptions extends AudioNodeOptions {
    curve?: number[] | Float32Array;
    oversample?: OverSampleType;
}

interface WebAccessibleResourceInit {
    extension_ids?: string[] | null;
    matches?: MatchPatternSetOrStringSequence | null;
    resources: MatchGlobOrString[];
}

interface WebExtensionContentScriptInit extends MozDocumentMatcherInit {
    cssPaths?: string[];
    jsPaths?: string[];
    runAt?: ContentScriptRunAt;
    world?: ContentScriptExecutionWorld;
    worldId?: string | null;
}

interface WebExtensionInit {
    allowedOrigins: MatchPatternSetOrStringSequence;
    backgroundScripts?: string[] | null;
    backgroundTypeModule?: boolean;
    backgroundWorkerScript?: string | null;
    baseURL: string;
    contentScripts?: WebExtensionContentScriptInit[];
    extensionPageCSP?: string | null;
    id: string;
    ignoreQuarantine?: boolean;
    isPrivileged?: boolean;
    localizeCallback: WebExtensionLocalizeCallback;
    manifestVersion?: number;
    mozExtensionHostname: string;
    name?: string;
    permissions?: string[];
    readyPromise?: Promise<WebExtensionPolicy | null>;
    temporarilyInstalled?: boolean;
    type?: string;
    webAccessibleResources?: WebAccessibleResourceInit[];
}

interface WebGLContextAttributes {
    alpha?: GLboolean;
    antialias?: GLboolean;
    depth?: GLboolean;
    failIfMajorPerformanceCaveat?: GLboolean;
    forceSoftwareRendering?: GLboolean;
    powerPreference?: WebGLPowerPreference;
    premultipliedAlpha?: GLboolean;
    preserveDrawingBuffer?: GLboolean;
    stencil?: GLboolean;
    xrCompatible?: boolean;
}

interface WebGLContextEventInit extends EventInit {
    statusMessage?: string;
}

interface WebTransportCloseInfo {
    closeCode?: number;
    reason?: string;
}

interface WebTransportDatagramStats {
    droppedIncoming?: number;
    expiredOutgoing?: number;
    lostOutgoing?: number;
    timestamp?: DOMHighResTimeStamp;
}

interface WebTransportErrorInit {
    message?: string;
    streamErrorCode?: number;
}

interface WebTransportHash {
    algorithm?: string;
    value?: BufferSource;
}

interface WebTransportOptions {
    allowPooling?: boolean;
    congestionControl?: WebTransportCongestionControl;
    requireUnreliable?: boolean;
    serverCertificateHashes?: WebTransportHash[];
}

interface WebTransportReceiveStreamStats {
    bytesRead?: number;
    bytesReceived?: number;
    timestamp?: DOMHighResTimeStamp;
}

interface WebTransportSendStreamOptions {
    sendOrder?: number | null;
}

interface WebTransportSendStreamStats {
    bytesAcknowledged?: number;
    bytesSent?: number;
    bytesWritten?: number;
    timestamp?: DOMHighResTimeStamp;
}

interface WebTransportStats {
    bytesReceived?: number;
    bytesSent?: number;
    datagrams?: WebTransportDatagramStats;
    minRtt?: DOMHighResTimeStamp;
    numIncomingStreamsCreated?: number;
    numOutgoingStreamsCreated?: number;
    packetsLost?: number;
    packetsReceived?: number;
    packetsSent?: number;
    rttVariation?: DOMHighResTimeStamp;
    smoothedRtt?: DOMHighResTimeStamp;
    timestamp?: DOMHighResTimeStamp;
}

interface WebrtcGlobalMediaContext {
    hasAv1: boolean;
    hasH264Hardware: boolean;
}

interface WebrtcGlobalStatisticsReport {
    reports?: RTCStatsReportInternal[];
    sdpHistories?: RTCSdpHistoryInternal[];
}

interface WheelEventInit extends MouseEventInit {
    deltaMode?: number;
    deltaX?: number;
    deltaY?: number;
    deltaZ?: number;
}

interface WindowActorChildOptions extends WindowActorSidedOptions {
    events?: Record<string, WindowActorEventListenerOptions>;
    observers?: string[];
}

interface WindowActorEventListenerOptions extends AddEventListenerOptions {
    createActor?: boolean;
}

interface WindowActorOptions {
    allFrames?: boolean;
    child?: WindowActorChildOptions;
    includeChrome?: boolean;
    matches?: string[];
    messageManagerGroups?: string[];
    parent?: WindowActorSidedOptions;
    remoteTypes?: string[];
}

interface WindowActorSidedOptions {
    esModuleURI?: string;
}

interface WindowInfoDictionary {
    documentTitle?: string;
    documentURI?: URI | null;
    isInProcess?: boolean;
    isProcessRoot?: boolean;
    outerWindowId?: number;
}

interface WindowPostMessageOptions extends StructuredSerializeOptions {
    targetOrigin?: string;
}

interface WindowsFileAttributes {
    hidden?: boolean;
    readOnly?: boolean;
    system?: boolean;
}

interface Wireframe {
    canvasBackground?: number;
    rects?: WireframeTaggedRect[];
    version?: number;
}

interface WireframeTaggedRect {
    color?: number;
    height?: number;
    node?: Node | null;
    type?: WireframeRectType;
    width?: number;
    x?: number;
    y?: number;
}

interface WorkerOptions {
    credentials?: RequestCredentials;
    name?: string;
    type?: WorkerType;
}

interface WorkletOptions {
    credentials?: RequestCredentials;
}

interface WriteOptions {
    backupFile?: string;
    compress?: boolean;
    flush?: boolean;
    mode?: WriteMode;
    tmpPath?: string;
}

interface WriteParams {
    data?: BufferSource | Blob | string | null;
    position?: number | null;
    size?: number | null;
    type: WriteCommandType;
}

interface XRInputSourceEventInit extends EventInit {
    frame: XRFrame;
    inputSource: XRInputSource;
}

interface XRInputSourcesChangeEventInit extends EventInit {
    added: XRInputSource[];
    removed: XRInputSource[];
    session: XRSession;
}

interface XRReferenceSpaceEventInit extends EventInit {
    referenceSpace: XRReferenceSpace;
    transform?: XRRigidTransform | null;
}

interface XRRenderStateInit {
    baseLayer?: XRWebGLLayer | null;
    depthFar?: number;
    depthNear?: number;
    inlineVerticalFieldOfView?: number;
}

interface XRSessionEventInit extends EventInit {
    session: XRSession;
}

interface XRSessionInit {
    optionalFeatures?: string[];
    requiredFeatures?: string[];
}

interface XRWebGLLayerInit {
    alpha?: boolean;
    antialias?: boolean;
    depth?: boolean;
    framebufferScaleFactor?: number;
    ignoreDepthValues?: boolean;
    stencil?: boolean;
}

interface addonInstallOptions {
    hash?: string | null;
    url: string;
}

interface sendAbuseReportOptions {
    authorization?: string | null;
}

type EventListener = ((event: Event) => void) | { handleEvent(event: Event): void; };

type MessageListener = ((argument: ReceiveMessageArgument) => any) | { receiveMessage(argument: ReceiveMessageArgument): any; };

type MozDocumentCallback = ((matcher: MozDocumentMatcher, window: WindowProxy) => void) | { onNewDocument(matcher: MozDocumentMatcher, window: WindowProxy): void; };

type NodeFilter = ((node: Node) => number) | { acceptNode(node: Node): number; };

declare var NodeFilter: {
    readonly FILTER_ACCEPT: 1;
    readonly FILTER_REJECT: 2;
    readonly FILTER_SKIP: 3;
    readonly SHOW_ALL: 0xFFFFFFFF;
    readonly SHOW_ELEMENT: 0x1;
    readonly SHOW_ATTRIBUTE: 0x2;
    readonly SHOW_TEXT: 0x4;
    readonly SHOW_CDATA_SECTION: 0x8;
    readonly SHOW_ENTITY_REFERENCE: 0x10;
    readonly SHOW_ENTITY: 0x20;
    readonly SHOW_PROCESSING_INSTRUCTION: 0x40;
    readonly SHOW_COMMENT: 0x80;
    readonly SHOW_DOCUMENT: 0x100;
    readonly SHOW_DOCUMENT_TYPE: 0x200;
    readonly SHOW_DOCUMENT_FRAGMENT: 0x400;
    readonly SHOW_NOTATION: 0x800;
};

type ObserverCallback = ((observer: FetchObserver) => void) | { handleEvent(observer: FetchObserver): void; };

type UncaughtRejectionObserver = ((p: any) => boolean) | { onLeftUncaught(p: any): boolean; };

type UniFFICallbackHandler = ((objectHandle: UniFFICallbackObjectHandle, methodIndex: number, ...args: UniFFIScaffoldingValue[]) => UniFFIScaffoldingValue | null) | { call(objectHandle: UniFFICallbackObjectHandle, methodIndex: number, ...args: UniFFIScaffoldingValue[]): UniFFIScaffoldingValue | null; };

type XPathNSResolver = ((prefix: string | null) => string | null) | { lookupNamespaceURI(prefix: string | null): string | null; };

interface ANGLE_instanced_arrays {
    drawArraysInstancedANGLE(mode: GLenum, first: GLint, count: GLsizei, primcount: GLsizei): void;
    drawElementsInstancedANGLE(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, primcount: GLsizei): void;
    vertexAttribDivisorANGLE(index: GLuint, divisor: GLuint): void;
    readonly VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88FE;
}

interface ARIAMixin {
    ariaActiveDescendantElement: Element | null;
    ariaAtomic: string | null;
    ariaAutoComplete: string | null;
    ariaBrailleLabel: string | null;
    ariaBrailleRoleDescription: string | null;
    ariaBusy: string | null;
    ariaChecked: string | null;
    ariaColCount: string | null;
    ariaColIndex: string | null;
    ariaColIndexText: string | null;
    ariaColSpan: string | null;
    ariaControlsElements: Element[] | null;
    ariaCurrent: string | null;
    ariaDescribedByElements: Element[] | null;
    ariaDescription: string | null;
    ariaDetailsElements: Element[] | null;
    ariaDisabled: string | null;
    ariaErrorMessageElements: Element[] | null;
    ariaExpanded: string | null;
    ariaFlowToElements: Element[] | null;
    ariaHasPopup: string | null;
    ariaHidden: string | null;
    ariaInvalid: string | null;
    ariaKeyShortcuts: string | null;
    ariaLabel: string | null;
    ariaLabelledByElements: Element[] | null;
    ariaLevel: string | null;
    ariaLive: string | null;
    ariaModal: string | null;
    ariaMultiLine: string | null;
    ariaMultiSelectable: string | null;
    ariaOrientation: string | null;
    ariaOwnsElements: Element[] | null;
    ariaPlaceholder: string | null;
    ariaPosInSet: string | null;
    ariaPressed: string | null;
    ariaReadOnly: string | null;
    ariaRelevant: string | null;
    ariaRequired: string | null;
    ariaRoleDescription: string | null;
    ariaRowCount: string | null;
    ariaRowIndex: string | null;
    ariaRowIndexText: string | null;
    ariaRowSpan: string | null;
    ariaSelected: string | null;
    ariaSetSize: string | null;
    ariaSort: string | null;
    ariaValueMax: string | null;
    ariaValueMin: string | null;
    ariaValueNow: string | null;
    ariaValueText: string | null;
    role: string | null;
}

interface AbortController {
    readonly signal: AbortSignal;
    abort(reason?: any): void;
}

declare var AbortController: {
    prototype: AbortController;
    new(): AbortController;
    isInstance: IsInstance<AbortController>;
};

interface AbortSignalEventMap {
    "abort": Event;
}

interface AbortSignal extends EventTarget {
    readonly aborted: boolean;
    onabort: ((this: AbortSignal, ev: Event) => any) | null;
    readonly reason: any;
    throwIfAborted(): void;
    addEventListener<K extends keyof AbortSignalEventMap>(type: K, listener: (this: AbortSignal, ev: AbortSignalEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AbortSignalEventMap>(type: K, listener: (this: AbortSignal, ev: AbortSignalEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var AbortSignal: {
    prototype: AbortSignal;
    new(): AbortSignal;
    isInstance: IsInstance<AbortSignal>;
    abort(reason?: any): AbortSignal;
    any(signals: AbortSignal[]): AbortSignal;
    timeout(milliseconds: number): AbortSignal;
};

interface AbstractRange {
    readonly collapsed: boolean;
    readonly endContainer: Node;
    readonly endOffset: number;
    readonly startContainer: Node;
    readonly startOffset: number;
}

declare var AbstractRange: {
    prototype: AbstractRange;
    new(): AbstractRange;
    isInstance: IsInstance<AbstractRange>;
};

interface AbstractWorkerEventMap {
    "error": Event;
}

interface AbstractWorker {
    onerror: ((this: AbstractWorker, ev: Event) => any) | null;
    addEventListener<K extends keyof AbstractWorkerEventMap>(type: K, listener: (this: AbstractWorker, ev: AbstractWorkerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AbstractWorkerEventMap>(type: K, listener: (this: AbstractWorker, ev: AbstractWorkerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

interface AccessibleNode {
    readonly DOMNode: Node | null;
    activeDescendant: AccessibleNode | null;
    atomic: boolean | null;
    readonly attributes: string[];
    autocomplete: string | null;
    busy: boolean | null;
    checked: string | null;
    colCount: number | null;
    colIndex: number | null;
    colSpan: number | null;
    readonly computedRole: string;
    current: string | null;
    details: AccessibleNode | null;
    disabled: boolean | null;
    errorMessage: AccessibleNode | null;
    expanded: boolean | null;
    hasPopUp: string | null;
    hidden: boolean | null;
    invalid: string | null;
    keyShortcuts: string | null;
    label: string | null;
    level: number | null;
    live: string | null;
    modal: boolean | null;
    multiline: boolean | null;
    multiselectable: boolean | null;
    orientation: string | null;
    placeholder: string | null;
    posInSet: number | null;
    pressed: string | null;
    readOnly: boolean | null;
    relevant: string | null;
    required: boolean | null;
    role: string | null;
    roleDescription: string | null;
    rowCount: number | null;
    rowIndex: number | null;
    rowSpan: number | null;
    selected: boolean | null;
    setSize: number | null;
    sort: string | null;
    readonly states: string[];
    valueMax: number | null;
    valueMin: number | null;
    valueNow: number | null;
    valueText: string | null;
    get(attribute: string): any;
    has(...attributes: string[]): boolean;
    is(...states: string[]): boolean;
}

declare var AccessibleNode: {
    prototype: AccessibleNode;
    new(): AccessibleNode;
    isInstance: IsInstance<AccessibleNode>;
};

interface Addon {
    readonly canUninstall: boolean;
    readonly description: string;
    readonly id: string;
    readonly isActive: boolean;
    readonly isEnabled: boolean;
    readonly name: string;
    readonly type: string;
    readonly version: string;
    setEnabled(value: boolean): Promise<void>;
    uninstall(): Promise<boolean>;
}

declare var Addon: {
    prototype: Addon;
    new(): Addon;
    isInstance: IsInstance<Addon>;
};

interface AddonEvent extends Event {
    readonly id: string;
}

declare var AddonEvent: {
    prototype: AddonEvent;
    new(type: string, eventInitDict: AddonEventInit): AddonEvent;
    isInstance: IsInstance<AddonEvent>;
};

interface AddonInstall extends EventTarget {
    readonly error: string | null;
    readonly maxProgress: number;
    readonly progress: number;
    readonly state: string;
    cancel(): Promise<void>;
    install(): Promise<void>;
}

declare var AddonInstall: {
    prototype: AddonInstall;
    new(): AddonInstall;
    isInstance: IsInstance<AddonInstall>;
};

interface AddonManager extends EventTarget {
    createInstall(options?: addonInstallOptions): Promise<AddonInstall>;
    getAddonByID(id: string): Promise<Addon>;
    sendAbuseReport(addonId: string, data: Record<string, string | null>, options?: sendAbuseReportOptions): Promise<any>;
}

declare var AddonManager: {
    prototype: AddonManager;
    new(): AddonManager;
    isInstance: IsInstance<AddonManager>;
};

interface AnalyserNode extends AudioNode, AudioNodePassThrough {
    fftSize: number;
    readonly frequencyBinCount: number;
    maxDecibels: number;
    minDecibels: number;
    smoothingTimeConstant: number;
    getByteFrequencyData(array: Uint8Array): void;
    getByteTimeDomainData(array: Uint8Array): void;
    getFloatFrequencyData(array: Float32Array): void;
    getFloatTimeDomainData(array: Float32Array): void;
}

declare var AnalyserNode: {
    prototype: AnalyserNode;
    new(context: BaseAudioContext, options?: AnalyserOptions): AnalyserNode;
    isInstance: IsInstance<AnalyserNode>;
};

interface Animatable {
    animate(keyframes: any, options?: UnrestrictedDoubleOrKeyframeAnimationOptions): Animation;
    getAnimations(options?: GetAnimationsOptions): Animation[];
}

interface AnimationEventMap {
    "cancel": Event;
    "finish": Event;
    "remove": Event;
}

interface Animation extends EventTarget {
    currentTime: number | null;
    effect: AnimationEffect | null;
    readonly finished: Promise<Animation>;
    id: string;
    readonly isRunningOnCompositor: boolean;
    oncancel: ((this: Animation, ev: Event) => any) | null;
    onfinish: ((this: Animation, ev: Event) => any) | null;
    onremove: ((this: Animation, ev: Event) => any) | null;
    readonly pending: boolean;
    readonly playState: AnimationPlayState;
    playbackRate: number;
    readonly ready: Promise<Animation>;
    readonly replaceState: AnimationReplaceState;
    startTime: number | null;
    timeline: AnimationTimeline | null;
    cancel(): void;
    commitStyles(): void;
    finish(): void;
    pause(): void;
    persist(): void;
    play(): void;
    reverse(): void;
    updatePlaybackRate(playbackRate: number): void;
    addEventListener<K extends keyof AnimationEventMap>(type: K, listener: (this: Animation, ev: AnimationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AnimationEventMap>(type: K, listener: (this: Animation, ev: AnimationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var Animation: {
    prototype: Animation;
    new(effect?: AnimationEffect | null, timeline?: AnimationTimeline | null): Animation;
    isInstance: IsInstance<Animation>;
};

interface AnimationEffect {
    getComputedTiming(): ComputedEffectTiming;
    getTiming(): EffectTiming;
    updateTiming(timing?: OptionalEffectTiming): void;
}

declare var AnimationEffect: {
    prototype: AnimationEffect;
    new(): AnimationEffect;
    isInstance: IsInstance<AnimationEffect>;
};

interface AnimationEvent extends Event {
    readonly animationName: string;
    readonly elapsedTime: number;
    readonly pseudoElement: string;
}

declare var AnimationEvent: {
    prototype: AnimationEvent;
    new(type: string, eventInitDict?: AnimationEventInit): AnimationEvent;
    isInstance: IsInstance<AnimationEvent>;
};

interface AnimationFrameProvider {
    cancelAnimationFrame(handle: number): void;
    requestAnimationFrame(callback: FrameRequestCallback): number;
}

interface AnimationPlaybackEvent extends Event {
    readonly currentTime: number | null;
    readonly timelineTime: number | null;
}

declare var AnimationPlaybackEvent: {
    prototype: AnimationPlaybackEvent;
    new(type: string, eventInitDict?: AnimationPlaybackEventInit): AnimationPlaybackEvent;
    isInstance: IsInstance<AnimationPlaybackEvent>;
};

interface AnimationTimeline {
    readonly currentTime: number | null;
}

declare var AnimationTimeline: {
    prototype: AnimationTimeline;
    new(): AnimationTimeline;
    isInstance: IsInstance<AnimationTimeline>;
};

interface AnonymousContent {
    readonly root: ShadowRoot;
}

declare var AnonymousContent: {
    prototype: AnonymousContent;
    new(): AnonymousContent;
    isInstance: IsInstance<AnonymousContent>;
};

interface Attr extends Node {
    readonly localName: string;
    readonly name: string;
    readonly namespaceURI: string | null;
    readonly ownerElement: Element | null;
    readonly prefix: string | null;
    readonly specified: boolean;
    value: string;
}

declare var Attr: {
    prototype: Attr;
    new(): Attr;
    isInstance: IsInstance<Attr>;
};

interface AudioBuffer {
    readonly duration: number;
    readonly length: number;
    readonly numberOfChannels: number;
    readonly sampleRate: number;
    copyFromChannel(destination: Float32Array, channelNumber: number, startInChannel?: number): void;
    copyToChannel(source: Float32Array, channelNumber: number, startInChannel?: number): void;
    getChannelData(channel: number): Float32Array;
}

declare var AudioBuffer: {
    prototype: AudioBuffer;
    new(options: AudioBufferOptions): AudioBuffer;
    isInstance: IsInstance<AudioBuffer>;
};

interface AudioBufferSourceNode extends AudioScheduledSourceNode, AudioNodePassThrough {
    buffer: AudioBuffer | null;
    readonly detune: AudioParam;
    loop: boolean;
    loopEnd: number;
    loopStart: number;
    readonly playbackRate: AudioParam;
    start(when?: number, grainOffset?: number, grainDuration?: number): void;
    addEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: AudioBufferSourceNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: AudioBufferSourceNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var AudioBufferSourceNode: {
    prototype: AudioBufferSourceNode;
    new(context: BaseAudioContext, options?: AudioBufferSourceOptions): AudioBufferSourceNode;
    isInstance: IsInstance<AudioBufferSourceNode>;
};

interface AudioContext extends BaseAudioContext {
    readonly baseLatency: number;
    readonly outputLatency: number;
    close(): Promise<void>;
    createMediaElementSource(mediaElement: HTMLMediaElement): MediaElementAudioSourceNode;
    createMediaStreamDestination(): MediaStreamAudioDestinationNode;
    createMediaStreamSource(mediaStream: MediaStream): MediaStreamAudioSourceNode;
    createMediaStreamTrackSource(mediaStreamTrack: MediaStreamTrack): MediaStreamTrackAudioSourceNode;
    getOutputTimestamp(): AudioTimestamp;
    suspend(): Promise<void>;
    addEventListener<K extends keyof BaseAudioContextEventMap>(type: K, listener: (this: AudioContext, ev: BaseAudioContextEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof BaseAudioContextEventMap>(type: K, listener: (this: AudioContext, ev: BaseAudioContextEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var AudioContext: {
    prototype: AudioContext;
    new(contextOptions?: AudioContextOptions): AudioContext;
    isInstance: IsInstance<AudioContext>;
};

interface AudioData {
    readonly duration: number;
    readonly format: AudioSampleFormat | null;
    readonly numberOfChannels: number;
    readonly numberOfFrames: number;
    readonly sampleRate: number;
    readonly timestamp: number;
    allocationSize(options: AudioDataCopyToOptions): number;
    clone(): AudioData;
    close(): void;
    copyTo(destination: AllowSharedBufferSource, options: AudioDataCopyToOptions): void;
}

declare var AudioData: {
    prototype: AudioData;
    new(init: AudioDataInit): AudioData;
    isInstance: IsInstance<AudioData>;
};

interface AudioDecoderEventMap {
    "dequeue": Event;
}

/** Available only in secure contexts. */
interface AudioDecoder extends EventTarget {
    readonly decodeQueueSize: number;
    ondequeue: ((this: AudioDecoder, ev: Event) => any) | null;
    readonly state: CodecState;
    close(): void;
    configure(config: AudioDecoderConfig): void;
    decode(chunk: EncodedAudioChunk): void;
    flush(): Promise<void>;
    reset(): void;
    addEventListener<K extends keyof AudioDecoderEventMap>(type: K, listener: (this: AudioDecoder, ev: AudioDecoderEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AudioDecoderEventMap>(type: K, listener: (this: AudioDecoder, ev: AudioDecoderEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var AudioDecoder: {
    prototype: AudioDecoder;
    new(init: AudioDecoderInit): AudioDecoder;
    isInstance: IsInstance<AudioDecoder>;
    isConfigSupported(config: AudioDecoderConfig): Promise<AudioDecoderSupport>;
};

interface AudioDestinationNode extends AudioNode {
    readonly maxChannelCount: number;
}

declare var AudioDestinationNode: {
    prototype: AudioDestinationNode;
    new(): AudioDestinationNode;
    isInstance: IsInstance<AudioDestinationNode>;
};

interface AudioEncoderEventMap {
    "dequeue": Event;
}

/** Available only in secure contexts. */
interface AudioEncoder extends EventTarget {
    readonly encodeQueueSize: number;
    ondequeue: ((this: AudioEncoder, ev: Event) => any) | null;
    readonly state: CodecState;
    close(): void;
    configure(config: AudioEncoderConfig): void;
    encode(data: AudioData): void;
    flush(): Promise<void>;
    reset(): void;
    addEventListener<K extends keyof AudioEncoderEventMap>(type: K, listener: (this: AudioEncoder, ev: AudioEncoderEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AudioEncoderEventMap>(type: K, listener: (this: AudioEncoder, ev: AudioEncoderEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var AudioEncoder: {
    prototype: AudioEncoder;
    new(init: AudioEncoderInit): AudioEncoder;
    isInstance: IsInstance<AudioEncoder>;
    isConfigSupported(config: AudioEncoderConfig): Promise<AudioEncoderSupport>;
};

interface AudioListener {
    setOrientation(x: number, y: number, z: number, xUp: number, yUp: number, zUp: number): void;
    setPosition(x: number, y: number, z: number): void;
}

declare var AudioListener: {
    prototype: AudioListener;
    new(): AudioListener;
    isInstance: IsInstance<AudioListener>;
};

interface AudioNode extends EventTarget {
    channelCount: number;
    channelCountMode: ChannelCountMode;
    channelInterpretation: ChannelInterpretation;
    readonly context: BaseAudioContext;
    readonly id: number;
    readonly numberOfInputs: number;
    readonly numberOfOutputs: number;
    connect(destination: AudioNode, output?: number, input?: number): AudioNode;
    connect(destination: AudioParam, output?: number): void;
    disconnect(): void;
    disconnect(output: number): void;
    disconnect(destination: AudioNode): void;
    disconnect(destination: AudioNode, output: number): void;
    disconnect(destination: AudioNode, output: number, input: number): void;
    disconnect(destination: AudioParam): void;
    disconnect(destination: AudioParam, output: number): void;
}

declare var AudioNode: {
    prototype: AudioNode;
    new(): AudioNode;
    isInstance: IsInstance<AudioNode>;
};

interface AudioNodePassThrough {
    passThrough: boolean;
}

interface AudioParam {
    readonly defaultValue: number;
    readonly isTrackSuspended: boolean;
    readonly maxValue: number;
    readonly minValue: number;
    readonly name: string;
    readonly parentNodeId: number;
    value: number;
    cancelScheduledValues(startTime: number): AudioParam;
    exponentialRampToValueAtTime(value: number, endTime: number): AudioParam;
    linearRampToValueAtTime(value: number, endTime: number): AudioParam;
    setTargetAtTime(target: number, startTime: number, timeConstant: number): AudioParam;
    setValueAtTime(value: number, startTime: number): AudioParam;
    setValueCurveAtTime(values: number[] | Float32Array, startTime: number, duration: number): AudioParam;
}

declare var AudioParam: {
    prototype: AudioParam;
    new(): AudioParam;
    isInstance: IsInstance<AudioParam>;
};

/** Available only in secure contexts. */
interface AudioParamMap {
    forEach(callbackfn: (value: AudioParam, key: string, parent: AudioParamMap) => void, thisArg?: any): void;
}

declare var AudioParamMap: {
    prototype: AudioParamMap;
    new(): AudioParamMap;
    isInstance: IsInstance<AudioParamMap>;
};

interface AudioProcessingEvent extends Event {
    readonly inputBuffer: AudioBuffer;
    readonly outputBuffer: AudioBuffer;
    readonly playbackTime: number;
}

declare var AudioProcessingEvent: {
    prototype: AudioProcessingEvent;
    new(): AudioProcessingEvent;
    isInstance: IsInstance<AudioProcessingEvent>;
};

interface AudioScheduledSourceNodeEventMap {
    "ended": Event;
}

interface AudioScheduledSourceNode extends AudioNode {
    onended: ((this: AudioScheduledSourceNode, ev: Event) => any) | null;
    start(when?: number): void;
    stop(when?: number): void;
    addEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: AudioScheduledSourceNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: AudioScheduledSourceNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var AudioScheduledSourceNode: {
    prototype: AudioScheduledSourceNode;
    new(): AudioScheduledSourceNode;
    isInstance: IsInstance<AudioScheduledSourceNode>;
};

interface AudioTrack {
    enabled: boolean;
    readonly id: string;
    readonly kind: string;
    readonly label: string;
    readonly language: string;
}

declare var AudioTrack: {
    prototype: AudioTrack;
    new(): AudioTrack;
    isInstance: IsInstance<AudioTrack>;
};

interface AudioTrackListEventMap {
    "addtrack": Event;
    "change": Event;
    "removetrack": Event;
}

interface AudioTrackList extends EventTarget {
    readonly length: number;
    onaddtrack: ((this: AudioTrackList, ev: Event) => any) | null;
    onchange: ((this: AudioTrackList, ev: Event) => any) | null;
    onremovetrack: ((this: AudioTrackList, ev: Event) => any) | null;
    getTrackById(id: string): AudioTrack | null;
    addEventListener<K extends keyof AudioTrackListEventMap>(type: K, listener: (this: AudioTrackList, ev: AudioTrackListEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AudioTrackListEventMap>(type: K, listener: (this: AudioTrackList, ev: AudioTrackListEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    [index: number]: AudioTrack;
}

declare var AudioTrackList: {
    prototype: AudioTrackList;
    new(): AudioTrackList;
    isInstance: IsInstance<AudioTrackList>;
};

/** Available only in secure contexts. */
interface AudioWorklet extends Worklet {
    readonly port: MessagePort;
}

declare var AudioWorklet: {
    prototype: AudioWorklet;
    new(): AudioWorklet;
    isInstance: IsInstance<AudioWorklet>;
};

interface AudioWorkletNodeEventMap {
    "processorerror": Event;
}

/** Available only in secure contexts. */
interface AudioWorkletNode extends AudioNode {
    onprocessorerror: ((this: AudioWorkletNode, ev: Event) => any) | null;
    readonly parameters: AudioParamMap;
    readonly port: MessagePort;
    addEventListener<K extends keyof AudioWorkletNodeEventMap>(type: K, listener: (this: AudioWorkletNode, ev: AudioWorkletNodeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AudioWorkletNodeEventMap>(type: K, listener: (this: AudioWorkletNode, ev: AudioWorkletNodeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var AudioWorkletNode: {
    prototype: AudioWorkletNode;
    new(context: BaseAudioContext, name: string, options?: AudioWorkletNodeOptions): AudioWorkletNode;
    isInstance: IsInstance<AudioWorkletNode>;
};

/** Available only in secure contexts. */
interface AuthenticatorAssertionResponse extends AuthenticatorResponse {
    readonly authenticatorData: ArrayBuffer;
    readonly signature: ArrayBuffer;
    readonly userHandle: ArrayBuffer | null;
}

declare var AuthenticatorAssertionResponse: {
    prototype: AuthenticatorAssertionResponse;
    new(): AuthenticatorAssertionResponse;
    isInstance: IsInstance<AuthenticatorAssertionResponse>;
};

/** Available only in secure contexts. */
interface AuthenticatorAttestationResponse extends AuthenticatorResponse {
    readonly attestationObject: ArrayBuffer;
    getAuthenticatorData(): ArrayBuffer;
    getPublicKey(): ArrayBuffer | null;
    getPublicKeyAlgorithm(): COSEAlgorithmIdentifier;
    getTransports(): string[];
}

declare var AuthenticatorAttestationResponse: {
    prototype: AuthenticatorAttestationResponse;
    new(): AuthenticatorAttestationResponse;
    isInstance: IsInstance<AuthenticatorAttestationResponse>;
};

/** Available only in secure contexts. */
interface AuthenticatorResponse {
    readonly clientDataJSON: ArrayBuffer;
}

declare var AuthenticatorResponse: {
    prototype: AuthenticatorResponse;
    new(): AuthenticatorResponse;
    isInstance: IsInstance<AuthenticatorResponse>;
};

interface BarProp {
    visible: boolean;
}

declare var BarProp: {
    prototype: BarProp;
    new(): BarProp;
    isInstance: IsInstance<BarProp>;
};

interface BaseAudioContextEventMap {
    "statechange": Event;
}

interface BaseAudioContext extends EventTarget {
    /** Available only in secure contexts. */
    readonly audioWorklet: AudioWorklet;
    readonly currentTime: number;
    readonly destination: AudioDestinationNode;
    readonly listener: AudioListener;
    onstatechange: ((this: BaseAudioContext, ev: Event) => any) | null;
    readonly sampleRate: number;
    readonly state: AudioContextState;
    createAnalyser(): AnalyserNode;
    createBiquadFilter(): BiquadFilterNode;
    createBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer;
    createBufferSource(): AudioBufferSourceNode;
    createChannelMerger(numberOfInputs?: number): ChannelMergerNode;
    createChannelSplitter(numberOfOutputs?: number): ChannelSplitterNode;
    createConstantSource(): ConstantSourceNode;
    createConvolver(): ConvolverNode;
    createDelay(maxDelayTime?: number): DelayNode;
    createDynamicsCompressor(): DynamicsCompressorNode;
    createGain(): GainNode;
    createIIRFilter(feedforward: number[], feedback: number[]): IIRFilterNode;
    createOscillator(): OscillatorNode;
    createPanner(): PannerNode;
    createPeriodicWave(real: number[] | Float32Array, imag: number[] | Float32Array, constraints?: PeriodicWaveConstraints): PeriodicWave;
    createScriptProcessor(bufferSize?: number, numberOfInputChannels?: number, numberOfOutputChannels?: number): ScriptProcessorNode;
    createStereoPanner(): StereoPannerNode;
    createWaveShaper(): WaveShaperNode;
    decodeAudioData(audioData: ArrayBuffer, successCallback?: DecodeSuccessCallback, errorCallback?: DecodeErrorCallback): Promise<AudioBuffer>;
    resume(): Promise<void>;
    addEventListener<K extends keyof BaseAudioContextEventMap>(type: K, listener: (this: BaseAudioContext, ev: BaseAudioContextEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof BaseAudioContextEventMap>(type: K, listener: (this: BaseAudioContext, ev: BaseAudioContextEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var BaseAudioContext: {
    prototype: BaseAudioContext;
    new(): BaseAudioContext;
    isInstance: IsInstance<BaseAudioContext>;
};

interface BatteryManagerEventMap {
    "chargingchange": Event;
    "chargingtimechange": Event;
    "dischargingtimechange": Event;
    "levelchange": Event;
}

interface BatteryManager extends EventTarget {
    readonly charging: boolean;
    readonly chargingTime: number;
    readonly dischargingTime: number;
    readonly level: number;
    onchargingchange: ((this: BatteryManager, ev: Event) => any) | null;
    onchargingtimechange: ((this: BatteryManager, ev: Event) => any) | null;
    ondischargingtimechange: ((this: BatteryManager, ev: Event) => any) | null;
    onlevelchange: ((this: BatteryManager, ev: Event) => any) | null;
    addEventListener<K extends keyof BatteryManagerEventMap>(type: K, listener: (this: BatteryManager, ev: BatteryManagerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof BatteryManagerEventMap>(type: K, listener: (this: BatteryManager, ev: BatteryManagerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var BatteryManager: {
    prototype: BatteryManager;
    new(): BatteryManager;
    isInstance: IsInstance<BatteryManager>;
};

// @ts-ignore
interface BeforeUnloadEvent extends Event {
    returnValue: string;
}

declare var BeforeUnloadEvent: {
    prototype: BeforeUnloadEvent;
    new(): BeforeUnloadEvent;
    isInstance: IsInstance<BeforeUnloadEvent>;
};

interface BiquadFilterNode extends AudioNode, AudioNodePassThrough {
    readonly Q: AudioParam;
    readonly detune: AudioParam;
    readonly frequency: AudioParam;
    readonly gain: AudioParam;
    type: BiquadFilterType;
    getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void;
}

declare var BiquadFilterNode: {
    prototype: BiquadFilterNode;
    new(context: BaseAudioContext, options?: BiquadFilterOptions): BiquadFilterNode;
    isInstance: IsInstance<BiquadFilterNode>;
};

interface Blob {
    readonly blobImplType: string;
    readonly size: number;
    readonly type: string;
    arrayBuffer(): Promise<ArrayBuffer>;
    bytes(): Promise<Uint8Array>;
    slice(start?: number, end?: number, contentType?: string): Blob;
    stream(): ReadableStream;
    text(): Promise<string>;
}

declare var Blob: {
    prototype: Blob;
    new(blobParts?: BlobPart[], options?: BlobPropertyBag): Blob;
    isInstance: IsInstance<Blob>;
};

interface BlobEvent extends Event {
    readonly data: Blob;
}

declare var BlobEvent: {
    prototype: BlobEvent;
    new(type: string, eventInitDict: BlobEventInit): BlobEvent;
    isInstance: IsInstance<BlobEvent>;
};

interface Body {
    readonly bodyUsed: boolean;
    arrayBuffer(): Promise<ArrayBuffer>;
    blob(): Promise<Blob>;
    bytes(): Promise<Uint8Array>;
    formData(): Promise<FormData>;
    json(): Promise<JSON>;
    text(): Promise<string>;
}

interface BroadcastChannelEventMap {
    "message": Event;
    "messageerror": Event;
}

interface BroadcastChannel extends EventTarget {
    readonly name: string;
    onmessage: ((this: BroadcastChannel, ev: Event) => any) | null;
    onmessageerror: ((this: BroadcastChannel, ev: Event) => any) | null;
    close(): void;
    postMessage(message: any): void;
    addEventListener<K extends keyof BroadcastChannelEventMap>(type: K, listener: (this: BroadcastChannel, ev: BroadcastChannelEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof BroadcastChannelEventMap>(type: K, listener: (this: BroadcastChannel, ev: BroadcastChannelEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var BroadcastChannel: {
    prototype: BroadcastChannel;
    new(channel: string): BroadcastChannel;
    isInstance: IsInstance<BroadcastChannel>;
    unpartitionedTestingChannel(channel: string): BroadcastChannel;
};

interface BrowsingContext extends LoadContextMixin {
    allowJavascript: boolean;
    readonly ancestorsAreCurrent: boolean;
    authorStyleDisabledDefault: boolean;
    browserId: number;
    readonly childOffset: number;
    readonly childSessionHistory: ChildSHistory | null;
    readonly children: BrowsingContext[];
    readonly createdDynamically: boolean;
    readonly currentWindowContext: WindowContext | null;
    customPlatform: string;
    customUserAgent: string;
    defaultLoadFlags: number;
    displayMode: DisplayMode;
    readonly docShell: nsIDocShell | null;
    readonly embedderElement: Element | null;
    readonly embedderElementType: string;
    forceDesktopViewport: boolean;
    forceOffline: boolean;
    forcedColorsOverride: ForcedColorsOverride;
    fullZoom: number;
    readonly group: BrowsingContextGroup;
    hasSiblings: boolean;
    readonly historyID: any;
    readonly id: number;
    inRDMPane: boolean;
    readonly isActive: boolean;
    isAppTab: boolean;
    readonly isDiscarded: boolean;
    readonly isInBFCache: boolean;
    mediumOverride: string;
    readonly name: string;
    readonly opener: BrowsingContext | null;
    overrideDPPX: number;
    readonly parent: BrowsingContext | null;
    readonly parentWindowContext: WindowContext | null;
    prefersColorSchemeOverride: PrefersColorSchemeOverride;
    sandboxFlags: number;
    serviceWorkersTestingEnabled: boolean;
    suspendMediaWhenInactive: boolean;
    readonly targetTopLevelLinkClicksToBlank: boolean;
    textZoom: number;
    readonly top: BrowsingContext;
    readonly topWindowContext: WindowContext | null;
    readonly touchEventsOverride: TouchEventsOverride;
    useGlobalHistory: boolean;
    watchedByDevTools: boolean;
    readonly window: WindowProxy | null;
    getAllBrowsingContextsInSubtree(): BrowsingContext[];
    resetNavigationRateLimit(): void;
    setGeolocationServiceOverride(position?: nsIDOMGeoPosition): void;
    setRDMPaneMaxTouchPoints(maxTouchPoints: number): void;
    setRDMPaneOrientation(type: OrientationType, rotationAngle: number): void;
}

declare var BrowsingContext: {
    prototype: BrowsingContext;
    new(): BrowsingContext;
    isInstance: IsInstance<BrowsingContext>;
    get(aId: number): BrowsingContext | null;
    getCurrentTopByBrowserId(aId: number): BrowsingContext | null;
    getFromWindow(window: WindowProxy): BrowsingContext | null;
};

interface BrowsingContextGroup {
    readonly id: number;
    getToplevels(): BrowsingContext[];
}

declare var BrowsingContextGroup: {
    prototype: BrowsingContextGroup;
    new(): BrowsingContextGroup;
    isInstance: IsInstance<BrowsingContextGroup>;
};

interface BufferSource {
}

interface ByteLengthQueuingStrategy {
    readonly highWaterMark: number;
    readonly size: Function;
}

declare var ByteLengthQueuingStrategy: {
    prototype: ByteLengthQueuingStrategy;
    new(init: QueuingStrategyInit): ByteLengthQueuingStrategy;
    isInstance: IsInstance<ByteLengthQueuingStrategy>;
};

interface CDATASection extends Text {
}

declare var CDATASection: {
    prototype: CDATASection;
    new(): CDATASection;
    isInstance: IsInstance<CDATASection>;
};

interface CSPViolationReportBody extends ReportBody {
    readonly blockedURL: string | null;
    readonly columnNumber: number | null;
    readonly disposition: SecurityPolicyViolationEventDisposition;
    readonly documentURL: string;
    readonly effectiveDirective: string;
    readonly lineNumber: number | null;
    readonly originalPolicy: string;
    readonly referrer: string | null;
    readonly sample: string | null;
    readonly sourceFile: string | null;
    readonly statusCode: number;
    toJSON(): any;
}

declare var CSPViolationReportBody: {
    prototype: CSPViolationReportBody;
    new(): CSPViolationReportBody;
    isInstance: IsInstance<CSPViolationReportBody>;
};

interface CSSAnimation extends Animation {
    readonly animationName: string;
    addEventListener<K extends keyof AnimationEventMap>(type: K, listener: (this: CSSAnimation, ev: AnimationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AnimationEventMap>(type: K, listener: (this: CSSAnimation, ev: AnimationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var CSSAnimation: {
    prototype: CSSAnimation;
    new(): CSSAnimation;
    isInstance: IsInstance<CSSAnimation>;
};

interface CSSConditionRule extends CSSGroupingRule {
    readonly conditionText: string;
}

declare var CSSConditionRule: {
    prototype: CSSConditionRule;
    new(): CSSConditionRule;
    isInstance: IsInstance<CSSConditionRule>;
};

interface CSSContainerRule extends CSSConditionRule {
    readonly containerName: string;
    readonly containerQuery: string;
    queryContainerFor(element: Element): Element | null;
}

declare var CSSContainerRule: {
    prototype: CSSContainerRule;
    new(): CSSContainerRule;
    isInstance: IsInstance<CSSContainerRule>;
};

interface CSSCounterStyleRule extends CSSRule {
    additiveSymbols: string;
    fallback: string;
    name: string;
    negative: string;
    pad: string;
    prefix: string;
    range: string;
    speakAs: string;
    suffix: string;
    symbols: string;
    system: string;
}

declare var CSSCounterStyleRule: {
    prototype: CSSCounterStyleRule;
    new(): CSSCounterStyleRule;
    isInstance: IsInstance<CSSCounterStyleRule>;
};

interface CSSCustomPropertyRegisteredEvent extends Event {
    readonly propertyDefinition: InspectorCSSPropertyDefinition;
}

declare var CSSCustomPropertyRegisteredEvent: {
    prototype: CSSCustomPropertyRegisteredEvent;
    new(type: string, eventInitDict?: CSSCustomPropertyRegisteredEventInit): CSSCustomPropertyRegisteredEvent;
    isInstance: IsInstance<CSSCustomPropertyRegisteredEvent>;
};

interface CSSFontFaceRule extends CSSRule {
    readonly style: CSSStyleDeclaration;
}

declare var CSSFontFaceRule: {
    prototype: CSSFontFaceRule;
    new(): CSSFontFaceRule;
    isInstance: IsInstance<CSSFontFaceRule>;
};

interface CSSFontFeatureValuesRule extends CSSRule {
    fontFamily: string;
    valueText: string;
}

declare var CSSFontFeatureValuesRule: {
    prototype: CSSFontFeatureValuesRule;
    new(): CSSFontFeatureValuesRule;
    isInstance: IsInstance<CSSFontFeatureValuesRule>;
};

interface CSSFontPaletteValuesRule extends CSSRule {
    readonly basePalette: string;
    readonly fontFamily: string;
    readonly name: string;
    readonly overrideColors: string;
}

declare var CSSFontPaletteValuesRule: {
    prototype: CSSFontPaletteValuesRule;
    new(): CSSFontPaletteValuesRule;
    isInstance: IsInstance<CSSFontPaletteValuesRule>;
};

interface CSSGroupingRule extends CSSRule {
    readonly cssRules: CSSRuleList;
    deleteRule(index: number): void;
    insertRule(rule: string, index?: number): number;
}

declare var CSSGroupingRule: {
    prototype: CSSGroupingRule;
    new(): CSSGroupingRule;
    isInstance: IsInstance<CSSGroupingRule>;
};

interface CSSImportRule extends CSSRule {
    readonly href: string;
    readonly layerName: string | null;
    readonly media: MediaList | null;
    readonly styleSheet: CSSStyleSheet | null;
    readonly supportsText: string | null;
}

declare var CSSImportRule: {
    prototype: CSSImportRule;
    new(): CSSImportRule;
    isInstance: IsInstance<CSSImportRule>;
};

interface CSSKeyframeRule extends CSSRule {
    keyText: string;
    readonly style: CSSStyleDeclaration;
}

declare var CSSKeyframeRule: {
    prototype: CSSKeyframeRule;
    new(): CSSKeyframeRule;
    isInstance: IsInstance<CSSKeyframeRule>;
};

interface CSSKeyframesRule extends CSSRule {
    readonly cssRules: CSSRuleList;
    readonly length: number;
    name: string;
    appendRule(rule: string): void;
    deleteRule(select: string): void;
    findRule(select: string): CSSKeyframeRule | null;
    [index: number]: CSSKeyframeRule;
}

declare var CSSKeyframesRule: {
    prototype: CSSKeyframesRule;
    new(): CSSKeyframesRule;
    isInstance: IsInstance<CSSKeyframesRule>;
};

interface CSSLayerBlockRule extends CSSGroupingRule {
    readonly name: string;
}

declare var CSSLayerBlockRule: {
    prototype: CSSLayerBlockRule;
    new(): CSSLayerBlockRule;
    isInstance: IsInstance<CSSLayerBlockRule>;
};

interface CSSLayerStatementRule extends CSSRule {
    readonly nameList: string[];
}

declare var CSSLayerStatementRule: {
    prototype: CSSLayerStatementRule;
    new(): CSSLayerStatementRule;
    isInstance: IsInstance<CSSLayerStatementRule>;
};

interface CSSMarginRule extends CSSRule {
    readonly name: string;
    readonly style: CSSStyleDeclaration;
}

declare var CSSMarginRule: {
    prototype: CSSMarginRule;
    new(): CSSMarginRule;
    isInstance: IsInstance<CSSMarginRule>;
};

interface CSSMediaRule extends CSSConditionRule {
    readonly media: MediaList;
}

declare var CSSMediaRule: {
    prototype: CSSMediaRule;
    new(): CSSMediaRule;
    isInstance: IsInstance<CSSMediaRule>;
};

interface CSSMozDocumentRule extends CSSConditionRule {
}

declare var CSSMozDocumentRule: {
    prototype: CSSMozDocumentRule;
    new(): CSSMozDocumentRule;
    isInstance: IsInstance<CSSMozDocumentRule>;
};

interface CSSNamespaceRule extends CSSRule {
    readonly namespaceURI: string;
    readonly prefix: string;
}

declare var CSSNamespaceRule: {
    prototype: CSSNamespaceRule;
    new(): CSSNamespaceRule;
    isInstance: IsInstance<CSSNamespaceRule>;
};

interface CSSNestedDeclarations extends CSSRule {
    readonly style: CSSStyleDeclaration;
}

declare var CSSNestedDeclarations: {
    prototype: CSSNestedDeclarations;
    new(): CSSNestedDeclarations;
    isInstance: IsInstance<CSSNestedDeclarations>;
};

interface CSSPageDescriptors {
}

interface CSSPageRule extends CSSGroupingRule {
    selectorText: string;
    readonly style: CSSPageDescriptors;
}

declare var CSSPageRule: {
    prototype: CSSPageRule;
    new(): CSSPageRule;
    isInstance: IsInstance<CSSPageRule>;
};

interface CSSPositionTryDescriptors {
}

interface CSSPositionTryRule extends CSSRule {
    readonly name: string;
    readonly style: CSSPositionTryDescriptors;
}

declare var CSSPositionTryRule: {
    prototype: CSSPositionTryRule;
    new(): CSSPositionTryRule;
    isInstance: IsInstance<CSSPositionTryRule>;
};

interface CSSPropertyRule extends CSSRule {
    readonly inherits: boolean;
    readonly initialValue: string | null;
    readonly name: string;
    readonly syntax: string;
}

declare var CSSPropertyRule: {
    prototype: CSSPropertyRule;
    new(): CSSPropertyRule;
    isInstance: IsInstance<CSSPropertyRule>;
};

interface CSSPseudoElement {
    readonly element: Element;
    readonly type: string;
}

declare var CSSPseudoElement: {
    prototype: CSSPseudoElement;
    new(): CSSPseudoElement;
    isInstance: IsInstance<CSSPseudoElement>;
};

interface CSSRule {
    cssText: string;
    readonly parentRule: CSSRule | null;
    readonly parentStyleSheet: CSSStyleSheet | null;
    readonly type: number;
    readonly STYLE_RULE: 1;
    readonly CHARSET_RULE: 2;
    readonly IMPORT_RULE: 3;
    readonly MEDIA_RULE: 4;
    readonly FONT_FACE_RULE: 5;
    readonly PAGE_RULE: 6;
    readonly NAMESPACE_RULE: 10;
    readonly KEYFRAMES_RULE: 7;
    readonly KEYFRAME_RULE: 8;
    readonly COUNTER_STYLE_RULE: 11;
    readonly SUPPORTS_RULE: 12;
    readonly DOCUMENT_RULE: 13;
    readonly FONT_FEATURE_VALUES_RULE: 14;
}

declare var CSSRule: {
    prototype: CSSRule;
    new(): CSSRule;
    readonly STYLE_RULE: 1;
    readonly CHARSET_RULE: 2;
    readonly IMPORT_RULE: 3;
    readonly MEDIA_RULE: 4;
    readonly FONT_FACE_RULE: 5;
    readonly PAGE_RULE: 6;
    readonly NAMESPACE_RULE: 10;
    readonly KEYFRAMES_RULE: 7;
    readonly KEYFRAME_RULE: 8;
    readonly COUNTER_STYLE_RULE: 11;
    readonly SUPPORTS_RULE: 12;
    readonly DOCUMENT_RULE: 13;
    readonly FONT_FEATURE_VALUES_RULE: 14;
    isInstance: IsInstance<CSSRule>;
};

interface CSSRuleList {
    readonly length: number;
    item(index: number): CSSRule | null;
    [index: number]: CSSRule;
}

declare var CSSRuleList: {
    prototype: CSSRuleList;
    new(): CSSRuleList;
    isInstance: IsInstance<CSSRuleList>;
};

interface CSSScopeRule extends CSSGroupingRule {
    readonly end: string | null;
    readonly start: string | null;
}

declare var CSSScopeRule: {
    prototype: CSSScopeRule;
    new(): CSSScopeRule;
    isInstance: IsInstance<CSSScopeRule>;
};

interface CSSStartingStyleRule extends CSSGroupingRule {
}

declare var CSSStartingStyleRule: {
    prototype: CSSStartingStyleRule;
    new(): CSSStartingStyleRule;
    isInstance: IsInstance<CSSStartingStyleRule>;
};

interface CSSStyleDeclaration {
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/accent-color) */
    accentColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/align-content) */
    alignContent: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/align-items) */
    alignItems: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/align-self) */
    alignSelf: string;
    alignmentBaseline: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/all) */
    all: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation) */
    animation: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-composition) */
    animationComposition: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-delay) */
    animationDelay: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-direction) */
    animationDirection: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-duration) */
    animationDuration: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode) */
    animationFillMode: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count) */
    animationIterationCount: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-name) */
    animationName: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-play-state) */
    animationPlayState: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-timing-function) */
    animationTimingFunction: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/appearance) */
    appearance: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/aspect-ratio) */
    aspectRatio: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/backdrop-filter) */
    backdropFilter: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/backface-visibility) */
    backfaceVisibility: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background) */
    background: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-attachment) */
    backgroundAttachment: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-blend-mode) */
    backgroundBlendMode: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-clip) */
    backgroundClip: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-color) */
    backgroundColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-image) */
    backgroundImage: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-origin) */
    backgroundOrigin: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-position) */
    backgroundPosition: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-position-x) */
    backgroundPositionX: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-position-y) */
    backgroundPositionY: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-repeat) */
    backgroundRepeat: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-size) */
    backgroundSize: string;
    baselineShift: string;
    baselineSource: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/block-size) */
    blockSize: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border) */
    border: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-block) */
    borderBlock: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-block-color) */
    borderBlockColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-block-end) */
    borderBlockEnd: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-block-end-color) */
    borderBlockEndColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-block-end-style) */
    borderBlockEndStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-block-end-width) */
    borderBlockEndWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-block-start) */
    borderBlockStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-block-start-color) */
    borderBlockStartColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-block-start-style) */
    borderBlockStartStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-block-start-width) */
    borderBlockStartWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-block-style) */
    borderBlockStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-block-width) */
    borderBlockWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-bottom) */
    borderBottom: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-bottom-color) */
    borderBottomColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius) */
    borderBottomLeftRadius: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius) */
    borderBottomRightRadius: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-bottom-style) */
    borderBottomStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-bottom-width) */
    borderBottomWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-collapse) */
    borderCollapse: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-color) */
    borderColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius) */
    borderEndEndRadius: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius) */
    borderEndStartRadius: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-image) */
    borderImage: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-image-outset) */
    borderImageOutset: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-image-repeat) */
    borderImageRepeat: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-image-slice) */
    borderImageSlice: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-image-source) */
    borderImageSource: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-image-width) */
    borderImageWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-inline) */
    borderInline: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-inline-color) */
    borderInlineColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-inline-end) */
    borderInlineEnd: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color) */
    borderInlineEndColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style) */
    borderInlineEndStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width) */
    borderInlineEndWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-inline-start) */
    borderInlineStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color) */
    borderInlineStartColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style) */
    borderInlineStartStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width) */
    borderInlineStartWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-inline-style) */
    borderInlineStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-inline-width) */
    borderInlineWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-left) */
    borderLeft: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-left-color) */
    borderLeftColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-left-style) */
    borderLeftStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-left-width) */
    borderLeftWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-radius) */
    borderRadius: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-right) */
    borderRight: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-right-color) */
    borderRightColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-right-style) */
    borderRightStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-right-width) */
    borderRightWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-spacing) */
    borderSpacing: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius) */
    borderStartEndRadius: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius) */
    borderStartStartRadius: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-style) */
    borderStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-top) */
    borderTop: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-top-color) */
    borderTopColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius) */
    borderTopLeftRadius: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius) */
    borderTopRightRadius: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-top-style) */
    borderTopStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-top-width) */
    borderTopWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-width) */
    borderWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/bottom) */
    bottom: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/box-shadow) */
    boxShadow: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/box-sizing) */
    boxSizing: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/break-after) */
    breakAfter: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/break-before) */
    breakBefore: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/break-inside) */
    breakInside: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/caption-side) */
    captionSide: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/caret-color) */
    caretColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/clear) */
    clear: string;
    /**
     * @deprecated
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/clip)
     */
    clip: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/clip-path) */
    clipPath: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/clip-rule) */
    clipRule: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/color) */
    color: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/color-interpolation) */
    colorInterpolation: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/color-interpolation-filters) */
    colorInterpolationFilters: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/color-scheme) */
    colorScheme: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/column-count) */
    columnCount: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/column-fill) */
    columnFill: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/column-gap) */
    columnGap: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/column-rule) */
    columnRule: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/column-rule-color) */
    columnRuleColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/column-rule-style) */
    columnRuleStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/column-rule-width) */
    columnRuleWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/column-span) */
    columnSpan: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/column-width) */
    columnWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/columns) */
    columns: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/contain) */
    contain: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-block-size) */
    containIntrinsicBlockSize: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-height) */
    containIntrinsicHeight: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-inline-size) */
    containIntrinsicInlineSize: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-size) */
    containIntrinsicSize: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-width) */
    containIntrinsicWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/container) */
    container: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/container-name) */
    containerName: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/container-type) */
    containerType: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/content) */
    content: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/content-visibility) */
    contentVisibility: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/counter-increment) */
    counterIncrement: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/counter-reset) */
    counterReset: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/counter-set) */
    counterSet: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleDeclaration/cssFloat) */
    cssFloat: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleDeclaration/cssText) */
    cssText: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/cursor) */
    cursor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/cx) */
    cx: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/cy) */
    cy: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/d) */
    d: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/direction) */
    direction: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/display) */
    display: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/dominant-baseline) */
    dominantBaseline: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/empty-cells) */
    emptyCells: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/fill) */
    fill: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/fill-opacity) */
    fillOpacity: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/fill-rule) */
    fillRule: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/filter) */
    filter: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex) */
    flex: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex-basis) */
    flexBasis: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex-direction) */
    flexDirection: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex-flow) */
    flexFlow: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex-grow) */
    flexGrow: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex-shrink) */
    flexShrink: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex-wrap) */
    flexWrap: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/float) */
    float: string;
    floodColor: string;
    floodOpacity: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font) */
    font: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-family) */
    fontFamily: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-feature-settings) */
    fontFeatureSettings: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-kerning) */
    fontKerning: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing) */
    fontOpticalSizing: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-palette) */
    fontPalette: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-size) */
    fontSize: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-size-adjust) */
    fontSizeAdjust: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-stretch) */
    fontStretch: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-style) */
    fontStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-synthesis) */
    fontSynthesis: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-synthesis-small-caps) */
    fontSynthesisSmallCaps: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-synthesis-style) */
    fontSynthesisStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-synthesis-weight) */
    fontSynthesisWeight: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-variant) */
    fontVariant: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates) */
    fontVariantAlternates: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-variant-caps) */
    fontVariantCaps: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian) */
    fontVariantEastAsian: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures) */
    fontVariantLigatures: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric) */
    fontVariantNumeric: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-variant-position) */
    fontVariantPosition: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-variation-settings) */
    fontVariationSettings: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/font-weight) */
    fontWeight: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/forced-color-adjust) */
    forcedColorAdjust: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/gap) */
    gap: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid) */
    grid: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-area) */
    gridArea: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns) */
    gridAutoColumns: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow) */
    gridAutoFlow: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows) */
    gridAutoRows: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-column) */
    gridColumn: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-column-end) */
    gridColumnEnd: string;
    /** @deprecated This is a legacy alias of `columnGap`. */
    gridColumnGap: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-column-start) */
    gridColumnStart: string;
    /** @deprecated This is a legacy alias of `gap`. */
    gridGap: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-row) */
    gridRow: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-row-end) */
    gridRowEnd: string;
    /** @deprecated This is a legacy alias of `rowGap`. */
    gridRowGap: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-row-start) */
    gridRowStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-template) */
    gridTemplate: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-template-areas) */
    gridTemplateAreas: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-template-columns) */
    gridTemplateColumns: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/grid-template-rows) */
    gridTemplateRows: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/height) */
    height: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/hyphenate-character) */
    hyphenateCharacter: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/hyphens) */
    hyphens: string;
    /**
     * @deprecated
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/image-orientation)
     */
    imageOrientation: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/image-rendering) */
    imageRendering: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/inline-size) */
    inlineSize: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/inset) */
    inset: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/inset-block) */
    insetBlock: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/inset-block-end) */
    insetBlockEnd: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/inset-block-start) */
    insetBlockStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/inset-inline) */
    insetInline: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/inset-inline-end) */
    insetInlineEnd: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/inset-inline-start) */
    insetInlineStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/isolation) */
    isolation: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/justify-content) */
    justifyContent: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/justify-items) */
    justifyItems: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/justify-self) */
    justifySelf: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/left) */
    left: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleDeclaration/length) */
    readonly length: number;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/letter-spacing) */
    letterSpacing: string;
    lightingColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/line-break) */
    lineBreak: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/line-height) */
    lineHeight: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/list-style) */
    listStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/list-style-image) */
    listStyleImage: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/list-style-position) */
    listStylePosition: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/list-style-type) */
    listStyleType: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/margin) */
    margin: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/margin-block) */
    marginBlock: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/margin-block-end) */
    marginBlockEnd: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/margin-block-start) */
    marginBlockStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/margin-bottom) */
    marginBottom: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/margin-inline) */
    marginInline: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/margin-inline-end) */
    marginInlineEnd: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/margin-inline-start) */
    marginInlineStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/margin-left) */
    marginLeft: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/margin-right) */
    marginRight: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/margin-top) */
    marginTop: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/marker) */
    marker: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/marker-end) */
    markerEnd: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/marker-mid) */
    markerMid: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/marker-start) */
    markerStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask) */
    mask: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-clip) */
    maskClip: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-composite) */
    maskComposite: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-image) */
    maskImage: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-mode) */
    maskMode: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-origin) */
    maskOrigin: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-position) */
    maskPosition: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-repeat) */
    maskRepeat: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-size) */
    maskSize: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-type) */
    maskType: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/math-depth) */
    mathDepth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/math-style) */
    mathStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/max-block-size) */
    maxBlockSize: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/max-height) */
    maxHeight: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/max-inline-size) */
    maxInlineSize: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/max-width) */
    maxWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/min-block-size) */
    minBlockSize: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/min-height) */
    minHeight: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/min-inline-size) */
    minInlineSize: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/min-width) */
    minWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode) */
    mixBlendMode: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/object-fit) */
    objectFit: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/object-position) */
    objectPosition: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/offset) */
    offset: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/offset-anchor) */
    offsetAnchor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/offset-distance) */
    offsetDistance: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/offset-path) */
    offsetPath: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/offset-position) */
    offsetPosition: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/offset-rotate) */
    offsetRotate: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/opacity) */
    opacity: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/order) */
    order: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/orphans) */
    orphans: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/outline) */
    outline: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/outline-color) */
    outlineColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/outline-offset) */
    outlineOffset: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/outline-style) */
    outlineStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/outline-width) */
    outlineWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/overflow) */
    overflow: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/overflow-anchor) */
    overflowAnchor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/overflow-clip-margin) */
    overflowClipMargin: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/overflow-wrap) */
    overflowWrap: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/overflow-x) */
    overflowX: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/overflow-y) */
    overflowY: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior) */
    overscrollBehavior: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block) */
    overscrollBehaviorBlock: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline) */
    overscrollBehaviorInline: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x) */
    overscrollBehaviorX: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y) */
    overscrollBehaviorY: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/padding) */
    padding: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/padding-block) */
    paddingBlock: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/padding-block-end) */
    paddingBlockEnd: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/padding-block-start) */
    paddingBlockStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/padding-bottom) */
    paddingBottom: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/padding-inline) */
    paddingInline: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/padding-inline-end) */
    paddingInlineEnd: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/padding-inline-start) */
    paddingInlineStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/padding-left) */
    paddingLeft: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/padding-right) */
    paddingRight: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/padding-top) */
    paddingTop: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/page) */
    page: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/page-break-after) */
    pageBreakAfter: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/page-break-before) */
    pageBreakBefore: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/page-break-inside) */
    pageBreakInside: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/paint-order) */
    paintOrder: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleDeclaration/parentRule) */
    readonly parentRule: CSSRule | null;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/perspective) */
    perspective: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/perspective-origin) */
    perspectiveOrigin: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/place-content) */
    placeContent: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/place-items) */
    placeItems: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/place-self) */
    placeSelf: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/pointer-events) */
    pointerEvents: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/position) */
    position: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/print-color-adjust) */
    printColorAdjust: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/quotes) */
    quotes: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/r) */
    r: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/resize) */
    resize: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/right) */
    right: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/rotate) */
    rotate: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/row-gap) */
    rowGap: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/ruby-align) */
    rubyAlign: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/ruby-position) */
    rubyPosition: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/rx) */
    rx: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/ry) */
    ry: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scale) */
    scale: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-behavior) */
    scrollBehavior: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-margin) */
    scrollMargin: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block) */
    scrollMarginBlock: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end) */
    scrollMarginBlockEnd: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start) */
    scrollMarginBlockStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom) */
    scrollMarginBottom: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline) */
    scrollMarginInline: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end) */
    scrollMarginInlineEnd: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start) */
    scrollMarginInlineStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left) */
    scrollMarginLeft: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right) */
    scrollMarginRight: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top) */
    scrollMarginTop: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-padding) */
    scrollPadding: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block) */
    scrollPaddingBlock: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end) */
    scrollPaddingBlockEnd: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start) */
    scrollPaddingBlockStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom) */
    scrollPaddingBottom: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline) */
    scrollPaddingInline: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end) */
    scrollPaddingInlineEnd: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start) */
    scrollPaddingInlineStart: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left) */
    scrollPaddingLeft: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right) */
    scrollPaddingRight: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top) */
    scrollPaddingTop: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align) */
    scrollSnapAlign: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop) */
    scrollSnapStop: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type) */
    scrollSnapType: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scrollbar-color) */
    scrollbarColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter) */
    scrollbarGutter: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/scrollbar-width) */
    scrollbarWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold) */
    shapeImageThreshold: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/shape-margin) */
    shapeMargin: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/shape-outside) */
    shapeOutside: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/shape-rendering) */
    shapeRendering: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/stop-color) */
    stopColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/stop-opacity) */
    stopOpacity: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/stroke) */
    stroke: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/stroke-dasharray) */
    strokeDasharray: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/stroke-dashoffset) */
    strokeDashoffset: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/stroke-linecap) */
    strokeLinecap: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/stroke-linejoin) */
    strokeLinejoin: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/stroke-miterlimit) */
    strokeMiterlimit: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/stroke-opacity) */
    strokeOpacity: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/stroke-width) */
    strokeWidth: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/tab-size) */
    tabSize: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/table-layout) */
    tableLayout: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-align) */
    textAlign: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-align-last) */
    textAlignLast: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-anchor) */
    textAnchor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-combine-upright) */
    textCombineUpright: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-decoration) */
    textDecoration: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-decoration-color) */
    textDecorationColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-decoration-line) */
    textDecorationLine: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink) */
    textDecorationSkipInk: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-decoration-style) */
    textDecorationStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness) */
    textDecorationThickness: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-emphasis) */
    textEmphasis: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color) */
    textEmphasisColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position) */
    textEmphasisPosition: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style) */
    textEmphasisStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-indent) */
    textIndent: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-orientation) */
    textOrientation: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-overflow) */
    textOverflow: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-rendering) */
    textRendering: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-shadow) */
    textShadow: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-transform) */
    textTransform: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-underline-offset) */
    textUnderlineOffset: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-underline-position) */
    textUnderlinePosition: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-wrap) */
    textWrap: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-wrap-mode) */
    textWrapMode: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-wrap-style) */
    textWrapStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/top) */
    top: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/touch-action) */
    touchAction: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transform) */
    transform: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transform-box) */
    transformBox: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transform-origin) */
    transformOrigin: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transform-style) */
    transformStyle: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transition) */
    transition: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transition-behavior) */
    transitionBehavior: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transition-delay) */
    transitionDelay: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transition-duration) */
    transitionDuration: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transition-property) */
    transitionProperty: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transition-timing-function) */
    transitionTimingFunction: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/translate) */
    translate: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/unicode-bidi) */
    unicodeBidi: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/user-select) */
    userSelect: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/vector-effect) */
    vectorEffect: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/vertical-align) */
    verticalAlign: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/view-transition-name) */
    viewTransitionName: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/visibility) */
    visibility: string;
    /**
     * @deprecated This is a legacy alias of `alignContent`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/align-content)
     */
    webkitAlignContent: string;
    /**
     * @deprecated This is a legacy alias of `alignItems`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/align-items)
     */
    webkitAlignItems: string;
    /**
     * @deprecated This is a legacy alias of `alignSelf`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/align-self)
     */
    webkitAlignSelf: string;
    /**
     * @deprecated This is a legacy alias of `animation`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation)
     */
    webkitAnimation: string;
    /**
     * @deprecated This is a legacy alias of `animationDelay`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-delay)
     */
    webkitAnimationDelay: string;
    /**
     * @deprecated This is a legacy alias of `animationDirection`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-direction)
     */
    webkitAnimationDirection: string;
    /**
     * @deprecated This is a legacy alias of `animationDuration`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-duration)
     */
    webkitAnimationDuration: string;
    /**
     * @deprecated This is a legacy alias of `animationFillMode`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode)
     */
    webkitAnimationFillMode: string;
    /**
     * @deprecated This is a legacy alias of `animationIterationCount`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count)
     */
    webkitAnimationIterationCount: string;
    /**
     * @deprecated This is a legacy alias of `animationName`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-name)
     */
    webkitAnimationName: string;
    /**
     * @deprecated This is a legacy alias of `animationPlayState`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-play-state)
     */
    webkitAnimationPlayState: string;
    /**
     * @deprecated This is a legacy alias of `animationTimingFunction`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/animation-timing-function)
     */
    webkitAnimationTimingFunction: string;
    /**
     * @deprecated This is a legacy alias of `appearance`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/appearance)
     */
    webkitAppearance: string;
    /**
     * @deprecated This is a legacy alias of `backfaceVisibility`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/backface-visibility)
     */
    webkitBackfaceVisibility: string;
    /**
     * @deprecated This is a legacy alias of `backgroundClip`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-clip)
     */
    webkitBackgroundClip: string;
    /**
     * @deprecated This is a legacy alias of `backgroundOrigin`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-origin)
     */
    webkitBackgroundOrigin: string;
    /**
     * @deprecated This is a legacy alias of `backgroundSize`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/background-size)
     */
    webkitBackgroundSize: string;
    /**
     * @deprecated This is a legacy alias of `borderBottomLeftRadius`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius)
     */
    webkitBorderBottomLeftRadius: string;
    /**
     * @deprecated This is a legacy alias of `borderBottomRightRadius`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius)
     */
    webkitBorderBottomRightRadius: string;
    /**
     * @deprecated This is a legacy alias of `borderRadius`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-radius)
     */
    webkitBorderRadius: string;
    /**
     * @deprecated This is a legacy alias of `borderTopLeftRadius`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius)
     */
    webkitBorderTopLeftRadius: string;
    /**
     * @deprecated This is a legacy alias of `borderTopRightRadius`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius)
     */
    webkitBorderTopRightRadius: string;
    /**
     * @deprecated This is a legacy alias of `boxAlign`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/box-align)
     */
    webkitBoxAlign: string;
    /**
     * @deprecated This is a legacy alias of `boxFlex`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/box-flex)
     */
    webkitBoxFlex: string;
    /**
     * @deprecated This is a legacy alias of `boxOrdinalGroup`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group)
     */
    webkitBoxOrdinalGroup: string;
    /**
     * @deprecated This is a legacy alias of `boxOrient`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/box-orient)
     */
    webkitBoxOrient: string;
    /**
     * @deprecated This is a legacy alias of `boxPack`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/box-pack)
     */
    webkitBoxPack: string;
    /**
     * @deprecated This is a legacy alias of `boxShadow`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/box-shadow)
     */
    webkitBoxShadow: string;
    /**
     * @deprecated This is a legacy alias of `boxSizing`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/box-sizing)
     */
    webkitBoxSizing: string;
    /**
     * @deprecated This is a legacy alias of `filter`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/filter)
     */
    webkitFilter: string;
    /**
     * @deprecated This is a legacy alias of `flex`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex)
     */
    webkitFlex: string;
    /**
     * @deprecated This is a legacy alias of `flexBasis`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex-basis)
     */
    webkitFlexBasis: string;
    /**
     * @deprecated This is a legacy alias of `flexDirection`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex-direction)
     */
    webkitFlexDirection: string;
    /**
     * @deprecated This is a legacy alias of `flexFlow`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex-flow)
     */
    webkitFlexFlow: string;
    /**
     * @deprecated This is a legacy alias of `flexGrow`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex-grow)
     */
    webkitFlexGrow: string;
    /**
     * @deprecated This is a legacy alias of `flexShrink`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex-shrink)
     */
    webkitFlexShrink: string;
    /**
     * @deprecated This is a legacy alias of `flexWrap`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/flex-wrap)
     */
    webkitFlexWrap: string;
    /**
     * @deprecated This is a legacy alias of `justifyContent`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/justify-content)
     */
    webkitJustifyContent: string;
    /**
     * @deprecated This is a legacy alias of `lineClamp`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp)
     */
    webkitLineClamp: string;
    /**
     * @deprecated This is a legacy alias of `mask`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask)
     */
    webkitMask: string;
    /**
     * @deprecated This is a legacy alias of `maskBorder`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-border)
     */
    webkitMaskBoxImage: string;
    /**
     * @deprecated This is a legacy alias of `maskBorderOutset`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-border-outset)
     */
    webkitMaskBoxImageOutset: string;
    /**
     * @deprecated This is a legacy alias of `maskBorderRepeat`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat)
     */
    webkitMaskBoxImageRepeat: string;
    /**
     * @deprecated This is a legacy alias of `maskBorderSlice`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-border-slice)
     */
    webkitMaskBoxImageSlice: string;
    /**
     * @deprecated This is a legacy alias of `maskBorderSource`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-border-source)
     */
    webkitMaskBoxImageSource: string;
    /**
     * @deprecated This is a legacy alias of `maskBorderWidth`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-border-width)
     */
    webkitMaskBoxImageWidth: string;
    /**
     * @deprecated This is a legacy alias of `maskClip`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-clip)
     */
    webkitMaskClip: string;
    /**
     * @deprecated This is a legacy alias of `maskComposite`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-composite)
     */
    webkitMaskComposite: string;
    /**
     * @deprecated This is a legacy alias of `maskImage`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-image)
     */
    webkitMaskImage: string;
    /**
     * @deprecated This is a legacy alias of `maskOrigin`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-origin)
     */
    webkitMaskOrigin: string;
    /**
     * @deprecated This is a legacy alias of `maskPosition`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-position)
     */
    webkitMaskPosition: string;
    /**
     * @deprecated This is a legacy alias of `maskRepeat`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-repeat)
     */
    webkitMaskRepeat: string;
    /**
     * @deprecated This is a legacy alias of `maskSize`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/mask-size)
     */
    webkitMaskSize: string;
    /**
     * @deprecated This is a legacy alias of `order`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/order)
     */
    webkitOrder: string;
    /**
     * @deprecated This is a legacy alias of `perspective`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/perspective)
     */
    webkitPerspective: string;
    /**
     * @deprecated This is a legacy alias of `perspectiveOrigin`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/perspective-origin)
     */
    webkitPerspectiveOrigin: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color) */
    webkitTextFillColor: string;
    /**
     * @deprecated This is a legacy alias of `textSizeAdjust`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/text-size-adjust)
     */
    webkitTextSizeAdjust: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke) */
    webkitTextStroke: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color) */
    webkitTextStrokeColor: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width) */
    webkitTextStrokeWidth: string;
    /**
     * @deprecated This is a legacy alias of `transform`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transform)
     */
    webkitTransform: string;
    /**
     * @deprecated This is a legacy alias of `transformOrigin`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transform-origin)
     */
    webkitTransformOrigin: string;
    /**
     * @deprecated This is a legacy alias of `transformStyle`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transform-style)
     */
    webkitTransformStyle: string;
    /**
     * @deprecated This is a legacy alias of `transition`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transition)
     */
    webkitTransition: string;
    /**
     * @deprecated This is a legacy alias of `transitionDelay`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transition-delay)
     */
    webkitTransitionDelay: string;
    /**
     * @deprecated This is a legacy alias of `transitionDuration`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transition-duration)
     */
    webkitTransitionDuration: string;
    /**
     * @deprecated This is a legacy alias of `transitionProperty`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transition-property)
     */
    webkitTransitionProperty: string;
    /**
     * @deprecated This is a legacy alias of `transitionTimingFunction`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/transition-timing-function)
     */
    webkitTransitionTimingFunction: string;
    /**
     * @deprecated This is a legacy alias of `userSelect`.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/user-select)
     */
    webkitUserSelect: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/white-space) */
    whiteSpace: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/white-space-collapse) */
    whiteSpaceCollapse: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/widows) */
    widows: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/width) */
    width: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/will-change) */
    willChange: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/word-break) */
    wordBreak: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/word-spacing) */
    wordSpacing: string;
    /** @deprecated */
    wordWrap: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/writing-mode) */
    writingMode: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/x) */
    x: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/y) */
    y: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/z-index) */
    zIndex: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/CSS/zoom) */
    zoom: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleDeclaration/getPropertyPriority) */
    getPropertyPriority(property: string): string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleDeclaration/getPropertyValue) */
    getPropertyValue(property: string): string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleDeclaration/item) */
    item(index: number): string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleDeclaration/removeProperty) */
    removeProperty(property: string): string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleDeclaration/setProperty) */
    setProperty(property: string, value: string | null, priority?: string): void;
    [index: number]: string;
}

declare var CSSStyleDeclaration: {
    prototype: CSSStyleDeclaration;
    new(): CSSStyleDeclaration;
    isInstance: IsInstance<CSSStyleDeclaration>;
};

interface CSSStyleRule extends CSSGroupingRule {
    readonly selectorCount: number;
    selectorText: string;
    readonly style: CSSStyleDeclaration;
    getSelectorWarnings(): SelectorWarning[];
    selectorMatchesElement(selectorIndex: number, element: Element, pseudo?: string, includeVisitedStyle?: boolean): boolean;
    selectorSpecificityAt(index: number, desugared?: boolean): number;
    selectorTextAt(index: number, desugared?: boolean): string;
}

declare var CSSStyleRule: {
    prototype: CSSStyleRule;
    new(): CSSStyleRule;
    isInstance: IsInstance<CSSStyleRule>;
};

interface CSSStyleSheet extends StyleSheet {
    readonly cssRules: CSSRuleList;
    readonly ownerRule: CSSRule | null;
    readonly parsingMode: CSSStyleSheetParsingMode;
    readonly rules: CSSRuleList;
    addRule(selector?: string, style?: string, index?: number): number;
    deleteRule(index: number): void;
    insertRule(rule: string, index?: number): number;
    removeRule(index?: number): void;
    replace(text: string): Promise<CSSStyleSheet>;
    replaceSync(text: string): void;
}

declare var CSSStyleSheet: {
    prototype: CSSStyleSheet;
    new(options?: CSSStyleSheetInit): CSSStyleSheet;
    isInstance: IsInstance<CSSStyleSheet>;
};

interface CSSSupportsRule extends CSSConditionRule {
}

declare var CSSSupportsRule: {
    prototype: CSSSupportsRule;
    new(): CSSSupportsRule;
    isInstance: IsInstance<CSSSupportsRule>;
};

interface CSSTransition extends Animation {
    readonly transitionProperty: string;
    addEventListener<K extends keyof AnimationEventMap>(type: K, listener: (this: CSSTransition, ev: AnimationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AnimationEventMap>(type: K, listener: (this: CSSTransition, ev: AnimationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var CSSTransition: {
    prototype: CSSTransition;
    new(): CSSTransition;
    isInstance: IsInstance<CSSTransition>;
};

interface Cache {
    add(request: RequestInfo | URL): Promise<void>;
    addAll(requests: RequestInfo[]): Promise<void>;
    delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<boolean>;
    keys(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<Request[]>;
    match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response>;
    matchAll(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response[]>;
    put(request: RequestInfo | URL, response: Response): Promise<void>;
}

declare var Cache: {
    prototype: Cache;
    new(): Cache;
    isInstance: IsInstance<Cache>;
};

interface CacheStorage {
    delete(cacheName: string): Promise<boolean>;
    has(cacheName: string): Promise<boolean>;
    keys(): Promise<string[]>;
    match(request: RequestInfo | URL, options?: MultiCacheQueryOptions): Promise<Response>;
    open(cacheName: string): Promise<Cache>;
}

declare var CacheStorage: {
    prototype: CacheStorage;
    new(namespace: CacheStorageNamespace, principal: Principal): CacheStorage;
    isInstance: IsInstance<CacheStorage>;
};

interface CallbackDebuggerNotification extends DebuggerNotification {
    readonly phase: CallbackDebuggerNotificationPhase;
}

declare var CallbackDebuggerNotification: {
    prototype: CallbackDebuggerNotification;
    new(): CallbackDebuggerNotification;
    isInstance: IsInstance<CallbackDebuggerNotification>;
};

interface CanonicalBrowsingContext extends BrowsingContext {
    readonly activeSessionHistoryEntry: nsISHEntry | null;
    readonly canOpenModalPicker: boolean;
    crossGroupOpener: CanonicalBrowsingContext | null;
    readonly currentRemoteType: string | null;
    readonly currentURI: URI | null;
    readonly currentWindowGlobal: WindowGlobalParent | null;
    readonly embedderWindowGlobal: WindowGlobalParent | null;
    forceAppWindowActive: boolean;
    isActive: boolean;
    readonly isReplaced: boolean;
    readonly isUnderHiddenEmbedderElement: boolean;
    readonly mediaController: MediaController | null;
    readonly mostRecentLoadingSessionHistoryEntry: nsISHEntry | null;
    readonly secureBrowserUI: nsISecureBrowserUI | null;
    readonly sessionHistory: nsISHistory | null;
    targetTopLevelLinkClicksToBlank: boolean;
    readonly topChromeWindow: WindowProxy | null;
    touchEventsOverride: TouchEventsOverride;
    readonly webProgress: nsIWebProgress | null;
    clearRestoreState(): void;
    fixupAndLoadURIString(aURI: string, aOptions?: LoadURIOptions): void;
    getWindowGlobals(): WindowGlobalParent[];
    goBack(aCancelContentJSEpoch?: number, aRequireUserInteraction?: boolean, aUserActivation?: boolean): void;
    goForward(aCancelContentJSEpoch?: number, aRequireUserInteraction?: boolean, aUserActivation?: boolean): void;
    goToIndex(aIndex: number, aCancelContentJSEpoch?: number, aUserActivation?: boolean): void;
    loadURI(aURI: URI, aOptions?: LoadURIOptions): void;
    notifyMediaMutedChanged(muted: boolean): void;
    notifyStartDelayedAutoplayMedia(): void;
    print(aPrintSettings: nsIPrintSettings): Promise<void>;
    reload(aReloadFlags: number): void;
    resetScalingZoom(): void;
    startApzAutoscroll(aAnchorX: number, aAnchorY: number, aScrollId: number, aPresShellId: number): boolean;
    stop(aStopFlags: number): void;
    stopApzAutoscroll(aScrollId: number, aPresShellId: number): void;
}

declare var CanonicalBrowsingContext: {
    prototype: CanonicalBrowsingContext;
    new(): CanonicalBrowsingContext;
    isInstance: IsInstance<CanonicalBrowsingContext>;
    countSiteOrigins(roots: BrowsingContext[]): number;
};

interface CanvasCaptureMediaStream extends MediaStream {
    readonly canvas: HTMLCanvasElement;
    requestFrame(): void;
    addEventListener<K extends keyof MediaStreamEventMap>(type: K, listener: (this: CanvasCaptureMediaStream, ev: MediaStreamEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MediaStreamEventMap>(type: K, listener: (this: CanvasCaptureMediaStream, ev: MediaStreamEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var CanvasCaptureMediaStream: {
    prototype: CanvasCaptureMediaStream;
    new(): CanvasCaptureMediaStream;
    isInstance: IsInstance<CanvasCaptureMediaStream>;
};

interface CanvasCompositing {
    globalAlpha: number;
    globalCompositeOperation: string;
}

interface CanvasDrawImage {
    contextProperties: CanvasContextProperties;
    drawImage(image: CanvasImageSource, dx: number, dy: number): void;
    drawImage(image: CanvasImageSource, dx: number, dy: number, dw: number, dh: number): void;
    drawImage(image: CanvasImageSource, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;
}

interface CanvasDrawPath {
    beginPath(): void;
    clip(winding?: CanvasWindingRule): void;
    clip(path: Path2D, winding?: CanvasWindingRule): void;
    fill(winding?: CanvasWindingRule): void;
    fill(path: Path2D, winding?: CanvasWindingRule): void;
    isPointInPath(x: number, y: number, winding?: CanvasWindingRule): boolean;
    isPointInPath(path: Path2D, x: number, y: number, winding?: CanvasWindingRule): boolean;
    isPointInStroke(x: number, y: number): boolean;
    isPointInStroke(path: Path2D, x: number, y: number): boolean;
    stroke(): void;
    stroke(path: Path2D): void;
}

interface CanvasFillStrokeStyles {
    fillStyle: string | CanvasGradient | CanvasPattern;
    strokeStyle: string | CanvasGradient | CanvasPattern;
    createConicGradient(angle: number, cx: number, cy: number): CanvasGradient;
    createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;
    createPattern(image: CanvasImageSource, repetition: string | null): CanvasPattern | null;
    createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;
}

interface CanvasFilters {
    filter: string;
}

interface CanvasGradient {
    addColorStop(offset: number, color: string): void;
}

declare var CanvasGradient: {
    prototype: CanvasGradient;
    new(): CanvasGradient;
    isInstance: IsInstance<CanvasGradient>;
};

interface CanvasImageData {
    createImageData(sw: number, sh: number): ImageData;
    createImageData(imagedata: ImageData): ImageData;
    getImageData(sx: number, sy: number, sw: number, sh: number): ImageData;
    putImageData(imagedata: ImageData, dx: number, dy: number): void;
    putImageData(imagedata: ImageData, dx: number, dy: number, dirtyX: number, dirtyY: number, dirtyWidth: number, dirtyHeight: number): void;
}

interface CanvasImageSmoothing {
    imageSmoothingEnabled: boolean;
}

interface CanvasPathDrawingStyles {
    lineCap: CanvasLineCap;
    lineDashOffset: number;
    lineJoin: CanvasLineJoin;
    lineWidth: number;
    miterLimit: number;
    getLineDash(): number[];
    setLineDash(segments: number[]): void;
}

interface CanvasPathMethods {
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    closePath(): void;
    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    lineTo(x: number, y: number): void;
    moveTo(x: number, y: number): void;
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    rect(x: number, y: number, w: number, h: number): void;
    roundRect(x: number, y: number, w: number, h: number, radii?: number | DOMPointInit | (number | DOMPointInit)[]): void;
}

interface CanvasPattern {
    setTransform(matrix?: DOMMatrix2DInit): void;
}

declare var CanvasPattern: {
    prototype: CanvasPattern;
    new(): CanvasPattern;
    isInstance: IsInstance<CanvasPattern>;
};

interface CanvasRect {
    clearRect(x: number, y: number, w: number, h: number): void;
    fillRect(x: number, y: number, w: number, h: number): void;
    strokeRect(x: number, y: number, w: number, h: number): void;
}

interface CanvasRenderingContext2D extends CanvasCompositing, CanvasDrawImage, CanvasDrawPath, CanvasFillStrokeStyles, CanvasFilters, CanvasImageData, CanvasImageSmoothing, CanvasPathDrawingStyles, CanvasPathMethods, CanvasRect, CanvasShadowStyles, CanvasState, CanvasText, CanvasTextDrawingStyles, CanvasTransform, CanvasUserInterface {
    readonly canvas: HTMLCanvasElement | null;
    demote(): void;
    drawWindow(window: Window, x: number, y: number, w: number, h: number, bgColor: string, flags?: number): void;
    getContextAttributes(): CanvasRenderingContext2DSettings;
    getDebugInfo(ensureTarget?: boolean): CanvasRenderingContext2DDebugInfo;
    readonly DRAWWINDOW_DRAW_CARET: 0x01;
    readonly DRAWWINDOW_DO_NOT_FLUSH: 0x02;
    readonly DRAWWINDOW_DRAW_VIEW: 0x04;
    readonly DRAWWINDOW_USE_WIDGET_LAYERS: 0x08;
    readonly DRAWWINDOW_ASYNC_DECODE_IMAGES: 0x10;
}

declare var CanvasRenderingContext2D: {
    prototype: CanvasRenderingContext2D;
    new(): CanvasRenderingContext2D;
    readonly DRAWWINDOW_DRAW_CARET: 0x01;
    readonly DRAWWINDOW_DO_NOT_FLUSH: 0x02;
    readonly DRAWWINDOW_DRAW_VIEW: 0x04;
    readonly DRAWWINDOW_USE_WIDGET_LAYERS: 0x08;
    readonly DRAWWINDOW_ASYNC_DECODE_IMAGES: 0x10;
    isInstance: IsInstance<CanvasRenderingContext2D>;
};

interface CanvasShadowStyles {
    shadowBlur: number;
    shadowColor: string;
    shadowOffsetX: number;
    shadowOffsetY: number;
}

interface CanvasState {
    isContextLost(): boolean;
    reset(): void;
    restore(): void;
    save(): void;
}

interface CanvasText {
    fillText(text: string, x: number, y: number, maxWidth?: number): void;
    measureText(text: string): TextMetrics;
    strokeText(text: string, x: number, y: number, maxWidth?: number): void;
}

interface CanvasTextDrawingStyles {
    direction: CanvasDirection;
    font: string;
    fontKerning: CanvasFontKerning;
    fontStretch: CanvasFontStretch;
    fontVariantCaps: CanvasFontVariantCaps;
    letterSpacing: string;
    textAlign: CanvasTextAlign;
    textBaseline: CanvasTextBaseline;
    textRendering: CanvasTextRendering;
    wordSpacing: string;
}

interface CanvasTransform {
    getTransform(): DOMMatrix;
    resetTransform(): void;
    rotate(angle: number): void;
    scale(x: number, y: number): void;
    setTransform(a: number, b: number, c: number, d: number, e: number, f: number): void;
    setTransform(transform?: DOMMatrix2DInit): void;
    transform(a: number, b: number, c: number, d: number, e: number, f: number): void;
    translate(x: number, y: number): void;
}

interface CanvasUserInterface {
    drawFocusIfNeeded(element: Element): void;
}

interface CaretPosition {
    readonly offset: number;
    readonly offsetNode: Node | null;
    getClientRect(): DOMRect | null;
}

declare var CaretPosition: {
    prototype: CaretPosition;
    new(): CaretPosition;
    isInstance: IsInstance<CaretPosition>;
};

interface CaretStateChangedEvent extends Event {
    readonly boundingClientRect: DOMRectReadOnly | null;
    readonly caretVisible: boolean;
    readonly caretVisuallyVisible: boolean;
    readonly clientX: number;
    readonly clientY: number;
    readonly collapsed: boolean;
    readonly reason: CaretChangedReason;
    readonly selectedTextContent: string;
    readonly selectionEditable: boolean;
    readonly selectionVisible: boolean;
}

declare var CaretStateChangedEvent: {
    prototype: CaretStateChangedEvent;
    new(type: string, eventInit?: CaretStateChangedEventInit): CaretStateChangedEvent;
    isInstance: IsInstance<CaretStateChangedEvent>;
};

interface ChannelMergerNode extends AudioNode {
}

declare var ChannelMergerNode: {
    prototype: ChannelMergerNode;
    new(context: BaseAudioContext, options?: ChannelMergerOptions): ChannelMergerNode;
    isInstance: IsInstance<ChannelMergerNode>;
};

interface ChannelSplitterNode extends AudioNode {
}

declare var ChannelSplitterNode: {
    prototype: ChannelSplitterNode;
    new(context: BaseAudioContext, options?: ChannelSplitterOptions): ChannelSplitterNode;
    isInstance: IsInstance<ChannelSplitterNode>;
};

interface ChannelWrapperEventMap {
    "error": Event;
    "start": Event;
    "stop": Event;
}

interface ChannelWrapper extends EventTarget {
    readonly browserElement: nsISupports | null;
    readonly canModify: boolean;
    channel: MozChannel | null;
    contentType: string;
    readonly documentURI: URI | null;
    readonly documentURL: string | null;
    readonly errorString: string | null;
    readonly finalURI: URI | null;
    readonly finalURL: string;
    readonly frameAncestors: MozFrameAncestorInfo[] | null;
    readonly frameId: number;
    readonly id: number;
    readonly isServiceWorkerScript: boolean;
    readonly loadInfo: LoadInfo | null;
    readonly method: string;
    onerror: ((this: ChannelWrapper, ev: Event) => any) | null;
    onstart: ((this: ChannelWrapper, ev: Event) => any) | null;
    onstop: ((this: ChannelWrapper, ev: Event) => any) | null;
    readonly originURI: URI | null;
    readonly originURL: string | null;
    readonly parentFrameId: number;
    readonly proxyInfo: MozProxyInfo | null;
    readonly remoteAddress: string | null;
    readonly requestSize: number;
    readonly responseSize: number;
    readonly statusCode: number;
    readonly statusLine: string;
    readonly suspended: boolean;
    readonly thirdParty: boolean;
    readonly type: MozContentPolicyType;
    readonly urlClassification: MozUrlClassification | null;
    cancel(result: number, reason?: number): void;
    errorCheck(): void;
    getRequestHeader(header: string): string | null;
    getRequestHeaders(): MozHTTPHeader[];
    getResponseHeaders(): MozHTTPHeader[];
    matches(filter?: MozRequestFilter, extension?: WebExtensionPolicy | null, options?: MozRequestMatchOptions): boolean;
    redirectTo(url: URI): void;
    registerTraceableChannel(extension: WebExtensionPolicy, remoteTab: RemoteTab | null): void;
    resume(): void;
    setRequestHeader(header: string, value: string, merge?: boolean): void;
    setResponseHeader(header: string, value: string, merge?: boolean): void;
    suspend(profileMarkerText: string): void;
    upgradeToSecure(): void;
    addEventListener<K extends keyof ChannelWrapperEventMap>(type: K, listener: (this: ChannelWrapper, ev: ChannelWrapperEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof ChannelWrapperEventMap>(type: K, listener: (this: ChannelWrapper, ev: ChannelWrapperEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var ChannelWrapper: {
    prototype: ChannelWrapper;
    new(): ChannelWrapper;
    isInstance: IsInstance<ChannelWrapper>;
    get(channel: MozChannel): ChannelWrapper;
    getRegisteredChannel(aChannelId: number, extension: WebExtensionPolicy, remoteTab: RemoteTab | null): ChannelWrapper | null;
};

interface CharacterData extends Node, ChildNode, NonDocumentTypeChildNode {
    data: string;
    readonly length: number;
    appendData(data: string): void;
    deleteData(offset: number, count: number): void;
    insertData(offset: number, data: string): void;
    replaceData(offset: number, count: number, data: string): void;
    substringData(offset: number, count: number): string;
}

declare var CharacterData: {
    prototype: CharacterData;
    new(): CharacterData;
    isInstance: IsInstance<CharacterData>;
};

interface CheckerboardReportService {
    flushActiveReports(): void;
    getReports(): CheckerboardReport[];
    isRecordingEnabled(): boolean;
    setRecordingEnabled(aEnabled: boolean): void;
}

declare var CheckerboardReportService: {
    prototype: CheckerboardReportService;
    new(): CheckerboardReportService;
    isInstance: IsInstance<CheckerboardReportService>;
};

interface ChildNode {
    after(...nodes: (Node | string)[]): void;
    before(...nodes: (Node | string)[]): void;
    remove(): void;
    replaceWith(...nodes: (Node | string)[]): void;
}

interface ChildProcessMessageManager extends SyncMessageSender {
}

declare var ChildProcessMessageManager: {
    prototype: ChildProcessMessageManager;
    new(): ChildProcessMessageManager;
    isInstance: IsInstance<ChildProcessMessageManager>;
};

interface ChildSHistory {
    readonly count: number;
    readonly index: number;
    readonly legacySHistory: nsISHistory;
    canGo(aOffset: number, aRequireUserInteraction?: boolean): boolean;
    go(aOffset: number, aRequireUserInteraction?: boolean, aUserActivation?: boolean): void;
    reload(aReloadFlags: number): void;
}

declare var ChildSHistory: {
    prototype: ChildSHistory;
    new(): ChildSHistory;
    isInstance: IsInstance<ChildSHistory>;
};

interface ChromeMessageBroadcaster extends MessageBroadcaster, FrameScriptLoader {
}

declare var ChromeMessageBroadcaster: {
    prototype: ChromeMessageBroadcaster;
    new(): ChromeMessageBroadcaster;
    isInstance: IsInstance<ChromeMessageBroadcaster>;
};

interface ChromeMessageSender extends MessageSender, FrameScriptLoader {
}

declare var ChromeMessageSender: {
    prototype: ChromeMessageSender;
    new(): ChromeMessageSender;
    isInstance: IsInstance<ChromeMessageSender>;
};

interface ChromeNodeList extends NodeList {
    append(aNode: Node): void;
    remove(aNode: Node): void;
}

declare var ChromeNodeList: {
    prototype: ChromeNodeList;
    new(): ChromeNodeList;
    isInstance: IsInstance<ChromeNodeList>;
};

interface ChromeWorker extends Worker {
    addEventListener<K extends keyof WorkerEventMap>(type: K, listener: (this: ChromeWorker, ev: WorkerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof WorkerEventMap>(type: K, listener: (this: ChromeWorker, ev: WorkerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var ChromeWorker: {
    prototype: ChromeWorker;
    new(scriptURL: string | URL, options?: WorkerOptions): ChromeWorker;
    isInstance: IsInstance<ChromeWorker>;
};

/** Available only in secure contexts. */
interface Clipboard extends EventTarget {
    read(): Promise<ClipboardItems>;
    readText(): Promise<string>;
    write(data: ClipboardItems): Promise<void>;
    writeText(data: string): Promise<void>;
}

declare var Clipboard: {
    prototype: Clipboard;
    new(): Clipboard;
    isInstance: IsInstance<Clipboard>;
};

interface ClipboardEvent extends Event {
    readonly clipboardData: DataTransfer | null;
}

declare var ClipboardEvent: {
    prototype: ClipboardEvent;
    new(type: string, eventInitDict?: ClipboardEventInit): ClipboardEvent;
    isInstance: IsInstance<ClipboardEvent>;
};

/** Available only in secure contexts. */
interface ClipboardItem {
    readonly presentationStyle: PresentationStyle;
    readonly types: string[];
    getType(type: string): Promise<Blob>;
}

declare var ClipboardItem: {
    prototype: ClipboardItem;
    new(items: Record<string, ClipboardItemDataType | PromiseLike<ClipboardItemDataType>>, options?: ClipboardItemOptions): ClipboardItem;
    isInstance: IsInstance<ClipboardItem>;
    supports(type: string): boolean;
};

interface ClonedErrorHolder {
}

declare var ClonedErrorHolder: {
    prototype: ClonedErrorHolder;
    new(aError: any): ClonedErrorHolder;
    isInstance: IsInstance<ClonedErrorHolder>;
};

interface CloseEvent extends Event {
    readonly code: number;
    readonly reason: string;
    readonly wasClean: boolean;
}

declare var CloseEvent: {
    prototype: CloseEvent;
    new(type: string, eventInitDict?: CloseEventInit): CloseEvent;
    isInstance: IsInstance<CloseEvent>;
};

interface CloseWatcherEventMap {
    "cancel": Event;
    "close": Event;
}

interface CloseWatcher extends EventTarget {
    oncancel: ((this: CloseWatcher, ev: Event) => any) | null;
    onclose: ((this: CloseWatcher, ev: Event) => any) | null;
    close(): void;
    destroy(): void;
    requestClose(): void;
    addEventListener<K extends keyof CloseWatcherEventMap>(type: K, listener: (this: CloseWatcher, ev: CloseWatcherEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof CloseWatcherEventMap>(type: K, listener: (this: CloseWatcher, ev: CloseWatcherEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var CloseWatcher: {
    prototype: CloseWatcher;
    new(options?: CloseWatcherOptions): CloseWatcher;
    isInstance: IsInstance<CloseWatcher>;
};

interface CommandEvent extends Event {
    readonly command: string | null;
}

declare var CommandEvent: {
    prototype: CommandEvent;
    new(): CommandEvent;
    isInstance: IsInstance<CommandEvent>;
};

interface Comment extends CharacterData {
}

declare var Comment: {
    prototype: Comment;
    new(data?: string): Comment;
    isInstance: IsInstance<Comment>;
};

interface CompositionEvent extends UIEvent {
    readonly data: string | null;
    readonly locale: string;
    readonly ranges: TextClause[];
    initCompositionEvent(typeArg: string, canBubbleArg?: boolean, cancelableArg?: boolean, viewArg?: Window | null, dataArg?: string | null, localeArg?: string): void;
}

declare var CompositionEvent: {
    prototype: CompositionEvent;
    new(type: string, eventInitDict?: CompositionEventInit): CompositionEvent;
    isInstance: IsInstance<CompositionEvent>;
};

interface CompressionStream extends GenericTransformStream {
}

declare var CompressionStream: {
    prototype: CompressionStream;
    new(format: CompressionFormat): CompressionStream;
    isInstance: IsInstance<CompressionStream>;
};

interface ConsoleInstance {
    assert(condition?: boolean, ...data: any[]): void;
    clear(): void;
    count(label?: string): void;
    countReset(label?: string): void;
    debug(...data: any[]): void;
    dir(...data: any[]): void;
    dirxml(...data: any[]): void;
    error(...data: any[]): void;
    exception(...data: any[]): void;
    group(...data: any[]): void;
    groupCollapsed(...data: any[]): void;
    groupEnd(): void;
    info(...data: any[]): void;
    log(...data: any[]): void;
    profile(...data: any[]): void;
    profileEnd(...data: any[]): void;
    reportForServiceWorkerScope(scope: string, message: string, filename: string, lineNumber: number, columnNumber: number, level: ConsoleLevel): void;
    shouldLog(level: ConsoleLogLevel): boolean;
    table(...data: any[]): void;
    time(label?: string): void;
    timeEnd(label?: string): void;
    timeLog(label?: string, ...data: any[]): void;
    timeStamp(data?: any): void;
    trace(...data: any[]): void;
    warn(...data: any[]): void;
}

declare var ConsoleInstance: {
    prototype: ConsoleInstance;
    new(): ConsoleInstance;
    isInstance: IsInstance<ConsoleInstance>;
};

interface ConstantSourceNode extends AudioScheduledSourceNode {
    readonly offset: AudioParam;
    addEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: ConstantSourceNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: ConstantSourceNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var ConstantSourceNode: {
    prototype: ConstantSourceNode;
    new(context: BaseAudioContext, options?: ConstantSourceOptions): ConstantSourceNode;
    isInstance: IsInstance<ConstantSourceNode>;
};

interface ContentFrameMessageManager extends EventTarget, MessageListenerManagerMixin, MessageManagerGlobal, MessageSenderMixin, SyncMessageSenderMixin {
    readonly content: WindowProxy | null;
    readonly docShell: nsIDocShell | null;
    readonly tabEventTarget: nsIEventTarget | null;
}

declare var ContentFrameMessageManager: {
    prototype: ContentFrameMessageManager;
    new(): ContentFrameMessageManager;
    isInstance: IsInstance<ContentFrameMessageManager>;
};

interface ContentProcessMessageManager extends MessageListenerManagerMixin, MessageManagerGlobal, MessageSenderMixin, SyncMessageSenderMixin {
    readonly initialProcessData: any;
    readonly sharedData: MozSharedMap | null;
}

declare var ContentProcessMessageManager: {
    prototype: ContentProcessMessageManager;
    new(): ContentProcessMessageManager;
    isInstance: IsInstance<ContentProcessMessageManager>;
};

interface ContentVisibilityAutoStateChangeEvent extends Event {
    readonly skipped: boolean;
}

declare var ContentVisibilityAutoStateChangeEvent: {
    prototype: ContentVisibilityAutoStateChangeEvent;
    new(type: string, eventInitDict?: ContentVisibilityAutoStateChangeEventInit): ContentVisibilityAutoStateChangeEvent;
    isInstance: IsInstance<ContentVisibilityAutoStateChangeEvent>;
};

interface ConvolverNode extends AudioNode, AudioNodePassThrough {
    buffer: AudioBuffer | null;
    normalize: boolean;
}

declare var ConvolverNode: {
    prototype: ConvolverNode;
    new(context: BaseAudioContext, options?: ConvolverOptions): ConvolverNode;
    isInstance: IsInstance<ConvolverNode>;
};

/** Available only in secure contexts. */
interface CookieChangeEvent extends Event {
    readonly changed: CookieListItem[];
    readonly deleted: CookieListItem[];
}

declare var CookieChangeEvent: {
    prototype: CookieChangeEvent;
    new(type: string, eventInitDict?: CookieChangeEventInit): CookieChangeEvent;
    isInstance: IsInstance<CookieChangeEvent>;
};

interface CookieStoreEventMap {
    "change": Event;
}

/** Available only in secure contexts. */
interface CookieStore extends EventTarget {
    onchange: ((this: CookieStore, ev: Event) => any) | null;
    delete(name: string): Promise<void>;
    delete(options: CookieStoreDeleteOptions): Promise<void>;
    get(name: string): Promise<CookieListItem | null>;
    get(options?: CookieStoreGetOptions): Promise<CookieListItem | null>;
    getAll(name: string): Promise<CookieList>;
    getAll(options?: CookieStoreGetOptions): Promise<CookieList>;
    set(name: string, value: string): Promise<void>;
    set(options: CookieInit): Promise<void>;
    addEventListener<K extends keyof CookieStoreEventMap>(type: K, listener: (this: CookieStore, ev: CookieStoreEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof CookieStoreEventMap>(type: K, listener: (this: CookieStore, ev: CookieStoreEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var CookieStore: {
    prototype: CookieStore;
    new(): CookieStore;
    isInstance: IsInstance<CookieStore>;
};

/** Available only in secure contexts. */
interface CookieStoreManager {
    getSubscriptions(): Promise<CookieStoreGetOptions[]>;
    subscribe(subscriptions: CookieStoreGetOptions[]): Promise<void>;
    unsubscribe(subscriptions: CookieStoreGetOptions[]): Promise<void>;
}

declare var CookieStoreManager: {
    prototype: CookieStoreManager;
    new(): CookieStoreManager;
    isInstance: IsInstance<CookieStoreManager>;
};

interface CountQueuingStrategy {
    readonly highWaterMark: number;
    readonly size: Function;
}

declare var CountQueuingStrategy: {
    prototype: CountQueuingStrategy;
    new(init: QueuingStrategyInit): CountQueuingStrategy;
    isInstance: IsInstance<CountQueuingStrategy>;
};

interface CreateOfferRequest {
    readonly callID: string;
    readonly innerWindowID: number;
    readonly isSecure: boolean;
    readonly windowID: number;
}

declare var CreateOfferRequest: {
    prototype: CreateOfferRequest;
    new(): CreateOfferRequest;
    isInstance: IsInstance<CreateOfferRequest>;
};

/** Available only in secure contexts. */
interface Credential {
    readonly id: string;
    readonly type: string;
}

declare var Credential: {
    prototype: Credential;
    new(): Credential;
    isInstance: IsInstance<Credential>;
};

/** Available only in secure contexts. */
interface CredentialsContainer {
    create(options?: CredentialCreationOptions): Promise<Credential | null>;
    get(options?: CredentialRequestOptions): Promise<Credential | null>;
    preventSilentAccess(): Promise<void>;
    store(credential: Credential): Promise<Credential>;
}

declare var CredentialsContainer: {
    prototype: CredentialsContainer;
    new(): CredentialsContainer;
    isInstance: IsInstance<CredentialsContainer>;
};

interface Crypto {
    /** Available only in secure contexts. */
    readonly subtle: SubtleCrypto;
    getRandomValues(array: ArrayBufferView): ArrayBufferView;
    /** Available only in secure contexts. */
    randomUUID(): string;
}

declare var Crypto: {
    prototype: Crypto;
    new(): Crypto;
    isInstance: IsInstance<Crypto>;
};

/** Available only in secure contexts. */
interface CryptoKey {
    readonly algorithm: any;
    readonly extractable: boolean;
    readonly type: KeyType;
    readonly usages: KeyUsage[];
}

declare var CryptoKey: {
    prototype: CryptoKey;
    new(): CryptoKey;
    isInstance: IsInstance<CryptoKey>;
};

interface CustomElementRegistry {
    define(name: string, constructor: CustomElementConstructor, options?: ElementDefinitionOptions): void;
    get(name: string): CustomElementConstructor | undefined;
    getName(constructor: CustomElementConstructor): string | null;
    setElementCreationCallback(name: string, callback: CustomElementCreationCallback): void;
    upgrade(root: Node): void;
    whenDefined(name: string): Promise<CustomElementConstructor>;
}

declare var CustomElementRegistry: {
    prototype: CustomElementRegistry;
    new(): CustomElementRegistry;
    isInstance: IsInstance<CustomElementRegistry>;
};

interface CustomEvent extends Event {
    readonly detail: any;
    initCustomEvent(type: string, canBubble?: boolean, cancelable?: boolean, detail?: any): void;
}

declare var CustomEvent: {
    prototype: CustomEvent;
    new(type: string, eventInitDict?: CustomEventInit): CustomEvent;
    isInstance: IsInstance<CustomEvent>;
};

interface CustomStateSet {
    forEach(callbackfn: (value: string, key: string, parent: CustomStateSet) => void, thisArg?: any): void;
}

declare var CustomStateSet: {
    prototype: CustomStateSet;
    new(): CustomStateSet;
    isInstance: IsInstance<CustomStateSet>;
};

interface DOMApplication {
}

interface DOMException extends ExceptionMembers {
    readonly code: number;
    readonly message: string;
    readonly name: string;
    readonly INDEX_SIZE_ERR: 1;
    readonly DOMSTRING_SIZE_ERR: 2;
    readonly HIERARCHY_REQUEST_ERR: 3;
    readonly WRONG_DOCUMENT_ERR: 4;
    readonly INVALID_CHARACTER_ERR: 5;
    readonly NO_DATA_ALLOWED_ERR: 6;
    readonly NO_MODIFICATION_ALLOWED_ERR: 7;
    readonly NOT_FOUND_ERR: 8;
    readonly NOT_SUPPORTED_ERR: 9;
    readonly INUSE_ATTRIBUTE_ERR: 10;
    readonly INVALID_STATE_ERR: 11;
    readonly SYNTAX_ERR: 12;
    readonly INVALID_MODIFICATION_ERR: 13;
    readonly NAMESPACE_ERR: 14;
    readonly INVALID_ACCESS_ERR: 15;
    readonly VALIDATION_ERR: 16;
    readonly TYPE_MISMATCH_ERR: 17;
    readonly SECURITY_ERR: 18;
    readonly NETWORK_ERR: 19;
    readonly ABORT_ERR: 20;
    readonly URL_MISMATCH_ERR: 21;
    readonly QUOTA_EXCEEDED_ERR: 22;
    readonly TIMEOUT_ERR: 23;
    readonly INVALID_NODE_TYPE_ERR: 24;
    readonly DATA_CLONE_ERR: 25;
}

declare var DOMException: {
    prototype: DOMException;
    new(message?: string, name?: string): DOMException;
    readonly INDEX_SIZE_ERR: 1;
    readonly DOMSTRING_SIZE_ERR: 2;
    readonly HIERARCHY_REQUEST_ERR: 3;
    readonly WRONG_DOCUMENT_ERR: 4;
    readonly INVALID_CHARACTER_ERR: 5;
    readonly NO_DATA_ALLOWED_ERR: 6;
    readonly NO_MODIFICATION_ALLOWED_ERR: 7;
    readonly NOT_FOUND_ERR: 8;
    readonly NOT_SUPPORTED_ERR: 9;
    readonly INUSE_ATTRIBUTE_ERR: 10;
    readonly INVALID_STATE_ERR: 11;
    readonly SYNTAX_ERR: 12;
    readonly INVALID_MODIFICATION_ERR: 13;
    readonly NAMESPACE_ERR: 14;
    readonly INVALID_ACCESS_ERR: 15;
    readonly VALIDATION_ERR: 16;
    readonly TYPE_MISMATCH_ERR: 17;
    readonly SECURITY_ERR: 18;
    readonly NETWORK_ERR: 19;
    readonly ABORT_ERR: 20;
    readonly URL_MISMATCH_ERR: 21;
    readonly QUOTA_EXCEEDED_ERR: 22;
    readonly TIMEOUT_ERR: 23;
    readonly INVALID_NODE_TYPE_ERR: 24;
    readonly DATA_CLONE_ERR: 25;
    isInstance: IsInstance<DOMException>;
};

interface DOMImplementation {
    createDocument(namespace: string | null, qualifiedName: string | null, doctype?: DocumentType | null): Document;
    createDocumentType(qualifiedName: string, publicId: string, systemId: string): DocumentType;
    createHTMLDocument(title?: string): Document;
    hasFeature(): boolean;
}

declare var DOMImplementation: {
    prototype: DOMImplementation;
    new(): DOMImplementation;
    isInstance: IsInstance<DOMImplementation>;
};

interface DOMLocalization extends Localization {
    connectRoot(aElement: Node): void;
    disconnectRoot(aElement: Node): void;
    getAttributes(aElement: Element): L10nIdArgs;
    pauseObserving(): void;
    resumeObserving(): void;
    setArgs(aElement: Element, aArgs?: any): void;
    setAttributes(aElement: Element, aId: string, aArgs?: any): void;
    translateElements(aElements: Element[]): Promise<void>;
    translateFragment(aNode: Node): Promise<any>;
    translateRoots(): Promise<void>;
}

declare var DOMLocalization: {
    prototype: DOMLocalization;
    new(aResourceIds: L10nResourceId[], aSync?: boolean, aRegistry?: L10nRegistry, aLocales?: string[]): DOMLocalization;
    isInstance: IsInstance<DOMLocalization>;
};

interface DOMMatrix extends DOMMatrixReadOnly {
    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;
    m11: number;
    m12: number;
    m13: number;
    m14: number;
    m21: number;
    m22: number;
    m23: number;
    m24: number;
    m31: number;
    m32: number;
    m33: number;
    m34: number;
    m41: number;
    m42: number;
    m43: number;
    m44: number;
    invertSelf(): DOMMatrix;
    multiplySelf(other?: DOMMatrixInit): DOMMatrix;
    preMultiplySelf(other?: DOMMatrixInit): DOMMatrix;
    rotateAxisAngleSelf(x?: number, y?: number, z?: number, angle?: number): DOMMatrix;
    rotateFromVectorSelf(x?: number, y?: number): DOMMatrix;
    rotateSelf(rotX?: number, rotY?: number, rotZ?: number): DOMMatrix;
    scale3dSelf(scale?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    scaleSelf(scaleX?: number, scaleY?: number, scaleZ?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    setMatrixValue(transformList: string): DOMMatrix;
    skewXSelf(sx?: number): DOMMatrix;
    skewYSelf(sy?: number): DOMMatrix;
    translateSelf(tx?: number, ty?: number, tz?: number): DOMMatrix;
}

declare var DOMMatrix: {
    prototype: DOMMatrix;
    new(init?: string | number[] | DOMMatrixReadOnly): DOMMatrix;
    isInstance: IsInstance<DOMMatrix>;
    fromFloat32Array(array32: Float32Array): DOMMatrix;
    fromFloat64Array(array64: Float64Array): DOMMatrix;
    fromMatrix(other?: DOMMatrixInit): DOMMatrix;
};

type WebKitCSSMatrix = DOMMatrix;
declare var WebKitCSSMatrix: typeof DOMMatrix;

interface DOMMatrixReadOnly {
    readonly a: number;
    readonly b: number;
    readonly c: number;
    readonly d: number;
    readonly e: number;
    readonly f: number;
    readonly is2D: boolean;
    readonly isIdentity: boolean;
    readonly m11: number;
    readonly m12: number;
    readonly m13: number;
    readonly m14: number;
    readonly m21: number;
    readonly m22: number;
    readonly m23: number;
    readonly m24: number;
    readonly m31: number;
    readonly m32: number;
    readonly m33: number;
    readonly m34: number;
    readonly m41: number;
    readonly m42: number;
    readonly m43: number;
    readonly m44: number;
    flipX(): DOMMatrix;
    flipY(): DOMMatrix;
    inverse(): DOMMatrix;
    multiply(other?: DOMMatrixInit): DOMMatrix;
    rotate(rotX?: number, rotY?: number, rotZ?: number): DOMMatrix;
    rotateAxisAngle(x?: number, y?: number, z?: number, angle?: number): DOMMatrix;
    rotateFromVector(x?: number, y?: number): DOMMatrix;
    scale(scaleX?: number, scaleY?: number, scaleZ?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    scale3d(scale?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    scaleNonUniform(scaleX?: number, scaleY?: number): DOMMatrix;
    skewX(sx?: number): DOMMatrix;
    skewY(sy?: number): DOMMatrix;
    toFloat32Array(): Float32Array;
    toFloat64Array(): Float64Array;
    toJSON(): any;
    transformPoint(point?: DOMPointInit): DOMPoint;
    translate(tx?: number, ty?: number, tz?: number): DOMMatrix;
    toString(): string;
}

declare var DOMMatrixReadOnly: {
    prototype: DOMMatrixReadOnly;
    new(init?: string | number[] | DOMMatrixReadOnly): DOMMatrixReadOnly;
    isInstance: IsInstance<DOMMatrixReadOnly>;
    fromFloat32Array(array32: Float32Array): DOMMatrixReadOnly;
    fromFloat64Array(array64: Float64Array): DOMMatrixReadOnly;
    fromMatrix(other?: DOMMatrixInit): DOMMatrixReadOnly;
};

interface DOMParser {
    forceEnableDTD(): void;
    forceEnableXULXBL(): void;
    parseFromBuffer(buf: number[], type: SupportedType): Document;
    parseFromBuffer(buf: Uint8Array, type: SupportedType): Document;
    parseFromSafeString(str: string, type: SupportedType): Document;
    parseFromStream(stream: InputStream, charset: string | null, contentLength: number, type: SupportedType): Document;
    parseFromString(str: TrustedHTML | string, type: SupportedType): Document;
}

declare var DOMParser: {
    prototype: DOMParser;
    new(): DOMParser;
    isInstance: IsInstance<DOMParser>;
};

interface DOMPoint extends DOMPointReadOnly {
    w: number;
    x: number;
    y: number;
    z: number;
}

declare var DOMPoint: {
    prototype: DOMPoint;
    new(x?: number, y?: number, z?: number, w?: number): DOMPoint;
    isInstance: IsInstance<DOMPoint>;
    fromPoint(other?: DOMPointInit): DOMPoint;
};

interface DOMPointReadOnly {
    readonly w: number;
    readonly x: number;
    readonly y: number;
    readonly z: number;
    matrixTransform(matrix?: DOMMatrixInit): DOMPoint;
    toJSON(): any;
}

declare var DOMPointReadOnly: {
    prototype: DOMPointReadOnly;
    new(x?: number, y?: number, z?: number, w?: number): DOMPointReadOnly;
    isInstance: IsInstance<DOMPointReadOnly>;
    fromPoint(other?: DOMPointInit): DOMPointReadOnly;
};

interface DOMQuad {
    readonly p1: DOMPoint;
    readonly p2: DOMPoint;
    readonly p3: DOMPoint;
    readonly p4: DOMPoint;
    getBounds(): DOMRectReadOnly;
    toJSON(): any;
}

declare var DOMQuad: {
    prototype: DOMQuad;
    new(p1?: DOMPointInit, p2?: DOMPointInit, p3?: DOMPointInit, p4?: DOMPointInit): DOMQuad;
    new(rect: DOMRectReadOnly): DOMQuad;
    isInstance: IsInstance<DOMQuad>;
    fromQuad(other?: DOMQuadInit): DOMQuad;
    fromRect(other?: DOMRectInit): DOMQuad;
};

interface DOMRect extends DOMRectReadOnly {
    height: number;
    width: number;
    x: number;
    y: number;
}

declare var DOMRect: {
    prototype: DOMRect;
    new(x?: number, y?: number, width?: number, height?: number): DOMRect;
    isInstance: IsInstance<DOMRect>;
    fromRect(other?: DOMRectInit): DOMRect;
};

interface DOMRectList {
    readonly length: number;
    item(index: number): DOMRect | null;
    [index: number]: DOMRect;
}

declare var DOMRectList: {
    prototype: DOMRectList;
    new(): DOMRectList;
    isInstance: IsInstance<DOMRectList>;
};

interface DOMRectReadOnly {
    readonly bottom: number;
    readonly height: number;
    readonly left: number;
    readonly right: number;
    readonly top: number;
    readonly width: number;
    readonly x: number;
    readonly y: number;
    toJSON(): any;
}

declare var DOMRectReadOnly: {
    prototype: DOMRectReadOnly;
    new(x?: number, y?: number, width?: number, height?: number): DOMRectReadOnly;
    isInstance: IsInstance<DOMRectReadOnly>;
    fromRect(other?: DOMRectInit): DOMRectReadOnly;
};

interface DOMStringList {
    readonly length: number;
    contains(string: string): boolean;
    item(index: number): string | null;
    [index: number]: string;
}

declare var DOMStringList: {
    prototype: DOMStringList;
    new(): DOMStringList;
    isInstance: IsInstance<DOMStringList>;
};

interface DOMStringMap {
}

declare var DOMStringMap: {
    prototype: DOMStringMap;
    new(): DOMStringMap;
    isInstance: IsInstance<DOMStringMap>;
};

interface DOMTokenList {
    readonly length: number;
    value: string;
    toString(): string;
    add(...tokens: string[]): void;
    contains(token: string): boolean;
    item(index: number): string | null;
    remove(...tokens: string[]): void;
    replace(token: string, newToken: string): boolean;
    supports(token: string): boolean;
    toggle(token: string, force?: boolean): boolean;
    forEach(callbackfn: (value: string | null, key: number, parent: DOMTokenList) => void, thisArg?: any): void;
    [index: number]: string;
}

declare var DOMTokenList: {
    prototype: DOMTokenList;
    new(): DOMTokenList;
    isInstance: IsInstance<DOMTokenList>;
};

interface DataTransfer {
    dropEffect: string;
    effectAllowed: string;
    readonly files: FileList | null;
    readonly items: DataTransferItemList;
    readonly mozCSP: ContentSecurityPolicy | null;
    mozCursor: string;
    readonly mozItemCount: number;
    mozShowFailAnimation: boolean;
    readonly mozSourceNode: Node | null;
    readonly mozTriggeringPrincipalURISpec: string;
    readonly mozUserCancelled: boolean;
    readonly sourceTopWindowContext: WindowContext | null;
    readonly types: string[];
    addElement(element: Element): void;
    clearData(format?: string): void;
    getData(format: string): string;
    mozClearDataAt(format: string, index: number): void;
    mozCloneForEvent(event: string): DataTransfer;
    mozGetDataAt(format: string, index: number): any;
    mozSetDataAt(format: string, data: any, index: number): void;
    mozTypesAt(index: number): DOMStringList;
    setData(format: string, data: string): void;
    setDragImage(image: Element, x: number, y: number): void;
    updateDragImage(image: Element, x: number, y: number): void;
}

declare var DataTransfer: {
    prototype: DataTransfer;
    new(): DataTransfer;
    isInstance: IsInstance<DataTransfer>;
};

interface DataTransferItem {
    readonly kind: string;
    readonly type: string;
    getAsFile(): File | null;
    getAsString(callback: FunctionStringCallback | null): void;
    webkitGetAsEntry(): FileSystemEntry | null;
}

declare var DataTransferItem: {
    prototype: DataTransferItem;
    new(): DataTransferItem;
    isInstance: IsInstance<DataTransferItem>;
};

interface DataTransferItemList {
    readonly length: number;
    add(data: string, type: string): DataTransferItem | null;
    add(data: File): DataTransferItem | null;
    clear(): void;
    remove(index: number): void;
    [index: number]: DataTransferItem;
}

declare var DataTransferItemList: {
    prototype: DataTransferItemList;
    new(): DataTransferItemList;
    isInstance: IsInstance<DataTransferItemList>;
};

interface DebuggerNotification {
    readonly global: any;
    readonly type: DebuggerNotificationType;
}

declare var DebuggerNotification: {
    prototype: DebuggerNotification;
    new(): DebuggerNotification;
    isInstance: IsInstance<DebuggerNotification>;
};

interface DebuggerNotificationObserver {
    addListener(handler: DebuggerNotificationCallback): boolean;
    connect(global: any): boolean;
    disconnect(global: any): boolean;
    removeListener(handler: DebuggerNotificationCallback): boolean;
}

declare var DebuggerNotificationObserver: {
    prototype: DebuggerNotificationObserver;
    new(): DebuggerNotificationObserver;
    isInstance: IsInstance<DebuggerNotificationObserver>;
};

interface DecompressionStream extends GenericTransformStream {
}

declare var DecompressionStream: {
    prototype: DecompressionStream;
    new(format: CompressionFormat): DecompressionStream;
    isInstance: IsInstance<DecompressionStream>;
};

interface DelayNode extends AudioNode, AudioNodePassThrough {
    readonly delayTime: AudioParam;
}

declare var DelayNode: {
    prototype: DelayNode;
    new(context: BaseAudioContext, options?: DelayOptions): DelayNode;
    isInstance: IsInstance<DelayNode>;
};

interface DeprecationReportBody extends ReportBody {
    readonly anticipatedRemoval: any;
    readonly columnNumber: number | null;
    readonly id: string;
    readonly lineNumber: number | null;
    readonly message: string;
    readonly sourceFile: string | null;
    toJSON(): any;
}

declare var DeprecationReportBody: {
    prototype: DeprecationReportBody;
    new(): DeprecationReportBody;
    isInstance: IsInstance<DeprecationReportBody>;
};

interface DeviceAcceleration {
    readonly x: number | null;
    readonly y: number | null;
    readonly z: number | null;
}

interface DeviceLightEvent extends Event {
    readonly value: number;
}

declare var DeviceLightEvent: {
    prototype: DeviceLightEvent;
    new(type: string, eventInitDict?: DeviceLightEventInit): DeviceLightEvent;
    isInstance: IsInstance<DeviceLightEvent>;
};

interface DeviceMotionEvent extends Event {
    readonly acceleration: DeviceAcceleration | null;
    readonly accelerationIncludingGravity: DeviceAcceleration | null;
    readonly interval: number | null;
    readonly rotationRate: DeviceRotationRate | null;
    initDeviceMotionEvent(type: string, canBubble?: boolean, cancelable?: boolean, acceleration?: DeviceAccelerationInit, accelerationIncludingGravity?: DeviceAccelerationInit, rotationRate?: DeviceRotationRateInit, interval?: number | null): void;
}

declare var DeviceMotionEvent: {
    prototype: DeviceMotionEvent;
    new(type: string, eventInitDict?: DeviceMotionEventInit): DeviceMotionEvent;
    isInstance: IsInstance<DeviceMotionEvent>;
};

interface DeviceOrientationEvent extends Event {
    readonly absolute: boolean;
    readonly alpha: number | null;
    readonly beta: number | null;
    readonly gamma: number | null;
    initDeviceOrientationEvent(type: string, canBubble?: boolean, cancelable?: boolean, alpha?: number | null, beta?: number | null, gamma?: number | null, absolute?: boolean): void;
}

declare var DeviceOrientationEvent: {
    prototype: DeviceOrientationEvent;
    new(type: string, eventInitDict?: DeviceOrientationEventInit): DeviceOrientationEvent;
    isInstance: IsInstance<DeviceOrientationEvent>;
};

interface DeviceRotationRate {
    readonly alpha: number | null;
    readonly beta: number | null;
    readonly gamma: number | null;
}

interface Directory {
    readonly name: string;
    readonly path: string;
    getFiles(recursiveFlag?: boolean): Promise<File[]>;
    getFilesAndDirectories(): Promise<(File | Directory)[]>;
}

declare var Directory: {
    prototype: Directory;
    new(path: string): Directory;
    isInstance: IsInstance<Directory>;
};

interface DocumentEventMap extends GlobalEventHandlersEventMap, OnErrorEventHandlerForNodesEventMap, TouchEventHandlersEventMap {
    "afterscriptexecute": Event;
    "beforescriptexecute": Event;
    "fullscreenchange": Event;
    "fullscreenerror": Event;
    "pointerlockchange": Event;
    "pointerlockerror": Event;
    "readystatechange": Event;
    "visibilitychange": Event;
}

interface Document extends Node, DocumentOrShadowRoot, FontFaceSource, GeometryUtils, GlobalEventHandlers, NonElementParentNode, OnErrorEventHandlerForNodes, ParentNode, TouchEventHandlers, XPathEvaluatorMixin {
    readonly URL: string;
    alinkColor: string;
    readonly all: HTMLAllCollection;
    readonly anchors: HTMLCollection;
    readonly applets: HTMLCollection;
    bgColor: string;
    readonly blockedNodeByClassifierCount: number;
    readonly blockedNodesByClassifier: NodeList;
    body: HTMLElement | null;
    readonly characterSet: string;
    readonly charset: string;
    readonly commandDispatcher: XULCommandDispatcher | null;
    readonly compatMode: string;
    readonly contentLanguage: string;
    readonly contentType: string;
    cookie: string;
    readonly cookieJarSettings: nsICookieJarSettings;
    readonly csp: ContentSecurityPolicy | null;
    readonly cspJSON: string;
    readonly currentScript: Element | null;
    readonly defaultView: WindowProxy | null;
    designMode: string;
    devToolsAnonymousAndShadowEventsEnabled: boolean;
    devToolsWatchingDOMMutations: boolean;
    dir: string;
    readonly doctype: DocumentType | null;
    readonly documentElement: Element | null;
    readonly documentLoadGroup: nsILoadGroup | null;
    readonly documentReadyForIdle: Promise<void>;
    readonly documentURI: string;
    readonly documentURIObject: URI | null;
    domain: string;
    readonly effectiveStoragePrincipal: Principal;
    readonly embeds: HTMLCollection;
    readonly featurePolicy: FeaturePolicy;
    fgColor: string;
    readonly forms: HTMLCollection;
    readonly fragmentDirective: FragmentDirective;
    readonly fullscreen: boolean;
    readonly fullscreenEnabled: boolean;
    readonly hasBeenUserGestureActivated: boolean;
    readonly hasPendingL10nMutations: boolean;
    readonly hasValidTransientUserGestureActivation: boolean;
    readonly head: HTMLHeadElement | null;
    readonly hidden: boolean;
    readonly images: HTMLCollection;
    readonly implementation: DOMImplementation;
    readonly inAndroidPipMode: boolean;
    readonly inputEncoding: string;
    readonly isInitialDocument: boolean;
    readonly isSrcdocDocument: boolean;
    readonly l10n: DocumentL10n | null;
    readonly lastModified: string;
    readonly lastStyleSheetSet: string | null;
    readonly lastUserGestureTimeStamp: DOMHighResTimeStamp;
    linkColor: string;
    readonly links: HTMLCollection;
    readonly loadedFromPrototype: boolean;
    readonly location: Location | null;
    readonly mozDocumentURIIfNotForErrorPages: URI | null;
    readonly mozFullScreen: boolean;
    readonly mozFullScreenEnabled: boolean;
    readonly mozSyntheticDocument: boolean;
    onafterscriptexecute: ((this: Document, ev: Event) => any) | null;
    onbeforescriptexecute: ((this: Document, ev: Event) => any) | null;
    onfullscreenchange: ((this: Document, ev: Event) => any) | null;
    onfullscreenerror: ((this: Document, ev: Event) => any) | null;
    onpointerlockchange: ((this: Document, ev: Event) => any) | null;
    onpointerlockerror: ((this: Document, ev: Event) => any) | null;
    onreadystatechange: ((this: Document, ev: Event) => any) | null;
    onvisibilitychange: ((this: Document, ev: Event) => any) | null;
    readonly partitionedPrincipal: Principal;
    readonly permDelegateHandler: nsIPermissionDelegateHandler;
    readonly plugins: HTMLCollection;
    readonly preferredStyleSheetSet: string | null;
    readonly readyState: string;
    readonly referrer: string;
    readonly referrerInfo: nsIReferrerInfo;
    readonly referrerPolicy: ReferrerPolicy;
    readonly rootElement: SVGSVGElement | null;
    readonly sandboxFlagsAsString: string | null;
    readonly scripts: HTMLCollection;
    readonly scrollingElement: Element | null;
    selectedStyleSheetSet: string | null;
    styleSheetChangeEventsEnabled: boolean;
    readonly styleSheetSets: DOMStringList;
    readonly timeline: DocumentTimeline;
    title: string;
    readonly userHasInteracted: boolean;
    readonly visibilityState: VisibilityState;
    vlinkColor: string;
    addCertException(isTemporary: boolean): Promise<any>;
    adoptNode(node: Node): Node;
    blockParsing(promise: any, options?: BlockParsingOptions): Promise<any>;
    blockUnblockOnload(block: boolean): void;
    captureEvents(): void;
    caretPositionFromPoint(x: number, y: number, options?: CaretPositionFromPointOptions): CaretPosition | null;
    clear(): void;
    clearUserGestureActivation(): void;
    close(): void;
    completeStorageAccessRequestFromSite(serializedSite: string): Promise<void>;
    consumeTransientUserGestureActivation(): boolean;
    createAttribute(name: string): Attr;
    createAttributeNS(namespace: string | null, name: string): Attr;
    createCDATASection(data: string): CDATASection;
    createComment(data: string): Comment;
    createDocumentFragment(): DocumentFragment;
    createElement<K extends keyof HTMLElementTagNameMap>(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K];
    /** @deprecated */
    createElement<K extends keyof HTMLElementDeprecatedTagNameMap>(tagName: K, options?: ElementCreationOptions): HTMLElementDeprecatedTagNameMap[K];
    createElement(tagName: string, options?: ElementCreationOptions): HTMLElement;
    createElementNS(namespace: string | null, qualifiedName: string, options?: string | ElementCreationOptions): Element;
    createEvent(eventInterface: "AddonEvent"): AddonEvent;
    createEvent(eventInterface: "AnimationEvent"): AnimationEvent;
    createEvent(eventInterface: "AnimationPlaybackEvent"): AnimationPlaybackEvent;
    createEvent(eventInterface: "AudioProcessingEvent"): AudioProcessingEvent;
    createEvent(eventInterface: "BeforeUnloadEvent"): BeforeUnloadEvent;
    createEvent(eventInterface: "BlobEvent"): BlobEvent;
    createEvent(eventInterface: "CSSCustomPropertyRegisteredEvent"): CSSCustomPropertyRegisteredEvent;
    createEvent(eventInterface: "CaretStateChangedEvent"): CaretStateChangedEvent;
    createEvent(eventInterface: "ClipboardEvent"): ClipboardEvent;
    createEvent(eventInterface: "CloseEvent"): CloseEvent;
    createEvent(eventInterface: "CommandEvent"): CommandEvent;
    createEvent(eventInterface: "CompositionEvent"): CompositionEvent;
    createEvent(eventInterface: "ContentVisibilityAutoStateChangeEvent"): ContentVisibilityAutoStateChangeEvent;
    createEvent(eventInterface: "CookieChangeEvent"): CookieChangeEvent;
    createEvent(eventInterface: "CustomEvent"): CustomEvent;
    createEvent(eventInterface: "DeviceLightEvent"): DeviceLightEvent;
    createEvent(eventInterface: "DeviceMotionEvent"): DeviceMotionEvent;
    createEvent(eventInterface: "DeviceOrientationEvent"): DeviceOrientationEvent;
    createEvent(eventInterface: "DragEvent"): DragEvent;
    createEvent(eventInterface: "ErrorEvent"): ErrorEvent;
    createEvent(eventInterface: "FocusEvent"): FocusEvent;
    createEvent(eventInterface: "FontFaceSetLoadEvent"): FontFaceSetLoadEvent;
    createEvent(eventInterface: "FormDataEvent"): FormDataEvent;
    createEvent(eventInterface: "FrameCrashedEvent"): FrameCrashedEvent;
    createEvent(eventInterface: "GPUUncapturedErrorEvent"): GPUUncapturedErrorEvent;
    createEvent(eventInterface: "GamepadAxisMoveEvent"): GamepadAxisMoveEvent;
    createEvent(eventInterface: "GamepadButtonEvent"): GamepadButtonEvent;
    createEvent(eventInterface: "GamepadEvent"): GamepadEvent;
    createEvent(eventInterface: "HashChangeEvent"): HashChangeEvent;
    createEvent(eventInterface: "IDBVersionChangeEvent"): IDBVersionChangeEvent;
    createEvent(eventInterface: "ImageCaptureErrorEvent"): ImageCaptureErrorEvent;
    createEvent(eventInterface: "InputEvent"): InputEvent;
    createEvent(eventInterface: "InvokeEvent"): InvokeEvent;
    createEvent(eventInterface: "KeyboardEvent"): KeyboardEvent;
    createEvent(eventInterface: "MIDIConnectionEvent"): MIDIConnectionEvent;
    createEvent(eventInterface: "MIDIMessageEvent"): MIDIMessageEvent;
    createEvent(eventInterface: "MediaEncryptedEvent"): MediaEncryptedEvent;
    createEvent(eventInterface: "MediaKeyMessageEvent"): MediaKeyMessageEvent;
    createEvent(eventInterface: "MediaQueryListEvent"): MediaQueryListEvent;
    createEvent(eventInterface: "MediaRecorderErrorEvent"): MediaRecorderErrorEvent;
    createEvent(eventInterface: "MediaStreamEvent"): MediaStreamEvent;
    createEvent(eventInterface: "MediaStreamTrackEvent"): MediaStreamTrackEvent;
    createEvent(eventInterface: "MerchantValidationEvent"): MerchantValidationEvent;
    createEvent(eventInterface: "MessageEvent"): MessageEvent;
    createEvent(eventInterface: "MouseEvent"): MouseEvent;
    createEvent(eventInterface: "MouseEvents"): MouseEvent;
    createEvent(eventInterface: "MouseScrollEvent"): MouseScrollEvent;
    createEvent(eventInterface: "MozSharedMapChangeEvent"): MozSharedMapChangeEvent;
    createEvent(eventInterface: "MutationEvent"): MutationEvent;
    createEvent(eventInterface: "MutationEvents"): MutationEvent;
    createEvent(eventInterface: "NavigateEvent"): NavigateEvent;
    createEvent(eventInterface: "NavigationCurrentEntryChangeEvent"): NavigationCurrentEntryChangeEvent;
    createEvent(eventInterface: "NotifyPaintEvent"): NotifyPaintEvent;
    createEvent(eventInterface: "OfflineAudioCompletionEvent"): OfflineAudioCompletionEvent;
    createEvent(eventInterface: "PageTransitionEvent"): PageTransitionEvent;
    createEvent(eventInterface: "PaymentMethodChangeEvent"): PaymentMethodChangeEvent;
    createEvent(eventInterface: "PaymentRequestUpdateEvent"): PaymentRequestUpdateEvent;
    createEvent(eventInterface: "PerformanceEntryEvent"): PerformanceEntryEvent;
    createEvent(eventInterface: "PluginCrashedEvent"): PluginCrashedEvent;
    createEvent(eventInterface: "PointerEvent"): PointerEvent;
    createEvent(eventInterface: "PopStateEvent"): PopStateEvent;
    createEvent(eventInterface: "PopupBlockedEvent"): PopupBlockedEvent;
    createEvent(eventInterface: "PopupPositionedEvent"): PopupPositionedEvent;
    createEvent(eventInterface: "PositionStateEvent"): PositionStateEvent;
    createEvent(eventInterface: "ProgressEvent"): ProgressEvent;
    createEvent(eventInterface: "PromiseRejectionEvent"): PromiseRejectionEvent;
    createEvent(eventInterface: "RTCDTMFToneChangeEvent"): RTCDTMFToneChangeEvent;
    createEvent(eventInterface: "RTCDataChannelEvent"): RTCDataChannelEvent;
    createEvent(eventInterface: "RTCPeerConnectionIceEvent"): RTCPeerConnectionIceEvent;
    createEvent(eventInterface: "RTCTrackEvent"): RTCTrackEvent;
    createEvent(eventInterface: "ScrollAreaEvent"): ScrollAreaEvent;
    createEvent(eventInterface: "SecurityPolicyViolationEvent"): SecurityPolicyViolationEvent;
    createEvent(eventInterface: "SimpleGestureEvent"): SimpleGestureEvent;
    createEvent(eventInterface: "SpeechRecognitionEvent"): SpeechRecognitionEvent;
    createEvent(eventInterface: "SpeechSynthesisErrorEvent"): SpeechSynthesisErrorEvent;
    createEvent(eventInterface: "SpeechSynthesisEvent"): SpeechSynthesisEvent;
    createEvent(eventInterface: "StorageEvent"): StorageEvent;
    createEvent(eventInterface: "StreamFilterDataEvent"): StreamFilterDataEvent;
    createEvent(eventInterface: "StyleSheetApplicableStateChangeEvent"): StyleSheetApplicableStateChangeEvent;
    createEvent(eventInterface: "StyleSheetRemovedEvent"): StyleSheetRemovedEvent;
    createEvent(eventInterface: "SubmitEvent"): SubmitEvent;
    createEvent(eventInterface: "TCPServerSocketEvent"): TCPServerSocketEvent;
    createEvent(eventInterface: "TCPSocketErrorEvent"): TCPSocketErrorEvent;
    createEvent(eventInterface: "TCPSocketEvent"): TCPSocketEvent;
    createEvent(eventInterface: "TaskPriorityChangeEvent"): TaskPriorityChangeEvent;
    createEvent(eventInterface: "TextEvent"): TextEvent;
    createEvent(eventInterface: "TimeEvent"): TimeEvent;
    createEvent(eventInterface: "ToggleEvent"): ToggleEvent;
    createEvent(eventInterface: "TouchEvent"): TouchEvent;
    createEvent(eventInterface: "TrackEvent"): TrackEvent;
    createEvent(eventInterface: "TransitionEvent"): TransitionEvent;
    createEvent(eventInterface: "UDPMessageEvent"): UDPMessageEvent;
    createEvent(eventInterface: "UIEvent"): UIEvent;
    createEvent(eventInterface: "UIEvents"): UIEvent;
    createEvent(eventInterface: "UserProximityEvent"): UserProximityEvent;
    createEvent(eventInterface: "VRDisplayEvent"): VRDisplayEvent;
    createEvent(eventInterface: "WebGLContextEvent"): WebGLContextEvent;
    createEvent(eventInterface: "WheelEvent"): WheelEvent;
    createEvent(eventInterface: "XRInputSourceEvent"): XRInputSourceEvent;
    createEvent(eventInterface: "XRInputSourcesChangeEvent"): XRInputSourcesChangeEvent;
    createEvent(eventInterface: "XRReferenceSpaceEvent"): XRReferenceSpaceEvent;
    createEvent(eventInterface: "XRSessionEvent"): XRSessionEvent;
    createEvent(eventInterface: "XULCommandEvent"): XULCommandEvent;
    createEvent(eventInterface: string): Event;
    createNodeIterator(root: Node, whatToShow?: number, filter?: NodeFilter | null): NodeIterator;
    createProcessingInstruction(target: string, data: string): ProcessingInstruction;
    createRange(): Range;
    createTextNode(data: string): Text;
    createTouch(view?: Window | null, target?: EventTarget | null, identifier?: number, pageX?: number, pageY?: number, screenX?: number, screenY?: number, clientX?: number, clientY?: number, radiusX?: number, radiusY?: number, rotationAngle?: number, force?: number): Touch;
    createTouchList(touch: Touch, ...touches: Touch[]): TouchList;
    createTouchList(): TouchList;
    createTouchList(touches: Touch[]): TouchList;
    createTreeWalker(root: Node, whatToShow?: number, filter?: NodeFilter | null): TreeWalker;
    createXULElement(localName: string, options?: string | ElementCreationOptions): Element;
    enableStyleSheetsForSet(name: string | null): void;
    execCommand(commandId: string, showUI?: boolean, value?: TrustedHTML | string): boolean;
    exitFullscreen(): Promise<void>;
    exitPointerLock(): void;
    getConnectedShadowRoots(): ShadowRoot[];
    getElementsByClassName(classNames: string): HTMLCollection;
    getElementsByName(elementName: string): NodeList;
    getElementsByTagName<K extends keyof HTMLElementTagNameMap>(localName: K): HTMLCollectionOf<HTMLElementTagNameMap[K]>;
    getElementsByTagName<K extends keyof SVGElementTagNameMap>(localName: K): HTMLCollectionOf<SVGElementTagNameMap[K]>;
    getElementsByTagName<K extends keyof MathMLElementTagNameMap>(localName: K): HTMLCollectionOf<MathMLElementTagNameMap[K]>;
    /** @deprecated */
    getElementsByTagName<K extends keyof HTMLElementDeprecatedTagNameMap>(localName: K): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K]>;
    getElementsByTagName(localName: string): HTMLCollectionOf<Element>;
    getElementsByTagNameNS(namespace: string | null, localName: string): HTMLCollection;
    getFailedCertSecurityInfo(): FailedCertSecurityInfo;
    getNetErrorInfo(): NetErrorInfo;
    getSelection(): Selection | null;
    getWireframe(aIncludeNodes?: boolean): Wireframe | null;
    hasFocus(): boolean;
    hasStorageAccess(): Promise<boolean>;
    importNode(node: Node, deep?: boolean): Node;
    insertAnonymousContent(): AnonymousContent;
    isActive(): boolean;
    mozCancelFullScreen(): Promise<void>;
    mozSetImageElement(aImageElementId: string, aImageElement: Element | null): void;
    notifyUserGestureActivation(): void;
    open(unused1?: string, unused2?: string): Document;
    open(url: string, name: string, features: string): WindowProxy | null;
    queryCommandEnabled(commandId: string): boolean;
    queryCommandIndeterm(commandId: string): boolean;
    queryCommandState(commandId: string): boolean;
    queryCommandSupported(commandId: string): boolean;
    queryCommandValue(commandId: string): string;
    releaseCapture(): void;
    releaseEvents(): void;
    reloadWithHttpsOnlyException(): void;
    removeAnonymousContent(aContent: AnonymousContent): void;
    requestStorageAccess(): Promise<void>;
    requestStorageAccessForOrigin(thirdPartyOrigin: string, requireUserInteraction?: boolean): Promise<void>;
    requestStorageAccessUnderSite(serializedSite: string): Promise<void>;
    setKeyPressEventModel(aKeyPressEventModel: number): void;
    setNotifyFetchSuccess(aShouldNotify: boolean): void;
    setNotifyFormOrPasswordRemoved(aShouldNotify: boolean): void;
    setSuppressedEventListener(aListener: EventListener | null): void;
    startViewTransition(updateCallback?: ViewTransitionUpdateCallback): ViewTransition;
    synchronouslyUpdateRemoteBrowserDimensions(aIncludeInactive?: boolean): void;
    userInteractionForTesting(): void;
    write(...text: (TrustedHTML | string)[]): void;
    writeln(...text: (TrustedHTML | string)[]): void;
    readonly KEYPRESS_EVENT_MODEL_DEFAULT: 0;
    readonly KEYPRESS_EVENT_MODEL_SPLIT: 1;
    readonly KEYPRESS_EVENT_MODEL_CONFLATED: 2;
    addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var Document: {
    prototype: Document;
    new(): Document;
    readonly KEYPRESS_EVENT_MODEL_DEFAULT: 0;
    readonly KEYPRESS_EVENT_MODEL_SPLIT: 1;
    readonly KEYPRESS_EVENT_MODEL_CONFLATED: 2;
    isInstance: IsInstance<Document>;
    parseHTML(html: string, options?: SetHTMLOptions): Document;
    parseHTMLUnsafe(html: TrustedHTML | string, options?: SetHTMLUnsafeOptions): Document;
};

interface DocumentFragment extends Node, NonElementParentNode, ParentNode {
}

declare var DocumentFragment: {
    prototype: DocumentFragment;
    new(): DocumentFragment;
    isInstance: IsInstance<DocumentFragment>;
};

interface DocumentL10n extends DOMLocalization {
    readonly ready: Promise<any>;
    connectRoot(aElement: Node, aTranslate?: boolean): void;
}

interface DocumentOrShadowRoot {
    readonly activeElement: Element | null;
    adoptedStyleSheets: CSSStyleSheet[];
    readonly fullscreenElement: Element | null;
    readonly mozFullScreenElement: Element | null;
    readonly pointerLockElement: Element | null;
    readonly styleSheets: StyleSheetList;
    elementFromPoint(x: number, y: number): Element | null;
    elementsFromPoint(x: number, y: number): Element[];
    getAnimations(): Animation[];
    nodeFromPoint(x: number, y: number): Node | null;
    nodesFromPoint(x: number, y: number): Node[];
}

interface DocumentTimeline extends AnimationTimeline {
}

declare var DocumentTimeline: {
    prototype: DocumentTimeline;
    new(options?: DocumentTimelineOptions): DocumentTimeline;
    isInstance: IsInstance<DocumentTimeline>;
};

interface DocumentType extends Node, ChildNode {
    readonly name: string;
    readonly publicId: string;
    readonly systemId: string;
}

declare var DocumentType: {
    prototype: DocumentType;
    new(): DocumentType;
    isInstance: IsInstance<DocumentType>;
};

interface DominatorTree {
    readonly root: NodeId;
    getImmediateDominator(node: NodeId): NodeId | null;
    getImmediatelyDominated(node: NodeId): NodeId[] | null;
    getRetainedSize(node: NodeId): NodeSize | null;
}

declare var DominatorTree: {
    prototype: DominatorTree;
    new(): DominatorTree;
    isInstance: IsInstance<DominatorTree>;
};

interface DragEvent extends MouseEvent {
    readonly dataTransfer: DataTransfer | null;
    initDragEvent(type: string, canBubble?: boolean, cancelable?: boolean, aView?: Window | null, aDetail?: number, aScreenX?: number, aScreenY?: number, aClientX?: number, aClientY?: number, aCtrlKey?: boolean, aAltKey?: boolean, aShiftKey?: boolean, aMetaKey?: boolean, aButton?: number, aRelatedTarget?: EventTarget | null, aDataTransfer?: DataTransfer | null): void;
}

declare var DragEvent: {
    prototype: DragEvent;
    new(type: string, eventInitDict?: DragEventInit): DragEvent;
    isInstance: IsInstance<DragEvent>;
};

interface DynamicsCompressorNode extends AudioNode, AudioNodePassThrough {
    readonly attack: AudioParam;
    readonly knee: AudioParam;
    readonly ratio: AudioParam;
    readonly reduction: number;
    readonly release: AudioParam;
    readonly threshold: AudioParam;
}

declare var DynamicsCompressorNode: {
    prototype: DynamicsCompressorNode;
    new(context: BaseAudioContext, options?: DynamicsCompressorOptions): DynamicsCompressorNode;
    isInstance: IsInstance<DynamicsCompressorNode>;
};

interface EXT_blend_minmax {
    readonly MIN_EXT: 0x8007;
    readonly MAX_EXT: 0x8008;
}

interface EXT_color_buffer_float {
}

interface EXT_color_buffer_half_float {
    readonly RGBA16F_EXT: 0x881A;
    readonly RGB16F_EXT: 0x881B;
    readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211;
    readonly UNSIGNED_NORMALIZED_EXT: 0x8C17;
}

interface EXT_depth_clamp {
    readonly DEPTH_CLAMP_EXT: 0x864F;
}

interface EXT_disjoint_timer_query {
    beginQueryEXT(target: GLenum, query: WebGLQuery): void;
    createQueryEXT(): WebGLQuery;
    deleteQueryEXT(query: WebGLQuery | null): void;
    endQueryEXT(target: GLenum): void;
    getQueryEXT(target: GLenum, pname: GLenum): any;
    getQueryObjectEXT(query: WebGLQuery, pname: GLenum): any;
    isQueryEXT(query: WebGLQuery | null): boolean;
    queryCounterEXT(query: WebGLQuery, target: GLenum): void;
    readonly QUERY_COUNTER_BITS_EXT: 0x8864;
    readonly CURRENT_QUERY_EXT: 0x8865;
    readonly QUERY_RESULT_EXT: 0x8866;
    readonly QUERY_RESULT_AVAILABLE_EXT: 0x8867;
    readonly TIME_ELAPSED_EXT: 0x88BF;
    readonly TIMESTAMP_EXT: 0x8E28;
    readonly GPU_DISJOINT_EXT: 0x8FBB;
}

interface EXT_float_blend {
}

interface EXT_frag_depth {
}

interface EXT_sRGB {
    readonly SRGB_EXT: 0x8C40;
    readonly SRGB_ALPHA_EXT: 0x8C42;
    readonly SRGB8_ALPHA8_EXT: 0x8C43;
    readonly FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 0x8210;
}

interface EXT_shader_texture_lod {
}

interface EXT_texture_compression_bptc {
    readonly COMPRESSED_RGBA_BPTC_UNORM_EXT: 0x8E8C;
    readonly COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT: 0x8E8D;
    readonly COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT: 0x8E8E;
    readonly COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT: 0x8E8F;
}

interface EXT_texture_compression_rgtc {
    readonly COMPRESSED_RED_RGTC1_EXT: 0x8DBB;
    readonly COMPRESSED_SIGNED_RED_RGTC1_EXT: 0x8DBC;
    readonly COMPRESSED_RED_GREEN_RGTC2_EXT: 0x8DBD;
    readonly COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 0x8DBE;
}

interface EXT_texture_filter_anisotropic {
    readonly TEXTURE_MAX_ANISOTROPY_EXT: 0x84FE;
    readonly MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84FF;
}

interface EXT_texture_norm16 {
    readonly R16_EXT: 0x822A;
    readonly RG16_EXT: 0x822C;
    readonly RGB16_EXT: 0x8054;
    readonly RGBA16_EXT: 0x805B;
    readonly R16_SNORM_EXT: 0x8F98;
    readonly RG16_SNORM_EXT: 0x8F99;
    readonly RGB16_SNORM_EXT: 0x8F9A;
    readonly RGBA16_SNORM_EXT: 0x8F9B;
}

interface ElementEventMap {
    "fullscreenchange": Event;
    "fullscreenerror": Event;
}

interface Element extends Node, ARIAMixin, Animatable, ChildNode, GeometryUtils, NonDocumentTypeChildNode, ParentNode {
    readonly assignedSlot: HTMLSlotElement | null;
    readonly attributes: NamedNodeMap;
    readonly classList: DOMTokenList;
    className: string;
    readonly clientHeight: number;
    readonly clientHeightDouble: number;
    readonly clientLeft: number;
    readonly clientTop: number;
    readonly clientWidth: number;
    readonly clientWidthDouble: number;
    readonly currentCSSZoom: number;
    readonly firstLineBoxBSize: number;
    readonly fontSizeInflation: number;
    readonly hasVisibleScrollbars: boolean;
    id: string;
    readonly implementedPseudoElement: string | null;
    innerHTML: TrustedHTML | string;
    readonly localName: string;
    readonly namespaceURI: string | null;
    onfullscreenchange: ((this: Element, ev: Event) => any) | null;
    onfullscreenerror: ((this: Element, ev: Event) => any) | null;
    readonly openOrClosedAssignedSlot: HTMLSlotElement | null;
    readonly openOrClosedShadowRoot: ShadowRoot | null;
    outerHTML: TrustedHTML | string;
    readonly part: DOMTokenList;
    readonly prefix: string | null;
    readonly screen: nsIScreen | null;
    readonly screenX: number;
    readonly screenY: number;
    readonly scrollHeight: number;
    scrollLeft: number;
    readonly scrollLeftMax: number;
    readonly scrollLeftMin: number;
    scrollTop: number;
    readonly scrollTopMax: number;
    readonly scrollTopMin: number;
    readonly scrollWidth: number;
    readonly shadowRoot: ShadowRoot | null;
    slot: string;
    readonly tagName: string;
    attachShadow(shadowRootInitDict: ShadowRootInit): ShadowRoot;
    checkVisibility(options?: CheckVisibilityOptions): boolean;
    closest(selector: string): Element | null;
    getAsFlexContainer(): Flex | null;
    getAttribute(name: string): string | null;
    getAttributeNS(namespace: string | null, localName: string): string | null;
    getAttributeNames(): string[];
    getAttributeNode(name: string): Attr | null;
    getAttributeNodeNS(namespaceURI: string | null, localName: string): Attr | null;
    getBoundingClientRect(): DOMRect;
    getClientRects(): DOMRectList;
    getElementsByClassName(classNames: string): HTMLCollection;
    getElementsByTagName<K extends keyof HTMLElementTagNameMap>(localName: K): HTMLCollectionOf<HTMLElementTagNameMap[K]>;
    getElementsByTagName<K extends keyof SVGElementTagNameMap>(localName: K): HTMLCollectionOf<SVGElementTagNameMap[K]>;
    getElementsByTagName<K extends keyof MathMLElementTagNameMap>(localName: K): HTMLCollectionOf<MathMLElementTagNameMap[K]>;
    /** @deprecated */
    getElementsByTagName<K extends keyof HTMLElementDeprecatedTagNameMap>(localName: K): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K]>;
    getElementsByTagName(localName: string): HTMLCollectionOf<Element>;
    getElementsByTagNameNS(namespace: string | null, localName: string): HTMLCollection;
    getElementsWithGrid(): Element[];
    getGridFragments(): Grid[];
    getHTML(options?: GetHTMLOptions): string;
    getTransformToAncestor(ancestor: Element): DOMMatrixReadOnly;
    getTransformToParent(): DOMMatrixReadOnly;
    getTransformToViewport(): DOMMatrixReadOnly;
    hasAttribute(name: string): boolean;
    hasAttributeNS(namespace: string | null, localName: string): boolean;
    hasAttributes(): boolean;
    hasGridFragments(): boolean;
    hasPointerCapture(pointerId: number): boolean;
    insertAdjacentElement(where: string, element: Element): Element | null;
    insertAdjacentHTML(position: string, text: TrustedHTML | string): void;
    insertAdjacentText(where: string, data: string): void;
    matches(selector: string): boolean;
    mozMatchesSelector(selector: string): boolean;
    mozRequestFullScreen(): Promise<void>;
    mozScrollSnap(): void;
    releaseCapture(): void;
    releasePointerCapture(pointerId: number): void;
    removeAttribute(name: string): void;
    removeAttributeNS(namespace: string | null, localName: string): void;
    removeAttributeNode(oldAttr: Attr): Attr | null;
    requestFullscreen(): Promise<void>;
    requestPointerLock(): void;
    scroll(x: number, y: number): void;
    scroll(options?: ScrollToOptions): void;
    scrollBy(x: number, y: number): void;
    scrollBy(options?: ScrollToOptions): void;
    scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
    scrollTo(x: number, y: number): void;
    scrollTo(options?: ScrollToOptions): void;
    setAttribute(name: string, value: TrustedType | string): void;
    setAttributeDevtools(name: string, value: string): void;
    setAttributeDevtoolsNS(namespace: string | null, name: string, value: string): void;
    setAttributeNS(namespace: string | null, name: string, value: TrustedType | string): void;
    setAttributeNode(newAttr: Attr): Attr | null;
    setAttributeNodeNS(newAttr: Attr): Attr | null;
    setCapture(retargetToElement?: boolean): void;
    setCaptureAlways(retargetToElement?: boolean): void;
    setHTML(aInnerHTML: string, options?: SetHTMLOptions): void;
    setHTMLUnsafe(html: TrustedHTML | string, options?: SetHTMLUnsafeOptions): void;
    setPointerCapture(pointerId: number): void;
    toggleAttribute(name: string, force?: boolean): boolean;
    webkitMatchesSelector(selector: string): boolean;
    addEventListener<K extends keyof ElementEventMap>(type: K, listener: (this: Element, ev: ElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof ElementEventMap>(type: K, listener: (this: Element, ev: ElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var Element: {
    prototype: Element;
    new(): Element;
    isInstance: IsInstance<Element>;
};

interface ElementCSSInlineStyle {
    readonly style: CSSStyleDeclaration;
}

interface ElementInternals extends ARIAMixin {
    readonly form: HTMLFormElement | null;
    readonly labels: NodeList;
    readonly shadowRoot: ShadowRoot | null;
    readonly states: CustomStateSet;
    readonly validationAnchor: HTMLElement | null;
    readonly validationMessage: string;
    readonly validity: ValidityState;
    readonly willValidate: boolean;
    checkValidity(): boolean;
    reportValidity(): boolean;
    setFormValue(value: File | string | FormData | null, state?: File | string | FormData | null): void;
    setValidity(flags?: ValidityStateFlags, message?: string, anchor?: HTMLElement): void;
}

declare var ElementInternals: {
    prototype: ElementInternals;
    new(): ElementInternals;
    isInstance: IsInstance<ElementInternals>;
};

interface EncodedAudioChunk {
    readonly byteLength: number;
    readonly duration: number | null;
    readonly timestamp: number;
    readonly type: EncodedAudioChunkType;
    copyTo(destination: AllowSharedBufferSource): void;
}

declare var EncodedAudioChunk: {
    prototype: EncodedAudioChunk;
    new(init: EncodedAudioChunkInit): EncodedAudioChunk;
    isInstance: IsInstance<EncodedAudioChunk>;
};

interface EncodedVideoChunk {
    readonly byteLength: number;
    readonly duration: number | null;
    readonly timestamp: number;
    readonly type: EncodedVideoChunkType;
    copyTo(destination: AllowSharedBufferSource): void;
}

declare var EncodedVideoChunk: {
    prototype: EncodedVideoChunk;
    new(init: EncodedVideoChunkInit): EncodedVideoChunk;
    isInstance: IsInstance<EncodedVideoChunk>;
};

interface ErrorEvent extends Event {
    readonly colno: number;
    readonly error: any;
    readonly filename: string;
    readonly lineno: number;
    readonly message: string;
}

declare var ErrorEvent: {
    prototype: ErrorEvent;
    new(type: string, eventInitDict?: ErrorEventInit): ErrorEvent;
    isInstance: IsInstance<ErrorEvent>;
};

interface Event {
    readonly bubbles: boolean;
    cancelBubble: boolean;
    readonly cancelable: boolean;
    readonly composed: boolean;
    readonly composedTarget: EventTarget | null;
    readonly currentTarget: EventTarget | null;
    readonly defaultPrevented: boolean;
    readonly defaultPreventedByChrome: boolean;
    readonly defaultPreventedByContent: boolean;
    readonly eventPhase: number;
    readonly explicitOriginalTarget: EventTarget | null;
    readonly isReplyEventFromRemoteContent: boolean;
    readonly isSynthesized: boolean;
    readonly isTrusted: boolean;
    readonly isWaitingReplyFromRemoteContent: boolean;
    readonly multipleActionsPrevented: boolean;
    readonly originalTarget: EventTarget | null;
    returnValue: boolean;
    readonly target: EventTarget | null;
    readonly timeStamp: DOMHighResTimeStamp;
    readonly type: string;
    composedPath(): EventTarget[];
    initEvent(type: string, bubbles?: boolean, cancelable?: boolean): void;
    preventDefault(): void;
    preventMultipleActions(): void;
    requestReplyFromRemoteContent(): void;
    stopImmediatePropagation(): void;
    stopPropagation(): void;
    readonly NONE: 0;
    readonly CAPTURING_PHASE: 1;
    readonly AT_TARGET: 2;
    readonly BUBBLING_PHASE: 3;
    readonly ALT_MASK: 0x00000001;
    readonly CONTROL_MASK: 0x00000002;
    readonly SHIFT_MASK: 0x00000004;
    readonly META_MASK: 0x00000008;
}

declare var Event: {
    prototype: Event;
    new(type: string, eventInitDict?: EventInit): Event;
    readonly NONE: 0;
    readonly CAPTURING_PHASE: 1;
    readonly AT_TARGET: 2;
    readonly BUBBLING_PHASE: 3;
    readonly ALT_MASK: 0x00000001;
    readonly CONTROL_MASK: 0x00000002;
    readonly SHIFT_MASK: 0x00000004;
    readonly META_MASK: 0x00000008;
    isInstance: IsInstance<Event>;
};

interface EventCallbackDebuggerNotification extends CallbackDebuggerNotification {
    readonly event: Event;
    readonly targetType: EventCallbackDebuggerNotificationType;
}

declare var EventCallbackDebuggerNotification: {
    prototype: EventCallbackDebuggerNotification;
    new(): EventCallbackDebuggerNotification;
    isInstance: IsInstance<EventCallbackDebuggerNotification>;
};

interface EventCounts {
    forEach(callbackfn: (value: number, key: string, parent: EventCounts) => void, thisArg?: any): void;
}

declare var EventCounts: {
    prototype: EventCounts;
    new(): EventCounts;
    isInstance: IsInstance<EventCounts>;
};

interface EventHandler {
}

interface EventListenerOrEventListenerObject {
}

interface EventSourceEventMap {
    "error": Event;
    "message": Event;
    "open": Event;
}

interface EventSource extends EventTarget {
    onerror: ((this: EventSource, ev: Event) => any) | null;
    onmessage: ((this: EventSource, ev: Event) => any) | null;
    onopen: ((this: EventSource, ev: Event) => any) | null;
    readonly readyState: number;
    readonly url: string;
    readonly withCredentials: boolean;
    close(): void;
    readonly CONNECTING: 0;
    readonly OPEN: 1;
    readonly CLOSED: 2;
    addEventListener<K extends keyof EventSourceEventMap>(type: K, listener: (this: EventSource, ev: EventSourceEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: (this: EventSource, event: MessageEvent) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof EventSourceEventMap>(type: K, listener: (this: EventSource, ev: EventSourceEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: (this: EventSource, event: MessageEvent) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var EventSource: {
    prototype: EventSource;
    new(url: string | URL, eventSourceInitDict?: EventSourceInit): EventSource;
    readonly CONNECTING: 0;
    readonly OPEN: 1;
    readonly CLOSED: 2;
    isInstance: IsInstance<EventSource>;
};

interface EventTarget {
    readonly ownerGlobal: WindowProxy | null;
    addEventListener(type: string, listener: EventListener | null, options?: AddEventListenerOptions | boolean, wantsUntrusted?: boolean | null): void;
    dispatchEvent(event: Event): boolean;
    getEventHandler(type: string): EventHandler;
    removeEventListener(type: string, listener: EventListener | null, options?: EventListenerOptions | boolean): void;
    setEventHandler(type: string, handler: EventHandler): void;
}

declare var EventTarget: {
    prototype: EventTarget;
    new(): EventTarget;
    isInstance: IsInstance<EventTarget>;
};

interface Exception extends ExceptionMembers {
    readonly message: string;
    readonly name: string;
    toString(): string;
}

interface ExceptionMembers {
    readonly columnNumber: number;
    readonly data: nsISupports | null;
    readonly filename: string;
    readonly lineNumber: number;
    readonly location: StackFrame | null;
    readonly result: number;
    readonly stack: string;
}

interface External {
    AddSearchProvider(): void;
    IsSearchProviderInstalled(): void;
}

interface FeaturePolicy {
    allowedFeatures(): string[];
    allowsFeature(feature: string, origin?: string): boolean;
    features(): string[];
    getAllowlistForFeature(feature: string): string[];
}

interface FeaturePolicyViolationReportBody extends ReportBody {
    readonly columnNumber: number | null;
    readonly disposition: string;
    readonly featureId: string;
    readonly lineNumber: number | null;
    readonly sourceFile: string | null;
}

declare var FeaturePolicyViolationReportBody: {
    prototype: FeaturePolicyViolationReportBody;
    new(): FeaturePolicyViolationReportBody;
    isInstance: IsInstance<FeaturePolicyViolationReportBody>;
};

interface FetchObserverEventMap {
    "requestprogress": Event;
    "responseprogress": Event;
    "statechange": Event;
}

interface FetchObserver extends EventTarget {
    onrequestprogress: ((this: FetchObserver, ev: Event) => any) | null;
    onresponseprogress: ((this: FetchObserver, ev: Event) => any) | null;
    onstatechange: ((this: FetchObserver, ev: Event) => any) | null;
    readonly state: FetchState;
    addEventListener<K extends keyof FetchObserverEventMap>(type: K, listener: (this: FetchObserver, ev: FetchObserverEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof FetchObserverEventMap>(type: K, listener: (this: FetchObserver, ev: FetchObserverEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var FetchObserver: {
    prototype: FetchObserver;
    new(): FetchObserver;
    isInstance: IsInstance<FetchObserver>;
};

interface File extends Blob {
    readonly lastModified: number;
    readonly mozFullPath: string;
    readonly name: string;
    readonly webkitRelativePath: string;
}

declare var File: {
    prototype: File;
    new(fileBits: BlobPart[], fileName: string, options?: FilePropertyBag): File;
    isInstance: IsInstance<File>;
    createFromFileName(fileName: string, options?: ChromeFilePropertyBag): Promise<File>;
    createFromNsIFile(file: nsIFile, options?: ChromeFilePropertyBag): Promise<File>;
};

interface FileList {
    readonly length: number;
    item(index: number): File | null;
    [index: number]: File;
}

declare var FileList: {
    prototype: FileList;
    new(): FileList;
    isInstance: IsInstance<FileList>;
};

interface FileReaderEventMap {
    "abort": Event;
    "error": Event;
    "load": Event;
    "loadend": Event;
    "loadstart": Event;
    "progress": Event;
}

interface FileReader extends EventTarget {
    readonly error: DOMException | null;
    onabort: ((this: FileReader, ev: Event) => any) | null;
    onerror: ((this: FileReader, ev: Event) => any) | null;
    onload: ((this: FileReader, ev: Event) => any) | null;
    onloadend: ((this: FileReader, ev: Event) => any) | null;
    onloadstart: ((this: FileReader, ev: Event) => any) | null;
    onprogress: ((this: FileReader, ev: Event) => any) | null;
    readonly readyState: number;
    readonly result: string | ArrayBuffer | null;
    abort(): void;
    readAsArrayBuffer(blob: Blob): void;
    readAsBinaryString(filedata: Blob): void;
    readAsDataURL(blob: Blob): void;
    readAsText(blob: Blob, label?: string): void;
    readonly EMPTY: 0;
    readonly LOADING: 1;
    readonly DONE: 2;
    addEventListener<K extends keyof FileReaderEventMap>(type: K, listener: (this: FileReader, ev: FileReaderEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof FileReaderEventMap>(type: K, listener: (this: FileReader, ev: FileReaderEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var FileReader: {
    prototype: FileReader;
    new(): FileReader;
    readonly EMPTY: 0;
    readonly LOADING: 1;
    readonly DONE: 2;
    isInstance: IsInstance<FileReader>;
};

interface FileSystem {
    readonly name: string;
    readonly root: FileSystemDirectoryEntry;
}

declare var FileSystem: {
    prototype: FileSystem;
    new(): FileSystem;
    isInstance: IsInstance<FileSystem>;
};

interface FileSystemDirectoryEntry extends FileSystemEntry {
    createReader(): FileSystemDirectoryReader;
    getDirectory(path?: string | null, options?: FileSystemFlags, successCallback?: FileSystemEntryCallback, errorCallback?: ErrorCallback): void;
    getFile(path?: string | null, options?: FileSystemFlags, successCallback?: FileSystemEntryCallback, errorCallback?: ErrorCallback): void;
}

declare var FileSystemDirectoryEntry: {
    prototype: FileSystemDirectoryEntry;
    new(): FileSystemDirectoryEntry;
    isInstance: IsInstance<FileSystemDirectoryEntry>;
};

/** Available only in secure contexts. */
interface FileSystemDirectoryHandle extends FileSystemHandle {
    getDirectoryHandle(name: string, options?: FileSystemGetDirectoryOptions): Promise<FileSystemDirectoryHandle>;
    getFileHandle(name: string, options?: FileSystemGetFileOptions): Promise<FileSystemFileHandle>;
    removeEntry(name: string, options?: FileSystemRemoveOptions): Promise<void>;
    resolve(possibleDescendant: FileSystemHandle): Promise<string[] | null>;
}

declare var FileSystemDirectoryHandle: {
    prototype: FileSystemDirectoryHandle;
    new(): FileSystemDirectoryHandle;
    isInstance: IsInstance<FileSystemDirectoryHandle>;
};

/** Available only in secure contexts. */
interface FileSystemDirectoryIterator {
    next(): Promise<any>;
}

interface FileSystemDirectoryReader {
    readEntries(successCallback: FileSystemEntriesCallback, errorCallback?: ErrorCallback): void;
}

declare var FileSystemDirectoryReader: {
    prototype: FileSystemDirectoryReader;
    new(): FileSystemDirectoryReader;
    isInstance: IsInstance<FileSystemDirectoryReader>;
};

interface FileSystemEntry {
    readonly filesystem: FileSystem;
    readonly fullPath: string;
    readonly isDirectory: boolean;
    readonly isFile: boolean;
    readonly name: string;
    getParent(successCallback?: FileSystemEntryCallback, errorCallback?: ErrorCallback): void;
}

declare var FileSystemEntry: {
    prototype: FileSystemEntry;
    new(): FileSystemEntry;
    isInstance: IsInstance<FileSystemEntry>;
};

interface FileSystemFileEntry extends FileSystemEntry {
    file(successCallback: FileCallback, errorCallback?: ErrorCallback): void;
}

declare var FileSystemFileEntry: {
    prototype: FileSystemFileEntry;
    new(): FileSystemFileEntry;
    isInstance: IsInstance<FileSystemFileEntry>;
};

/** Available only in secure contexts. */
interface FileSystemFileHandle extends FileSystemHandle {
    createWritable(options?: FileSystemCreateWritableOptions): Promise<FileSystemWritableFileStream>;
    getFile(): Promise<File>;
}

declare var FileSystemFileHandle: {
    prototype: FileSystemFileHandle;
    new(): FileSystemFileHandle;
    isInstance: IsInstance<FileSystemFileHandle>;
};

/** Available only in secure contexts. */
interface FileSystemHandle {
    readonly kind: FileSystemHandleKind;
    readonly name: string;
    isSameEntry(other: FileSystemHandle): Promise<boolean>;
    move(name: string): Promise<void>;
    move(parent: FileSystemDirectoryHandle): Promise<void>;
    move(parent: FileSystemDirectoryHandle, name: string): Promise<void>;
}

declare var FileSystemHandle: {
    prototype: FileSystemHandle;
    new(): FileSystemHandle;
    isInstance: IsInstance<FileSystemHandle>;
};

/** Available only in secure contexts. */
interface FileSystemWritableFileStream extends WritableStream {
    seek(position: number): Promise<void>;
    truncate(size: number): Promise<void>;
    write(data: FileSystemWriteChunkType): Promise<void>;
}

declare var FileSystemWritableFileStream: {
    prototype: FileSystemWritableFileStream;
    new(): FileSystemWritableFileStream;
    isInstance: IsInstance<FileSystemWritableFileStream>;
};

interface Flex {
    readonly crossAxisDirection: FlexPhysicalDirection;
    readonly mainAxisDirection: FlexPhysicalDirection;
    getLines(): FlexLineValues[];
}

declare var Flex: {
    prototype: Flex;
    new(): Flex;
    isInstance: IsInstance<Flex>;
};

interface FlexItemValues {
    readonly clampState: FlexItemClampState;
    readonly crossMaxSize: number;
    readonly crossMinSize: number;
    readonly frameRect: DOMRectReadOnly;
    readonly mainBaseSize: number;
    readonly mainDeltaSize: number;
    readonly mainMaxSize: number;
    readonly mainMinSize: number;
    readonly node: Node | null;
}

declare var FlexItemValues: {
    prototype: FlexItemValues;
    new(): FlexItemValues;
    isInstance: IsInstance<FlexItemValues>;
};

interface FlexLineValues {
    readonly crossSize: number;
    readonly crossStart: number;
    readonly firstBaselineOffset: number;
    readonly growthState: FlexLineGrowthState;
    readonly lastBaselineOffset: number;
    getItems(): FlexItemValues[];
}

declare var FlexLineValues: {
    prototype: FlexLineValues;
    new(): FlexLineValues;
    isInstance: IsInstance<FlexLineValues>;
};

interface FluentBundle {
    readonly locales: string[];
    addResource(aResource: FluentResource, aOptions?: FluentBundleAddResourceOptions): void;
    formatPattern(pattern: FluentPattern, aArgs?: L10nArgs | null, aErrors?: any): string;
    getMessage(id: string): FluentMessage | null;
    hasMessage(id: string): boolean;
}

declare var FluentBundle: {
    prototype: FluentBundle;
    new(aLocales: string | string[], aOptions?: FluentBundleOptions): FluentBundle;
    isInstance: IsInstance<FluentBundle>;
};

interface FluentBundleAsyncIterator {
    next(): Promise<FluentBundleIteratorResult>;
    values(): FluentBundleAsyncIterator;
}

interface FluentBundleIterator {
    next(): FluentBundleIteratorResult;
    values(): FluentBundleIterator;
}

interface FluentPattern {
}

declare var FluentPattern: {
    prototype: FluentPattern;
    new(): FluentPattern;
    isInstance: IsInstance<FluentPattern>;
};

interface FluentResource {
    textElements(): FluentTextElementItem[];
}

declare var FluentResource: {
    prototype: FluentResource;
    new(source: string): FluentResource;
    isInstance: IsInstance<FluentResource>;
};

interface FocusEvent extends UIEvent {
    readonly relatedTarget: EventTarget | null;
}

declare var FocusEvent: {
    prototype: FocusEvent;
    new(typeArg: string, focusEventInitDict?: FocusEventInit): FocusEvent;
    isInstance: IsInstance<FocusEvent>;
};

interface FontFace {
    ascentOverride: string;
    descentOverride: string;
    display: string;
    family: string;
    featureSettings: string;
    lineGapOverride: string;
    readonly loaded: Promise<FontFace>;
    sizeAdjust: string;
    readonly status: FontFaceLoadStatus;
    stretch: string;
    style: string;
    unicodeRange: string;
    variant: string;
    variationSettings: string;
    weight: string;
    load(): Promise<FontFace>;
}

declare var FontFace: {
    prototype: FontFace;
    new(family: string, source: string | BinaryData, descriptors?: FontFaceDescriptors): FontFace;
    isInstance: IsInstance<FontFace>;
};

interface FontFaceSetEventMap {
    "loading": Event;
    "loadingdone": Event;
    "loadingerror": Event;
}

interface FontFaceSet extends EventTarget {
    onloading: ((this: FontFaceSet, ev: Event) => any) | null;
    onloadingdone: ((this: FontFaceSet, ev: Event) => any) | null;
    onloadingerror: ((this: FontFaceSet, ev: Event) => any) | null;
    readonly ready: Promise<void>;
    readonly size: number;
    readonly status: FontFaceSetLoadStatus;
    add(font: FontFace): void;
    check(font: string, text?: string): boolean;
    clear(): void;
    delete(font: FontFace): boolean;
    entries(): FontFaceSetIterator;
    forEach(cb: FontFaceSetForEachCallback, thisArg?: any): void;
    has(font: FontFace): boolean;
    load(font: string, text?: string): Promise<FontFace[]>;
    values(): FontFaceSetIterator;
    addEventListener<K extends keyof FontFaceSetEventMap>(type: K, listener: (this: FontFaceSet, ev: FontFaceSetEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof FontFaceSetEventMap>(type: K, listener: (this: FontFaceSet, ev: FontFaceSetEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var FontFaceSet: {
    prototype: FontFaceSet;
    new(): FontFaceSet;
    isInstance: IsInstance<FontFaceSet>;
};

interface FontFaceSetIterator {
    next(): FontFaceSetIteratorResult;
}

interface FontFaceSetLoadEvent extends Event {
    readonly fontfaces: FontFace[];
}

declare var FontFaceSetLoadEvent: {
    prototype: FontFaceSetLoadEvent;
    new(type: string, eventInitDict?: FontFaceSetLoadEventInit): FontFaceSetLoadEvent;
    isInstance: IsInstance<FontFaceSetLoadEvent>;
};

interface FontFaceSource {
    readonly fonts: FontFaceSet;
}

interface FormData {
    append(name: string, value: Blob, filename?: string): void;
    append(name: string, value: string): void;
    delete(name: string): void;
    get(name: string): FormDataEntryValue | null;
    getAll(name: string): FormDataEntryValue[];
    has(name: string): boolean;
    set(name: string, value: Blob, filename?: string): void;
    set(name: string, value: string): void;
    forEach(callbackfn: (value: FormDataEntryValue, key: string, parent: FormData) => void, thisArg?: any): void;
}

declare var FormData: {
    prototype: FormData;
    new(form?: HTMLFormElement, submitter?: HTMLElement | null): FormData;
    isInstance: IsInstance<FormData>;
};

interface FormDataEvent extends Event {
    readonly formData: FormData;
}

declare var FormDataEvent: {
    prototype: FormDataEvent;
    new(type: string, eventInitDict?: FormDataEventInit): FormDataEvent;
    isInstance: IsInstance<FormDataEvent>;
};

interface FragmentDirective {
    createTextDirective(range: Range): Promise<string>;
    getTextDirectiveRanges(): Range[];
    removeAllTextDirectives(): void;
}

declare var FragmentDirective: {
    prototype: FragmentDirective;
    new(): FragmentDirective;
    isInstance: IsInstance<FragmentDirective>;
};

interface FrameCrashedEvent extends Event {
    readonly browsingContextId: number;
    readonly childID: number;
    readonly isTopFrame: boolean;
}

declare var FrameCrashedEvent: {
    prototype: FrameCrashedEvent;
    new(type: string, eventInitDict?: FrameCrashedEventInit): FrameCrashedEvent;
    isInstance: IsInstance<FrameCrashedEvent>;
};

interface FrameLoader extends WebBrowserPersistable {
    readonly browsingContext: BrowsingContext | null;
    readonly childID: number;
    readonly depthTooGreat: boolean;
    readonly docShell: nsIDocShell | null;
    readonly isDead: boolean;
    readonly isRemoteFrame: boolean;
    readonly lazyHeight: number;
    readonly lazyWidth: number;
    readonly loadContext: LoadContext | null;
    readonly messageManager: MessageSender | null;
    readonly ownerElement: Element | null;
    readonly remoteTab: RemoteTab | null;
    exitPrintPreview(): void;
    printPreview(aPrintSettings: nsIPrintSettings, aSourceBrowsingContext: BrowsingContext | null): Promise<number>;
    requestEpochUpdate(aEpoch: number): void;
    requestSHistoryUpdate(): void;
    requestTabStateFlush(): Promise<void>;
    requestUpdatePosition(): void;
}

declare var FrameLoader: {
    prototype: FrameLoader;
    new(): FrameLoader;
    isInstance: IsInstance<FrameLoader>;
};

interface FrameScriptLoader {
    getDelayedFrameScripts(): any[][];
    loadFrameScript(url: string, allowDelayedLoad: boolean, runInGlobalScope?: boolean): void;
    removeDelayedFrameScript(url: string): void;
}

/** Available only in secure contexts. */
interface GPU {
    readonly wgslLanguageFeatures: WGSLLanguageFeatures;
    getPreferredCanvasFormat(): GPUTextureFormat;
    requestAdapter(options?: GPURequestAdapterOptions): Promise<GPUAdapter | null>;
}

declare var GPU: {
    prototype: GPU;
    new(): GPU;
    isInstance: IsInstance<GPU>;
};

/** Available only in secure contexts. */
interface GPUAdapter {
    readonly features: GPUSupportedFeatures;
    readonly info: GPUAdapterInfo;
    readonly isFallbackAdapter: boolean;
    readonly limits: GPUSupportedLimits;
    readonly missingFeatures: number;
    requestDevice(descriptor?: GPUDeviceDescriptor): Promise<GPUDevice>;
}

declare var GPUAdapter: {
    prototype: GPUAdapter;
    new(): GPUAdapter;
    isInstance: IsInstance<GPUAdapter>;
};

/** Available only in secure contexts. */
interface GPUAdapterInfo {
    readonly architecture: string;
    readonly description: string;
    readonly device: string;
    readonly isFallbackAdapter: boolean;
    readonly subgroupMaxSize: number;
    readonly subgroupMinSize: number;
    readonly vendor: string;
    readonly wgpuBackend: string;
    readonly wgpuDevice: number;
    readonly wgpuDeviceType: string;
    readonly wgpuDriver: string;
    readonly wgpuDriverInfo: string;
    readonly wgpuName: string;
    readonly wgpuVendor: number;
}

declare var GPUAdapterInfo: {
    prototype: GPUAdapterInfo;
    new(): GPUAdapterInfo;
    isInstance: IsInstance<GPUAdapterInfo>;
};

/** Available only in secure contexts. */
interface GPUBindGroup extends GPUObjectBase {
}

declare var GPUBindGroup: {
    prototype: GPUBindGroup;
    new(): GPUBindGroup;
    isInstance: IsInstance<GPUBindGroup>;
};

/** Available only in secure contexts. */
interface GPUBindGroupLayout extends GPUObjectBase {
}

declare var GPUBindGroupLayout: {
    prototype: GPUBindGroupLayout;
    new(): GPUBindGroupLayout;
    isInstance: IsInstance<GPUBindGroupLayout>;
};

interface GPUBindingCommandsMixin {
    setBindGroup(index: GPUIndex32, bindGroup: GPUBindGroup | null, dynamicOffsets?: GPUBufferDynamicOffset[]): void;
    setBindGroup(index: GPUIndex32, bindGroup: GPUBindGroup | null, dynamicOffsetsData: Uint32Array, dynamicOffsetsDataStart: GPUSize64, dynamicOffsetsDataLength: GPUSize32): void;
}

/** Available only in secure contexts. */
interface GPUBuffer extends GPUObjectBase {
    readonly mapState: GPUBufferMapState;
    readonly size: GPUSize64Out;
    readonly usage: GPUFlagsConstant;
    destroy(): void;
    getMappedRange(offset?: GPUSize64, size?: GPUSize64): ArrayBuffer;
    mapAsync(mode: GPUMapModeFlags, offset?: GPUSize64, size?: GPUSize64): Promise<void>;
    unmap(): void;
}

declare var GPUBuffer: {
    prototype: GPUBuffer;
    new(): GPUBuffer;
    isInstance: IsInstance<GPUBuffer>;
};

/** Available only in secure contexts. */
interface GPUCanvasContext {
    readonly canvas: HTMLCanvasElement | OffscreenCanvas;
    configure(configuration: GPUCanvasConfiguration): void;
    getConfiguration(): GPUCanvasConfiguration | null;
    getCurrentTexture(): GPUTexture;
    unconfigure(): void;
}

declare var GPUCanvasContext: {
    prototype: GPUCanvasContext;
    new(): GPUCanvasContext;
    isInstance: IsInstance<GPUCanvasContext>;
};

/** Available only in secure contexts. */
interface GPUCommandBuffer extends GPUObjectBase {
}

declare var GPUCommandBuffer: {
    prototype: GPUCommandBuffer;
    new(): GPUCommandBuffer;
    isInstance: IsInstance<GPUCommandBuffer>;
};

/** Available only in secure contexts. */
interface GPUCommandEncoder extends GPUDebugCommandsMixin, GPUObjectBase {
    beginComputePass(descriptor?: GPUComputePassDescriptor): GPUComputePassEncoder;
    beginRenderPass(descriptor: GPURenderPassDescriptor): GPURenderPassEncoder;
    clearBuffer(buffer: GPUBuffer, offset?: GPUSize64, size?: GPUSize64): void;
    copyBufferToBuffer(source: GPUBuffer, sourceOffset: GPUSize64, destination: GPUBuffer, destinationOffset: GPUSize64, size: GPUSize64): void;
    copyBufferToTexture(source: GPUTexelCopyBufferInfo, destination: GPUTexelCopyTextureInfo, copySize: GPUExtent3D): void;
    copyTextureToBuffer(source: GPUTexelCopyTextureInfo, destination: GPUTexelCopyBufferInfo, copySize: GPUExtent3D): void;
    copyTextureToTexture(source: GPUTexelCopyTextureInfo, destination: GPUTexelCopyTextureInfo, copySize: GPUExtent3D): void;
    finish(descriptor?: GPUCommandBufferDescriptor): GPUCommandBuffer;
    resolveQuerySet(querySet: GPUQuerySet, firstQuery: GPUSize32, queryCount: GPUSize32, destination: GPUBuffer, destinationOffset: GPUSize64): void;
}

declare var GPUCommandEncoder: {
    prototype: GPUCommandEncoder;
    new(): GPUCommandEncoder;
    isInstance: IsInstance<GPUCommandEncoder>;
};

/** Available only in secure contexts. */
interface GPUCompilationInfo {
    readonly messages: GPUCompilationMessage[];
}

declare var GPUCompilationInfo: {
    prototype: GPUCompilationInfo;
    new(): GPUCompilationInfo;
    isInstance: IsInstance<GPUCompilationInfo>;
};

/** Available only in secure contexts. */
interface GPUCompilationMessage {
    readonly length: number;
    readonly lineNum: number;
    readonly linePos: number;
    readonly message: string;
    readonly offset: number;
    readonly type: GPUCompilationMessageType;
}

declare var GPUCompilationMessage: {
    prototype: GPUCompilationMessage;
    new(): GPUCompilationMessage;
    isInstance: IsInstance<GPUCompilationMessage>;
};

/** Available only in secure contexts. */
interface GPUComputePassEncoder extends GPUBindingCommandsMixin, GPUDebugCommandsMixin, GPUObjectBase {
    dispatchWorkgroups(workgroupCountX: GPUSize32, workgroupCountY?: GPUSize32, workgroupCountZ?: GPUSize32): void;
    dispatchWorkgroupsIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64): void;
    end(): void;
    setPipeline(pipeline: GPUComputePipeline): void;
}

declare var GPUComputePassEncoder: {
    prototype: GPUComputePassEncoder;
    new(): GPUComputePassEncoder;
    isInstance: IsInstance<GPUComputePassEncoder>;
};

/** Available only in secure contexts. */
interface GPUComputePipeline extends GPUObjectBase, GPUPipelineBase {
}

declare var GPUComputePipeline: {
    prototype: GPUComputePipeline;
    new(): GPUComputePipeline;
    isInstance: IsInstance<GPUComputePipeline>;
};

interface GPUDebugCommandsMixin {
    insertDebugMarker(markerLabel: string): void;
    popDebugGroup(): void;
    pushDebugGroup(groupLabel: string): void;
}

interface GPUDeviceEventMap {
    "uncapturederror": Event;
}

/** Available only in secure contexts. */
interface GPUDevice extends EventTarget, GPUObjectBase {
    readonly features: GPUSupportedFeatures;
    readonly limits: GPUSupportedLimits;
    readonly lost: Promise<GPUDeviceLostInfo>;
    onuncapturederror: ((this: GPUDevice, ev: Event) => any) | null;
    readonly queue: GPUQueue;
    createBindGroup(descriptor: GPUBindGroupDescriptor): GPUBindGroup;
    createBindGroupLayout(descriptor: GPUBindGroupLayoutDescriptor): GPUBindGroupLayout;
    createBuffer(descriptor: GPUBufferDescriptor): GPUBuffer;
    createCommandEncoder(descriptor?: GPUCommandEncoderDescriptor): GPUCommandEncoder;
    createComputePipeline(descriptor: GPUComputePipelineDescriptor): GPUComputePipeline;
    createComputePipelineAsync(descriptor: GPUComputePipelineDescriptor): Promise<GPUComputePipeline>;
    createPipelineLayout(descriptor: GPUPipelineLayoutDescriptor): GPUPipelineLayout;
    createQuerySet(descriptor: GPUQuerySetDescriptor): GPUQuerySet;
    createRenderBundleEncoder(descriptor: GPURenderBundleEncoderDescriptor): GPURenderBundleEncoder;
    createRenderPipeline(descriptor: GPURenderPipelineDescriptor): GPURenderPipeline;
    createRenderPipelineAsync(descriptor: GPURenderPipelineDescriptor): Promise<GPURenderPipeline>;
    createSampler(descriptor?: GPUSamplerDescriptor): GPUSampler;
    createShaderModule(descriptor: GPUShaderModuleDescriptor): GPUShaderModule;
    createTexture(descriptor: GPUTextureDescriptor): GPUTexture;
    destroy(): void;
    popErrorScope(): Promise<GPUError | null>;
    pushErrorScope(filter: GPUErrorFilter): void;
    addEventListener<K extends keyof GPUDeviceEventMap>(type: K, listener: (this: GPUDevice, ev: GPUDeviceEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof GPUDeviceEventMap>(type: K, listener: (this: GPUDevice, ev: GPUDeviceEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var GPUDevice: {
    prototype: GPUDevice;
    new(): GPUDevice;
    isInstance: IsInstance<GPUDevice>;
};

/** Available only in secure contexts. */
interface GPUDeviceLostInfo {
    readonly message: string;
    readonly reason: any;
}

declare var GPUDeviceLostInfo: {
    prototype: GPUDeviceLostInfo;
    new(): GPUDeviceLostInfo;
    isInstance: IsInstance<GPUDeviceLostInfo>;
};

/** Available only in secure contexts. */
interface GPUError {
    readonly message: string;
}

declare var GPUError: {
    prototype: GPUError;
    new(): GPUError;
    isInstance: IsInstance<GPUError>;
};

/** Available only in secure contexts. */
interface GPUExternalTexture extends GPUObjectBase {
}

declare var GPUExternalTexture: {
    prototype: GPUExternalTexture;
    new(): GPUExternalTexture;
    isInstance: IsInstance<GPUExternalTexture>;
};

/** Available only in secure contexts. */
interface GPUInternalError extends GPUError {
}

declare var GPUInternalError: {
    prototype: GPUInternalError;
    new(message: string): GPUInternalError;
    isInstance: IsInstance<GPUInternalError>;
};

interface GPUObjectBase {
    label: string;
}

/** Available only in secure contexts. */
interface GPUOutOfMemoryError extends GPUError {
}

declare var GPUOutOfMemoryError: {
    prototype: GPUOutOfMemoryError;
    new(message: string): GPUOutOfMemoryError;
    isInstance: IsInstance<GPUOutOfMemoryError>;
};

interface GPUPipelineBase {
    getBindGroupLayout(index: number): GPUBindGroupLayout;
}

/** Available only in secure contexts. */
interface GPUPipelineError extends DOMException {
    readonly reason: GPUPipelineErrorReason;
}

declare var GPUPipelineError: {
    prototype: GPUPipelineError;
    new(message?: string, options: GPUPipelineErrorInit): GPUPipelineError;
    isInstance: IsInstance<GPUPipelineError>;
};

/** Available only in secure contexts. */
interface GPUPipelineLayout extends GPUObjectBase {
}

declare var GPUPipelineLayout: {
    prototype: GPUPipelineLayout;
    new(): GPUPipelineLayout;
    isInstance: IsInstance<GPUPipelineLayout>;
};

/** Available only in secure contexts. */
interface GPUQuerySet extends GPUObjectBase {
    readonly count: GPUSize32Out;
    readonly type: GPUQueryType;
    destroy(): void;
}

declare var GPUQuerySet: {
    prototype: GPUQuerySet;
    new(): GPUQuerySet;
    isInstance: IsInstance<GPUQuerySet>;
};

/** Available only in secure contexts. */
interface GPUQueue extends GPUObjectBase {
    copyExternalImageToTexture(source: GPUCopyExternalImageSourceInfo, destination: GPUCopyExternalImageDestInfo, copySize: GPUExtent3D): void;
    onSubmittedWorkDone(): Promise<void>;
    submit(buffers: GPUCommandBuffer[]): void;
    writeBuffer(buffer: GPUBuffer, bufferOffset: GPUSize64, data: AllowSharedBufferSource, dataOffset?: GPUSize64, size?: GPUSize64): void;
    writeTexture(destination: GPUTexelCopyTextureInfo, data: AllowSharedBufferSource, dataLayout: GPUTexelCopyBufferLayout, size: GPUExtent3D): void;
}

declare var GPUQueue: {
    prototype: GPUQueue;
    new(): GPUQueue;
    isInstance: IsInstance<GPUQueue>;
};

/** Available only in secure contexts. */
interface GPURenderBundle extends GPUObjectBase {
}

declare var GPURenderBundle: {
    prototype: GPURenderBundle;
    new(): GPURenderBundle;
    isInstance: IsInstance<GPURenderBundle>;
};

/** Available only in secure contexts. */
interface GPURenderBundleEncoder extends GPUBindingCommandsMixin, GPUDebugCommandsMixin, GPUObjectBase, GPURenderCommandsMixin {
    finish(descriptor?: GPURenderBundleDescriptor): GPURenderBundle;
}

declare var GPURenderBundleEncoder: {
    prototype: GPURenderBundleEncoder;
    new(): GPURenderBundleEncoder;
    isInstance: IsInstance<GPURenderBundleEncoder>;
};

interface GPURenderCommandsMixin {
    draw(vertexCount: GPUSize32, instanceCount?: GPUSize32, firstVertex?: GPUSize32, firstInstance?: GPUSize32): void;
    drawIndexed(indexCount: GPUSize32, instanceCount?: GPUSize32, firstIndex?: GPUSize32, baseVertex?: GPUSignedOffset32, firstInstance?: GPUSize32): void;
    drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64): void;
    drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64): void;
    setIndexBuffer(buffer: GPUBuffer, indexFormat: GPUIndexFormat, offset?: GPUSize64, size?: GPUSize64): void;
    setPipeline(pipeline: GPURenderPipeline): void;
    setVertexBuffer(slot: GPUIndex32, buffer: GPUBuffer, offset?: GPUSize64, size?: GPUSize64): void;
}

/** Available only in secure contexts. */
interface GPURenderPassEncoder extends GPUBindingCommandsMixin, GPUDebugCommandsMixin, GPUObjectBase, GPURenderCommandsMixin {
    beginOcclusionQuery(queryIndex: GPUSize32): void;
    end(): void;
    endOcclusionQuery(): void;
    executeBundles(bundles: GPURenderBundle[]): void;
    setBlendConstant(color: GPUColor): void;
    setScissorRect(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate, width: GPUIntegerCoordinate, height: GPUIntegerCoordinate): void;
    setStencilReference(reference: GPUStencilValue): void;
    setViewport(x: number, y: number, width: number, height: number, minDepth: number, maxDepth: number): void;
}

declare var GPURenderPassEncoder: {
    prototype: GPURenderPassEncoder;
    new(): GPURenderPassEncoder;
    isInstance: IsInstance<GPURenderPassEncoder>;
};

/** Available only in secure contexts. */
interface GPURenderPipeline extends GPUObjectBase, GPUPipelineBase {
}

declare var GPURenderPipeline: {
    prototype: GPURenderPipeline;
    new(): GPURenderPipeline;
    isInstance: IsInstance<GPURenderPipeline>;
};

/** Available only in secure contexts. */
interface GPUSampler extends GPUObjectBase {
}

declare var GPUSampler: {
    prototype: GPUSampler;
    new(): GPUSampler;
    isInstance: IsInstance<GPUSampler>;
};

/** Available only in secure contexts. */
interface GPUShaderModule extends GPUObjectBase {
    getCompilationInfo(): Promise<GPUCompilationInfo>;
}

declare var GPUShaderModule: {
    prototype: GPUShaderModule;
    new(): GPUShaderModule;
    isInstance: IsInstance<GPUShaderModule>;
};

/** Available only in secure contexts. */
interface GPUSupportedFeatures {
    forEach(callbackfn: (value: string, key: string, parent: GPUSupportedFeatures) => void, thisArg?: any): void;
}

declare var GPUSupportedFeatures: {
    prototype: GPUSupportedFeatures;
    new(): GPUSupportedFeatures;
    isInstance: IsInstance<GPUSupportedFeatures>;
};

/** Available only in secure contexts. */
interface GPUSupportedLimits {
    readonly maxBindGroups: number;
    readonly maxBindGroupsPlusVertexBuffers: number;
    readonly maxBindingsPerBindGroup: number;
    readonly maxBufferSize: number;
    readonly maxColorAttachmentBytesPerSample: number;
    readonly maxColorAttachments: number;
    readonly maxComputeInvocationsPerWorkgroup: number;
    readonly maxComputeWorkgroupSizeX: number;
    readonly maxComputeWorkgroupSizeY: number;
    readonly maxComputeWorkgroupSizeZ: number;
    readonly maxComputeWorkgroupStorageSize: number;
    readonly maxComputeWorkgroupsPerDimension: number;
    readonly maxDynamicStorageBuffersPerPipelineLayout: number;
    readonly maxDynamicUniformBuffersPerPipelineLayout: number;
    readonly maxInterStageShaderVariables: number;
    readonly maxSampledTexturesPerShaderStage: number;
    readonly maxSamplersPerShaderStage: number;
    readonly maxStorageBufferBindingSize: number;
    readonly maxStorageBuffersPerShaderStage: number;
    readonly maxStorageTexturesPerShaderStage: number;
    readonly maxTextureArrayLayers: number;
    readonly maxTextureDimension1D: number;
    readonly maxTextureDimension2D: number;
    readonly maxTextureDimension3D: number;
    readonly maxUniformBufferBindingSize: number;
    readonly maxUniformBuffersPerShaderStage: number;
    readonly maxVertexAttributes: number;
    readonly maxVertexBufferArrayStride: number;
    readonly maxVertexBuffers: number;
    readonly minStorageBufferOffsetAlignment: number;
    readonly minUniformBufferOffsetAlignment: number;
}

declare var GPUSupportedLimits: {
    prototype: GPUSupportedLimits;
    new(): GPUSupportedLimits;
    isInstance: IsInstance<GPUSupportedLimits>;
};

/** Available only in secure contexts. */
interface GPUTexture extends GPUObjectBase {
    readonly depthOrArrayLayers: GPUIntegerCoordinateOut;
    readonly dimension: GPUTextureDimension;
    readonly format: GPUTextureFormat;
    readonly height: GPUIntegerCoordinateOut;
    readonly mipLevelCount: GPUIntegerCoordinateOut;
    readonly sampleCount: GPUSize32Out;
    readonly usage: GPUFlagsConstant;
    readonly width: GPUIntegerCoordinateOut;
    createView(descriptor?: GPUTextureViewDescriptor): GPUTextureView;
    destroy(): void;
}

declare var GPUTexture: {
    prototype: GPUTexture;
    new(): GPUTexture;
    isInstance: IsInstance<GPUTexture>;
};

/** Available only in secure contexts. */
interface GPUTextureView extends GPUObjectBase {
}

declare var GPUTextureView: {
    prototype: GPUTextureView;
    new(): GPUTextureView;
    isInstance: IsInstance<GPUTextureView>;
};

/** Available only in secure contexts. */
interface GPUUncapturedErrorEvent extends Event {
    readonly error: GPUError;
}

declare var GPUUncapturedErrorEvent: {
    prototype: GPUUncapturedErrorEvent;
    new(type: string, gpuUncapturedErrorEventInitDict: GPUUncapturedErrorEventInit): GPUUncapturedErrorEvent;
    isInstance: IsInstance<GPUUncapturedErrorEvent>;
};

/** Available only in secure contexts. */
interface GPUValidationError extends GPUError {
}

declare var GPUValidationError: {
    prototype: GPUValidationError;
    new(message: string): GPUValidationError;
    isInstance: IsInstance<GPUValidationError>;
};

interface GainNode extends AudioNode, AudioNodePassThrough {
    readonly gain: AudioParam;
}

declare var GainNode: {
    prototype: GainNode;
    new(context: BaseAudioContext, options?: GainOptions): GainNode;
    isInstance: IsInstance<GainNode>;
};

interface Gamepad {
    readonly axes: number[];
    readonly buttons: GamepadButton[];
    readonly connected: boolean;
    readonly displayId: number;
    readonly hand: GamepadHand;
    readonly hapticActuators: GamepadHapticActuator[];
    readonly id: string;
    readonly index: number;
    readonly lightIndicators: GamepadLightIndicator[];
    readonly mapping: GamepadMappingType;
    readonly pose: GamepadPose | null;
    readonly timestamp: DOMHighResTimeStamp;
    readonly touchEvents: GamepadTouch[];
}

declare var Gamepad: {
    prototype: Gamepad;
    new(): Gamepad;
    isInstance: IsInstance<Gamepad>;
};

interface GamepadAxisMoveEvent extends GamepadEvent {
    readonly axis: number;
    readonly value: number;
}

declare var GamepadAxisMoveEvent: {
    prototype: GamepadAxisMoveEvent;
    new(type: string, eventInitDict?: GamepadAxisMoveEventInit): GamepadAxisMoveEvent;
    isInstance: IsInstance<GamepadAxisMoveEvent>;
};

interface GamepadButton {
    readonly pressed: boolean;
    readonly touched: boolean;
    readonly value: number;
}

declare var GamepadButton: {
    prototype: GamepadButton;
    new(): GamepadButton;
    isInstance: IsInstance<GamepadButton>;
};

interface GamepadButtonEvent extends GamepadEvent {
    readonly button: number;
}

declare var GamepadButtonEvent: {
    prototype: GamepadButtonEvent;
    new(type: string, eventInitDict?: GamepadButtonEventInit): GamepadButtonEvent;
    isInstance: IsInstance<GamepadButtonEvent>;
};

interface GamepadEvent extends Event {
    readonly gamepad: Gamepad | null;
}

declare var GamepadEvent: {
    prototype: GamepadEvent;
    new(type: string, eventInitDict?: GamepadEventInit): GamepadEvent;
    isInstance: IsInstance<GamepadEvent>;
};

interface GamepadHapticActuator {
    readonly type: GamepadHapticActuatorType;
    pulse(value: number, duration: number): Promise<boolean>;
}

declare var GamepadHapticActuator: {
    prototype: GamepadHapticActuator;
    new(): GamepadHapticActuator;
    isInstance: IsInstance<GamepadHapticActuator>;
};

interface GamepadLightIndicator {
    readonly type: GamepadLightIndicatorType;
    setColor(color: GamepadLightColor): Promise<boolean>;
}

declare var GamepadLightIndicator: {
    prototype: GamepadLightIndicator;
    new(): GamepadLightIndicator;
    isInstance: IsInstance<GamepadLightIndicator>;
};

interface GamepadPose {
    readonly angularAcceleration: Float32Array | null;
    readonly angularVelocity: Float32Array | null;
    readonly hasOrientation: boolean;
    readonly hasPosition: boolean;
    readonly linearAcceleration: Float32Array | null;
    readonly linearVelocity: Float32Array | null;
    readonly orientation: Float32Array | null;
    readonly position: Float32Array | null;
}

declare var GamepadPose: {
    prototype: GamepadPose;
    new(): GamepadPose;
    isInstance: IsInstance<GamepadPose>;
};

interface GamepadServiceTest {
    readonly leftHand: GamepadHand;
    readonly noHand: GamepadHand;
    readonly noMapping: GamepadMappingType;
    readonly rightHand: GamepadHand;
    readonly standardMapping: GamepadMappingType;
    addGamepad(id: string, mapping: GamepadMappingType, hand: GamepadHand, numButtons: number, numAxes: number, numHaptics: number, numLightIndicator: number, numTouchEvents: number): Promise<number>;
    newAxisMoveEvent(index: number, axis: number, value: number): Promise<number>;
    newButtonEvent(index: number, button: number, pressed: boolean, touched: boolean): Promise<number>;
    newButtonValueEvent(index: number, button: number, pressed: boolean, touched: boolean, value: number): Promise<number>;
    newPoseMove(index: number, orient: Float32Array | null, pos: Float32Array | null, angVelocity: Float32Array | null, angAcceleration: Float32Array | null, linVelocity: Float32Array | null, linAcceleration: Float32Array | null): Promise<number>;
    newTouch(index: number, aTouchArrayIndex: number, touchId: number, surfaceId: number, position: Float32Array, surfaceDimension: Float32Array | null): Promise<number>;
    removeGamepad(index: number): Promise<number>;
}

declare var GamepadServiceTest: {
    prototype: GamepadServiceTest;
    new(): GamepadServiceTest;
    isInstance: IsInstance<GamepadServiceTest>;
};

interface GamepadTouch {
    readonly position: Float32Array;
    readonly surfaceDimensions: Uint32Array | null;
    readonly surfaceId: number;
    readonly touchId: number;
}

declare var GamepadTouch: {
    prototype: GamepadTouch;
    new(): GamepadTouch;
    isInstance: IsInstance<GamepadTouch>;
};

interface GenericTransformStream {
    readonly readable: ReadableStream;
    readonly writable: WritableStream;
}

interface Geolocation {
    clearWatch(watchId: number): void;
    getCurrentPosition(successCallback: PositionCallback, errorCallback?: PositionErrorCallback | null, options?: PositionOptions): void;
    watchPosition(successCallback: PositionCallback, errorCallback?: PositionErrorCallback | null, options?: PositionOptions): number;
}

declare var Geolocation: {
    prototype: Geolocation;
    new(): Geolocation;
    isInstance: IsInstance<Geolocation>;
};

/** Available only in secure contexts. */
interface GeolocationCoordinates {
    readonly accuracy: number;
    readonly altitude: number | null;
    readonly altitudeAccuracy: number | null;
    readonly heading: number | null;
    readonly latitude: number;
    readonly longitude: number;
    readonly speed: number | null;
    toJSON(): any;
}

declare var GeolocationCoordinates: {
    prototype: GeolocationCoordinates;
    new(): GeolocationCoordinates;
    isInstance: IsInstance<GeolocationCoordinates>;
};

/** Available only in secure contexts. */
interface GeolocationPosition {
    readonly coords: GeolocationCoordinates;
    readonly timestamp: EpochTimeStamp;
    toJSON(): any;
}

declare var GeolocationPosition: {
    prototype: GeolocationPosition;
    new(): GeolocationPosition;
    isInstance: IsInstance<GeolocationPosition>;
};

interface GeolocationPositionError {
    readonly code: number;
    readonly message: string;
    readonly PERMISSION_DENIED: 1;
    readonly POSITION_UNAVAILABLE: 2;
    readonly TIMEOUT: 3;
}

declare var GeolocationPositionError: {
    prototype: GeolocationPositionError;
    new(): GeolocationPositionError;
    readonly PERMISSION_DENIED: 1;
    readonly POSITION_UNAVAILABLE: 2;
    readonly TIMEOUT: 3;
    isInstance: IsInstance<GeolocationPositionError>;
};

interface GeometryUtils {
    convertPointFromNode(point: DOMPointInit, from: GeometryNode, options?: ConvertCoordinateOptions): DOMPoint;
    convertQuadFromNode(quad: DOMQuad, from: GeometryNode, options?: ConvertCoordinateOptions): DOMQuad;
    convertRectFromNode(rect: DOMRectReadOnly, from: GeometryNode, options?: ConvertCoordinateOptions): DOMQuad;
    getBoxQuads(options?: BoxQuadOptions): DOMQuad[];
    getBoxQuadsFromWindowOrigin(options?: BoxQuadOptions): DOMQuad[];
}

interface GetUserMediaRequest {
    readonly callID: string;
    readonly devices: nsIMediaDevice[];
    readonly innerWindowID: number;
    readonly isHandlingUserInput: boolean;
    readonly isSecure: boolean;
    readonly mediaSource: string;
    readonly rawID: string;
    readonly type: GetUserMediaRequestType;
    readonly windowID: number;
    getAudioOutputOptions(): AudioOutputOptions;
    getConstraints(): MediaStreamConstraints;
}

interface GleanBoolean extends GleanMetric {
    set(value: boolean): void;
    testGetValue(aPingName?: string): boolean | null;
}

declare var GleanBoolean: {
    prototype: GleanBoolean;
    new(): GleanBoolean;
    isInstance: IsInstance<GleanBoolean>;
};

interface GleanCategory {
}

declare var GleanCategory: {
    prototype: GleanCategory;
    new(): GleanCategory;
    isInstance: IsInstance<GleanCategory>;
};

interface GleanCounter extends GleanMetric {
    add(aAmount?: number): void;
    testGetValue(aPingName?: string): number | null;
}

declare var GleanCounter: {
    prototype: GleanCounter;
    new(): GleanCounter;
    isInstance: IsInstance<GleanCounter>;
};

interface GleanCustomDistribution extends GleanMetric {
    accumulateSamples(aSamples: number[]): void;
    accumulateSingleSample(aSample: number): void;
    testGetValue(aPingName?: string): GleanDistributionData | null;
}

declare var GleanCustomDistribution: {
    prototype: GleanCustomDistribution;
    new(): GleanCustomDistribution;
    isInstance: IsInstance<GleanCustomDistribution>;
};

interface GleanDatetime extends GleanMetric {
    set(aValue?: number): void;
    testGetValue(aPingName?: string): any;
}

declare var GleanDatetime: {
    prototype: GleanDatetime;
    new(): GleanDatetime;
    isInstance: IsInstance<GleanDatetime>;
};

interface GleanDenominator extends GleanMetric {
    add(aAmount?: number): void;
    testGetValue(aPingName?: string): number | null;
}

declare var GleanDenominator: {
    prototype: GleanDenominator;
    new(): GleanDenominator;
    isInstance: IsInstance<GleanDenominator>;
};

interface GleanEvent extends GleanMetric {
    record(aExtra?: Record<string, string | null> | null): void;
    testGetValue(aPingName?: string): GleanEventRecord[] | null;
}

declare var GleanEvent: {
    prototype: GleanEvent;
    new(): GleanEvent;
    isInstance: IsInstance<GleanEvent>;
};

interface GleanImpl {
}

declare var GleanImpl: {
    prototype: GleanImpl;
    new(): GleanImpl;
    isInstance: IsInstance<GleanImpl>;
};

interface GleanLabeled {
}

declare var GleanLabeled: {
    prototype: GleanLabeled;
    new(): GleanLabeled;
    isInstance: IsInstance<GleanLabeled>;
};

interface GleanMemoryDistribution extends GleanMetric {
    accumulate(aSample: number): void;
    testGetValue(aPingName?: string): GleanDistributionData | null;
}

declare var GleanMemoryDistribution: {
    prototype: GleanMemoryDistribution;
    new(): GleanMemoryDistribution;
    isInstance: IsInstance<GleanMemoryDistribution>;
};

interface GleanMetric {
}

declare var GleanMetric: {
    prototype: GleanMetric;
    new(): GleanMetric;
    isInstance: IsInstance<GleanMetric>;
};

interface GleanNumerator extends GleanMetric {
    addToNumerator(aAmount?: number): void;
    testGetValue(aPingName?: string): GleanRateData | null;
}

declare var GleanNumerator: {
    prototype: GleanNumerator;
    new(): GleanNumerator;
    isInstance: IsInstance<GleanNumerator>;
};

interface GleanObject extends GleanMetric {
    set(value: any): void;
    testGetValue(aPingName?: string): any;
}

declare var GleanObject: {
    prototype: GleanObject;
    new(): GleanObject;
    isInstance: IsInstance<GleanObject>;
};

interface GleanPingsImpl {
}

declare var GleanPingsImpl: {
    prototype: GleanPingsImpl;
    new(): GleanPingsImpl;
    isInstance: IsInstance<GleanPingsImpl>;
};

interface GleanQuantity extends GleanMetric {
    set(aValue: number): void;
    testGetValue(aPingName?: string): number | null;
}

declare var GleanQuantity: {
    prototype: GleanQuantity;
    new(): GleanQuantity;
    isInstance: IsInstance<GleanQuantity>;
};

interface GleanRate extends GleanMetric {
    addToDenominator(aAmount?: number): void;
    addToNumerator(aAmount?: number): void;
    testGetValue(aPingName?: string): GleanRateData | null;
}

declare var GleanRate: {
    prototype: GleanRate;
    new(): GleanRate;
    isInstance: IsInstance<GleanRate>;
};

interface GleanString extends GleanMetric {
    set(aValue: string | null): void;
    testGetValue(aPingName?: string): string | null;
}

declare var GleanString: {
    prototype: GleanString;
    new(): GleanString;
    isInstance: IsInstance<GleanString>;
};

interface GleanStringList extends GleanMetric {
    add(value: string): void;
    set(aValue: string[]): void;
    testGetValue(aPingName?: string): string[] | null;
}

declare var GleanStringList: {
    prototype: GleanStringList;
    new(): GleanStringList;
    isInstance: IsInstance<GleanStringList>;
};

interface GleanText extends GleanMetric {
    set(aValue: string): void;
    testGetValue(aPingName?: string): string | null;
}

declare var GleanText: {
    prototype: GleanText;
    new(): GleanText;
    isInstance: IsInstance<GleanText>;
};

interface GleanTimespan extends GleanMetric {
    cancel(): void;
    setRaw(aDuration: number): void;
    start(): void;
    stop(): void;
    testGetValue(aPingName?: string): number | null;
}

declare var GleanTimespan: {
    prototype: GleanTimespan;
    new(): GleanTimespan;
    isInstance: IsInstance<GleanTimespan>;
};

interface GleanTimingDistribution extends GleanMetric {
    accumulateSamples(aSamples: number[]): void;
    accumulateSingleSample(aSample: number): void;
    cancel(aId: number): void;
    start(): number;
    stopAndAccumulate(aId: number): void;
    testAccumulateRawMillis(aSample: number): void;
    testGetValue(aPingName?: string): GleanDistributionData | null;
}

declare var GleanTimingDistribution: {
    prototype: GleanTimingDistribution;
    new(): GleanTimingDistribution;
    isInstance: IsInstance<GleanTimingDistribution>;
};

interface GleanUrl extends GleanMetric {
    set(aValue: string): void;
    testGetValue(aPingName?: string): string | null;
}

declare var GleanUrl: {
    prototype: GleanUrl;
    new(): GleanUrl;
    isInstance: IsInstance<GleanUrl>;
};

interface GleanUuid extends GleanMetric {
    generateAndSet(): void;
    set(aValue: string): void;
    testGetValue(aPingName?: string): string | null;
}

declare var GleanUuid: {
    prototype: GleanUuid;
    new(): GleanUuid;
    isInstance: IsInstance<GleanUuid>;
};

interface GlobalCrypto {
    readonly crypto: Crypto;
}

interface GlobalEventHandlersEventMap {
    "abort": Event;
    "animationcancel": Event;
    "animationend": Event;
    "animationiteration": Event;
    "animationstart": Event;
    "auxclick": Event;
    "beforeinput": Event;
    "beforematch": Event;
    "beforetoggle": Event;
    "blur": Event;
    "cancel": Event;
    "canplay": Event;
    "canplaythrough": Event;
    "change": Event;
    "click": Event;
    "close": Event;
    "contentvisibilityautostatechange": Event;
    "contextlost": Event;
    "contextmenu": Event;
    "contextrestored": Event;
    "copy": Event;
    "cuechange": Event;
    "cut": Event;
    "dblclick": Event;
    "drag": Event;
    "dragend": Event;
    "dragenter": Event;
    "dragexit": Event;
    "dragleave": Event;
    "dragover": Event;
    "dragstart": Event;
    "drop": Event;
    "durationchange": Event;
    "emptied": Event;
    "ended": Event;
    "focus": Event;
    "formdata": Event;
    "gotpointercapture": Event;
    "input": Event;
    "invalid": Event;
    "keydown": Event;
    "keypress": Event;
    "keyup": Event;
    "load": Event;
    "loadeddata": Event;
    "loadedmetadata": Event;
    "loadstart": Event;
    "lostpointercapture": Event;
    "mousedown": Event;
    "mouseenter": Event;
    "mouseleave": Event;
    "mousemove": Event;
    "mouseout": Event;
    "mouseover": Event;
    "mouseup": Event;
    "mozfullscreenchange": Event;
    "mozfullscreenerror": Event;
    "paste": Event;
    "pause": Event;
    "play": Event;
    "playing": Event;
    "pointercancel": Event;
    "pointerdown": Event;
    "pointerenter": Event;
    "pointerleave": Event;
    "pointermove": Event;
    "pointerout": Event;
    "pointerover": Event;
    "pointerrawupdate": Event;
    "pointerup": Event;
    "progress": Event;
    "ratechange": Event;
    "reset": Event;
    "resize": Event;
    "scroll": Event;
    "scrollend": Event;
    "securitypolicyviolation": Event;
    "seeked": Event;
    "seeking": Event;
    "select": Event;
    "selectionchange": Event;
    "selectstart": Event;
    "slotchange": Event;
    "stalled": Event;
    "submit": Event;
    "suspend": Event;
    "timeupdate": Event;
    "toggle": Event;
    "transitioncancel": Event;
    "transitionend": Event;
    "transitionrun": Event;
    "transitionstart": Event;
    "volumechange": Event;
    "waiting": Event;
    "webkitanimationend": Event;
    "webkitanimationiteration": Event;
    "webkitanimationstart": Event;
    "webkittransitionend": Event;
    "wheel": Event;
}

interface GlobalEventHandlers {
    onabort: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onanimationcancel: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onanimationend: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onanimationiteration: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onanimationstart: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onauxclick: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onbeforeinput: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onbeforematch: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onbeforetoggle: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onblur: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    oncancel: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    oncanplay: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    oncanplaythrough: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onclick: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onclose: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    oncontentvisibilityautostatechange: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    oncontextlost: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    oncontextmenu: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    oncontextrestored: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    oncopy: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    oncuechange: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    oncut: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ondblclick: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ondrag: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ondragend: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ondragenter: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ondragexit: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ondragleave: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ondragover: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ondragstart: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ondrop: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ondurationchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onemptied: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onended: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onfocus: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onformdata: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ongotpointercapture: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    oninput: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    oninvalid: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onkeydown: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onkeypress: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onkeyup: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onload: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onloadeddata: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onloadedmetadata: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onloadstart: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onlostpointercapture: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onmousedown: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onmouseenter: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onmouseleave: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onmousemove: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onmouseout: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onmouseover: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onmouseup: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onmozfullscreenchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onmozfullscreenerror: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onpaste: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onpause: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onplay: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onplaying: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onpointercancel: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onpointerdown: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onpointerenter: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onpointerleave: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onpointermove: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onpointerout: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onpointerover: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    /** Available only in secure contexts. */
    onpointerrawupdate: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onpointerup: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onprogress: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onratechange: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onreset: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onresize: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onscroll: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onscrollend: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onsecuritypolicyviolation: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onseeked: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onseeking: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onselect: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onselectionchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onselectstart: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onslotchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onstalled: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onsubmit: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onsuspend: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ontimeupdate: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ontoggle: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ontransitioncancel: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ontransitionend: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ontransitionrun: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    ontransitionstart: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onvolumechange: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onwaiting: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onwebkitanimationend: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onwebkitanimationiteration: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onwebkitanimationstart: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onwebkittransitionend: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    onwheel: ((this: GlobalEventHandlers, ev: Event) => any) | null;
    addEventListener<K extends keyof GlobalEventHandlersEventMap>(type: K, listener: (this: GlobalEventHandlers, ev: GlobalEventHandlersEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof GlobalEventHandlersEventMap>(type: K, listener: (this: GlobalEventHandlers, ev: GlobalEventHandlersEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

interface GlobalPrivacyControl {
    readonly globalPrivacyControl: boolean;
}

interface GlobalProcessScriptLoader {
    readonly initialProcessData: any;
    readonly sharedData: MozWritableSharedMap;
}

interface Grid {
    readonly areas: GridArea[];
    readonly cols: GridDimension;
    readonly rows: GridDimension;
}

declare var Grid: {
    prototype: Grid;
    new(): Grid;
    isInstance: IsInstance<Grid>;
};

interface GridArea {
    readonly columnEnd: number;
    readonly columnStart: number;
    readonly name: string;
    readonly rowEnd: number;
    readonly rowStart: number;
    readonly type: GridDeclaration;
}

declare var GridArea: {
    prototype: GridArea;
    new(): GridArea;
    isInstance: IsInstance<GridArea>;
};

interface GridDimension {
    readonly lines: GridLines;
    readonly tracks: GridTracks;
}

declare var GridDimension: {
    prototype: GridDimension;
    new(): GridDimension;
    isInstance: IsInstance<GridDimension>;
};

interface GridLine {
    readonly breadth: number;
    readonly names: string[];
    readonly negativeNumber: number;
    readonly number: number;
    readonly start: number;
    readonly type: GridDeclaration;
}

declare var GridLine: {
    prototype: GridLine;
    new(): GridLine;
    isInstance: IsInstance<GridLine>;
};

interface GridLines {
    readonly length: number;
    item(index: number): GridLine | null;
    [index: number]: GridLine;
}

declare var GridLines: {
    prototype: GridLines;
    new(): GridLines;
    isInstance: IsInstance<GridLines>;
};

interface GridTrack {
    readonly breadth: number;
    readonly start: number;
    readonly state: GridTrackState;
    readonly type: GridDeclaration;
}

declare var GridTrack: {
    prototype: GridTrack;
    new(): GridTrack;
    isInstance: IsInstance<GridTrack>;
};

interface GridTracks {
    readonly length: number;
    item(index: number): GridTrack | null;
    [index: number]: GridTrack;
}

declare var GridTracks: {
    prototype: GridTracks;
    new(): GridTracks;
    isInstance: IsInstance<GridTracks>;
};

interface HTMLAllCollection {
    readonly length: number;
    item(nameOrIndex?: string): HTMLCollection | Element | null;
    namedItem(name: string): HTMLCollection | Element | null;
    [index: number]: Element;
}

declare var HTMLAllCollection: {
    prototype: HTMLAllCollection;
    new(): HTMLAllCollection;
    isInstance: IsInstance<HTMLAllCollection>;
};

interface HTMLAnchorElement extends HTMLElement, HTMLHyperlinkElementUtils {
    charset: string;
    coords: string;
    download: string;
    hreflang: string;
    name: string;
    ping: string;
    referrerPolicy: string;
    rel: string;
    readonly relList: DOMTokenList;
    rev: string;
    shape: string;
    target: string;
    text: string;
    type: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLAnchorElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLAnchorElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLAnchorElement: {
    prototype: HTMLAnchorElement;
    new(): HTMLAnchorElement;
    isInstance: IsInstance<HTMLAnchorElement>;
};

interface HTMLAreaElement extends HTMLElement, HTMLHyperlinkElementUtils {
    alt: string;
    coords: string;
    download: string;
    noHref: boolean;
    ping: string;
    referrerPolicy: string;
    rel: string;
    readonly relList: DOMTokenList;
    shape: string;
    target: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLAreaElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLAreaElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLAreaElement: {
    prototype: HTMLAreaElement;
    new(): HTMLAreaElement;
    isInstance: IsInstance<HTMLAreaElement>;
};

interface HTMLAudioElement extends HTMLMediaElement {
    addEventListener<K extends keyof HTMLMediaElementEventMap>(type: K, listener: (this: HTMLAudioElement, ev: HTMLMediaElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLMediaElementEventMap>(type: K, listener: (this: HTMLAudioElement, ev: HTMLMediaElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLAudioElement: {
    prototype: HTMLAudioElement;
    new(): HTMLAudioElement;
    isInstance: IsInstance<HTMLAudioElement>;
};

interface HTMLBRElement extends HTMLElement {
    clear: string;
    readonly isPaddingForEmptyEditor: boolean;
    readonly isPaddingForEmptyLastLine: boolean;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLBRElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLBRElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLBRElement: {
    prototype: HTMLBRElement;
    new(): HTMLBRElement;
    isInstance: IsInstance<HTMLBRElement>;
};

interface HTMLBaseElement extends HTMLElement {
    href: string;
    target: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLBaseElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLBaseElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLBaseElement: {
    prototype: HTMLBaseElement;
    new(): HTMLBaseElement;
    isInstance: IsInstance<HTMLBaseElement>;
};

interface HTMLBodyElementEventMap extends HTMLElementEventMap, WindowEventHandlersEventMap {
}

interface HTMLBodyElement extends HTMLElement, WindowEventHandlers {
    aLink: string;
    background: string;
    bgColor: string;
    link: string;
    text: string;
    vLink: string;
    addEventListener<K extends keyof HTMLBodyElementEventMap>(type: K, listener: (this: HTMLBodyElement, ev: HTMLBodyElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLBodyElementEventMap>(type: K, listener: (this: HTMLBodyElement, ev: HTMLBodyElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLBodyElement: {
    prototype: HTMLBodyElement;
    new(): HTMLBodyElement;
    isInstance: IsInstance<HTMLBodyElement>;
};

interface HTMLButtonElement extends HTMLElement, InvokerElement, PopoverInvokerElement {
    disabled: boolean;
    readonly form: HTMLFormElement | null;
    formAction: string;
    formEnctype: string;
    formMethod: string;
    formNoValidate: boolean;
    formTarget: string;
    readonly labels: NodeList;
    name: string;
    type: string;
    readonly validationMessage: string;
    readonly validity: ValidityState;
    value: string;
    readonly willValidate: boolean;
    checkValidity(): boolean;
    reportValidity(): boolean;
    setCustomValidity(error: string): void;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLButtonElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLButtonElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLButtonElement: {
    prototype: HTMLButtonElement;
    new(): HTMLButtonElement;
    isInstance: IsInstance<HTMLButtonElement>;
};

interface HTMLCanvasElement extends HTMLElement {
    height: number;
    mozOpaque: boolean;
    mozPrintCallback: PrintCallback | null;
    width: number;
    captureStream(frameRate?: number): CanvasCaptureMediaStream;
    getContext(contextId: string, contextOptions?: any): nsISupports | null;
    toBlob(callback: BlobCallback, type?: string, encoderOptions?: any): void;
    toDataURL(type?: string, encoderOptions?: any): string;
    transferControlToOffscreen(): OffscreenCanvas;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLCanvasElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLCanvasElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLCanvasElement: {
    prototype: HTMLCanvasElement;
    new(): HTMLCanvasElement;
    isInstance: IsInstance<HTMLCanvasElement>;
};

interface HTMLCollectionBase {
    readonly length: number;
    item(index: number): Element | null;
    [index: number]: Element;
}

interface HTMLCollection extends HTMLCollectionBase {
    namedItem(name: string): Element | null;
}

declare var HTMLCollection: {
    prototype: HTMLCollection;
    new(): HTMLCollection;
    isInstance: IsInstance<HTMLCollection>;
};

interface HTMLDListElement extends HTMLElement {
    compact: boolean;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLDListElement: {
    prototype: HTMLDListElement;
    new(): HTMLDListElement;
    isInstance: IsInstance<HTMLDListElement>;
};

interface HTMLDataElement extends HTMLElement {
    value: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDataElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDataElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLDataElement: {
    prototype: HTMLDataElement;
    new(): HTMLDataElement;
    isInstance: IsInstance<HTMLDataElement>;
};

interface HTMLDataListElement extends HTMLElement {
    readonly options: HTMLCollection;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDataListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDataListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLDataListElement: {
    prototype: HTMLDataListElement;
    new(): HTMLDataListElement;
    isInstance: IsInstance<HTMLDataListElement>;
};

interface HTMLDetailsElement extends HTMLElement {
    name: string;
    open: boolean;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDetailsElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDetailsElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLDetailsElement: {
    prototype: HTMLDetailsElement;
    new(): HTMLDetailsElement;
    isInstance: IsInstance<HTMLDetailsElement>;
};

interface HTMLDialogElement extends HTMLElement {
    closedBy: string;
    open: boolean;
    returnValue: string;
    close(returnValue?: string): void;
    requestClose(returnValue?: string): void;
    show(): void;
    showModal(): void;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDialogElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDialogElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLDialogElement: {
    prototype: HTMLDialogElement;
    new(): HTMLDialogElement;
    isInstance: IsInstance<HTMLDialogElement>;
};

interface HTMLDirectoryElement extends HTMLElement {
    compact: boolean;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDirectoryElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDirectoryElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLDirectoryElement: {
    prototype: HTMLDirectoryElement;
    new(): HTMLDirectoryElement;
    isInstance: IsInstance<HTMLDirectoryElement>;
};

interface HTMLDivElement extends HTMLElement {
    align: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDivElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDivElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLDivElement: {
    prototype: HTMLDivElement;
    new(): HTMLDivElement;
    isInstance: IsInstance<HTMLDivElement>;
};

interface HTMLDocument extends Document {
    addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: HTMLDocument, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: HTMLDocument, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    [name: string]: any;
}

declare var HTMLDocument: {
    prototype: HTMLDocument;
    new(): HTMLDocument;
    isInstance: IsInstance<HTMLDocument>;
};

interface HTMLElementEventMap extends ElementEventMap, GlobalEventHandlersEventMap, OnErrorEventHandlerForNodesEventMap, TouchEventHandlersEventMap {
}

interface HTMLElement extends Element, ElementCSSInlineStyle, GlobalEventHandlers, HTMLOrForeignElement, OnErrorEventHandlerForNodes, TouchEventHandlers {
    accessKey: string;
    readonly accessKeyLabel: string;
    autocapitalize: string;
    autocorrect: boolean;
    contentEditable: string;
    dir: string;
    draggable: boolean;
    enterKeyHint: string;
    hidden: boolean | number | string | null;
    inert: boolean;
    innerText: string;
    inputMode: string;
    readonly internals: ElementInternals | null;
    readonly isContentEditable: boolean;
    readonly isFormAssociatedCustomElements: boolean;
    lang: string;
    nonce: string;
    readonly offsetHeight: number;
    readonly offsetLeft: number;
    readonly offsetParent: Element | null;
    readonly offsetTop: number;
    readonly offsetWidth: number;
    outerText: string;
    popover: string | null;
    spellcheck: boolean;
    title: string;
    translate: boolean;
    attachInternals(): ElementInternals;
    click(): void;
    hidePopover(): void;
    showPopover(): void;
    togglePopover(force?: boolean): boolean;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLElement: {
    prototype: HTMLElement;
    new(): HTMLElement;
    isInstance: IsInstance<HTMLElement>;
};

interface HTMLEmbedElement extends HTMLElement, MozFrameLoaderOwner, MozObjectLoadingContent {
    align: string;
    height: string;
    name: string;
    src: string;
    type: string;
    width: string;
    getSVGDocument(): Document | null;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLEmbedElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLEmbedElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLEmbedElement: {
    prototype: HTMLEmbedElement;
    new(): HTMLEmbedElement;
    readonly TYPE_LOADING: 0;
    readonly TYPE_DOCUMENT: 1;
    readonly TYPE_FALLBACK: 2;
    isInstance: IsInstance<HTMLEmbedElement>;
};

interface HTMLFieldSetElement extends HTMLElement {
    disabled: boolean;
    readonly elements: HTMLCollection;
    readonly form: HTMLFormElement | null;
    name: string;
    readonly type: string;
    readonly validationMessage: string;
    readonly validity: ValidityState;
    readonly willValidate: boolean;
    checkValidity(): boolean;
    reportValidity(): boolean;
    setCustomValidity(error: string): void;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFieldSetElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFieldSetElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLFieldSetElement: {
    prototype: HTMLFieldSetElement;
    new(): HTMLFieldSetElement;
    isInstance: IsInstance<HTMLFieldSetElement>;
};

interface HTMLFontElement extends HTMLElement {
    color: string;
    face: string;
    size: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFontElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFontElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLFontElement: {
    prototype: HTMLFontElement;
    new(): HTMLFontElement;
    isInstance: IsInstance<HTMLFontElement>;
};

interface HTMLFormControlsCollection extends HTMLCollectionBase {
    namedItem(name: string): RadioNodeList | Element | null;
}

declare var HTMLFormControlsCollection: {
    prototype: HTMLFormControlsCollection;
    new(): HTMLFormControlsCollection;
    isInstance: IsInstance<HTMLFormControlsCollection>;
};

interface HTMLFormElement extends HTMLElement {
    acceptCharset: string;
    action: string;
    autocomplete: string;
    readonly elements: HTMLFormControlsCollection;
    encoding: string;
    enctype: string;
    readonly length: number;
    method: string;
    name: string;
    noValidate: boolean;
    rel: string;
    readonly relList: DOMTokenList;
    target: string;
    checkValidity(): boolean;
    reportValidity(): boolean;
    requestSubmit(submitter?: HTMLElement | null): void;
    reset(): void;
    submit(): void;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFormElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFormElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    [index: number]: Element;
}

declare var HTMLFormElement: {
    prototype: HTMLFormElement;
    new(): HTMLFormElement;
    isInstance: IsInstance<HTMLFormElement>;
};

interface HTMLFrameElement extends HTMLElement, MozFrameLoaderOwner {
    readonly contentDocument: Document | null;
    readonly contentWindow: WindowProxy | null;
    frameBorder: string;
    longDesc: string;
    marginHeight: string;
    marginWidth: string;
    name: string;
    noResize: boolean;
    scrolling: string;
    src: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFrameElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFrameElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLFrameElement: {
    prototype: HTMLFrameElement;
    new(): HTMLFrameElement;
    isInstance: IsInstance<HTMLFrameElement>;
};

interface HTMLFrameSetElementEventMap extends HTMLElementEventMap, WindowEventHandlersEventMap {
}

interface HTMLFrameSetElement extends HTMLElement, WindowEventHandlers {
    cols: string;
    rows: string;
    addEventListener<K extends keyof HTMLFrameSetElementEventMap>(type: K, listener: (this: HTMLFrameSetElement, ev: HTMLFrameSetElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLFrameSetElementEventMap>(type: K, listener: (this: HTMLFrameSetElement, ev: HTMLFrameSetElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLFrameSetElement: {
    prototype: HTMLFrameSetElement;
    new(): HTMLFrameSetElement;
    isInstance: IsInstance<HTMLFrameSetElement>;
};

interface HTMLHRElement extends HTMLElement {
    align: string;
    color: string;
    noShade: boolean;
    size: string;
    width: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHRElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHRElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLHRElement: {
    prototype: HTMLHRElement;
    new(): HTMLHRElement;
    isInstance: IsInstance<HTMLHRElement>;
};

interface HTMLHeadElement extends HTMLElement {
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHeadElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHeadElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLHeadElement: {
    prototype: HTMLHeadElement;
    new(): HTMLHeadElement;
    isInstance: IsInstance<HTMLHeadElement>;
};

interface HTMLHeadingElement extends HTMLElement {
    align: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHeadingElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHeadingElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLHeadingElement: {
    prototype: HTMLHeadingElement;
    new(): HTMLHeadingElement;
    isInstance: IsInstance<HTMLHeadingElement>;
};

interface HTMLHtmlElement extends HTMLElement {
    version: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHtmlElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHtmlElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLHtmlElement: {
    prototype: HTMLHtmlElement;
    new(): HTMLHtmlElement;
    isInstance: IsInstance<HTMLHtmlElement>;
};

interface HTMLHyperlinkElementUtils {
    hash: string;
    host: string;
    hostname: string;
    href: string;
    toString(): string;
    readonly origin: string;
    password: string;
    pathname: string;
    port: string;
    protocol: string;
    search: string;
    username: string;
}

interface HTMLIFrameElement extends HTMLElement, MozFrameLoaderOwner {
    align: string;
    allow: string;
    allowFullscreen: boolean;
    readonly contentDocument: Document | null;
    readonly contentWindow: WindowProxy | null;
    readonly featurePolicy: FeaturePolicy;
    frameBorder: string;
    height: string;
    loading: string;
    longDesc: string;
    marginHeight: string;
    marginWidth: string;
    name: string;
    referrerPolicy: string;
    readonly sandbox: DOMTokenList;
    scrolling: string;
    src: string;
    srcdoc: TrustedHTML | string;
    width: string;
    getSVGDocument(): Document | null;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLIFrameElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLIFrameElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLIFrameElement: {
    prototype: HTMLIFrameElement;
    new(): HTMLIFrameElement;
    isInstance: IsInstance<HTMLIFrameElement>;
};

interface HTMLImageElement extends HTMLElement, MozImageLoadingContent {
    align: string;
    alt: string;
    border: string;
    readonly complete: boolean;
    crossOrigin: string | null;
    readonly currentSrc: string;
    decoding: string;
    fetchPriority: string;
    height: number;
    hspace: number;
    isMap: boolean;
    loading: string;
    longDesc: string;
    lowsrc: string;
    name: string;
    readonly naturalHeight: number;
    readonly naturalWidth: number;
    referrerPolicy: string;
    sizes: string;
    src: string;
    srcset: string;
    useMap: string;
    vspace: number;
    width: number;
    readonly x: number;
    readonly y: number;
    decode(): Promise<void>;
    recognizeCurrentImageText(): Promise<ImageText[]>;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLImageElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLImageElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLImageElement: {
    prototype: HTMLImageElement;
    new(): HTMLImageElement;
    readonly UNKNOWN_REQUEST: -1;
    readonly CURRENT_REQUEST: 0;
    readonly PENDING_REQUEST: 1;
    isInstance: IsInstance<HTMLImageElement>;
};

interface HTMLInputElement extends HTMLElement, InvokerElement, MozEditableElement, MozImageLoadingContent, PopoverInvokerElement {
    accept: string;
    align: string;
    alt: string;
    autocomplete: string;
    autofillState: string;
    capture: string;
    checked: boolean;
    readonly controllers: XULControllers | null;
    readonly dateTimeBoxElement: Element | null;
    defaultChecked: boolean;
    defaultValue: string;
    dirName: string;
    disabled: boolean;
    files: FileList | null;
    readonly form: HTMLFormElement | null;
    formAction: string;
    formEnctype: string;
    formMethod: string;
    formNoValidate: boolean;
    formTarget: string;
    readonly hasBeenTypePassword: boolean;
    height: number;
    indeterminate: boolean;
    readonly labels: NodeList | null;
    readonly lastInteractiveValue: string;
    readonly list: HTMLDataListElement | null;
    max: string;
    maxLength: number;
    min: string;
    minLength: number;
    multiple: boolean;
    name: string;
    pattern: string;
    placeholder: string;
    previewValue: string;
    readOnly: boolean;
    required: boolean;
    revealPassword: boolean;
    selectionDirection: string | null;
    selectionEnd: number | null;
    selectionStart: number | null;
    size: number;
    src: string;
    step: string;
    readonly textLength: number;
    type: string;
    useMap: string;
    readonly validationMessage: string;
    readonly validity: ValidityState;
    value: string;
    valueAsDate: any;
    valueAsNumber: number;
    readonly webkitEntries: FileSystemEntry[];
    webkitdirectory: boolean;
    width: number;
    readonly willValidate: boolean;
    checkValidity(): boolean;
    closeDateTimePicker(): void;
    getAutocompleteInfo(): AutocompleteInfo | null;
    getDateTimeInputBoxValue(): DateTimeValue;
    getFilesAndDirectories(): Promise<(File | Directory)[]>;
    getMaximum(): number;
    getMinimum(): number;
    getStep(): number;
    getStepBase(): number;
    mozGetFileNameArray(): string[];
    mozIsTextField(aExcludePassword: boolean): boolean;
    mozSetDirectory(directoryPath: string): void;
    mozSetDndFilesAndDirectories(list: (File | Directory)[]): void;
    mozSetFileArray(files: File[]): void;
    mozSetFileNameArray(fileNames: string[]): void;
    openDateTimePicker(initialValue?: DateTimeValue): void;
    reportValidity(): boolean;
    select(): void;
    setCustomValidity(error: string): void;
    setDateTimePickerState(aIsOpen: boolean): void;
    setFocusState(aIsFocused: boolean): void;
    setRangeText(replacement: string): void;
    setRangeText(replacement: string, start: number, end: number, selectionMode?: SelectionMode): void;
    setSelectionRange(start: number, end: number, direction?: string): void;
    showPicker(): void;
    stepDown(n?: number): void;
    stepUp(n?: number): void;
    updateDateTimePicker(value?: DateTimeValue): void;
    updateValidityState(): void;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLInputElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLInputElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLInputElement: {
    prototype: HTMLInputElement;
    new(): HTMLInputElement;
    readonly UNKNOWN_REQUEST: -1;
    readonly CURRENT_REQUEST: 0;
    readonly PENDING_REQUEST: 1;
    isInstance: IsInstance<HTMLInputElement>;
};

interface HTMLLIElement extends HTMLElement {
    type: string;
    value: number;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLIElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLIElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLLIElement: {
    prototype: HTMLLIElement;
    new(): HTMLLIElement;
    isInstance: IsInstance<HTMLLIElement>;
};

interface HTMLLabelElement extends HTMLElement {
    readonly control: HTMLElement | null;
    readonly form: HTMLFormElement | null;
    htmlFor: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLabelElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLabelElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLLabelElement: {
    prototype: HTMLLabelElement;
    new(): HTMLLabelElement;
    isInstance: IsInstance<HTMLLabelElement>;
};

interface HTMLLegendElement extends HTMLElement {
    align: string;
    readonly form: HTMLFormElement | null;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLegendElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLegendElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLLegendElement: {
    prototype: HTMLLegendElement;
    new(): HTMLLegendElement;
    isInstance: IsInstance<HTMLLegendElement>;
};

interface HTMLLinkElement extends HTMLElement, LinkStyle {
    as: string;
    readonly blocking: DOMTokenList;
    charset: string;
    crossOrigin: string | null;
    disabled: boolean;
    fetchPriority: string;
    href: string;
    hreflang: string;
    imageSizes: string;
    imageSrcset: string;
    integrity: string;
    media: string;
    referrerPolicy: string;
    rel: string;
    readonly relList: DOMTokenList;
    rev: string;
    readonly sizes: DOMTokenList;
    target: string;
    type: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLinkElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLinkElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLLinkElement: {
    prototype: HTMLLinkElement;
    new(): HTMLLinkElement;
    isInstance: IsInstance<HTMLLinkElement>;
};

interface HTMLMapElement extends HTMLElement {
    readonly areas: HTMLCollection;
    name: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMapElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMapElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLMapElement: {
    prototype: HTMLMapElement;
    new(): HTMLMapElement;
    isInstance: IsInstance<HTMLMapElement>;
};

interface HTMLMarqueeElement extends HTMLElement {
    behavior: string;
    bgColor: string;
    direction: string;
    height: string;
    hspace: number;
    loop: number;
    scrollAmount: number;
    scrollDelay: number;
    trueSpeed: boolean;
    vspace: number;
    width: string;
    start(): void;
    stop(): void;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMarqueeElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMarqueeElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLMarqueeElement: {
    prototype: HTMLMarqueeElement;
    new(): HTMLMarqueeElement;
    isInstance: IsInstance<HTMLMarqueeElement>;
};

interface HTMLMediaElementEventMap extends HTMLElementEventMap {
    "encrypted": Event;
    "waitingforkey": Event;
}

interface HTMLMediaElement extends HTMLElement {
    readonly allowedToPlay: boolean;
    readonly audiblePlayTime: number;
    readonly audioTracks: AudioTrackList;
    autoplay: boolean;
    readonly buffered: TimeRanges;
    readonly computedMuted: boolean;
    readonly computedVolume: number;
    controls: boolean;
    crossOrigin: string | null;
    readonly currentSrc: string;
    currentTime: number;
    defaultMuted: boolean;
    defaultPlaybackRate: number;
    readonly duration: number;
    readonly ended: boolean;
    readonly error: MediaError | null;
    readonly inaudiblePlayTime: number;
    readonly invisiblePlayTime: number;
    readonly isEncrypted: boolean;
    readonly isInViewPort: boolean;
    readonly isSuspendedByInactiveDocOrDocShell: boolean;
    readonly isVideoDecodingSuspended: boolean;
    loop: boolean;
    readonly mediaKeys: MediaKeys | null;
    mozAllowCasting: boolean;
    readonly mozAudioCaptured: boolean;
    readonly mozFragmentEnd: number;
    mozIsCasting: boolean;
    readonly mozMediaSourceObject: MediaSource | null;
    muted: boolean;
    readonly mutedPlayTime: number;
    readonly networkState: number;
    onencrypted: ((this: HTMLMediaElement, ev: Event) => any) | null;
    onwaitingforkey: ((this: HTMLMediaElement, ev: Event) => any) | null;
    readonly paused: boolean;
    playbackRate: number;
    readonly played: TimeRanges;
    preload: string;
    preservesPitch: boolean;
    readonly readyState: number;
    readonly seekable: TimeRanges;
    readonly seeking: boolean;
    /** Available only in secure contexts. */
    readonly sinkId: string;
    src: string;
    srcObject: MediaStream | null;
    readonly textTracks: TextTrackList | null;
    readonly totalAudioPlayTime: number;
    readonly totalVideoHDRPlayTime: number;
    readonly totalVideoPlayTime: number;
    readonly videoTracks: VideoTrackList;
    readonly visiblePlayTime: number;
    volume: number;
    addTextTrack(kind: TextTrackKind, label?: string, language?: string): TextTrack;
    canPlayType(type: string): string;
    fastSeek(time: number): void;
    hasSuspendTaint(): boolean;
    load(): void;
    mozCaptureStream(): MediaStream;
    mozCaptureStreamUntilEnded(): MediaStream;
    mozGetMetadata(): any;
    mozRequestDebugInfo(): Promise<HTMLMediaElementDebugInfo>;
    mozRequestDebugLog(): Promise<string>;
    pause(): void;
    play(): Promise<void>;
    seekToNextFrame(): Promise<void>;
    setAudioSinkFailedStartup(): void;
    setDecodeError(error: string): void;
    setFormatDiagnosticsReportForMimeType(mimeType: string, error: DecoderDoctorReportType): void;
    setMediaKeys(mediaKeys: MediaKeys | null): Promise<void>;
    /** Available only in secure contexts. */
    setSinkId(sinkId: string): Promise<void>;
    setVisible(aVisible: boolean): void;
    readonly NETWORK_EMPTY: 0;
    readonly NETWORK_IDLE: 1;
    readonly NETWORK_LOADING: 2;
    readonly NETWORK_NO_SOURCE: 3;
    readonly HAVE_NOTHING: 0;
    readonly HAVE_METADATA: 1;
    readonly HAVE_CURRENT_DATA: 2;
    readonly HAVE_FUTURE_DATA: 3;
    readonly HAVE_ENOUGH_DATA: 4;
    addEventListener<K extends keyof HTMLMediaElementEventMap>(type: K, listener: (this: HTMLMediaElement, ev: HTMLMediaElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLMediaElementEventMap>(type: K, listener: (this: HTMLMediaElement, ev: HTMLMediaElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLMediaElement: {
    prototype: HTMLMediaElement;
    new(): HTMLMediaElement;
    readonly NETWORK_EMPTY: 0;
    readonly NETWORK_IDLE: 1;
    readonly NETWORK_LOADING: 2;
    readonly NETWORK_NO_SOURCE: 3;
    readonly HAVE_NOTHING: 0;
    readonly HAVE_METADATA: 1;
    readonly HAVE_CURRENT_DATA: 2;
    readonly HAVE_FUTURE_DATA: 3;
    readonly HAVE_ENOUGH_DATA: 4;
    isInstance: IsInstance<HTMLMediaElement>;
    mozEnableDebugLog(): void;
};

interface HTMLMenuElement extends HTMLElement {
    compact: boolean;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMenuElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMenuElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLMenuElement: {
    prototype: HTMLMenuElement;
    new(): HTMLMenuElement;
    isInstance: IsInstance<HTMLMenuElement>;
};

interface HTMLMetaElement extends HTMLElement {
    content: string;
    httpEquiv: string;
    media: string;
    name: string;
    scheme: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMetaElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMetaElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLMetaElement: {
    prototype: HTMLMetaElement;
    new(): HTMLMetaElement;
    isInstance: IsInstance<HTMLMetaElement>;
};

interface HTMLMeterElement extends HTMLElement {
    high: number;
    readonly labels: NodeList;
    low: number;
    max: number;
    min: number;
    optimum: number;
    value: number;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMeterElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMeterElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLMeterElement: {
    prototype: HTMLMeterElement;
    new(): HTMLMeterElement;
    isInstance: IsInstance<HTMLMeterElement>;
};

interface HTMLModElement extends HTMLElement {
    cite: string;
    dateTime: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLModElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLModElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLModElement: {
    prototype: HTMLModElement;
    new(): HTMLModElement;
    isInstance: IsInstance<HTMLModElement>;
};

interface HTMLOListElement extends HTMLElement {
    compact: boolean;
    reversed: boolean;
    start: number;
    type: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLOListElement: {
    prototype: HTMLOListElement;
    new(): HTMLOListElement;
    isInstance: IsInstance<HTMLOListElement>;
};

interface HTMLObjectElement extends HTMLElement, MozFrameLoaderOwner, MozObjectLoadingContent {
    align: string;
    archive: string;
    border: string;
    code: string;
    codeBase: string;
    codeType: string;
    readonly contentDocument: Document | null;
    readonly contentWindow: WindowProxy | null;
    data: string;
    declare: boolean;
    readonly form: HTMLFormElement | null;
    height: string;
    hspace: number;
    name: string;
    standby: string;
    type: string;
    useMap: string;
    readonly validationMessage: string;
    readonly validity: ValidityState;
    vspace: number;
    width: string;
    readonly willValidate: boolean;
    checkValidity(): boolean;
    getSVGDocument(): Document | null;
    reportValidity(): boolean;
    setCustomValidity(error: string): void;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLObjectElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLObjectElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLObjectElement: {
    prototype: HTMLObjectElement;
    new(): HTMLObjectElement;
    readonly TYPE_LOADING: 0;
    readonly TYPE_DOCUMENT: 1;
    readonly TYPE_FALLBACK: 2;
    isInstance: IsInstance<HTMLObjectElement>;
};

interface HTMLOptGroupElement extends HTMLElement {
    disabled: boolean;
    label: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOptGroupElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOptGroupElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLOptGroupElement: {
    prototype: HTMLOptGroupElement;
    new(): HTMLOptGroupElement;
    isInstance: IsInstance<HTMLOptGroupElement>;
};

interface HTMLOptionElement extends HTMLElement {
    defaultSelected: boolean;
    disabled: boolean;
    readonly form: HTMLFormElement | null;
    readonly index: number;
    label: string;
    selected: boolean;
    text: string;
    value: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOptionElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOptionElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLOptionElement: {
    prototype: HTMLOptionElement;
    new(): HTMLOptionElement;
    isInstance: IsInstance<HTMLOptionElement>;
};

interface HTMLOptionsCollection extends HTMLCollectionBase {
    length: number;
    selectedIndex: number;
    add(element: HTMLOptionElement | HTMLOptGroupElement, before?: HTMLElement | number | null): void;
    remove(index: number): void;
}

declare var HTMLOptionsCollection: {
    prototype: HTMLOptionsCollection;
    new(): HTMLOptionsCollection;
    isInstance: IsInstance<HTMLOptionsCollection>;
};

interface HTMLOrForeignElement {
    autofocus: boolean;
    readonly dataset: DOMStringMap;
    tabIndex: number;
    blur(): void;
    focus(options?: FocusOptions): void;
}

interface HTMLOutputElement extends HTMLElement {
    defaultValue: string;
    readonly form: HTMLFormElement | null;
    readonly htmlFor: DOMTokenList;
    readonly labels: NodeList;
    name: string;
    readonly type: string;
    readonly validationMessage: string;
    readonly validity: ValidityState;
    value: string;
    readonly willValidate: boolean;
    checkValidity(): boolean;
    reportValidity(): boolean;
    setCustomValidity(error: string): void;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOutputElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOutputElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLOutputElement: {
    prototype: HTMLOutputElement;
    new(): HTMLOutputElement;
    isInstance: IsInstance<HTMLOutputElement>;
};

interface HTMLParagraphElement extends HTMLElement {
    align: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLParagraphElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLParagraphElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLParagraphElement: {
    prototype: HTMLParagraphElement;
    new(): HTMLParagraphElement;
    isInstance: IsInstance<HTMLParagraphElement>;
};

interface HTMLParamElement extends HTMLElement {
    name: string;
    type: string;
    value: string;
    valueType: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLParamElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLParamElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLParamElement: {
    prototype: HTMLParamElement;
    new(): HTMLParamElement;
    isInstance: IsInstance<HTMLParamElement>;
};

interface HTMLPictureElement extends HTMLElement {
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLPictureElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLPictureElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLPictureElement: {
    prototype: HTMLPictureElement;
    new(): HTMLPictureElement;
    isInstance: IsInstance<HTMLPictureElement>;
};

interface HTMLPreElement extends HTMLElement {
    width: number;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLPreElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLPreElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLPreElement: {
    prototype: HTMLPreElement;
    new(): HTMLPreElement;
    isInstance: IsInstance<HTMLPreElement>;
};

interface HTMLProgressElement extends HTMLElement {
    readonly labels: NodeList;
    max: number;
    readonly position: number;
    value: number;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLProgressElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLProgressElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLProgressElement: {
    prototype: HTMLProgressElement;
    new(): HTMLProgressElement;
    isInstance: IsInstance<HTMLProgressElement>;
};

interface HTMLQuoteElement extends HTMLElement {
    cite: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLQuoteElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLQuoteElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLQuoteElement: {
    prototype: HTMLQuoteElement;
    new(): HTMLQuoteElement;
    isInstance: IsInstance<HTMLQuoteElement>;
};

// @ts-ignore
interface HTMLScriptElement extends HTMLElement {
    async: boolean;
    readonly blocking: DOMTokenList;
    charset: string;
    crossOrigin: string | null;
    defer: boolean;
    event: string;
    fetchPriority: string;
    htmlFor: string;
    innerText: TrustedScript | string;
    integrity: string;
    noModule: boolean;
    referrerPolicy: string;
    src: TrustedScriptURL | string;
    text: TrustedScript | string;
    textContent: TrustedScript | string | null;
    type: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLScriptElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLScriptElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLScriptElement: {
    prototype: HTMLScriptElement;
    new(): HTMLScriptElement;
    isInstance: IsInstance<HTMLScriptElement>;
    supports(type: string): boolean;
};

interface HTMLSelectElement extends HTMLElement {
    autocomplete: string;
    autofillState: string;
    disabled: boolean;
    readonly form: HTMLFormElement | null;
    readonly isCombobox: boolean;
    readonly labels: NodeList;
    length: number;
    multiple: boolean;
    name: string;
    openInParentProcess: boolean;
    readonly options: HTMLOptionsCollection;
    previewValue: string;
    required: boolean;
    selectedIndex: number;
    readonly selectedOptions: HTMLCollection;
    size: number;
    readonly type: string;
    readonly validationMessage: string;
    readonly validity: ValidityState;
    value: string;
    readonly willValidate: boolean;
    add(element: HTMLOptionElement | HTMLOptGroupElement, before?: HTMLElement | number | null): void;
    checkValidity(): boolean;
    getAutocompleteInfo(): AutocompleteInfo;
    item(index: number): Element | null;
    namedItem(name: string): HTMLOptionElement | null;
    remove(index: number): void;
    remove(): void;
    reportValidity(): boolean;
    setCustomValidity(error: string): void;
    showPicker(): void;
    userFinishedInteracting(changed: boolean): void;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSelectElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSelectElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    [index: number]: Element;
}

declare var HTMLSelectElement: {
    prototype: HTMLSelectElement;
    new(): HTMLSelectElement;
    isInstance: IsInstance<HTMLSelectElement>;
};

interface HTMLSlotElement extends HTMLElement {
    name: string;
    assign(...nodes: (Element | Text)[]): void;
    assignedElements(options?: AssignedNodesOptions): Element[];
    assignedNodes(options?: AssignedNodesOptions): Node[];
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSlotElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSlotElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLSlotElement: {
    prototype: HTMLSlotElement;
    new(): HTMLSlotElement;
    isInstance: IsInstance<HTMLSlotElement>;
};

interface HTMLSourceElement extends HTMLElement {
    height: number;
    media: string;
    sizes: string;
    src: string;
    srcset: string;
    type: string;
    width: number;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSourceElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSourceElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLSourceElement: {
    prototype: HTMLSourceElement;
    new(): HTMLSourceElement;
    isInstance: IsInstance<HTMLSourceElement>;
};

interface HTMLSpanElement extends HTMLElement {
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSpanElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSpanElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLSpanElement: {
    prototype: HTMLSpanElement;
    new(): HTMLSpanElement;
    isInstance: IsInstance<HTMLSpanElement>;
};

interface HTMLStyleElement extends HTMLElement, LinkStyle {
    readonly blocking: DOMTokenList;
    disabled: boolean;
    media: string;
    type: string;
    setDevtoolsAsTriggeringPrincipal(): void;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLStyleElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLStyleElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLStyleElement: {
    prototype: HTMLStyleElement;
    new(): HTMLStyleElement;
    isInstance: IsInstance<HTMLStyleElement>;
};

interface HTMLTableCaptionElement extends HTMLElement {
    align: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableCaptionElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableCaptionElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLTableCaptionElement: {
    prototype: HTMLTableCaptionElement;
    new(): HTMLTableCaptionElement;
    isInstance: IsInstance<HTMLTableCaptionElement>;
};

interface HTMLTableCellElement extends HTMLElement {
    abbr: string;
    align: string;
    axis: string;
    bgColor: string;
    readonly cellIndex: number;
    ch: string;
    chOff: string;
    colSpan: number;
    headers: string;
    height: string;
    noWrap: boolean;
    rowSpan: number;
    scope: string;
    vAlign: string;
    width: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableCellElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableCellElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLTableCellElement: {
    prototype: HTMLTableCellElement;
    new(): HTMLTableCellElement;
    isInstance: IsInstance<HTMLTableCellElement>;
};

interface HTMLTableColElement extends HTMLElement {
    align: string;
    ch: string;
    chOff: string;
    span: number;
    vAlign: string;
    width: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableColElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableColElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLTableColElement: {
    prototype: HTMLTableColElement;
    new(): HTMLTableColElement;
    isInstance: IsInstance<HTMLTableColElement>;
};

interface HTMLTableElement extends HTMLElement {
    align: string;
    bgColor: string;
    border: string;
    caption: HTMLTableCaptionElement | null;
    cellPadding: string;
    cellSpacing: string;
    frame: string;
    readonly rows: HTMLCollection;
    rules: string;
    summary: string;
    readonly tBodies: HTMLCollection;
    tFoot: HTMLTableSectionElement | null;
    tHead: HTMLTableSectionElement | null;
    width: string;
    createCaption(): HTMLElement;
    createTBody(): HTMLElement;
    createTFoot(): HTMLElement;
    createTHead(): HTMLElement;
    deleteCaption(): void;
    deleteRow(index: number): void;
    deleteTFoot(): void;
    deleteTHead(): void;
    insertRow(index?: number): HTMLElement;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLTableElement: {
    prototype: HTMLTableElement;
    new(): HTMLTableElement;
    isInstance: IsInstance<HTMLTableElement>;
};

interface HTMLTableRowElement extends HTMLElement {
    align: string;
    bgColor: string;
    readonly cells: HTMLCollection;
    ch: string;
    chOff: string;
    readonly rowIndex: number;
    readonly sectionRowIndex: number;
    vAlign: string;
    deleteCell(index: number): void;
    insertCell(index?: number): HTMLElement;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableRowElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableRowElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLTableRowElement: {
    prototype: HTMLTableRowElement;
    new(): HTMLTableRowElement;
    isInstance: IsInstance<HTMLTableRowElement>;
};

interface HTMLTableSectionElement extends HTMLElement {
    align: string;
    ch: string;
    chOff: string;
    readonly rows: HTMLCollection;
    vAlign: string;
    deleteRow(index: number): void;
    insertRow(index?: number): HTMLElement;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableSectionElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableSectionElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLTableSectionElement: {
    prototype: HTMLTableSectionElement;
    new(): HTMLTableSectionElement;
    isInstance: IsInstance<HTMLTableSectionElement>;
};

interface HTMLTemplateElement extends HTMLElement {
    readonly content: DocumentFragment;
    shadowRootClonable: boolean;
    shadowRootDelegatesFocus: boolean;
    shadowRootMode: string;
    shadowRootSerializable: boolean;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTemplateElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTemplateElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLTemplateElement: {
    prototype: HTMLTemplateElement;
    new(): HTMLTemplateElement;
    isInstance: IsInstance<HTMLTemplateElement>;
};

interface HTMLTextAreaElement extends HTMLElement, MozEditableElement {
    autocomplete: string;
    autofillState: string;
    cols: number;
    readonly controllers: XULControllers;
    defaultValue: string;
    dirName: string;
    disabled: boolean;
    readonly form: HTMLFormElement | null;
    readonly labels: NodeList;
    maxLength: number;
    minLength: number;
    name: string;
    placeholder: string;
    previewValue: string;
    readOnly: boolean;
    required: boolean;
    rows: number;
    selectionDirection: string | null;
    selectionEnd: number | null;
    selectionStart: number | null;
    readonly textLength: number;
    readonly type: string;
    readonly validationMessage: string;
    readonly validity: ValidityState;
    value: string;
    readonly willValidate: boolean;
    wrap: string;
    checkValidity(): boolean;
    getAutocompleteInfo(): AutocompleteInfo;
    reportValidity(): boolean;
    select(): void;
    setCustomValidity(error: string): void;
    setRangeText(replacement: string): void;
    setRangeText(replacement: string, start: number, end: number, selectionMode?: SelectionMode): void;
    setSelectionRange(start: number, end: number, direction?: string): void;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTextAreaElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTextAreaElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLTextAreaElement: {
    prototype: HTMLTextAreaElement;
    new(): HTMLTextAreaElement;
    isInstance: IsInstance<HTMLTextAreaElement>;
};

interface HTMLTimeElement extends HTMLElement {
    dateTime: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTimeElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTimeElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLTimeElement: {
    prototype: HTMLTimeElement;
    new(): HTMLTimeElement;
    isInstance: IsInstance<HTMLTimeElement>;
};

interface HTMLTitleElement extends HTMLElement {
    text: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTitleElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTitleElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLTitleElement: {
    prototype: HTMLTitleElement;
    new(): HTMLTitleElement;
    isInstance: IsInstance<HTMLTitleElement>;
};

interface HTMLTrackElement extends HTMLElement {
    default: boolean;
    kind: string;
    label: string;
    readonly readyState: number;
    src: string;
    srclang: string;
    readonly track: TextTrack | null;
    readonly NONE: 0;
    readonly LOADING: 1;
    readonly LOADED: 2;
    readonly ERROR: 3;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTrackElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTrackElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLTrackElement: {
    prototype: HTMLTrackElement;
    new(): HTMLTrackElement;
    readonly NONE: 0;
    readonly LOADING: 1;
    readonly LOADED: 2;
    readonly ERROR: 3;
    isInstance: IsInstance<HTMLTrackElement>;
};

interface HTMLUListElement extends HTMLElement {
    compact: boolean;
    type: string;
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLUListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLUListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLUListElement: {
    prototype: HTMLUListElement;
    new(): HTMLUListElement;
    isInstance: IsInstance<HTMLUListElement>;
};

interface HTMLUnknownElement extends HTMLElement {
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLUnknownElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLUnknownElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLUnknownElement: {
    prototype: HTMLUnknownElement;
    new(): HTMLUnknownElement;
    isInstance: IsInstance<HTMLUnknownElement>;
};

interface HTMLVideoElement extends HTMLMediaElement {
    disablePictureInPicture: boolean;
    height: number;
    readonly isCloningElementVisually: boolean;
    readonly mozDecodedFrames: number;
    readonly mozFrameDelay: number;
    readonly mozHasAudio: boolean;
    readonly mozPaintedFrames: number;
    readonly mozParsedFrames: number;
    readonly mozPresentedFrames: number;
    poster: string;
    readonly videoHeight: number;
    readonly videoWidth: number;
    width: number;
    cancelVideoFrameCallback(handle: number): void;
    cloneElementVisually(target: HTMLVideoElement): Promise<void>;
    getVideoPlaybackQuality(): VideoPlaybackQuality;
    requestVideoFrameCallback(callback: VideoFrameRequestCallback): number;
    stopCloningElementVisually(): void;
    addEventListener<K extends keyof HTMLMediaElementEventMap>(type: K, listener: (this: HTMLVideoElement, ev: HTMLMediaElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof HTMLMediaElementEventMap>(type: K, listener: (this: HTMLVideoElement, ev: HTMLMediaElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var HTMLVideoElement: {
    prototype: HTMLVideoElement;
    new(): HTMLVideoElement;
    isInstance: IsInstance<HTMLVideoElement>;
};

interface HashChangeEvent extends Event {
    readonly newURL: string;
    readonly oldURL: string;
}

declare var HashChangeEvent: {
    prototype: HashChangeEvent;
    new(type: string, eventInitDict?: HashChangeEventInit): HashChangeEvent;
    isInstance: IsInstance<HashChangeEvent>;
};

interface Headers {
    guard: HeadersGuardEnum;
    append(name: string, value: string): void;
    delete(name: string): void;
    get(name: string): string | null;
    getSetCookie(): string[];
    has(name: string): boolean;
    set(name: string, value: string): void;
    forEach(callbackfn: (value: string, key: string, parent: Headers) => void, thisArg?: any): void;
}

declare var Headers: {
    prototype: Headers;
    new(init?: HeadersInit): Headers;
    isInstance: IsInstance<Headers>;
};

interface HeapSnapshot {
    readonly creationTime: number | null;
    computeDominatorTree(): DominatorTree;
    computeShortestPaths(start: NodeId, targets: NodeId[], maxNumPaths: number): any;
    describeNode(breakdown: any, node: NodeId): any;
    takeCensus(options: any): any;
}

declare var HeapSnapshot: {
    prototype: HeapSnapshot;
    new(): HeapSnapshot;
    isInstance: IsInstance<HeapSnapshot>;
};

interface Highlight {
    priority: number;
    type: HighlightType;
    forEach(callbackfn: (value: AbstractRange, key: AbstractRange, parent: Highlight) => void, thisArg?: any): void;
}

declare var Highlight: {
    prototype: Highlight;
    new(...initialRanges: AbstractRange[]): Highlight;
    isInstance: IsInstance<Highlight>;
};

interface HighlightRegistry {
    forEach(callbackfn: (value: Highlight, key: string, parent: HighlightRegistry) => void, thisArg?: any): void;
}

declare var HighlightRegistry: {
    prototype: HighlightRegistry;
    new(): HighlightRegistry;
    isInstance: IsInstance<HighlightRegistry>;
};

interface History {
    readonly length: number;
    scrollRestoration: ScrollRestoration;
    readonly state: any;
    back(): void;
    forward(): void;
    go(delta?: number): void;
    pushState(data: any, title: string, url?: string | null): void;
    replaceState(data: any, title: string, url?: string | null): void;
}

declare var History: {
    prototype: History;
    new(): History;
    isInstance: IsInstance<History>;
};

interface IDBCursor {
    readonly direction: IDBCursorDirection;
    readonly key: any;
    readonly primaryKey: any;
    readonly request: IDBRequest;
    readonly source: IDBObjectStore | IDBIndex;
    advance(count: number): void;
    continue(key?: any): void;
    continuePrimaryKey(key: any, primaryKey: any): void;
    delete(): IDBRequest;
    update(value: any): IDBRequest;
}

declare var IDBCursor: {
    prototype: IDBCursor;
    new(): IDBCursor;
    isInstance: IsInstance<IDBCursor>;
};

interface IDBCursorWithValue extends IDBCursor {
    readonly value: any;
}

declare var IDBCursorWithValue: {
    prototype: IDBCursorWithValue;
    new(): IDBCursorWithValue;
    isInstance: IsInstance<IDBCursorWithValue>;
};

interface IDBDatabaseEventMap {
    "abort": Event;
    "close": Event;
    "error": Event;
    "versionchange": Event;
}

interface IDBDatabase extends EventTarget {
    readonly name: string;
    readonly objectStoreNames: DOMStringList;
    onabort: ((this: IDBDatabase, ev: Event) => any) | null;
    onclose: ((this: IDBDatabase, ev: Event) => any) | null;
    onerror: ((this: IDBDatabase, ev: Event) => any) | null;
    onversionchange: ((this: IDBDatabase, ev: Event) => any) | null;
    readonly version: number;
    close(): void;
    createObjectStore(name: string, options?: IDBObjectStoreParameters): IDBObjectStore;
    deleteObjectStore(name: string): void;
    transaction(storeNames: string | string[], mode?: IDBTransactionMode, options?: IDBTransactionOptions): IDBTransaction;
    addEventListener<K extends keyof IDBDatabaseEventMap>(type: K, listener: (this: IDBDatabase, ev: IDBDatabaseEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof IDBDatabaseEventMap>(type: K, listener: (this: IDBDatabase, ev: IDBDatabaseEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var IDBDatabase: {
    prototype: IDBDatabase;
    new(): IDBDatabase;
    isInstance: IsInstance<IDBDatabase>;
};

interface IDBFactory {
    cmp(first: any, second: any): number;
    databases(): Promise<IDBDatabaseInfo[]>;
    deleteDatabase(name: string): IDBOpenDBRequest;
    deleteForPrincipal(principal: Principal, name: string, options?: IDBOpenDBOptions): IDBOpenDBRequest;
    open(name: string, version?: number): IDBOpenDBRequest;
    openForPrincipal(principal: Principal, name: string, version: number): IDBOpenDBRequest;
    openForPrincipal(principal: Principal, name: string, options?: IDBOpenDBOptions): IDBOpenDBRequest;
}

declare var IDBFactory: {
    prototype: IDBFactory;
    new(): IDBFactory;
    isInstance: IsInstance<IDBFactory>;
};

interface IDBIndex {
    readonly isAutoLocale: boolean;
    readonly keyPath: any;
    readonly locale: string | null;
    readonly multiEntry: boolean;
    name: string;
    readonly objectStore: IDBObjectStore;
    readonly unique: boolean;
    count(query?: any): IDBRequest;
    get(query: any): IDBRequest;
    getAll(query?: any, count?: number): IDBRequest;
    getAllKeys(query?: any, count?: number): IDBRequest;
    getKey(query: any): IDBRequest;
    openCursor(query?: any, direction?: IDBCursorDirection): IDBRequest;
    openKeyCursor(query?: any, direction?: IDBCursorDirection): IDBRequest;
}

declare var IDBIndex: {
    prototype: IDBIndex;
    new(): IDBIndex;
    isInstance: IsInstance<IDBIndex>;
};

interface IDBKeyRange {
    readonly lower: any;
    readonly lowerOpen: boolean;
    readonly upper: any;
    readonly upperOpen: boolean;
    includes(key: any): boolean;
}

declare var IDBKeyRange: {
    prototype: IDBKeyRange;
    new(): IDBKeyRange;
    isInstance: IsInstance<IDBKeyRange>;
    bound(lower: any, upper: any, lowerOpen?: boolean, upperOpen?: boolean): IDBKeyRange;
    lowerBound(lower: any, open?: boolean): IDBKeyRange;
    only(value: any): IDBKeyRange;
    upperBound(upper: any, open?: boolean): IDBKeyRange;
};

interface IDBObjectStore {
    readonly autoIncrement: boolean;
    readonly indexNames: DOMStringList;
    readonly keyPath: any;
    name: string;
    readonly transaction: IDBTransaction;
    add(value: any, key?: any): IDBRequest;
    clear(): IDBRequest;
    count(key?: any): IDBRequest;
    createIndex(name: string, keyPath: string | string[], optionalParameters?: IDBIndexParameters): IDBIndex;
    delete(key: any): IDBRequest;
    deleteIndex(indexName: string): void;
    get(key: any): IDBRequest;
    getAll(query?: any, count?: number): IDBRequest;
    getAllKeys(query?: any, count?: number): IDBRequest;
    getKey(key: any): IDBRequest;
    index(name: string): IDBIndex;
    openCursor(range?: any, direction?: IDBCursorDirection): IDBRequest;
    openKeyCursor(query?: any, direction?: IDBCursorDirection): IDBRequest;
    put(value: any, key?: any): IDBRequest;
}

declare var IDBObjectStore: {
    prototype: IDBObjectStore;
    new(): IDBObjectStore;
    isInstance: IsInstance<IDBObjectStore>;
};

interface IDBOpenDBRequestEventMap extends IDBRequestEventMap {
    "blocked": Event;
    "upgradeneeded": Event;
}

interface IDBOpenDBRequest extends IDBRequest {
    onblocked: ((this: IDBOpenDBRequest, ev: Event) => any) | null;
    onupgradeneeded: ((this: IDBOpenDBRequest, ev: Event) => any) | null;
    addEventListener<K extends keyof IDBOpenDBRequestEventMap>(type: K, listener: (this: IDBOpenDBRequest, ev: IDBOpenDBRequestEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof IDBOpenDBRequestEventMap>(type: K, listener: (this: IDBOpenDBRequest, ev: IDBOpenDBRequestEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var IDBOpenDBRequest: {
    prototype: IDBOpenDBRequest;
    new(): IDBOpenDBRequest;
    isInstance: IsInstance<IDBOpenDBRequest>;
};

interface IDBRequestEventMap {
    "error": Event;
    "success": Event;
}

interface IDBRequest extends EventTarget {
    readonly error: DOMException | null;
    onerror: ((this: IDBRequest, ev: Event) => any) | null;
    onsuccess: ((this: IDBRequest, ev: Event) => any) | null;
    readonly readyState: IDBRequestReadyState;
    readonly result: any;
    readonly source: IDBObjectStore | IDBIndex | IDBCursor | null;
    readonly transaction: IDBTransaction | null;
    addEventListener<K extends keyof IDBRequestEventMap>(type: K, listener: (this: IDBRequest, ev: IDBRequestEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof IDBRequestEventMap>(type: K, listener: (this: IDBRequest, ev: IDBRequestEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var IDBRequest: {
    prototype: IDBRequest;
    new(): IDBRequest;
    isInstance: IsInstance<IDBRequest>;
};

interface IDBTransactionEventMap {
    "abort": Event;
    "complete": Event;
    "error": Event;
}

interface IDBTransaction extends EventTarget {
    readonly db: IDBDatabase;
    readonly durability: IDBTransactionDurability;
    readonly error: DOMException | null;
    readonly mode: IDBTransactionMode;
    readonly objectStoreNames: DOMStringList;
    onabort: ((this: IDBTransaction, ev: Event) => any) | null;
    oncomplete: ((this: IDBTransaction, ev: Event) => any) | null;
    onerror: ((this: IDBTransaction, ev: Event) => any) | null;
    abort(): void;
    commit(): void;
    objectStore(name: string): IDBObjectStore;
    addEventListener<K extends keyof IDBTransactionEventMap>(type: K, listener: (this: IDBTransaction, ev: IDBTransactionEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof IDBTransactionEventMap>(type: K, listener: (this: IDBTransaction, ev: IDBTransactionEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var IDBTransaction: {
    prototype: IDBTransaction;
    new(): IDBTransaction;
    isInstance: IsInstance<IDBTransaction>;
};

interface IDBVersionChangeEvent extends Event {
    readonly newVersion: number | null;
    readonly oldVersion: number;
}

declare var IDBVersionChangeEvent: {
    prototype: IDBVersionChangeEvent;
    new(type: string, eventInitDict?: IDBVersionChangeEventInit): IDBVersionChangeEvent;
    isInstance: IsInstance<IDBVersionChangeEvent>;
};

interface IIRFilterNode extends AudioNode, AudioNodePassThrough {
    getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void;
}

declare var IIRFilterNode: {
    prototype: IIRFilterNode;
    new(context: BaseAudioContext, options: IIRFilterOptions): IIRFilterNode;
    isInstance: IsInstance<IIRFilterNode>;
};

/** Available only in secure contexts. */
interface IdentityCredential extends Credential {
    readonly origin: string;
    readonly token: string | null;
}

declare var IdentityCredential: {
    prototype: IdentityCredential;
    new(init: IdentityCredentialInit): IdentityCredential;
    isInstance: IsInstance<IdentityCredential>;
    disconnect(options?: IdentityCredentialDisconnectOptions): Promise<void>;
};

interface IdleDeadline {
    readonly didTimeout: boolean;
    timeRemaining(): DOMHighResTimeStamp;
}

declare var IdleDeadline: {
    prototype: IdleDeadline;
    new(): IdleDeadline;
    isInstance: IsInstance<IdleDeadline>;
};

interface ImageBitmap {
    readonly height: number;
    readonly width: number;
    close(): void;
}

declare var ImageBitmap: {
    prototype: ImageBitmap;
    new(): ImageBitmap;
    isInstance: IsInstance<ImageBitmap>;
};

interface ImageBitmapRenderingContext {
    readonly canvas: CanvasSource | null;
    transferFromImageBitmap(bitmap: ImageBitmap | null): void;
    transferImageBitmap(bitmap: ImageBitmap): void;
}

declare var ImageBitmapRenderingContext: {
    prototype: ImageBitmapRenderingContext;
    new(): ImageBitmapRenderingContext;
    isInstance: IsInstance<ImageBitmapRenderingContext>;
};

interface ImageCaptureEventMap {
    "error": Event;
    "photo": Event;
}

interface ImageCapture extends EventTarget {
    onerror: ((this: ImageCapture, ev: Event) => any) | null;
    onphoto: ((this: ImageCapture, ev: Event) => any) | null;
    readonly videoStreamTrack: MediaStreamTrack;
    takePhoto(): void;
    addEventListener<K extends keyof ImageCaptureEventMap>(type: K, listener: (this: ImageCapture, ev: ImageCaptureEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof ImageCaptureEventMap>(type: K, listener: (this: ImageCapture, ev: ImageCaptureEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var ImageCapture: {
    prototype: ImageCapture;
    new(track: MediaStreamTrack): ImageCapture;
    isInstance: IsInstance<ImageCapture>;
};

interface ImageCaptureError {
    readonly code: number;
    readonly message: string;
    readonly FRAME_GRAB_ERROR: 1;
    readonly SETTINGS_ERROR: 2;
    readonly PHOTO_ERROR: 3;
    readonly ERROR_UNKNOWN: 4;
}

interface ImageCaptureErrorEvent extends Event {
    readonly imageCaptureError: ImageCaptureError | null;
}

declare var ImageCaptureErrorEvent: {
    prototype: ImageCaptureErrorEvent;
    new(type: string, imageCaptureErrorInitDict?: ImageCaptureErrorEventInit): ImageCaptureErrorEvent;
    isInstance: IsInstance<ImageCaptureErrorEvent>;
};

interface ImageData {
    readonly data: Uint8ClampedArray;
    readonly height: number;
    readonly width: number;
}

declare var ImageData: {
    prototype: ImageData;
    new(sw: number, sh: number): ImageData;
    new(data: Uint8ClampedArray, sw: number, sh?: number): ImageData;
    isInstance: IsInstance<ImageData>;
};

/** Available only in secure contexts. */
interface ImageDecoder {
    readonly complete: boolean;
    readonly completed: Promise<void>;
    readonly tracks: ImageTrackList;
    readonly type: string;
    close(): void;
    decode(options?: ImageDecodeOptions): Promise<ImageDecodeResult>;
    reset(): void;
}

declare var ImageDecoder: {
    prototype: ImageDecoder;
    new(init: ImageDecoderInit): ImageDecoder;
    isInstance: IsInstance<ImageDecoder>;
    isTypeSupported(type: string): Promise<boolean>;
};

interface ImageDocument extends HTMLDocument {
    readonly imageIsOverflowing: boolean;
    readonly imageIsResized: boolean;
    restoreImage(): void;
    shrinkToFit(): void;
    addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: ImageDocument, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: ImageDocument, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var ImageDocument: {
    prototype: ImageDocument;
    new(): ImageDocument;
    isInstance: IsInstance<ImageDocument>;
};

/** Available only in secure contexts. */
interface ImageTrack {
    readonly animated: boolean;
    readonly frameCount: number;
    readonly repetitionCount: number;
    selected: boolean;
}

declare var ImageTrack: {
    prototype: ImageTrack;
    new(): ImageTrack;
    isInstance: IsInstance<ImageTrack>;
};

/** Available only in secure contexts. */
interface ImageTrackList {
    readonly length: number;
    readonly ready: Promise<void>;
    readonly selectedIndex: number;
    readonly selectedTrack: ImageTrack | null;
    [index: number]: ImageTrack;
}

declare var ImageTrackList: {
    prototype: ImageTrackList;
    new(): ImageTrackList;
    isInstance: IsInstance<ImageTrackList>;
};

interface InputEvent extends UIEvent {
    readonly data: string | null;
    readonly dataTransfer: DataTransfer | null;
    readonly inputType: string;
    readonly isComposing: boolean;
    getTargetRanges(): StaticRange[];
}

declare var InputEvent: {
    prototype: InputEvent;
    new(type: string, eventInitDict?: InputEventInit): InputEvent;
    isInstance: IsInstance<InputEvent>;
};

interface InspectorCSSParser {
    readonly columnNumber: number;
    readonly lineNumber: number;
    nextToken(): InspectorCSSToken | null;
}

declare var InspectorCSSParser: {
    prototype: InspectorCSSParser;
    new(text: string): InspectorCSSParser;
    isInstance: IsInstance<InspectorCSSParser>;
};

interface InspectorFontFace {
    readonly CSSFamilyName: string;
    readonly CSSGeneric: string;
    readonly URI: string;
    readonly format: string;
    readonly fromFontGroup: boolean;
    readonly fromLanguagePrefs: boolean;
    readonly fromSystemFallback: boolean;
    readonly localName: string;
    readonly metadata: string;
    readonly name: string;
    readonly ranges: Range[];
    readonly rule: CSSFontFaceRule | null;
    readonly srcIndex: number;
    getFeatures(): InspectorFontFeature[];
    getNameString(id: number): string;
    getVariationAxes(): InspectorVariationAxis[];
    getVariationInstances(): InspectorVariationInstance[];
    readonly NAME_ID_COPYRIGHT: 0;
    readonly NAME_ID_FAMILY: 1;
    readonly NAME_ID_SUBFAMILY: 2;
    readonly NAME_ID_UNIQUE: 3;
    readonly NAME_ID_FULL: 4;
    readonly NAME_ID_VERSION: 5;
    readonly NAME_ID_POSTSCRIPT: 6;
    readonly NAME_ID_TRADEMARK: 7;
    readonly NAME_ID_MANUFACTURER: 8;
    readonly NAME_ID_DESIGNER: 9;
    readonly NAME_ID_DESCRIPTION: 10;
    readonly NAME_ID_VENDOR_URL: 11;
    readonly NAME_ID_DESIGNER_URL: 12;
    readonly NAME_ID_LICENSE: 13;
    readonly NAME_ID_LICENSE_URL: 14;
    readonly NAME_ID_TYPOGRAPHIC_FAMILY: 16;
    readonly NAME_ID_TYPOGRAPHIC_SUBFAMILY: 17;
    readonly NAME_ID_COMPATIBLE_FULL: 18;
    readonly NAME_ID_SAMPLE_TEXT: 19;
}

declare var InspectorFontFace: {
    prototype: InspectorFontFace;
    new(): InspectorFontFace;
    readonly NAME_ID_COPYRIGHT: 0;
    readonly NAME_ID_FAMILY: 1;
    readonly NAME_ID_SUBFAMILY: 2;
    readonly NAME_ID_UNIQUE: 3;
    readonly NAME_ID_FULL: 4;
    readonly NAME_ID_VERSION: 5;
    readonly NAME_ID_POSTSCRIPT: 6;
    readonly NAME_ID_TRADEMARK: 7;
    readonly NAME_ID_MANUFACTURER: 8;
    readonly NAME_ID_DESIGNER: 9;
    readonly NAME_ID_DESCRIPTION: 10;
    readonly NAME_ID_VENDOR_URL: 11;
    readonly NAME_ID_DESIGNER_URL: 12;
    readonly NAME_ID_LICENSE: 13;
    readonly NAME_ID_LICENSE_URL: 14;
    readonly NAME_ID_TYPOGRAPHIC_FAMILY: 16;
    readonly NAME_ID_TYPOGRAPHIC_SUBFAMILY: 17;
    readonly NAME_ID_COMPATIBLE_FULL: 18;
    readonly NAME_ID_SAMPLE_TEXT: 19;
    isInstance: IsInstance<InspectorFontFace>;
};

interface InstallTriggerImpl {
    enabled(): boolean;
    install(installs: Record<string, string | InstallTriggerData>, callback?: InstallTriggerCallback): boolean;
    installChrome(type: number, url: string, skin: string): boolean;
    startSoftwareUpdate(url: string, flags?: number): boolean;
    updateEnabled(): boolean;
    readonly SKIN: 1;
    readonly LOCALE: 2;
    readonly CONTENT: 4;
    readonly PACKAGE: 7;
}

declare var InstallTriggerImpl: {
    prototype: InstallTriggerImpl;
    new(): InstallTriggerImpl;
    readonly SKIN: 1;
    readonly LOCALE: 2;
    readonly CONTENT: 4;
    readonly PACKAGE: 7;
    isInstance: IsInstance<InstallTriggerImpl>;
};

interface IntersectionObserver {
    readonly root: Node | null;
    readonly rootMargin: string;
    readonly thresholds: number[];
    disconnect(): void;
    observe(target: Element): void;
    takeRecords(): IntersectionObserverEntry[];
    unobserve(target: Element): void;
}

declare var IntersectionObserver: {
    prototype: IntersectionObserver;
    new(intersectionCallback: IntersectionCallback, options?: IntersectionObserverInit): IntersectionObserver;
    isInstance: IsInstance<IntersectionObserver>;
};

interface IntersectionObserverEntry {
    readonly boundingClientRect: DOMRectReadOnly;
    readonly intersectionRatio: number;
    readonly intersectionRect: DOMRectReadOnly;
    readonly isIntersecting: boolean;
    readonly rootBounds: DOMRectReadOnly | null;
    readonly target: Element;
    readonly time: DOMHighResTimeStamp;
}

declare var IntersectionObserverEntry: {
    prototype: IntersectionObserverEntry;
    new(): IntersectionObserverEntry;
    isInstance: IsInstance<IntersectionObserverEntry>;
};

interface IntlUtils {
    getDisplayNames(locales: string[], options?: DisplayNameOptions): DisplayNameResult;
    isAppLocaleRTL(): boolean;
}

interface InvokeEvent extends Event {
    readonly action: string;
    readonly invoker: Element | null;
}

declare var InvokeEvent: {
    prototype: InvokeEvent;
    new(type: string, eventInitDict?: InvokeEventInit): InvokeEvent;
    isInstance: IsInstance<InvokeEvent>;
};

interface InvokerElement {
    invokeAction: string;
    invokeTargetElement: Element | null;
}


interface JSActor {
    readonly name: string;
    sendAsyncMessage(messageName: string, obj?: any, transferables?: any): void;
    sendQuery(messageName: string, obj?: any): Promise<any>;
}

interface JSProcessActorChild extends JSActor {
    readonly manager: nsIDOMProcessChild;
}

declare var JSProcessActorChild: {
    prototype: JSProcessActorChild;
    new(): JSProcessActorChild;
    isInstance: IsInstance<JSProcessActorChild>;
};

interface JSProcessActorParent extends JSActor {
    readonly manager: nsIDOMProcessParent;
}

declare var JSProcessActorParent: {
    prototype: JSProcessActorParent;
    new(): JSProcessActorParent;
    isInstance: IsInstance<JSProcessActorParent>;
};

interface JSString {
}

interface JSWindowActorChild extends JSActor {
    readonly browsingContext: BrowsingContext | null;
    readonly contentWindow: WindowProxy | null;
    readonly docShell: nsIDocShell | null;
    readonly document: Document;
    readonly manager: WindowGlobalChild | null;
    readonly windowContext: WindowContext | null;
}

declare var JSWindowActorChild: {
    prototype: JSWindowActorChild;
    new(): JSWindowActorChild;
    isInstance: IsInstance<JSWindowActorChild>;
};

interface JSWindowActorParent extends JSActor {
    readonly browsingContext: CanonicalBrowsingContext | null;
    readonly manager: WindowGlobalParent | null;
    readonly windowContext: WindowContext | null;
}

declare var JSWindowActorParent: {
    prototype: JSWindowActorParent;
    new(): JSWindowActorParent;
    isInstance: IsInstance<JSWindowActorParent>;
};

interface KeyEvent extends KeyEventMixin {
}

declare var KeyEvent: {
    prototype: KeyEvent;
    new(): KeyEvent;
    readonly DOM_VK_CANCEL: 0x03;
    readonly DOM_VK_HELP: 0x06;
    readonly DOM_VK_BACK_SPACE: 0x08;
    readonly DOM_VK_TAB: 0x09;
    readonly DOM_VK_CLEAR: 0x0C;
    readonly DOM_VK_RETURN: 0x0D;
    readonly DOM_VK_SHIFT: 0x10;
    readonly DOM_VK_CONTROL: 0x11;
    readonly DOM_VK_ALT: 0x12;
    readonly DOM_VK_PAUSE: 0x13;
    readonly DOM_VK_CAPS_LOCK: 0x14;
    readonly DOM_VK_KANA: 0x15;
    readonly DOM_VK_HANGUL: 0x15;
    readonly DOM_VK_EISU: 0x16;
    readonly DOM_VK_JUNJA: 0x17;
    readonly DOM_VK_FINAL: 0x18;
    readonly DOM_VK_HANJA: 0x19;
    readonly DOM_VK_KANJI: 0x19;
    readonly DOM_VK_ESCAPE: 0x1B;
    readonly DOM_VK_CONVERT: 0x1C;
    readonly DOM_VK_NONCONVERT: 0x1D;
    readonly DOM_VK_ACCEPT: 0x1E;
    readonly DOM_VK_MODECHANGE: 0x1F;
    readonly DOM_VK_SPACE: 0x20;
    readonly DOM_VK_PAGE_UP: 0x21;
    readonly DOM_VK_PAGE_DOWN: 0x22;
    readonly DOM_VK_END: 0x23;
    readonly DOM_VK_HOME: 0x24;
    readonly DOM_VK_LEFT: 0x25;
    readonly DOM_VK_UP: 0x26;
    readonly DOM_VK_RIGHT: 0x27;
    readonly DOM_VK_DOWN: 0x28;
    readonly DOM_VK_SELECT: 0x29;
    readonly DOM_VK_PRINT: 0x2A;
    readonly DOM_VK_EXECUTE: 0x2B;
    readonly DOM_VK_PRINTSCREEN: 0x2C;
    readonly DOM_VK_INSERT: 0x2D;
    readonly DOM_VK_DELETE: 0x2E;
    readonly DOM_VK_0: 0x30;
    readonly DOM_VK_1: 0x31;
    readonly DOM_VK_2: 0x32;
    readonly DOM_VK_3: 0x33;
    readonly DOM_VK_4: 0x34;
    readonly DOM_VK_5: 0x35;
    readonly DOM_VK_6: 0x36;
    readonly DOM_VK_7: 0x37;
    readonly DOM_VK_8: 0x38;
    readonly DOM_VK_9: 0x39;
    readonly DOM_VK_COLON: 0x3A;
    readonly DOM_VK_SEMICOLON: 0x3B;
    readonly DOM_VK_LESS_THAN: 0x3C;
    readonly DOM_VK_EQUALS: 0x3D;
    readonly DOM_VK_GREATER_THAN: 0x3E;
    readonly DOM_VK_QUESTION_MARK: 0x3F;
    readonly DOM_VK_AT: 0x40;
    readonly DOM_VK_A: 0x41;
    readonly DOM_VK_B: 0x42;
    readonly DOM_VK_C: 0x43;
    readonly DOM_VK_D: 0x44;
    readonly DOM_VK_E: 0x45;
    readonly DOM_VK_F: 0x46;
    readonly DOM_VK_G: 0x47;
    readonly DOM_VK_H: 0x48;
    readonly DOM_VK_I: 0x49;
    readonly DOM_VK_J: 0x4A;
    readonly DOM_VK_K: 0x4B;
    readonly DOM_VK_L: 0x4C;
    readonly DOM_VK_M: 0x4D;
    readonly DOM_VK_N: 0x4E;
    readonly DOM_VK_O: 0x4F;
    readonly DOM_VK_P: 0x50;
    readonly DOM_VK_Q: 0x51;
    readonly DOM_VK_R: 0x52;
    readonly DOM_VK_S: 0x53;
    readonly DOM_VK_T: 0x54;
    readonly DOM_VK_U: 0x55;
    readonly DOM_VK_V: 0x56;
    readonly DOM_VK_W: 0x57;
    readonly DOM_VK_X: 0x58;
    readonly DOM_VK_Y: 0x59;
    readonly DOM_VK_Z: 0x5A;
    readonly DOM_VK_WIN: 0x5B;
    readonly DOM_VK_CONTEXT_MENU: 0x5D;
    readonly DOM_VK_SLEEP: 0x5F;
    readonly DOM_VK_NUMPAD0: 0x60;
    readonly DOM_VK_NUMPAD1: 0x61;
    readonly DOM_VK_NUMPAD2: 0x62;
    readonly DOM_VK_NUMPAD3: 0x63;
    readonly DOM_VK_NUMPAD4: 0x64;
    readonly DOM_VK_NUMPAD5: 0x65;
    readonly DOM_VK_NUMPAD6: 0x66;
    readonly DOM_VK_NUMPAD7: 0x67;
    readonly DOM_VK_NUMPAD8: 0x68;
    readonly DOM_VK_NUMPAD9: 0x69;
    readonly DOM_VK_MULTIPLY: 0x6A;
    readonly DOM_VK_ADD: 0x6B;
    readonly DOM_VK_SEPARATOR: 0x6C;
    readonly DOM_VK_SUBTRACT: 0x6D;
    readonly DOM_VK_DECIMAL: 0x6E;
    readonly DOM_VK_DIVIDE: 0x6F;
    readonly DOM_VK_F1: 0x70;
    readonly DOM_VK_F2: 0x71;
    readonly DOM_VK_F3: 0x72;
    readonly DOM_VK_F4: 0x73;
    readonly DOM_VK_F5: 0x74;
    readonly DOM_VK_F6: 0x75;
    readonly DOM_VK_F7: 0x76;
    readonly DOM_VK_F8: 0x77;
    readonly DOM_VK_F9: 0x78;
    readonly DOM_VK_F10: 0x79;
    readonly DOM_VK_F11: 0x7A;
    readonly DOM_VK_F12: 0x7B;
    readonly DOM_VK_F13: 0x7C;
    readonly DOM_VK_F14: 0x7D;
    readonly DOM_VK_F15: 0x7E;
    readonly DOM_VK_F16: 0x7F;
    readonly DOM_VK_F17: 0x80;
    readonly DOM_VK_F18: 0x81;
    readonly DOM_VK_F19: 0x82;
    readonly DOM_VK_F20: 0x83;
    readonly DOM_VK_F21: 0x84;
    readonly DOM_VK_F22: 0x85;
    readonly DOM_VK_F23: 0x86;
    readonly DOM_VK_F24: 0x87;
    readonly DOM_VK_NUM_LOCK: 0x90;
    readonly DOM_VK_SCROLL_LOCK: 0x91;
    readonly DOM_VK_WIN_OEM_FJ_JISHO: 0x92;
    readonly DOM_VK_WIN_OEM_FJ_MASSHOU: 0x93;
    readonly DOM_VK_WIN_OEM_FJ_TOUROKU: 0x94;
    readonly DOM_VK_WIN_OEM_FJ_LOYA: 0x95;
    readonly DOM_VK_WIN_OEM_FJ_ROYA: 0x96;
    readonly DOM_VK_CIRCUMFLEX: 0xA0;
    readonly DOM_VK_EXCLAMATION: 0xA1;
    readonly DOM_VK_DOUBLE_QUOTE: 0xA2;
    readonly DOM_VK_HASH: 0xA3;
    readonly DOM_VK_DOLLAR: 0xA4;
    readonly DOM_VK_PERCENT: 0xA5;
    readonly DOM_VK_AMPERSAND: 0xA6;
    readonly DOM_VK_UNDERSCORE: 0xA7;
    readonly DOM_VK_OPEN_PAREN: 0xA8;
    readonly DOM_VK_CLOSE_PAREN: 0xA9;
    readonly DOM_VK_ASTERISK: 0xAA;
    readonly DOM_VK_PLUS: 0xAB;
    readonly DOM_VK_PIPE: 0xAC;
    readonly DOM_VK_HYPHEN_MINUS: 0xAD;
    readonly DOM_VK_OPEN_CURLY_BRACKET: 0xAE;
    readonly DOM_VK_CLOSE_CURLY_BRACKET: 0xAF;
    readonly DOM_VK_TILDE: 0xB0;
    readonly DOM_VK_VOLUME_MUTE: 0xB5;
    readonly DOM_VK_VOLUME_DOWN: 0xB6;
    readonly DOM_VK_VOLUME_UP: 0xB7;
    readonly DOM_VK_COMMA: 0xBC;
    readonly DOM_VK_PERIOD: 0xBE;
    readonly DOM_VK_SLASH: 0xBF;
    readonly DOM_VK_BACK_QUOTE: 0xC0;
    readonly DOM_VK_OPEN_BRACKET: 0xDB;
    readonly DOM_VK_BACK_SLASH: 0xDC;
    readonly DOM_VK_CLOSE_BRACKET: 0xDD;
    readonly DOM_VK_QUOTE: 0xDE;
    readonly DOM_VK_META: 0xE0;
    readonly DOM_VK_ALTGR: 0xE1;
    readonly DOM_VK_WIN_ICO_HELP: 0xE3;
    readonly DOM_VK_WIN_ICO_00: 0xE4;
    readonly DOM_VK_PROCESSKEY: 0xE5;
    readonly DOM_VK_WIN_ICO_CLEAR: 0xE6;
    readonly DOM_VK_WIN_OEM_RESET: 0xE9;
    readonly DOM_VK_WIN_OEM_JUMP: 0xEA;
    readonly DOM_VK_WIN_OEM_PA1: 0xEB;
    readonly DOM_VK_WIN_OEM_PA2: 0xEC;
    readonly DOM_VK_WIN_OEM_PA3: 0xED;
    readonly DOM_VK_WIN_OEM_WSCTRL: 0xEE;
    readonly DOM_VK_WIN_OEM_CUSEL: 0xEF;
    readonly DOM_VK_WIN_OEM_ATTN: 0xF0;
    readonly DOM_VK_WIN_OEM_FINISH: 0xF1;
    readonly DOM_VK_WIN_OEM_COPY: 0xF2;
    readonly DOM_VK_WIN_OEM_AUTO: 0xF3;
    readonly DOM_VK_WIN_OEM_ENLW: 0xF4;
    readonly DOM_VK_WIN_OEM_BACKTAB: 0xF5;
    readonly DOM_VK_ATTN: 0xF6;
    readonly DOM_VK_CRSEL: 0xF7;
    readonly DOM_VK_EXSEL: 0xF8;
    readonly DOM_VK_EREOF: 0xF9;
    readonly DOM_VK_PLAY: 0xFA;
    readonly DOM_VK_ZOOM: 0xFB;
    readonly DOM_VK_PA1: 0xFD;
    readonly DOM_VK_WIN_OEM_CLEAR: 0xFE;
    isInstance: IsInstance<KeyEvent>;
};

interface KeyEventMixin {
    initKeyEvent(type: string, canBubble?: boolean, cancelable?: boolean, view?: Window | null, ctrlKey?: boolean, altKey?: boolean, shiftKey?: boolean, metaKey?: boolean, keyCode?: number, charCode?: number): void;
    readonly DOM_VK_CANCEL: 0x03;
    readonly DOM_VK_HELP: 0x06;
    readonly DOM_VK_BACK_SPACE: 0x08;
    readonly DOM_VK_TAB: 0x09;
    readonly DOM_VK_CLEAR: 0x0C;
    readonly DOM_VK_RETURN: 0x0D;
    readonly DOM_VK_SHIFT: 0x10;
    readonly DOM_VK_CONTROL: 0x11;
    readonly DOM_VK_ALT: 0x12;
    readonly DOM_VK_PAUSE: 0x13;
    readonly DOM_VK_CAPS_LOCK: 0x14;
    readonly DOM_VK_KANA: 0x15;
    readonly DOM_VK_HANGUL: 0x15;
    readonly DOM_VK_EISU: 0x16;
    readonly DOM_VK_JUNJA: 0x17;
    readonly DOM_VK_FINAL: 0x18;
    readonly DOM_VK_HANJA: 0x19;
    readonly DOM_VK_KANJI: 0x19;
    readonly DOM_VK_ESCAPE: 0x1B;
    readonly DOM_VK_CONVERT: 0x1C;
    readonly DOM_VK_NONCONVERT: 0x1D;
    readonly DOM_VK_ACCEPT: 0x1E;
    readonly DOM_VK_MODECHANGE: 0x1F;
    readonly DOM_VK_SPACE: 0x20;
    readonly DOM_VK_PAGE_UP: 0x21;
    readonly DOM_VK_PAGE_DOWN: 0x22;
    readonly DOM_VK_END: 0x23;
    readonly DOM_VK_HOME: 0x24;
    readonly DOM_VK_LEFT: 0x25;
    readonly DOM_VK_UP: 0x26;
    readonly DOM_VK_RIGHT: 0x27;
    readonly DOM_VK_DOWN: 0x28;
    readonly DOM_VK_SELECT: 0x29;
    readonly DOM_VK_PRINT: 0x2A;
    readonly DOM_VK_EXECUTE: 0x2B;
    readonly DOM_VK_PRINTSCREEN: 0x2C;
    readonly DOM_VK_INSERT: 0x2D;
    readonly DOM_VK_DELETE: 0x2E;
    readonly DOM_VK_0: 0x30;
    readonly DOM_VK_1: 0x31;
    readonly DOM_VK_2: 0x32;
    readonly DOM_VK_3: 0x33;
    readonly DOM_VK_4: 0x34;
    readonly DOM_VK_5: 0x35;
    readonly DOM_VK_6: 0x36;
    readonly DOM_VK_7: 0x37;
    readonly DOM_VK_8: 0x38;
    readonly DOM_VK_9: 0x39;
    readonly DOM_VK_COLON: 0x3A;
    readonly DOM_VK_SEMICOLON: 0x3B;
    readonly DOM_VK_LESS_THAN: 0x3C;
    readonly DOM_VK_EQUALS: 0x3D;
    readonly DOM_VK_GREATER_THAN: 0x3E;
    readonly DOM_VK_QUESTION_MARK: 0x3F;
    readonly DOM_VK_AT: 0x40;
    readonly DOM_VK_A: 0x41;
    readonly DOM_VK_B: 0x42;
    readonly DOM_VK_C: 0x43;
    readonly DOM_VK_D: 0x44;
    readonly DOM_VK_E: 0x45;
    readonly DOM_VK_F: 0x46;
    readonly DOM_VK_G: 0x47;
    readonly DOM_VK_H: 0x48;
    readonly DOM_VK_I: 0x49;
    readonly DOM_VK_J: 0x4A;
    readonly DOM_VK_K: 0x4B;
    readonly DOM_VK_L: 0x4C;
    readonly DOM_VK_M: 0x4D;
    readonly DOM_VK_N: 0x4E;
    readonly DOM_VK_O: 0x4F;
    readonly DOM_VK_P: 0x50;
    readonly DOM_VK_Q: 0x51;
    readonly DOM_VK_R: 0x52;
    readonly DOM_VK_S: 0x53;
    readonly DOM_VK_T: 0x54;
    readonly DOM_VK_U: 0x55;
    readonly DOM_VK_V: 0x56;
    readonly DOM_VK_W: 0x57;
    readonly DOM_VK_X: 0x58;
    readonly DOM_VK_Y: 0x59;
    readonly DOM_VK_Z: 0x5A;
    readonly DOM_VK_WIN: 0x5B;
    readonly DOM_VK_CONTEXT_MENU: 0x5D;
    readonly DOM_VK_SLEEP: 0x5F;
    readonly DOM_VK_NUMPAD0: 0x60;
    readonly DOM_VK_NUMPAD1: 0x61;
    readonly DOM_VK_NUMPAD2: 0x62;
    readonly DOM_VK_NUMPAD3: 0x63;
    readonly DOM_VK_NUMPAD4: 0x64;
    readonly DOM_VK_NUMPAD5: 0x65;
    readonly DOM_VK_NUMPAD6: 0x66;
    readonly DOM_VK_NUMPAD7: 0x67;
    readonly DOM_VK_NUMPAD8: 0x68;
    readonly DOM_VK_NUMPAD9: 0x69;
    readonly DOM_VK_MULTIPLY: 0x6A;
    readonly DOM_VK_ADD: 0x6B;
    readonly DOM_VK_SEPARATOR: 0x6C;
    readonly DOM_VK_SUBTRACT: 0x6D;
    readonly DOM_VK_DECIMAL: 0x6E;
    readonly DOM_VK_DIVIDE: 0x6F;
    readonly DOM_VK_F1: 0x70;
    readonly DOM_VK_F2: 0x71;
    readonly DOM_VK_F3: 0x72;
    readonly DOM_VK_F4: 0x73;
    readonly DOM_VK_F5: 0x74;
    readonly DOM_VK_F6: 0x75;
    readonly DOM_VK_F7: 0x76;
    readonly DOM_VK_F8: 0x77;
    readonly DOM_VK_F9: 0x78;
    readonly DOM_VK_F10: 0x79;
    readonly DOM_VK_F11: 0x7A;
    readonly DOM_VK_F12: 0x7B;
    readonly DOM_VK_F13: 0x7C;
    readonly DOM_VK_F14: 0x7D;
    readonly DOM_VK_F15: 0x7E;
    readonly DOM_VK_F16: 0x7F;
    readonly DOM_VK_F17: 0x80;
    readonly DOM_VK_F18: 0x81;
    readonly DOM_VK_F19: 0x82;
    readonly DOM_VK_F20: 0x83;
    readonly DOM_VK_F21: 0x84;
    readonly DOM_VK_F22: 0x85;
    readonly DOM_VK_F23: 0x86;
    readonly DOM_VK_F24: 0x87;
    readonly DOM_VK_NUM_LOCK: 0x90;
    readonly DOM_VK_SCROLL_LOCK: 0x91;
    readonly DOM_VK_WIN_OEM_FJ_JISHO: 0x92;
    readonly DOM_VK_WIN_OEM_FJ_MASSHOU: 0x93;
    readonly DOM_VK_WIN_OEM_FJ_TOUROKU: 0x94;
    readonly DOM_VK_WIN_OEM_FJ_LOYA: 0x95;
    readonly DOM_VK_WIN_OEM_FJ_ROYA: 0x96;
    readonly DOM_VK_CIRCUMFLEX: 0xA0;
    readonly DOM_VK_EXCLAMATION: 0xA1;
    readonly DOM_VK_DOUBLE_QUOTE: 0xA2;
    readonly DOM_VK_HASH: 0xA3;
    readonly DOM_VK_DOLLAR: 0xA4;
    readonly DOM_VK_PERCENT: 0xA5;
    readonly DOM_VK_AMPERSAND: 0xA6;
    readonly DOM_VK_UNDERSCORE: 0xA7;
    readonly DOM_VK_OPEN_PAREN: 0xA8;
    readonly DOM_VK_CLOSE_PAREN: 0xA9;
    readonly DOM_VK_ASTERISK: 0xAA;
    readonly DOM_VK_PLUS: 0xAB;
    readonly DOM_VK_PIPE: 0xAC;
    readonly DOM_VK_HYPHEN_MINUS: 0xAD;
    readonly DOM_VK_OPEN_CURLY_BRACKET: 0xAE;
    readonly DOM_VK_CLOSE_CURLY_BRACKET: 0xAF;
    readonly DOM_VK_TILDE: 0xB0;
    readonly DOM_VK_VOLUME_MUTE: 0xB5;
    readonly DOM_VK_VOLUME_DOWN: 0xB6;
    readonly DOM_VK_VOLUME_UP: 0xB7;
    readonly DOM_VK_COMMA: 0xBC;
    readonly DOM_VK_PERIOD: 0xBE;
    readonly DOM_VK_SLASH: 0xBF;
    readonly DOM_VK_BACK_QUOTE: 0xC0;
    readonly DOM_VK_OPEN_BRACKET: 0xDB;
    readonly DOM_VK_BACK_SLASH: 0xDC;
    readonly DOM_VK_CLOSE_BRACKET: 0xDD;
    readonly DOM_VK_QUOTE: 0xDE;
    readonly DOM_VK_META: 0xE0;
    readonly DOM_VK_ALTGR: 0xE1;
    readonly DOM_VK_WIN_ICO_HELP: 0xE3;
    readonly DOM_VK_WIN_ICO_00: 0xE4;
    readonly DOM_VK_PROCESSKEY: 0xE5;
    readonly DOM_VK_WIN_ICO_CLEAR: 0xE6;
    readonly DOM_VK_WIN_OEM_RESET: 0xE9;
    readonly DOM_VK_WIN_OEM_JUMP: 0xEA;
    readonly DOM_VK_WIN_OEM_PA1: 0xEB;
    readonly DOM_VK_WIN_OEM_PA2: 0xEC;
    readonly DOM_VK_WIN_OEM_PA3: 0xED;
    readonly DOM_VK_WIN_OEM_WSCTRL: 0xEE;
    readonly DOM_VK_WIN_OEM_CUSEL: 0xEF;
    readonly DOM_VK_WIN_OEM_ATTN: 0xF0;
    readonly DOM_VK_WIN_OEM_FINISH: 0xF1;
    readonly DOM_VK_WIN_OEM_COPY: 0xF2;
    readonly DOM_VK_WIN_OEM_AUTO: 0xF3;
    readonly DOM_VK_WIN_OEM_ENLW: 0xF4;
    readonly DOM_VK_WIN_OEM_BACKTAB: 0xF5;
    readonly DOM_VK_ATTN: 0xF6;
    readonly DOM_VK_CRSEL: 0xF7;
    readonly DOM_VK_EXSEL: 0xF8;
    readonly DOM_VK_EREOF: 0xF9;
    readonly DOM_VK_PLAY: 0xFA;
    readonly DOM_VK_ZOOM: 0xFB;
    readonly DOM_VK_PA1: 0xFD;
    readonly DOM_VK_WIN_OEM_CLEAR: 0xFE;
}

interface KeyboardEvent extends UIEvent, KeyEventMixin {
    readonly altKey: boolean;
    readonly charCode: number;
    readonly code: string;
    readonly ctrlKey: boolean;
    readonly initDict: KeyboardEventInit;
    readonly isComposing: boolean;
    readonly key: string;
    readonly keyCode: number;
    readonly location: number;
    readonly metaKey: boolean;
    readonly repeat: boolean;
    readonly shiftKey: boolean;
    getModifierState(key: string): boolean;
    initKeyboardEvent(typeArg: string, bubblesArg?: boolean, cancelableArg?: boolean, viewArg?: Window | null, keyArg?: string, locationArg?: number, ctrlKey?: boolean, altKey?: boolean, shiftKey?: boolean, metaKey?: boolean): void;
    readonly DOM_KEY_LOCATION_STANDARD: 0x00;
    readonly DOM_KEY_LOCATION_LEFT: 0x01;
    readonly DOM_KEY_LOCATION_RIGHT: 0x02;
    readonly DOM_KEY_LOCATION_NUMPAD: 0x03;
}

declare var KeyboardEvent: {
    prototype: KeyboardEvent;
    new(typeArg: string, keyboardEventInitDict?: KeyboardEventInit): KeyboardEvent;
    readonly DOM_KEY_LOCATION_STANDARD: 0x00;
    readonly DOM_KEY_LOCATION_LEFT: 0x01;
    readonly DOM_KEY_LOCATION_RIGHT: 0x02;
    readonly DOM_KEY_LOCATION_NUMPAD: 0x03;
    readonly DOM_VK_CANCEL: 0x03;
    readonly DOM_VK_HELP: 0x06;
    readonly DOM_VK_BACK_SPACE: 0x08;
    readonly DOM_VK_TAB: 0x09;
    readonly DOM_VK_CLEAR: 0x0C;
    readonly DOM_VK_RETURN: 0x0D;
    readonly DOM_VK_SHIFT: 0x10;
    readonly DOM_VK_CONTROL: 0x11;
    readonly DOM_VK_ALT: 0x12;
    readonly DOM_VK_PAUSE: 0x13;
    readonly DOM_VK_CAPS_LOCK: 0x14;
    readonly DOM_VK_KANA: 0x15;
    readonly DOM_VK_HANGUL: 0x15;
    readonly DOM_VK_EISU: 0x16;
    readonly DOM_VK_JUNJA: 0x17;
    readonly DOM_VK_FINAL: 0x18;
    readonly DOM_VK_HANJA: 0x19;
    readonly DOM_VK_KANJI: 0x19;
    readonly DOM_VK_ESCAPE: 0x1B;
    readonly DOM_VK_CONVERT: 0x1C;
    readonly DOM_VK_NONCONVERT: 0x1D;
    readonly DOM_VK_ACCEPT: 0x1E;
    readonly DOM_VK_MODECHANGE: 0x1F;
    readonly DOM_VK_SPACE: 0x20;
    readonly DOM_VK_PAGE_UP: 0x21;
    readonly DOM_VK_PAGE_DOWN: 0x22;
    readonly DOM_VK_END: 0x23;
    readonly DOM_VK_HOME: 0x24;
    readonly DOM_VK_LEFT: 0x25;
    readonly DOM_VK_UP: 0x26;
    readonly DOM_VK_RIGHT: 0x27;
    readonly DOM_VK_DOWN: 0x28;
    readonly DOM_VK_SELECT: 0x29;
    readonly DOM_VK_PRINT: 0x2A;
    readonly DOM_VK_EXECUTE: 0x2B;
    readonly DOM_VK_PRINTSCREEN: 0x2C;
    readonly DOM_VK_INSERT: 0x2D;
    readonly DOM_VK_DELETE: 0x2E;
    readonly DOM_VK_0: 0x30;
    readonly DOM_VK_1: 0x31;
    readonly DOM_VK_2: 0x32;
    readonly DOM_VK_3: 0x33;
    readonly DOM_VK_4: 0x34;
    readonly DOM_VK_5: 0x35;
    readonly DOM_VK_6: 0x36;
    readonly DOM_VK_7: 0x37;
    readonly DOM_VK_8: 0x38;
    readonly DOM_VK_9: 0x39;
    readonly DOM_VK_COLON: 0x3A;
    readonly DOM_VK_SEMICOLON: 0x3B;
    readonly DOM_VK_LESS_THAN: 0x3C;
    readonly DOM_VK_EQUALS: 0x3D;
    readonly DOM_VK_GREATER_THAN: 0x3E;
    readonly DOM_VK_QUESTION_MARK: 0x3F;
    readonly DOM_VK_AT: 0x40;
    readonly DOM_VK_A: 0x41;
    readonly DOM_VK_B: 0x42;
    readonly DOM_VK_C: 0x43;
    readonly DOM_VK_D: 0x44;
    readonly DOM_VK_E: 0x45;
    readonly DOM_VK_F: 0x46;
    readonly DOM_VK_G: 0x47;
    readonly DOM_VK_H: 0x48;
    readonly DOM_VK_I: 0x49;
    readonly DOM_VK_J: 0x4A;
    readonly DOM_VK_K: 0x4B;
    readonly DOM_VK_L: 0x4C;
    readonly DOM_VK_M: 0x4D;
    readonly DOM_VK_N: 0x4E;
    readonly DOM_VK_O: 0x4F;
    readonly DOM_VK_P: 0x50;
    readonly DOM_VK_Q: 0x51;
    readonly DOM_VK_R: 0x52;
    readonly DOM_VK_S: 0x53;
    readonly DOM_VK_T: 0x54;
    readonly DOM_VK_U: 0x55;
    readonly DOM_VK_V: 0x56;
    readonly DOM_VK_W: 0x57;
    readonly DOM_VK_X: 0x58;
    readonly DOM_VK_Y: 0x59;
    readonly DOM_VK_Z: 0x5A;
    readonly DOM_VK_WIN: 0x5B;
    readonly DOM_VK_CONTEXT_MENU: 0x5D;
    readonly DOM_VK_SLEEP: 0x5F;
    readonly DOM_VK_NUMPAD0: 0x60;
    readonly DOM_VK_NUMPAD1: 0x61;
    readonly DOM_VK_NUMPAD2: 0x62;
    readonly DOM_VK_NUMPAD3: 0x63;
    readonly DOM_VK_NUMPAD4: 0x64;
    readonly DOM_VK_NUMPAD5: 0x65;
    readonly DOM_VK_NUMPAD6: 0x66;
    readonly DOM_VK_NUMPAD7: 0x67;
    readonly DOM_VK_NUMPAD8: 0x68;
    readonly DOM_VK_NUMPAD9: 0x69;
    readonly DOM_VK_MULTIPLY: 0x6A;
    readonly DOM_VK_ADD: 0x6B;
    readonly DOM_VK_SEPARATOR: 0x6C;
    readonly DOM_VK_SUBTRACT: 0x6D;
    readonly DOM_VK_DECIMAL: 0x6E;
    readonly DOM_VK_DIVIDE: 0x6F;
    readonly DOM_VK_F1: 0x70;
    readonly DOM_VK_F2: 0x71;
    readonly DOM_VK_F3: 0x72;
    readonly DOM_VK_F4: 0x73;
    readonly DOM_VK_F5: 0x74;
    readonly DOM_VK_F6: 0x75;
    readonly DOM_VK_F7: 0x76;
    readonly DOM_VK_F8: 0x77;
    readonly DOM_VK_F9: 0x78;
    readonly DOM_VK_F10: 0x79;
    readonly DOM_VK_F11: 0x7A;
    readonly DOM_VK_F12: 0x7B;
    readonly DOM_VK_F13: 0x7C;
    readonly DOM_VK_F14: 0x7D;
    readonly DOM_VK_F15: 0x7E;
    readonly DOM_VK_F16: 0x7F;
    readonly DOM_VK_F17: 0x80;
    readonly DOM_VK_F18: 0x81;
    readonly DOM_VK_F19: 0x82;
    readonly DOM_VK_F20: 0x83;
    readonly DOM_VK_F21: 0x84;
    readonly DOM_VK_F22: 0x85;
    readonly DOM_VK_F23: 0x86;
    readonly DOM_VK_F24: 0x87;
    readonly DOM_VK_NUM_LOCK: 0x90;
    readonly DOM_VK_SCROLL_LOCK: 0x91;
    readonly DOM_VK_WIN_OEM_FJ_JISHO: 0x92;
    readonly DOM_VK_WIN_OEM_FJ_MASSHOU: 0x93;
    readonly DOM_VK_WIN_OEM_FJ_TOUROKU: 0x94;
    readonly DOM_VK_WIN_OEM_FJ_LOYA: 0x95;
    readonly DOM_VK_WIN_OEM_FJ_ROYA: 0x96;
    readonly DOM_VK_CIRCUMFLEX: 0xA0;
    readonly DOM_VK_EXCLAMATION: 0xA1;
    readonly DOM_VK_DOUBLE_QUOTE: 0xA2;
    readonly DOM_VK_HASH: 0xA3;
    readonly DOM_VK_DOLLAR: 0xA4;
    readonly DOM_VK_PERCENT: 0xA5;
    readonly DOM_VK_AMPERSAND: 0xA6;
    readonly DOM_VK_UNDERSCORE: 0xA7;
    readonly DOM_VK_OPEN_PAREN: 0xA8;
    readonly DOM_VK_CLOSE_PAREN: 0xA9;
    readonly DOM_VK_ASTERISK: 0xAA;
    readonly DOM_VK_PLUS: 0xAB;
    readonly DOM_VK_PIPE: 0xAC;
    readonly DOM_VK_HYPHEN_MINUS: 0xAD;
    readonly DOM_VK_OPEN_CURLY_BRACKET: 0xAE;
    readonly DOM_VK_CLOSE_CURLY_BRACKET: 0xAF;
    readonly DOM_VK_TILDE: 0xB0;
    readonly DOM_VK_VOLUME_MUTE: 0xB5;
    readonly DOM_VK_VOLUME_DOWN: 0xB6;
    readonly DOM_VK_VOLUME_UP: 0xB7;
    readonly DOM_VK_COMMA: 0xBC;
    readonly DOM_VK_PERIOD: 0xBE;
    readonly DOM_VK_SLASH: 0xBF;
    readonly DOM_VK_BACK_QUOTE: 0xC0;
    readonly DOM_VK_OPEN_BRACKET: 0xDB;
    readonly DOM_VK_BACK_SLASH: 0xDC;
    readonly DOM_VK_CLOSE_BRACKET: 0xDD;
    readonly DOM_VK_QUOTE: 0xDE;
    readonly DOM_VK_META: 0xE0;
    readonly DOM_VK_ALTGR: 0xE1;
    readonly DOM_VK_WIN_ICO_HELP: 0xE3;
    readonly DOM_VK_WIN_ICO_00: 0xE4;
    readonly DOM_VK_PROCESSKEY: 0xE5;
    readonly DOM_VK_WIN_ICO_CLEAR: 0xE6;
    readonly DOM_VK_WIN_OEM_RESET: 0xE9;
    readonly DOM_VK_WIN_OEM_JUMP: 0xEA;
    readonly DOM_VK_WIN_OEM_PA1: 0xEB;
    readonly DOM_VK_WIN_OEM_PA2: 0xEC;
    readonly DOM_VK_WIN_OEM_PA3: 0xED;
    readonly DOM_VK_WIN_OEM_WSCTRL: 0xEE;
    readonly DOM_VK_WIN_OEM_CUSEL: 0xEF;
    readonly DOM_VK_WIN_OEM_ATTN: 0xF0;
    readonly DOM_VK_WIN_OEM_FINISH: 0xF1;
    readonly DOM_VK_WIN_OEM_COPY: 0xF2;
    readonly DOM_VK_WIN_OEM_AUTO: 0xF3;
    readonly DOM_VK_WIN_OEM_ENLW: 0xF4;
    readonly DOM_VK_WIN_OEM_BACKTAB: 0xF5;
    readonly DOM_VK_ATTN: 0xF6;
    readonly DOM_VK_CRSEL: 0xF7;
    readonly DOM_VK_EXSEL: 0xF8;
    readonly DOM_VK_EREOF: 0xF9;
    readonly DOM_VK_PLAY: 0xFA;
    readonly DOM_VK_ZOOM: 0xFB;
    readonly DOM_VK_PA1: 0xFD;
    readonly DOM_VK_WIN_OEM_CLEAR: 0xFE;
    isInstance: IsInstance<KeyboardEvent>;
};

interface KeyframeEffect extends AnimationEffect {
    composite: CompositeOperation;
    iterationComposite: IterationCompositeOperation;
    pseudoElement: string | null;
    target: Element | null;
    getKeyframes(): any[];
    getProperties(): AnimationPropertyDetails[];
    setKeyframes(keyframes: any): void;
}

declare var KeyframeEffect: {
    prototype: KeyframeEffect;
    new(target: Element | null, keyframes: any, options?: number | KeyframeEffectOptions): KeyframeEffect;
    new(source: KeyframeEffect): KeyframeEffect;
    isInstance: IsInstance<KeyframeEffect>;
};

interface L10nFileSource {
    readonly index: string[] | null;
    readonly locales: string[];
    readonly metaSource: string;
    readonly name: string;
    readonly prePath: string;
    fetchFile(locale: string, path: string): Promise<FluentResource | null>;
    fetchFileSync(locale: string, path: string): FluentResource | null;
    hasFile(locale: string, path: string): L10nFileSourceHasFileStatus;
}

declare var L10nFileSource: {
    prototype: L10nFileSource;
    new(name: string, metaSource: string, locales: string[], prePath: string, options?: FileSourceOptions, index?: string[]): L10nFileSource;
    isInstance: IsInstance<L10nFileSource>;
    createMock(name: string, metasource: string, locales: string[], prePath: string, fs: L10nFileSourceMockFile[]): L10nFileSource;
};

interface L10nRegistry {
    clearSources(): void;
    generateBundles(aLocales: string[], aResourceIds: L10nResourceId[]): FluentBundleAsyncIterator;
    generateBundlesSync(aLocales: string[], aResourceIds: L10nResourceId[]): FluentBundleIterator;
    getAvailableLocales(): string[];
    getSource(aName: string): L10nFileSource | null;
    getSourceNames(): string[];
    hasSource(aName: string): boolean;
    registerSources(aSources: L10nFileSource[]): void;
    removeSources(aSources: string[]): void;
    updateSources(aSources: L10nFileSource[]): void;
}

declare var L10nRegistry: {
    prototype: L10nRegistry;
    new(aOptions?: L10nRegistryOptions): L10nRegistry;
    isInstance: IsInstance<L10nRegistry>;
    getInstance(): L10nRegistry;
};

interface LargestContentfulPaint extends PerformanceEntry, PaintTimingMixin {
    readonly element: Element | null;
    readonly id: string;
    readonly loadTime: DOMHighResTimeStamp;
    readonly renderTime: DOMHighResTimeStamp;
    readonly size: number;
    readonly url: string;
    toJSON(): any;
}

declare var LargestContentfulPaint: {
    prototype: LargestContentfulPaint;
    new(): LargestContentfulPaint;
    isInstance: IsInstance<LargestContentfulPaint>;
};

interface LegacyMozTCPSocket {
    listen(port: number, options?: ServerSocketOptions, backlog?: number): TCPServerSocket;
    open(host: string, port: number, options?: SocketOptions): TCPSocket;
}

interface LinkStyle {
    readonly sheet: StyleSheet | null;
}

interface LoadContextMixin {
    readonly associatedWindow: WindowProxy | null;
    readonly isContent: boolean;
    readonly originAttributes: any;
    readonly topFrameElement: Element | null;
    readonly topWindow: WindowProxy | null;
    usePrivateBrowsing: boolean;
    readonly useRemoteSubframes: boolean;
    readonly useRemoteTabs: boolean;
    useTrackingProtection: boolean;
}

interface Localization {
    addResourceIds(aResourceIds: L10nResourceId[]): void;
    formatMessages(aKeys: L10nKey[]): Promise<(L10nMessage | null)[]>;
    formatMessagesSync(aKeys: L10nKey[]): (L10nMessage | null)[];
    formatValue(aId: string, aArgs?: L10nArgs): Promise<string | null>;
    formatValueSync(aId: string, aArgs?: L10nArgs): string | null;
    formatValues(aKeys: L10nKey[]): Promise<(string | null)[]>;
    formatValuesSync(aKeys: L10nKey[]): (string | null)[];
    removeResourceIds(aResourceIds: L10nResourceId[]): number;
    setAsync(): void;
}

declare var Localization: {
    prototype: Localization;
    new(aResourceIds: L10nResourceId[], aSync?: boolean, aRegistry?: L10nRegistry, aLocales?: string[]): Localization;
    isInstance: IsInstance<Localization>;
};

interface Location {
    hash: string;
    host: string;
    hostname: string;
    href: string;
    toString(): string;
    readonly origin: string;
    pathname: string;
    port: string;
    protocol: string;
    search: string;
    assign(url: string): void;
    reload(forceget?: boolean): void;
    replace(url: string): void;
}

declare var Location: {
    prototype: Location;
    new(): Location;
    isInstance: IsInstance<Location>;
};

/** Available only in secure contexts. */
interface Lock {
    readonly mode: LockMode;
    readonly name: string;
}

declare var Lock: {
    prototype: Lock;
    new(): Lock;
    isInstance: IsInstance<Lock>;
};

/** Available only in secure contexts. */
interface LockManager {
    query(): Promise<LockManagerSnapshot>;
    request(name: string, callback: LockGrantedCallback): Promise<any>;
    request(name: string, options: LockOptions, callback: LockGrantedCallback): Promise<any>;
}

declare var LockManager: {
    prototype: LockManager;
    new(): LockManager;
    isInstance: IsInstance<LockManager>;
};

interface MIDIAccessEventMap {
    "statechange": Event;
}

/** Available only in secure contexts. */
interface MIDIAccess extends EventTarget {
    readonly inputs: MIDIInputMap;
    onstatechange: ((this: MIDIAccess, ev: Event) => any) | null;
    readonly outputs: MIDIOutputMap;
    readonly sysexEnabled: boolean;
    addEventListener<K extends keyof MIDIAccessEventMap>(type: K, listener: (this: MIDIAccess, ev: MIDIAccessEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MIDIAccessEventMap>(type: K, listener: (this: MIDIAccess, ev: MIDIAccessEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MIDIAccess: {
    prototype: MIDIAccess;
    new(): MIDIAccess;
    isInstance: IsInstance<MIDIAccess>;
};

/** Available only in secure contexts. */
interface MIDIConnectionEvent extends Event {
    readonly port: MIDIPort | null;
}

declare var MIDIConnectionEvent: {
    prototype: MIDIConnectionEvent;
    new(type: string, eventInitDict?: MIDIConnectionEventInit): MIDIConnectionEvent;
    isInstance: IsInstance<MIDIConnectionEvent>;
};

interface MIDIInputEventMap extends MIDIPortEventMap {
    "midimessage": Event;
}

/** Available only in secure contexts. */
interface MIDIInput extends MIDIPort {
    onmidimessage: ((this: MIDIInput, ev: Event) => any) | null;
    addEventListener<K extends keyof MIDIInputEventMap>(type: K, listener: (this: MIDIInput, ev: MIDIInputEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MIDIInputEventMap>(type: K, listener: (this: MIDIInput, ev: MIDIInputEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MIDIInput: {
    prototype: MIDIInput;
    new(): MIDIInput;
    isInstance: IsInstance<MIDIInput>;
};

/** Available only in secure contexts. */
interface MIDIInputMap {
    forEach(callbackfn: (value: MIDIInput, key: string, parent: MIDIInputMap) => void, thisArg?: any): void;
}

declare var MIDIInputMap: {
    prototype: MIDIInputMap;
    new(): MIDIInputMap;
    isInstance: IsInstance<MIDIInputMap>;
};

/** Available only in secure contexts. */
interface MIDIMessageEvent extends Event {
    readonly data: Uint8Array;
}

declare var MIDIMessageEvent: {
    prototype: MIDIMessageEvent;
    new(type: string, eventInitDict?: MIDIMessageEventInit): MIDIMessageEvent;
    isInstance: IsInstance<MIDIMessageEvent>;
};

/** Available only in secure contexts. */
interface MIDIOutput extends MIDIPort {
    clear(): void;
    send(data: number[], timestamp?: DOMHighResTimeStamp): void;
    addEventListener<K extends keyof MIDIPortEventMap>(type: K, listener: (this: MIDIOutput, ev: MIDIPortEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MIDIPortEventMap>(type: K, listener: (this: MIDIOutput, ev: MIDIPortEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MIDIOutput: {
    prototype: MIDIOutput;
    new(): MIDIOutput;
    isInstance: IsInstance<MIDIOutput>;
};

/** Available only in secure contexts. */
interface MIDIOutputMap {
    forEach(callbackfn: (value: MIDIOutput, key: string, parent: MIDIOutputMap) => void, thisArg?: any): void;
}

declare var MIDIOutputMap: {
    prototype: MIDIOutputMap;
    new(): MIDIOutputMap;
    isInstance: IsInstance<MIDIOutputMap>;
};

interface MIDIPortEventMap {
    "statechange": Event;
}

/** Available only in secure contexts. */
interface MIDIPort extends EventTarget {
    readonly connection: MIDIPortConnectionState;
    readonly id: string;
    readonly manufacturer: string | null;
    readonly name: string | null;
    onstatechange: ((this: MIDIPort, ev: Event) => any) | null;
    readonly state: MIDIPortDeviceState;
    readonly type: MIDIPortType;
    readonly version: string | null;
    close(): Promise<MIDIPort>;
    open(): Promise<MIDIPort>;
    addEventListener<K extends keyof MIDIPortEventMap>(type: K, listener: (this: MIDIPort, ev: MIDIPortEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MIDIPortEventMap>(type: K, listener: (this: MIDIPort, ev: MIDIPortEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MIDIPort: {
    prototype: MIDIPort;
    new(): MIDIPort;
    isInstance: IsInstance<MIDIPort>;
};

/** Available only in secure contexts. */
interface MLS {
    deleteState(): Promise<void>;
    generateCredential(credentialContent: MLSBytesOrUint8ArrayOrUTF8String): Promise<MLSCredential>;
    generateIdentity(): Promise<MLSClientId>;
    generateKeyPackage(clientId: MLSBytesOrUint8Array, credential: MLSBytesOrUint8Array): Promise<MLSKeyPackage>;
    getGroupEpochFromMessage(message: MLSBytesOrUint8Array): Promise<MLSGroupEpoch>;
    getGroupIdFromMessage(message: MLSBytesOrUint8Array): Promise<MLSGroupId>;
    groupCreate(clientId: MLSBytesOrUint8Array, credential: MLSBytesOrUint8Array): Promise<MLSGroupView>;
    groupGet(groupId: MLSBytesOrUint8Array, clientId: MLSBytesOrUint8Array): Promise<MLSGroupView | null>;
    groupJoin(clientId: MLSBytesOrUint8Array, welcome: MLSBytesOrUint8Array): Promise<MLSGroupView>;
}

declare var MLS: {
    prototype: MLS;
    new(): MLS;
    isInstance: IsInstance<MLS>;
};

/** Available only in secure contexts. */
interface MLSGroupView {
    readonly clientId: Uint8Array;
    readonly groupId: Uint8Array;
    add(keyPackage: MLSBytesOrUint8Array): Promise<MLSCommitOutput>;
    applyPendingCommit(): Promise<MLSReceived>;
    clearPendingCommit(): Promise<MLSReceived>;
    clearPendingProposals(): Promise<MLSReceived>;
    close(): Promise<MLSCommitOutput>;
    deleteState(): Promise<void>;
    details(): Promise<MLSGroupDetails>;
    exportSecret(label: MLSBytesOrUint8ArrayOrUTF8String, context: MLSBytesOrUint8Array, length: number): Promise<MLSExporterOutput>;
    hasPendingCommit(): Promise<MLSReceived>;
    hasPendingProposals(): Promise<MLSReceived>;
    proposeAdd(keyPackage: MLSBytesOrUint8Array): Promise<MLSProposal>;
    proposeRemove(remClientId: MLSBytesOrUint8Array): Promise<MLSProposal>;
    receive(message: MLSBytesOrUint8Array): Promise<MLSReceived>;
    remove(remClientId: MLSBytesOrUint8Array): Promise<MLSCommitOutput>;
    send(message: MLSBytesOrUint8ArrayOrUTF8String): Promise<MLSBytes>;
}

declare var MLSGroupView: {
    prototype: MLSGroupView;
    new(): MLSGroupView;
    isInstance: IsInstance<MLSGroupView>;
};

interface MOZ_debug {
    getParameter(pname: GLenum): any;
    readonly EXTENSIONS: 0x1F03;
    readonly WSI_INFO: 0x10000;
    readonly UNPACK_REQUIRE_FASTPATH: 0x10001;
    readonly DOES_INDEX_VALIDATION: 0x10002;
    readonly CONTEXT_TYPE: 0x10003;
}

interface MatchGlob {
    readonly glob: string;
    matches(string: string): boolean;
}

declare var MatchGlob: {
    prototype: MatchGlob;
    new(glob: string, allowQuestion?: boolean): MatchGlob;
    isInstance: IsInstance<MatchGlob>;
};

interface MatchPattern {
    readonly matchesAllWebUrls: boolean;
    readonly pattern: string;
    matches(uri: URI, explicit?: boolean): boolean;
    matches(url: string, explicit?: boolean): boolean;
    matchesCookie(cookie: Cookie): boolean;
    overlaps(pattern: MatchPattern): boolean;
    subsumes(pattern: MatchPattern): boolean;
    subsumesDomain(pattern: MatchPattern): boolean;
}

declare var MatchPattern: {
    prototype: MatchPattern;
    new(pattern: string, options?: MatchPatternOptions): MatchPattern;
    isInstance: IsInstance<MatchPattern>;
};

interface MatchPatternSet {
    readonly matchesAllWebUrls: boolean;
    readonly patterns: MatchPattern[];
    matches(uri: URI, explicit?: boolean): boolean;
    matches(url: string, explicit?: boolean): boolean;
    matchesCookie(cookie: Cookie): boolean;
    overlaps(pattern: MatchPattern): boolean;
    overlaps(patternSet: MatchPatternSet): boolean;
    overlapsAll(patternSet: MatchPatternSet): boolean;
    subsumes(pattern: MatchPattern): boolean;
    subsumesDomain(pattern: MatchPattern): boolean;
}

declare var MatchPatternSet: {
    prototype: MatchPatternSet;
    new(patterns: (string | MatchPattern)[], options?: MatchPatternOptions): MatchPatternSet;
    isInstance: IsInstance<MatchPatternSet>;
};

interface MathMLElementEventMap extends ElementEventMap, GlobalEventHandlersEventMap, OnErrorEventHandlerForNodesEventMap, TouchEventHandlersEventMap {
}

interface MathMLElement extends Element, ElementCSSInlineStyle, GlobalEventHandlers, HTMLOrForeignElement, OnErrorEventHandlerForNodes, TouchEventHandlers {
    addEventListener<K extends keyof MathMLElementEventMap>(type: K, listener: (this: MathMLElement, ev: MathMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MathMLElementEventMap>(type: K, listener: (this: MathMLElement, ev: MathMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MathMLElement: {
    prototype: MathMLElement;
    new(): MathMLElement;
    isInstance: IsInstance<MathMLElement>;
};

interface MediaCapabilities {
    decodingInfo(configuration: MediaDecodingConfiguration): Promise<MediaCapabilitiesDecodingInfo>;
    encodingInfo(configuration: MediaEncodingConfiguration): Promise<MediaCapabilitiesInfo>;
}

declare var MediaCapabilities: {
    prototype: MediaCapabilities;
    new(): MediaCapabilities;
    isInstance: IsInstance<MediaCapabilities>;
};

interface MediaControllerEventMap {
    "activated": Event;
    "deactivated": Event;
    "metadatachange": Event;
    "playbackstatechange": Event;
    "positionstatechange": Event;
    "supportedkeyschange": Event;
}

interface MediaController extends EventTarget {
    readonly id: number;
    readonly isActive: boolean;
    readonly isAudible: boolean;
    readonly isPlaying: boolean;
    onactivated: ((this: MediaController, ev: Event) => any) | null;
    ondeactivated: ((this: MediaController, ev: Event) => any) | null;
    onmetadatachange: ((this: MediaController, ev: Event) => any) | null;
    onplaybackstatechange: ((this: MediaController, ev: Event) => any) | null;
    onpositionstatechange: ((this: MediaController, ev: Event) => any) | null;
    onsupportedkeyschange: ((this: MediaController, ev: Event) => any) | null;
    readonly playbackState: MediaSessionPlaybackState;
    readonly supportedKeys: MediaControlKey[];
    focus(): void;
    getMetadata(): MediaMetadataInit;
    nextTrack(): void;
    pause(): void;
    play(): void;
    prevTrack(): void;
    seekBackward(seekOffset: number): void;
    seekForward(seekOffset: number): void;
    seekTo(seekTime: number, fastSeek?: boolean): void;
    skipAd(): void;
    stop(): void;
    addEventListener<K extends keyof MediaControllerEventMap>(type: K, listener: (this: MediaController, ev: MediaControllerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MediaControllerEventMap>(type: K, listener: (this: MediaController, ev: MediaControllerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MediaController: {
    prototype: MediaController;
    new(): MediaController;
    isInstance: IsInstance<MediaController>;
};

interface MediaDeviceInfo {
    readonly deviceId: string;
    readonly groupId: string;
    readonly kind: MediaDeviceKind;
    readonly label: string;
    toJSON(): any;
}

declare var MediaDeviceInfo: {
    prototype: MediaDeviceInfo;
    new(): MediaDeviceInfo;
    isInstance: IsInstance<MediaDeviceInfo>;
};

interface MediaDevicesEventMap {
    "devicechange": Event;
}

interface MediaDevices extends EventTarget {
    ondevicechange: ((this: MediaDevices, ev: Event) => any) | null;
    enumerateDevices(): Promise<MediaDeviceInfo[]>;
    /** Available only in secure contexts. */
    getDisplayMedia(constraints?: DisplayMediaStreamConstraints): Promise<MediaStream>;
    getSupportedConstraints(): MediaTrackSupportedConstraints;
    getUserMedia(constraints?: MediaStreamConstraints): Promise<MediaStream>;
    /** Available only in secure contexts. */
    selectAudioOutput(options?: AudioOutputOptions): Promise<MediaDeviceInfo>;
    addEventListener<K extends keyof MediaDevicesEventMap>(type: K, listener: (this: MediaDevices, ev: MediaDevicesEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MediaDevicesEventMap>(type: K, listener: (this: MediaDevices, ev: MediaDevicesEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MediaDevices: {
    prototype: MediaDevices;
    new(): MediaDevices;
    isInstance: IsInstance<MediaDevices>;
};

interface MediaElementAudioSourceNode extends AudioNode, AudioNodePassThrough {
    readonly mediaElement: HTMLMediaElement;
}

declare var MediaElementAudioSourceNode: {
    prototype: MediaElementAudioSourceNode;
    new(context: AudioContext, options: MediaElementAudioSourceOptions): MediaElementAudioSourceNode;
    isInstance: IsInstance<MediaElementAudioSourceNode>;
};

interface MediaEncryptedEvent extends Event {
    readonly initData: ArrayBuffer | null;
    readonly initDataType: string;
}

declare var MediaEncryptedEvent: {
    prototype: MediaEncryptedEvent;
    new(type: string, eventInitDict?: MediaKeyNeededEventInit): MediaEncryptedEvent;
    isInstance: IsInstance<MediaEncryptedEvent>;
};

interface MediaError {
    readonly code: number;
    readonly message: string;
    readonly MEDIA_ERR_ABORTED: 1;
    readonly MEDIA_ERR_NETWORK: 2;
    readonly MEDIA_ERR_DECODE: 3;
    readonly MEDIA_ERR_SRC_NOT_SUPPORTED: 4;
}

declare var MediaError: {
    prototype: MediaError;
    new(): MediaError;
    readonly MEDIA_ERR_ABORTED: 1;
    readonly MEDIA_ERR_NETWORK: 2;
    readonly MEDIA_ERR_DECODE: 3;
    readonly MEDIA_ERR_SRC_NOT_SUPPORTED: 4;
    isInstance: IsInstance<MediaError>;
};

interface MediaKeyError extends Event {
    readonly systemCode: number;
}

declare var MediaKeyError: {
    prototype: MediaKeyError;
    new(): MediaKeyError;
    isInstance: IsInstance<MediaKeyError>;
};

interface MediaKeyMessageEvent extends Event {
    readonly message: ArrayBuffer;
    readonly messageType: MediaKeyMessageType;
}

declare var MediaKeyMessageEvent: {
    prototype: MediaKeyMessageEvent;
    new(type: string, eventInitDict: MediaKeyMessageEventInit): MediaKeyMessageEvent;
    isInstance: IsInstance<MediaKeyMessageEvent>;
};

interface MediaKeySessionEventMap {
    "keystatuseschange": Event;
    "message": Event;
}

interface MediaKeySession extends EventTarget {
    readonly closed: Promise<void>;
    readonly error: MediaKeyError | null;
    readonly expiration: number;
    readonly keyStatuses: MediaKeyStatusMap;
    onkeystatuseschange: ((this: MediaKeySession, ev: Event) => any) | null;
    onmessage: ((this: MediaKeySession, ev: Event) => any) | null;
    readonly sessionId: string;
    close(): Promise<void>;
    generateRequest(initDataType: string, initData: BufferSource): Promise<void>;
    load(sessionId: string): Promise<boolean>;
    remove(): Promise<void>;
    update(response: BufferSource): Promise<void>;
    addEventListener<K extends keyof MediaKeySessionEventMap>(type: K, listener: (this: MediaKeySession, ev: MediaKeySessionEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MediaKeySessionEventMap>(type: K, listener: (this: MediaKeySession, ev: MediaKeySessionEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MediaKeySession: {
    prototype: MediaKeySession;
    new(): MediaKeySession;
    isInstance: IsInstance<MediaKeySession>;
};

interface MediaKeyStatusMap {
    readonly size: number;
    get(keyId: BufferSource): MediaKeyStatus | undefined;
    has(keyId: BufferSource): boolean;
    forEach(callbackfn: (value: MediaKeyStatus, key: ArrayBuffer, parent: MediaKeyStatusMap) => void, thisArg?: any): void;
}

declare var MediaKeyStatusMap: {
    prototype: MediaKeyStatusMap;
    new(): MediaKeyStatusMap;
    isInstance: IsInstance<MediaKeyStatusMap>;
};

interface MediaKeySystemAccess {
    readonly keySystem: string;
    createMediaKeys(): Promise<MediaKeys>;
    getConfiguration(): MediaKeySystemConfiguration;
}

declare var MediaKeySystemAccess: {
    prototype: MediaKeySystemAccess;
    new(): MediaKeySystemAccess;
    isInstance: IsInstance<MediaKeySystemAccess>;
};

interface MediaKeys {
    readonly keySystem: string;
    createSession(sessionType?: MediaKeySessionType): MediaKeySession;
    getStatusForPolicy(policy?: MediaKeysPolicy): Promise<MediaKeyStatus>;
    setServerCertificate(serverCertificate: BufferSource): Promise<void>;
}

declare var MediaKeys: {
    prototype: MediaKeys;
    new(): MediaKeys;
    isInstance: IsInstance<MediaKeys>;
};

interface MediaList {
    readonly length: number;
    mediaText: string;
    toString(): string;
    appendMedium(newMedium: string): void;
    deleteMedium(oldMedium: string): void;
    item(index: number): string | null;
    [index: number]: string;
}

declare var MediaList: {
    prototype: MediaList;
    new(): MediaList;
    isInstance: IsInstance<MediaList>;
};

interface MediaMetadata {
    album: string;
    artist: string;
    artwork: any[];
    title: string;
}

declare var MediaMetadata: {
    prototype: MediaMetadata;
    new(init?: MediaMetadataInit): MediaMetadata;
    isInstance: IsInstance<MediaMetadata>;
};

interface MediaQueryListEventMap {
    "change": Event;
}

interface MediaQueryList extends EventTarget {
    readonly matches: boolean;
    readonly media: string;
    onchange: ((this: MediaQueryList, ev: Event) => any) | null;
    addListener(listener: EventListener | null): void;
    removeListener(listener: EventListener | null): void;
    addEventListener<K extends keyof MediaQueryListEventMap>(type: K, listener: (this: MediaQueryList, ev: MediaQueryListEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MediaQueryListEventMap>(type: K, listener: (this: MediaQueryList, ev: MediaQueryListEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MediaQueryList: {
    prototype: MediaQueryList;
    new(): MediaQueryList;
    isInstance: IsInstance<MediaQueryList>;
};

interface MediaQueryListEvent extends Event {
    readonly matches: boolean;
    readonly media: string;
}

declare var MediaQueryListEvent: {
    prototype: MediaQueryListEvent;
    new(type: string, eventInitDict?: MediaQueryListEventInit): MediaQueryListEvent;
    isInstance: IsInstance<MediaQueryListEvent>;
};

interface MediaRecorderEventMap {
    "dataavailable": Event;
    "error": Event;
    "pause": Event;
    "resume": Event;
    "start": Event;
    "stop": Event;
}

interface MediaRecorder extends EventTarget {
    readonly audioBitsPerSecond: number;
    readonly mimeType: string;
    ondataavailable: ((this: MediaRecorder, ev: Event) => any) | null;
    onerror: ((this: MediaRecorder, ev: Event) => any) | null;
    onpause: ((this: MediaRecorder, ev: Event) => any) | null;
    onresume: ((this: MediaRecorder, ev: Event) => any) | null;
    onstart: ((this: MediaRecorder, ev: Event) => any) | null;
    onstop: ((this: MediaRecorder, ev: Event) => any) | null;
    readonly state: RecordingState;
    readonly stream: MediaStream;
    readonly videoBitsPerSecond: number;
    pause(): void;
    requestData(): void;
    resume(): void;
    start(timeslice?: number): void;
    stop(): void;
    addEventListener<K extends keyof MediaRecorderEventMap>(type: K, listener: (this: MediaRecorder, ev: MediaRecorderEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MediaRecorderEventMap>(type: K, listener: (this: MediaRecorder, ev: MediaRecorderEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MediaRecorder: {
    prototype: MediaRecorder;
    new(stream: MediaStream, options?: MediaRecorderOptions): MediaRecorder;
    new(node: AudioNode, output?: number, options?: MediaRecorderOptions): MediaRecorder;
    isInstance: IsInstance<MediaRecorder>;
    isTypeSupported(type: string): boolean;
};

interface MediaRecorderErrorEvent extends Event {
    readonly error: DOMException;
}

declare var MediaRecorderErrorEvent: {
    prototype: MediaRecorderErrorEvent;
    new(type: string, eventInitDict: MediaRecorderErrorEventInit): MediaRecorderErrorEvent;
    isInstance: IsInstance<MediaRecorderErrorEvent>;
};

interface MediaSession {
    metadata: MediaMetadata | null;
    playbackState: MediaSessionPlaybackState;
    notifyHandler(details: MediaSessionActionDetails): void;
    setActionHandler(action: MediaSessionAction, handler: MediaSessionActionHandler | null): void;
    setPositionState(state?: MediaPositionState): void;
}

declare var MediaSession: {
    prototype: MediaSession;
    new(): MediaSession;
    isInstance: IsInstance<MediaSession>;
};

interface MediaSourceEventMap {
    "sourceclose": Event;
    "sourceended": Event;
    "sourceopen": Event;
}

interface MediaSource extends EventTarget {
    readonly activeSourceBuffers: SourceBufferList;
    duration: number;
    onsourceclose: ((this: MediaSource, ev: Event) => any) | null;
    onsourceended: ((this: MediaSource, ev: Event) => any) | null;
    onsourceopen: ((this: MediaSource, ev: Event) => any) | null;
    readonly readyState: MediaSourceReadyState;
    readonly sourceBuffers: SourceBufferList;
    addSourceBuffer(type: string): SourceBuffer;
    clearLiveSeekableRange(): void;
    endOfStream(error?: MediaSourceEndOfStreamError): void;
    mozDebugReaderData(): Promise<MediaSourceDecoderDebugInfo>;
    removeSourceBuffer(sourceBuffer: SourceBuffer): void;
    setLiveSeekableRange(start: number, end: number): void;
    addEventListener<K extends keyof MediaSourceEventMap>(type: K, listener: (this: MediaSource, ev: MediaSourceEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MediaSourceEventMap>(type: K, listener: (this: MediaSource, ev: MediaSourceEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MediaSource: {
    prototype: MediaSource;
    new(): MediaSource;
    isInstance: IsInstance<MediaSource>;
    isTypeSupported(type: string): boolean;
};

interface MediaStreamEventMap {
    "addtrack": Event;
    "removetrack": Event;
}

interface MediaStream extends EventTarget {
    readonly active: boolean;
    readonly id: string;
    onaddtrack: ((this: MediaStream, ev: Event) => any) | null;
    onremovetrack: ((this: MediaStream, ev: Event) => any) | null;
    addTrack(track: MediaStreamTrack): void;
    assignId(id: string): void;
    clone(): MediaStream;
    getAudioTracks(): MediaStreamTrack[];
    getTrackById(trackId: string): MediaStreamTrack | null;
    getTracks(): MediaStreamTrack[];
    getVideoTracks(): MediaStreamTrack[];
    removeTrack(track: MediaStreamTrack): void;
    addEventListener<K extends keyof MediaStreamEventMap>(type: K, listener: (this: MediaStream, ev: MediaStreamEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MediaStreamEventMap>(type: K, listener: (this: MediaStream, ev: MediaStreamEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MediaStream: {
    prototype: MediaStream;
    new(): MediaStream;
    new(stream: MediaStream): MediaStream;
    new(tracks: MediaStreamTrack[]): MediaStream;
    isInstance: IsInstance<MediaStream>;
    countUnderlyingStreams(): Promise<number>;
};

interface MediaStreamAudioDestinationNode extends AudioNode {
    readonly stream: MediaStream;
}

declare var MediaStreamAudioDestinationNode: {
    prototype: MediaStreamAudioDestinationNode;
    new(context: AudioContext, options?: AudioNodeOptions): MediaStreamAudioDestinationNode;
    isInstance: IsInstance<MediaStreamAudioDestinationNode>;
};

interface MediaStreamAudioSourceNode extends AudioNode, AudioNodePassThrough {
    readonly mediaStream: MediaStream;
}

declare var MediaStreamAudioSourceNode: {
    prototype: MediaStreamAudioSourceNode;
    new(context: AudioContext, options: MediaStreamAudioSourceOptions): MediaStreamAudioSourceNode;
    isInstance: IsInstance<MediaStreamAudioSourceNode>;
};

interface MediaStreamError {
    readonly constraint: string | null;
    readonly message: string | null;
    readonly name: string;
}

interface MediaStreamEvent extends Event {
    readonly stream: MediaStream | null;
}

declare var MediaStreamEvent: {
    prototype: MediaStreamEvent;
    new(type: string, eventInitDict?: MediaStreamEventInit): MediaStreamEvent;
    isInstance: IsInstance<MediaStreamEvent>;
};

interface MediaStreamTrackEventMap {
    "ended": Event;
    "mute": Event;
    "unmute": Event;
}

interface MediaStreamTrack extends EventTarget {
    enabled: boolean;
    readonly id: string;
    readonly kind: string;
    readonly label: string;
    readonly muted: boolean;
    onended: ((this: MediaStreamTrack, ev: Event) => any) | null;
    onmute: ((this: MediaStreamTrack, ev: Event) => any) | null;
    onunmute: ((this: MediaStreamTrack, ev: Event) => any) | null;
    readonly readyState: MediaStreamTrackState;
    applyConstraints(constraints?: MediaTrackConstraints): Promise<void>;
    clone(): MediaStreamTrack;
    getCapabilities(): MediaTrackCapabilities;
    getConstraints(): MediaTrackConstraints;
    getSettings(): MediaTrackSettings;
    stop(): void;
    addEventListener<K extends keyof MediaStreamTrackEventMap>(type: K, listener: (this: MediaStreamTrack, ev: MediaStreamTrackEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MediaStreamTrackEventMap>(type: K, listener: (this: MediaStreamTrack, ev: MediaStreamTrackEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MediaStreamTrack: {
    prototype: MediaStreamTrack;
    new(): MediaStreamTrack;
    isInstance: IsInstance<MediaStreamTrack>;
};

interface MediaStreamTrackAudioSourceNode extends AudioNode, AudioNodePassThrough {
}

declare var MediaStreamTrackAudioSourceNode: {
    prototype: MediaStreamTrackAudioSourceNode;
    new(context: AudioContext, options: MediaStreamTrackAudioSourceOptions): MediaStreamTrackAudioSourceNode;
    isInstance: IsInstance<MediaStreamTrackAudioSourceNode>;
};

interface MediaStreamTrackEvent extends Event {
    readonly track: MediaStreamTrack;
}

declare var MediaStreamTrackEvent: {
    prototype: MediaStreamTrackEvent;
    new(type: string, eventInitDict: MediaStreamTrackEventInit): MediaStreamTrackEvent;
    isInstance: IsInstance<MediaStreamTrackEvent>;
};

/** Available only in secure contexts. */
interface MerchantValidationEvent extends Event {
    readonly methodName: string;
    readonly validationURL: string;
    complete(merchantSessionPromise: any): void;
}

declare var MerchantValidationEvent: {
    prototype: MerchantValidationEvent;
    new(type: string, eventInitDict?: MerchantValidationEventInit): MerchantValidationEvent;
    isInstance: IsInstance<MerchantValidationEvent>;
};

interface MessageBroadcaster extends MessageListenerManager {
    readonly childCount: number;
    broadcastAsyncMessage(messageName?: string | null, obj?: any): void;
    getChildAt(aIndex: number): MessageListenerManager | null;
    releaseCachedProcesses(): void;
}

declare var MessageBroadcaster: {
    prototype: MessageBroadcaster;
    new(): MessageBroadcaster;
    isInstance: IsInstance<MessageBroadcaster>;
};

interface MessageChannel {
    readonly port1: MessagePort;
    readonly port2: MessagePort;
}

declare var MessageChannel: {
    prototype: MessageChannel;
    new(): MessageChannel;
    isInstance: IsInstance<MessageChannel>;
};

interface MessageEvent extends Event {
    readonly data: any;
    readonly lastEventId: string;
    readonly origin: string;
    readonly ports: MessagePort[];
    readonly source: MessageEventSource | null;
    initMessageEvent(type: string, bubbles?: boolean, cancelable?: boolean, data?: any, origin?: string, lastEventId?: string, source?: MessageEventSource | null, ports?: MessagePort[]): void;
}

declare var MessageEvent: {
    prototype: MessageEvent;
    new(type: string, eventInitDict?: MessageEventInit): MessageEvent;
    isInstance: IsInstance<MessageEvent>;
};

interface MessageListenerManager extends MessageListenerManagerMixin {
}

declare var MessageListenerManager: {
    prototype: MessageListenerManager;
    new(): MessageListenerManager;
    isInstance: IsInstance<MessageListenerManager>;
};

interface MessageListenerManagerMixin {
    addMessageListener(messageName: string, listener: MessageListener, listenWhenClosed?: boolean): void;
    addWeakMessageListener(messageName: string, listener: MessageListener): void;
    removeMessageListener(messageName: string, listener: MessageListener): void;
    removeWeakMessageListener(messageName: string, listener: MessageListener): void;
}

interface MessageManagerGlobal {
    atob(asciiString: string): string;
    btoa(base64Data: string): string;
    dump(str: string): void;
}

interface MessagePortEventMap {
    "message": Event;
    "messageerror": Event;
}

interface MessagePort extends EventTarget {
    onmessage: ((this: MessagePort, ev: Event) => any) | null;
    onmessageerror: ((this: MessagePort, ev: Event) => any) | null;
    close(): void;
    postMessage(message: any, transferable: any[]): void;
    postMessage(message: any, options?: StructuredSerializeOptions): void;
    start(): void;
    addEventListener<K extends keyof MessagePortEventMap>(type: K, listener: (this: MessagePort, ev: MessagePortEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MessagePortEventMap>(type: K, listener: (this: MessagePort, ev: MessagePortEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var MessagePort: {
    prototype: MessagePort;
    new(): MessagePort;
    isInstance: IsInstance<MessagePort>;
};

interface MessageSender extends MessageListenerManager, MessageSenderMixin {
}

declare var MessageSender: {
    prototype: MessageSender;
    new(): MessageSender;
    isInstance: IsInstance<MessageSender>;
};

interface MessageSenderMixin {
    readonly processMessageManager: MessageSender | null;
    readonly remoteType: string;
    sendAsyncMessage(messageName?: string | null, obj?: any, transfers?: any): void;
}

interface MimeType {
    readonly description: string;
    readonly enabledPlugin: Plugin;
    readonly suffixes: string;
    readonly type: string;
}

declare var MimeType: {
    prototype: MimeType;
    new(): MimeType;
    isInstance: IsInstance<MimeType>;
};

interface MimeTypeArray {
    readonly length: number;
    item(index: number): MimeType | null;
    namedItem(name: string): MimeType | null;
    [index: number]: MimeType;
}

declare var MimeTypeArray: {
    prototype: MimeTypeArray;
    new(): MimeTypeArray;
    isInstance: IsInstance<MimeTypeArray>;
};

interface MouseEvent extends UIEvent {
    readonly altKey: boolean;
    readonly button: number;
    readonly buttons: number;
    readonly clientX: number;
    readonly clientY: number;
    readonly ctrlKey: boolean;
    readonly inputSource: number;
    readonly metaKey: boolean;
    readonly movementX: number;
    readonly movementY: number;
    readonly mozInputSource: number;
    readonly mozPressure: number;
    readonly offsetX: number;
    readonly offsetY: number;
    readonly pageX: number;
    readonly pageY: number;
    readonly relatedTarget: EventTarget | null;
    readonly screen: nsIScreen | null;
    readonly screenX: number;
    readonly screenY: number;
    readonly shiftKey: boolean;
    readonly x: number;
    readonly y: number;
    clickEventPrevented(): boolean;
    getModifierState(keyArg: string): boolean;
    initMouseEvent(typeArg: string, canBubbleArg?: boolean, cancelableArg?: boolean, viewArg?: Window | null, detailArg?: number, screenXArg?: number, screenYArg?: number, clientXArg?: number, clientYArg?: number, ctrlKeyArg?: boolean, altKeyArg?: boolean, shiftKeyArg?: boolean, metaKeyArg?: boolean, buttonArg?: number, relatedTargetArg?: EventTarget | null): void;
    initNSMouseEvent(typeArg: string, canBubbleArg?: boolean, cancelableArg?: boolean, viewArg?: Window | null, detailArg?: number, screenXArg?: number, screenYArg?: number, clientXArg?: number, clientYArg?: number, ctrlKeyArg?: boolean, altKeyArg?: boolean, shiftKeyArg?: boolean, metaKeyArg?: boolean, buttonArg?: number, relatedTargetArg?: EventTarget | null, pressure?: number, inputSourceArg?: number): void;
    preventClickEvent(): void;
    readonly MOZ_SOURCE_UNKNOWN: 0;
    readonly MOZ_SOURCE_MOUSE: 1;
    readonly MOZ_SOURCE_PEN: 2;
    readonly MOZ_SOURCE_ERASER: 3;
    readonly MOZ_SOURCE_CURSOR: 4;
    readonly MOZ_SOURCE_TOUCH: 5;
    readonly MOZ_SOURCE_KEYBOARD: 6;
}

declare var MouseEvent: {
    prototype: MouseEvent;
    new(typeArg: string, mouseEventInitDict?: MouseEventInit): MouseEvent;
    readonly MOZ_SOURCE_UNKNOWN: 0;
    readonly MOZ_SOURCE_MOUSE: 1;
    readonly MOZ_SOURCE_PEN: 2;
    readonly MOZ_SOURCE_ERASER: 3;
    readonly MOZ_SOURCE_CURSOR: 4;
    readonly MOZ_SOURCE_TOUCH: 5;
    readonly MOZ_SOURCE_KEYBOARD: 6;
    isInstance: IsInstance<MouseEvent>;
};

interface MouseScrollEvent extends MouseEvent {
    readonly axis: number;
    initMouseScrollEvent(type: string, canBubble?: boolean, cancelable?: boolean, view?: Window | null, detail?: number, screenX?: number, screenY?: number, clientX?: number, clientY?: number, ctrlKey?: boolean, altKey?: boolean, shiftKey?: boolean, metaKey?: boolean, button?: number, relatedTarget?: EventTarget | null, axis?: number): void;
    readonly HORIZONTAL_AXIS: 1;
    readonly VERTICAL_AXIS: 2;
}

declare var MouseScrollEvent: {
    prototype: MouseScrollEvent;
    new(): MouseScrollEvent;
    readonly HORIZONTAL_AXIS: 1;
    readonly VERTICAL_AXIS: 2;
    isInstance: IsInstance<MouseScrollEvent>;
};

interface MozCanvasPrintState {
    readonly context: nsISupports;
    done(): void;
}

declare var MozCanvasPrintState: {
    prototype: MozCanvasPrintState;
    new(): MozCanvasPrintState;
    isInstance: IsInstance<MozCanvasPrintState>;
};

interface MozDocumentMatcher {
    readonly allFrames: boolean;
    readonly checkPermissions: boolean;
    readonly excludeMatches: MatchPatternSet | null;
    readonly extension: WebExtensionPolicy | null;
    readonly frameID: number | null;
    readonly isUserScript: boolean;
    readonly matchAboutBlank: boolean;
    readonly matchOriginAsFallback: boolean;
    readonly matches: MatchPatternSet;
    readonly originAttributesPatterns: any;
    matchesURI(uri: URI): boolean;
    matchesWindowGlobal(windowGlobal: WindowGlobalChild, ignorePermissions?: boolean): boolean;
}

declare var MozDocumentMatcher: {
    prototype: MozDocumentMatcher;
    new(options: MozDocumentMatcherInit): MozDocumentMatcher;
    isInstance: IsInstance<MozDocumentMatcher>;
};

interface MozDocumentObserver {
    disconnect(): void;
    observe(matchers: MozDocumentMatcher[]): void;
}

declare var MozDocumentObserver: {
    prototype: MozDocumentObserver;
    new(callbacks: MozDocumentCallback): MozDocumentObserver;
    isInstance: IsInstance<MozDocumentObserver>;
};

interface MozEditableElement {
    readonly editor: nsIEditor | null;
    readonly hasEditor: boolean;
    readonly isInputEventTarget: boolean;
    setUserInput(input: string): void;
}

interface MozFrameLoaderOwner {
    readonly browsingContext: BrowsingContext | null;
    readonly frameLoader: FrameLoader | null;
    changeRemoteness(aOptions: RemotenessOptions): void;
    swapFrameLoaders(aOtherLoaderOwner: XULFrameElement): void;
    swapFrameLoaders(aOtherLoaderOwner: HTMLIFrameElement): void;
}

interface MozImageLoadingContent {
    readonly currentRequestFinalURI: URI | null;
    readonly currentURI: URI | null;
    loadingEnabled: boolean;
    addObserver(aObserver: imgINotificationObserver): void;
    forceReload(aNotify?: boolean): void;
    getRequest(aRequestType: number): imgIRequest | null;
    getRequestType(aRequest: imgIRequest): number;
    removeObserver(aObserver: imgINotificationObserver): void;
    readonly UNKNOWN_REQUEST: -1;
    readonly CURRENT_REQUEST: 0;
    readonly PENDING_REQUEST: 1;
}

interface MozObjectLoadingContent {
    readonly actualType: string;
    readonly displayedType: number;
    readonly srcURI: URI | null;
    readonly TYPE_LOADING: 0;
    readonly TYPE_DOCUMENT: 1;
    readonly TYPE_FALLBACK: 2;
}

interface MozQueryInterface {
}

declare var MozQueryInterface: {
    prototype: MozQueryInterface;
    new(): MozQueryInterface;
    isInstance: IsInstance<MozQueryInterface>;
};

interface MozSharedMap extends EventTarget {
    get(name: string): StructuredClonable;
    has(name: string): boolean;
    forEach(callbackfn: (value: StructuredClonable, key: string, parent: MozSharedMap) => void, thisArg?: any): void;
}

declare var MozSharedMap: {
    prototype: MozSharedMap;
    new(): MozSharedMap;
    isInstance: IsInstance<MozSharedMap>;
};

interface MozSharedMapChangeEvent extends Event {
    readonly changedKeys: string[];
}

declare var MozSharedMapChangeEvent: {
    prototype: MozSharedMapChangeEvent;
    new(): MozSharedMapChangeEvent;
    isInstance: IsInstance<MozSharedMapChangeEvent>;
};

interface MozStorageAsyncStatementParams {
    readonly length: number;
    [index: number]: any;
    [name: string]: any;
}

declare var MozStorageAsyncStatementParams: {
    prototype: MozStorageAsyncStatementParams;
    new(): MozStorageAsyncStatementParams;
    isInstance: IsInstance<MozStorageAsyncStatementParams>;
};

interface MozStorageStatementParams {
    readonly length: number;
    [index: number]: any;
    [name: string]: any;
}

declare var MozStorageStatementParams: {
    prototype: MozStorageStatementParams;
    new(): MozStorageStatementParams;
    isInstance: IsInstance<MozStorageStatementParams>;
};

interface MozStorageStatementRow {
    [name: string]: any;
}

declare var MozStorageStatementRow: {
    prototype: MozStorageStatementRow;
    new(): MozStorageStatementRow;
    isInstance: IsInstance<MozStorageStatementRow>;
};

interface MozWritableSharedMap extends MozSharedMap {
    delete(name: string): void;
    flush(): void;
    set(name: string, value: StructuredClonable): void;
}

declare var MozWritableSharedMap: {
    prototype: MozWritableSharedMap;
    new(): MozWritableSharedMap;
    isInstance: IsInstance<MozWritableSharedMap>;
};

interface MutationEvent extends Event {
    readonly attrChange: number;
    readonly attrName: string;
    readonly newValue: string;
    readonly prevValue: string;
    readonly relatedNode: Node | null;
    initMutationEvent(type: string, canBubble?: boolean, cancelable?: boolean, relatedNode?: Node | null, prevValue?: string, newValue?: string, attrName?: string, attrChange?: number): void;
    readonly MODIFICATION: 1;
    readonly ADDITION: 2;
    readonly REMOVAL: 3;
}

declare var MutationEvent: {
    prototype: MutationEvent;
    new(): MutationEvent;
    readonly MODIFICATION: 1;
    readonly ADDITION: 2;
    readonly REMOVAL: 3;
    isInstance: IsInstance<MutationEvent>;
};

interface MutationObserver {
    mergeAttributeRecords: boolean;
    readonly mutationCallback: MutationCallback;
    disconnect(): void;
    getObservingInfo(): (MutationObservingInfo | null)[];
    observe(target: Node, options?: MutationObserverInit): void;
    takeRecords(): MutationRecord[];
}

declare var MutationObserver: {
    prototype: MutationObserver;
    new(mutationCallback: MutationCallback): MutationObserver;
    isInstance: IsInstance<MutationObserver>;
};

interface MutationRecord {
    readonly addedAnimations: Animation[];
    readonly addedNodes: NodeList;
    readonly attributeName: string | null;
    readonly attributeNamespace: string | null;
    readonly changedAnimations: Animation[];
    readonly nextSibling: Node | null;
    readonly oldValue: string | null;
    readonly previousSibling: Node | null;
    readonly removedAnimations: Animation[];
    readonly removedNodes: NodeList;
    readonly target: Node | null;
    readonly type: string;
}

declare var MutationRecord: {
    prototype: MutationRecord;
    new(): MutationRecord;
    isInstance: IsInstance<MutationRecord>;
};

interface NamedNodeMap {
    readonly length: number;
    getNamedItem(name: string): Attr | null;
    getNamedItemNS(namespaceURI: string | null, localName: string): Attr | null;
    item(index: number): Attr | null;
    removeNamedItem(name: string): Attr;
    removeNamedItemNS(namespaceURI: string | null, localName: string): Attr;
    setNamedItem(arg: Attr): Attr | null;
    setNamedItemNS(arg: Attr): Attr | null;
    [index: number]: Attr;
}

declare var NamedNodeMap: {
    prototype: NamedNodeMap;
    new(): NamedNodeMap;
    isInstance: IsInstance<NamedNodeMap>;
};

interface NavigateEvent extends Event {
    readonly canIntercept: boolean;
    readonly destination: NavigationDestination;
    readonly downloadRequest: string | null;
    readonly formData: FormData | null;
    readonly hasUAVisualTransition: boolean;
    readonly hashChange: boolean;
    readonly info: any;
    readonly navigationType: NavigationType;
    readonly signal: AbortSignal;
    readonly sourceElement: Element | null;
    readonly userInitiated: boolean;
    intercept(options?: NavigationInterceptOptions): void;
    scroll(): void;
}

declare var NavigateEvent: {
    prototype: NavigateEvent;
    new(type: string, eventInitDict: NavigateEventInit): NavigateEvent;
    isInstance: IsInstance<NavigateEvent>;
};

interface NavigationEventMap {
    "currententrychange": Event;
    "navigate": Event;
    "navigateerror": Event;
    "navigatesuccess": Event;
}

interface Navigation extends EventTarget {
    readonly activation: NavigationActivation | null;
    readonly canGoBack: boolean;
    readonly canGoForward: boolean;
    readonly currentEntry: NavigationHistoryEntry | null;
    oncurrententrychange: ((this: Navigation, ev: Event) => any) | null;
    onnavigate: ((this: Navigation, ev: Event) => any) | null;
    onnavigateerror: ((this: Navigation, ev: Event) => any) | null;
    onnavigatesuccess: ((this: Navigation, ev: Event) => any) | null;
    readonly transition: NavigationTransition | null;
    back(options?: NavigationOptions): NavigationResult;
    entries(): NavigationHistoryEntry[];
    forward(options?: NavigationOptions): NavigationResult;
    navigate(url: string | URL, options?: NavigationNavigateOptions): NavigationResult;
    reload(options?: NavigationReloadOptions): NavigationResult;
    traverseTo(key: string, options?: NavigationOptions): NavigationResult;
    updateCurrentEntry(options: NavigationUpdateCurrentEntryOptions): void;
    addEventListener<K extends keyof NavigationEventMap>(type: K, listener: (this: Navigation, ev: NavigationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof NavigationEventMap>(type: K, listener: (this: Navigation, ev: NavigationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var Navigation: {
    prototype: Navigation;
    new(): Navigation;
    isInstance: IsInstance<Navigation>;
};

interface NavigationActivation {
    readonly entry: NavigationHistoryEntry;
    readonly from: NavigationHistoryEntry | null;
    readonly navigationType: NavigationType;
}

declare var NavigationActivation: {
    prototype: NavigationActivation;
    new(): NavigationActivation;
    isInstance: IsInstance<NavigationActivation>;
};

interface NavigationCurrentEntryChangeEvent extends Event {
    readonly from: NavigationHistoryEntry;
    readonly navigationType: NavigationType | null;
}

declare var NavigationCurrentEntryChangeEvent: {
    prototype: NavigationCurrentEntryChangeEvent;
    new(type: string, eventInitDict: NavigationCurrentEntryChangeEventInit): NavigationCurrentEntryChangeEvent;
    isInstance: IsInstance<NavigationCurrentEntryChangeEvent>;
};

interface NavigationDestination {
    readonly id: string;
    readonly index: number;
    readonly key: string;
    readonly sameDocument: boolean;
    readonly url: string;
    getState(): any;
}

declare var NavigationDestination: {
    prototype: NavigationDestination;
    new(): NavigationDestination;
    isInstance: IsInstance<NavigationDestination>;
};

interface NavigationHistoryEntryEventMap {
    "dispose": Event;
}

interface NavigationHistoryEntry extends EventTarget {
    readonly id: string;
    readonly index: number;
    readonly key: string;
    ondispose: ((this: NavigationHistoryEntry, ev: Event) => any) | null;
    readonly sameDocument: boolean;
    readonly url: string | null;
    getState(): any;
    addEventListener<K extends keyof NavigationHistoryEntryEventMap>(type: K, listener: (this: NavigationHistoryEntry, ev: NavigationHistoryEntryEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof NavigationHistoryEntryEventMap>(type: K, listener: (this: NavigationHistoryEntry, ev: NavigationHistoryEntryEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var NavigationHistoryEntry: {
    prototype: NavigationHistoryEntry;
    new(): NavigationHistoryEntry;
    isInstance: IsInstance<NavigationHistoryEntry>;
};

/** Available only in secure contexts. */
interface NavigationPreloadManager {
    disable(): Promise<void>;
    enable(): Promise<void>;
    getState(): Promise<NavigationPreloadState>;
    setHeaderValue(value: string): Promise<void>;
}

declare var NavigationPreloadManager: {
    prototype: NavigationPreloadManager;
    new(): NavigationPreloadManager;
    isInstance: IsInstance<NavigationPreloadManager>;
};

interface NavigationTransition {
    readonly finished: Promise<void>;
    readonly from: NavigationHistoryEntry;
    readonly navigationType: NavigationType;
}

declare var NavigationTransition: {
    prototype: NavigationTransition;
    new(): NavigationTransition;
    isInstance: IsInstance<NavigationTransition>;
};

interface Navigator extends GlobalPrivacyControl, NavigatorAutomationInformation, NavigatorConcurrentHardware, NavigatorContentUtils, NavigatorGPU, NavigatorGeolocation, NavigatorID, NavigatorLanguage, NavigatorLocks, NavigatorOnLine, NavigatorStorage {
    /** Available only in secure contexts. */
    readonly activeVRDisplays: VRDisplay[];
    readonly buildID: string;
    /** Available only in secure contexts. */
    readonly clipboard: Clipboard;
    readonly connection: NetworkInformation;
    readonly cookieEnabled: boolean;
    /** Available only in secure contexts. */
    readonly credentials: CredentialsContainer;
    readonly doNotTrack: string;
    readonly isWebVRContentDetected: boolean;
    readonly isWebVRContentPresenting: boolean;
    readonly login: NavigatorLogin;
    readonly maxTouchPoints: number;
    readonly mediaCapabilities: MediaCapabilities;
    readonly mediaDevices: MediaDevices;
    readonly mediaSession: MediaSession;
    readonly mimeTypes: MimeTypeArray;
    readonly mozAddonManager: AddonManager;
    readonly mozTCPSocket: LegacyMozTCPSocket;
    readonly oscpu: string;
    readonly pdfViewerEnabled: boolean;
    readonly permissions: Permissions;
    readonly plugins: PluginArray;
    readonly privateAttribution: PrivateAttribution;
    readonly productSub: string;
    readonly serviceWorker: ServiceWorkerContainer;
    readonly testTrialGatedAttribute: boolean;
    readonly userActivation: UserActivation;
    readonly vendor: string;
    readonly vendorSub: string;
    readonly wakeLock: WakeLock;
    /** Available only in secure contexts. */
    readonly xr: XRSystem;
    /** Available only in secure contexts. */
    canShare(data?: ShareData): boolean;
    getAutoplayPolicy(type: AutoplayPolicyMediaType): AutoplayPolicy;
    getAutoplayPolicy(element: HTMLMediaElement): AutoplayPolicy;
    getAutoplayPolicy(context: AudioContext): AutoplayPolicy;
    getBattery(): Promise<BatteryManager>;
    getGamepads(): (Gamepad | null)[];
    /** Available only in secure contexts. */
    getVRDisplays(): Promise<VRDisplay[]>;
    javaEnabled(): boolean;
    mozGetUserMedia(constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void;
    requestAllGamepads(): Promise<Gamepad[]>;
    requestGamepadServiceTest(): GamepadServiceTest;
    requestMIDIAccess(options?: MIDIOptions): Promise<MIDIAccess>;
    requestMediaKeySystemAccess(keySystem: string, supportedConfigurations: MediaKeySystemConfiguration[]): Promise<MediaKeySystemAccess>;
    requestVRPresentation(display: VRDisplay): void;
    requestVRServiceTest(): VRServiceTest;
    sendBeacon(url: string, data?: BodyInit | null): boolean;
    setVibrationPermission(permitted: boolean, persistent?: boolean): void;
    /** Available only in secure contexts. */
    share(data?: ShareData): Promise<void>;
    vibrate(duration: number): boolean;
    vibrate(pattern: number[]): boolean;
}

declare var Navigator: {
    prototype: Navigator;
    new(): Navigator;
    isInstance: IsInstance<Navigator>;
};

interface NavigatorAutomationInformation {
    readonly webdriver: boolean;
}

interface NavigatorConcurrentHardware {
    readonly hardwareConcurrency: number;
}

interface NavigatorContentUtils {
    checkProtocolHandlerAllowed(scheme: string, handlerURI: URI, documentURI: URI): void;
    /** Available only in secure contexts. */
    registerProtocolHandler(scheme: string, url: string): void;
}

interface NavigatorGPU {
    /** Available only in secure contexts. */
    readonly gpu: GPU;
}

interface NavigatorGeolocation {
    readonly geolocation: Geolocation;
}

interface NavigatorID {
    readonly appCodeName: string;
    readonly appName: string;
    readonly appVersion: string;
    readonly platform: string;
    readonly product: string;
    readonly userAgent: string;
    taintEnabled(): boolean;
}

interface NavigatorLanguage {
    readonly language: string | null;
    readonly languages: string[];
}

/** Available only in secure contexts. */
interface NavigatorLocks {
    readonly locks: LockManager;
}

/** Available only in secure contexts. */
interface NavigatorLogin {
    setStatus(status: LoginStatus): Promise<void>;
}

declare var NavigatorLogin: {
    prototype: NavigatorLogin;
    new(): NavigatorLogin;
    isInstance: IsInstance<NavigatorLogin>;
};

interface NavigatorOnLine {
    readonly onLine: boolean;
}

/** Available only in secure contexts. */
interface NavigatorStorage {
    readonly storage: StorageManager;
}

interface NetworkInformationEventMap {
    "typechange": Event;
}

interface NetworkInformation extends EventTarget {
    ontypechange: ((this: NetworkInformation, ev: Event) => any) | null;
    readonly type: ConnectionType;
    addEventListener<K extends keyof NetworkInformationEventMap>(type: K, listener: (this: NetworkInformation, ev: NetworkInformationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof NetworkInformationEventMap>(type: K, listener: (this: NetworkInformation, ev: NetworkInformationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var NetworkInformation: {
    prototype: NetworkInformation;
    new(): NetworkInformation;
    isInstance: IsInstance<NetworkInformation>;
};

interface Node extends EventTarget {
    readonly accessibleNode: AccessibleNode | null;
    readonly baseURI: string | null;
    readonly baseURIObject: URI | null;
    readonly childNodes: NodeList;
    readonly containingShadowRoot: ShadowRoot | null;
    readonly firstChild: Node | null;
    readonly flattenedTreeParentNode: Node | null;
    readonly isConnected: boolean;
    readonly isNativeAnonymous: boolean;
    readonly lastChild: Node | null;
    readonly nextSibling: Node | null;
    readonly nodeName: string;
    readonly nodePrincipal: Principal;
    readonly nodeType: number;
    nodeValue: string | null;
    readonly ownerDocument: Document | null;
    readonly parentElement: Element | null;
    readonly parentFlexElement: Element | null;
    readonly parentNode: Node | null;
    readonly previousSibling: Node | null;
    textContent: string | null;
    appendChild(node: Node): Node;
    cloneNode(deep?: boolean): Node;
    compareDocumentPosition(other: Node): number;
    contains(other: Node | null): boolean;
    generateXPath(): string;
    getRootNode(options?: GetRootNodeOptions): Node;
    hasChildNodes(): boolean;
    insertBefore(node: Node, child: Node | null): Node;
    isDefaultNamespace(namespace: string | null): boolean;
    isEqualNode(node: Node | null): boolean;
    isSameNode(node: Node | null): boolean;
    lookupNamespaceURI(prefix: string | null): string | null;
    lookupPrefix(namespace: string | null): string | null;
    normalize(): void;
    removeChild(child: Node): Node;
    replaceChild(node: Node, child: Node): Node;
    readonly ELEMENT_NODE: 1;
    readonly ATTRIBUTE_NODE: 2;
    readonly TEXT_NODE: 3;
    readonly CDATA_SECTION_NODE: 4;
    readonly ENTITY_REFERENCE_NODE: 5;
    readonly ENTITY_NODE: 6;
    readonly PROCESSING_INSTRUCTION_NODE: 7;
    readonly COMMENT_NODE: 8;
    readonly DOCUMENT_NODE: 9;
    readonly DOCUMENT_TYPE_NODE: 10;
    readonly DOCUMENT_FRAGMENT_NODE: 11;
    readonly NOTATION_NODE: 12;
    readonly DOCUMENT_POSITION_DISCONNECTED: 0x01;
    readonly DOCUMENT_POSITION_PRECEDING: 0x02;
    readonly DOCUMENT_POSITION_FOLLOWING: 0x04;
    readonly DOCUMENT_POSITION_CONTAINS: 0x08;
    readonly DOCUMENT_POSITION_CONTAINED_BY: 0x10;
    readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 0x20;
}

declare var Node: {
    prototype: Node;
    new(): Node;
    readonly ELEMENT_NODE: 1;
    readonly ATTRIBUTE_NODE: 2;
    readonly TEXT_NODE: 3;
    readonly CDATA_SECTION_NODE: 4;
    readonly ENTITY_REFERENCE_NODE: 5;
    readonly ENTITY_NODE: 6;
    readonly PROCESSING_INSTRUCTION_NODE: 7;
    readonly COMMENT_NODE: 8;
    readonly DOCUMENT_NODE: 9;
    readonly DOCUMENT_TYPE_NODE: 10;
    readonly DOCUMENT_FRAGMENT_NODE: 11;
    readonly NOTATION_NODE: 12;
    readonly DOCUMENT_POSITION_DISCONNECTED: 0x01;
    readonly DOCUMENT_POSITION_PRECEDING: 0x02;
    readonly DOCUMENT_POSITION_FOLLOWING: 0x04;
    readonly DOCUMENT_POSITION_CONTAINS: 0x08;
    readonly DOCUMENT_POSITION_CONTAINED_BY: 0x10;
    readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 0x20;
    isInstance: IsInstance<Node>;
};

interface NodeIterator {
    readonly filter: NodeFilter | null;
    readonly pointerBeforeReferenceNode: boolean;
    readonly referenceNode: Node | null;
    readonly root: Node;
    readonly whatToShow: number;
    detach(): void;
    nextNode(): Node | null;
    previousNode(): Node | null;
}

declare var NodeIterator: {
    prototype: NodeIterator;
    new(): NodeIterator;
    isInstance: IsInstance<NodeIterator>;
};

interface NodeList {
    readonly length: number;
    item(index: number): Node | null;
    forEach(callbackfn: (value: Node | null, key: number, parent: NodeList) => void, thisArg?: any): void;
    [index: number]: Node;
}

declare var NodeList: {
    prototype: NodeList;
    new(): NodeList;
    isInstance: IsInstance<NodeList>;
};

interface NonDocumentTypeChildNode {
    readonly nextElementSibling: Element | null;
    readonly previousElementSibling: Element | null;
}

interface NonElementParentNode {
    getElementById(elementId: string): Element | null;
}

interface NotificationEventMap {
    "click": Event;
    "close": Event;
    "error": Event;
    "show": Event;
}

interface Notification extends EventTarget {
    readonly actions: NotificationAction[];
    readonly body: string | null;
    readonly data: any;
    readonly dir: NotificationDirection;
    readonly icon: string | null;
    readonly lang: string | null;
    onclick: ((this: Notification, ev: Event) => any) | null;
    onclose: ((this: Notification, ev: Event) => any) | null;
    onerror: ((this: Notification, ev: Event) => any) | null;
    onshow: ((this: Notification, ev: Event) => any) | null;
    readonly requireInteraction: boolean;
    readonly silent: boolean;
    readonly tag: string | null;
    readonly title: string;
    readonly vibrate: number[];
    close(): void;
    addEventListener<K extends keyof NotificationEventMap>(type: K, listener: (this: Notification, ev: NotificationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof NotificationEventMap>(type: K, listener: (this: Notification, ev: NotificationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var Notification: {
    prototype: Notification;
    new(title: string, options?: NotificationOptions): Notification;
    isInstance: IsInstance<Notification>;
    readonly maxActions: number;
    readonly permission: NotificationPermission;
    requestPermission(permissionCallback?: NotificationPermissionCallback): Promise<NotificationPermission>;
};

interface NotifyPaintEvent extends Event {
    readonly boundingClientRect: DOMRect;
    readonly clientRects: DOMRectList;
    readonly paintRequests: PaintRequestList;
    readonly paintTimeStamp: DOMHighResTimeStamp;
    readonly transactionId: number;
}

declare var NotifyPaintEvent: {
    prototype: NotifyPaintEvent;
    new(): NotifyPaintEvent;
    isInstance: IsInstance<NotifyPaintEvent>;
};

interface OES_draw_buffers_indexed {
    blendEquationSeparateiOES(buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum): void;
    blendEquationiOES(buf: GLuint, mode: GLenum): void;
    blendFuncSeparateiOES(buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum): void;
    blendFunciOES(buf: GLuint, src: GLenum, dst: GLenum): void;
    colorMaskiOES(buf: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean): void;
    disableiOES(target: GLenum, index: GLuint): void;
    enableiOES(target: GLenum, index: GLuint): void;
}

interface OES_element_index_uint {
}

interface OES_fbo_render_mipmap {
}

interface OES_standard_derivatives {
    readonly FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 0x8B8B;
}

interface OES_texture_float {
}

interface OES_texture_float_linear {
}

interface OES_texture_half_float {
    readonly HALF_FLOAT_OES: 0x8D61;
}

interface OES_texture_half_float_linear {
}

interface OES_vertex_array_object {
    bindVertexArrayOES(arrayObject: WebGLVertexArrayObject | null): void;
    createVertexArrayOES(): WebGLVertexArrayObject;
    deleteVertexArrayOES(arrayObject: WebGLVertexArrayObject | null): void;
    isVertexArrayOES(arrayObject: WebGLVertexArrayObject | null): GLboolean;
    readonly VERTEX_ARRAY_BINDING_OES: 0x85B5;
}

interface OVR_multiview2 {
    framebufferTextureMultiviewOVR(target: GLenum, attachment: GLenum, texture: WebGLTexture | null, level: GLint, baseViewIndex: GLint, numViews: GLsizei): void;
    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR: 0x9630;
    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR: 0x9632;
    readonly MAX_VIEWS_OVR: 0x9631;
    readonly FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: 0x9633;
}

interface OfflineAudioCompletionEvent extends Event {
    readonly renderedBuffer: AudioBuffer;
}

declare var OfflineAudioCompletionEvent: {
    prototype: OfflineAudioCompletionEvent;
    new(type: string, eventInitDict: OfflineAudioCompletionEventInit): OfflineAudioCompletionEvent;
    isInstance: IsInstance<OfflineAudioCompletionEvent>;
};

interface OfflineAudioContextEventMap extends BaseAudioContextEventMap {
    "complete": Event;
}

interface OfflineAudioContext extends BaseAudioContext {
    readonly length: number;
    oncomplete: ((this: OfflineAudioContext, ev: Event) => any) | null;
    startRendering(): Promise<AudioBuffer>;
    addEventListener<K extends keyof OfflineAudioContextEventMap>(type: K, listener: (this: OfflineAudioContext, ev: OfflineAudioContextEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof OfflineAudioContextEventMap>(type: K, listener: (this: OfflineAudioContext, ev: OfflineAudioContextEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var OfflineAudioContext: {
    prototype: OfflineAudioContext;
    new(contextOptions: OfflineAudioContextOptions): OfflineAudioContext;
    new(numberOfChannels: number, length: number, sampleRate: number): OfflineAudioContext;
    isInstance: IsInstance<OfflineAudioContext>;
};

interface OffscreenCanvasEventMap {
    "contextlost": Event;
    "contextrestored": Event;
}

interface OffscreenCanvas extends EventTarget {
    height: number;
    oncontextlost: ((this: OffscreenCanvas, ev: Event) => any) | null;
    oncontextrestored: ((this: OffscreenCanvas, ev: Event) => any) | null;
    width: number;
    convertToBlob(options?: ImageEncodeOptions): Promise<Blob>;
    getContext(contextId: OffscreenRenderingContextId, contextOptions?: any): OffscreenRenderingContext | null;
    toBlob(type?: string, encoderOptions?: any): Promise<Blob>;
    transferToImageBitmap(): ImageBitmap;
    addEventListener<K extends keyof OffscreenCanvasEventMap>(type: K, listener: (this: OffscreenCanvas, ev: OffscreenCanvasEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof OffscreenCanvasEventMap>(type: K, listener: (this: OffscreenCanvas, ev: OffscreenCanvasEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var OffscreenCanvas: {
    prototype: OffscreenCanvas;
    new(width: number, height: number): OffscreenCanvas;
    isInstance: IsInstance<OffscreenCanvas>;
};

interface OffscreenCanvasRenderingContext2D extends CanvasCompositing, CanvasDrawImage, CanvasDrawPath, CanvasFillStrokeStyles, CanvasFilters, CanvasImageData, CanvasImageSmoothing, CanvasPathDrawingStyles, CanvasPathMethods, CanvasRect, CanvasShadowStyles, CanvasState, CanvasText, CanvasTextDrawingStyles, CanvasTransform {
    readonly canvas: OffscreenCanvas;
    commit(): void;
}

declare var OffscreenCanvasRenderingContext2D: {
    prototype: OffscreenCanvasRenderingContext2D;
    new(): OffscreenCanvasRenderingContext2D;
    isInstance: IsInstance<OffscreenCanvasRenderingContext2D>;
};

interface OnErrorEventHandlerForNodesEventMap {
    "error": Event;
}

interface OnErrorEventHandlerForNodes {
    onerror: ((this: OnErrorEventHandlerForNodes, ev: Event) => any) | null;
    addEventListener<K extends keyof OnErrorEventHandlerForNodesEventMap>(type: K, listener: (this: OnErrorEventHandlerForNodes, ev: OnErrorEventHandlerForNodesEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof OnErrorEventHandlerForNodesEventMap>(type: K, listener: (this: OnErrorEventHandlerForNodes, ev: OnErrorEventHandlerForNodesEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

interface OnErrorEventHandlerForWindowEventMap {
    "error": Event;
}

interface OnErrorEventHandlerForWindow {
    onerror: ((this: OnErrorEventHandlerForWindow, ev: Event) => any) | null;
    addEventListener<K extends keyof OnErrorEventHandlerForWindowEventMap>(type: K, listener: (this: OnErrorEventHandlerForWindow, ev: OnErrorEventHandlerForWindowEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof OnErrorEventHandlerForWindowEventMap>(type: K, listener: (this: OnErrorEventHandlerForWindow, ev: OnErrorEventHandlerForWindowEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

interface OscillatorNode extends AudioScheduledSourceNode, AudioNodePassThrough {
    readonly detune: AudioParam;
    readonly frequency: AudioParam;
    type: OscillatorType;
    setPeriodicWave(periodicWave: PeriodicWave): void;
    addEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: OscillatorNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: OscillatorNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var OscillatorNode: {
    prototype: OscillatorNode;
    new(context: BaseAudioContext, options?: OscillatorOptions): OscillatorNode;
    isInstance: IsInstance<OscillatorNode>;
};

interface PageTransitionEvent extends Event {
    readonly inFrameSwap: boolean;
    readonly persisted: boolean;
}

declare var PageTransitionEvent: {
    prototype: PageTransitionEvent;
    new(type: string, eventInitDict?: PageTransitionEventInit): PageTransitionEvent;
    isInstance: IsInstance<PageTransitionEvent>;
};

interface PaintRequest {
    readonly clientRect: DOMRect;
    readonly reason: string;
}

declare var PaintRequest: {
    prototype: PaintRequest;
    new(): PaintRequest;
    isInstance: IsInstance<PaintRequest>;
};

interface PaintRequestList {
    readonly length: number;
    item(index: number): PaintRequest | null;
    [index: number]: PaintRequest;
}

declare var PaintRequestList: {
    prototype: PaintRequestList;
    new(): PaintRequestList;
    isInstance: IsInstance<PaintRequestList>;
};

interface PaintTimingMixin {
    readonly paintTime: DOMHighResTimeStamp;
    readonly presentationTime: DOMHighResTimeStamp | null;
}

interface PannerNode extends AudioNode, AudioNodePassThrough {
    coneInnerAngle: number;
    coneOuterAngle: number;
    coneOuterGain: number;
    distanceModel: DistanceModelType;
    maxDistance: number;
    readonly orientationX: AudioParam;
    readonly orientationY: AudioParam;
    readonly orientationZ: AudioParam;
    panningModel: PanningModelType;
    readonly positionX: AudioParam;
    readonly positionY: AudioParam;
    readonly positionZ: AudioParam;
    refDistance: number;
    rolloffFactor: number;
    setOrientation(x: number, y: number, z: number): void;
    setPosition(x: number, y: number, z: number): void;
}

declare var PannerNode: {
    prototype: PannerNode;
    new(context: BaseAudioContext, options?: PannerOptions): PannerNode;
    isInstance: IsInstance<PannerNode>;
};

interface ParentNode {
    readonly childElementCount: number;
    readonly children: HTMLCollection;
    readonly firstElementChild: Element | null;
    readonly lastElementChild: Element | null;
    append(...nodes: (Node | string)[]): void;
    getElementsByAttribute(name: string, value: string | null): HTMLCollection;
    getElementsByAttributeNS(namespaceURI: string | null, name: string, value: string | null): HTMLCollection;
    prepend(...nodes: (Node | string)[]): void;
    querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;
    querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;
    querySelector<K extends keyof MathMLElementTagNameMap>(selectors: K): MathMLElementTagNameMap[K] | null;
    /** @deprecated */
    querySelector<K extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K): HTMLElementDeprecatedTagNameMap[K] | null;
    querySelector<E extends Element = Element>(selectors: string): E | null;
    querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;
    querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>;
    querySelectorAll<K extends keyof MathMLElementTagNameMap>(selectors: K): NodeListOf<MathMLElementTagNameMap[K]>;
    /** @deprecated */
    querySelectorAll<K extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K): NodeListOf<HTMLElementDeprecatedTagNameMap[K]>;
    querySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;
    replaceChildren(...nodes: (Node | string)[]): void;
}

interface ParentProcessMessageManager extends MessageBroadcaster, GlobalProcessScriptLoader, ProcessScriptLoader {
}

declare var ParentProcessMessageManager: {
    prototype: ParentProcessMessageManager;
    new(): ParentProcessMessageManager;
    isInstance: IsInstance<ParentProcessMessageManager>;
};

interface Path2D extends CanvasPathMethods {
    addPath(path: Path2D, transform?: DOMMatrix2DInit): void;
}

declare var Path2D: {
    prototype: Path2D;
    new(): Path2D;
    new(other: Path2D): Path2D;
    new(pathString: string): Path2D;
    isInstance: IsInstance<Path2D>;
};

/** Available only in secure contexts. */
interface PaymentAddress {
    readonly addressLine: string[];
    readonly city: string;
    readonly country: string;
    readonly dependentLocality: string;
    readonly organization: string;
    readonly phone: string;
    readonly postalCode: string;
    readonly recipient: string;
    readonly region: string;
    readonly regionCode: string;
    readonly sortingCode: string;
    toJSON(): any;
}

declare var PaymentAddress: {
    prototype: PaymentAddress;
    new(): PaymentAddress;
    isInstance: IsInstance<PaymentAddress>;
};

/** Available only in secure contexts. */
interface PaymentMethodChangeEvent extends PaymentRequestUpdateEvent {
    readonly methodDetails: any;
    readonly methodName: string;
}

declare var PaymentMethodChangeEvent: {
    prototype: PaymentMethodChangeEvent;
    new(type: string, eventInitDict?: PaymentMethodChangeEventInit): PaymentMethodChangeEvent;
    isInstance: IsInstance<PaymentMethodChangeEvent>;
};

interface PaymentRequestEventMap {
    "merchantvalidation": Event;
    "paymentmethodchange": Event;
    "shippingaddresschange": Event;
    "shippingoptionchange": Event;
}

/** Available only in secure contexts. */
interface PaymentRequest extends EventTarget {
    readonly id: string;
    onmerchantvalidation: ((this: PaymentRequest, ev: Event) => any) | null;
    onpaymentmethodchange: ((this: PaymentRequest, ev: Event) => any) | null;
    onshippingaddresschange: ((this: PaymentRequest, ev: Event) => any) | null;
    onshippingoptionchange: ((this: PaymentRequest, ev: Event) => any) | null;
    readonly shippingAddress: PaymentAddress | null;
    readonly shippingOption: string | null;
    readonly shippingType: PaymentShippingType | null;
    abort(): Promise<void>;
    canMakePayment(): Promise<boolean>;
    show(detailsPromise?: PaymentDetailsUpdate | PromiseLike<PaymentDetailsUpdate>): Promise<PaymentResponse>;
    addEventListener<K extends keyof PaymentRequestEventMap>(type: K, listener: (this: PaymentRequest, ev: PaymentRequestEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof PaymentRequestEventMap>(type: K, listener: (this: PaymentRequest, ev: PaymentRequestEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var PaymentRequest: {
    prototype: PaymentRequest;
    new(methodData: PaymentMethodData[], details: PaymentDetailsInit, options?: PaymentOptions): PaymentRequest;
    isInstance: IsInstance<PaymentRequest>;
};

/** Available only in secure contexts. */
interface PaymentRequestUpdateEvent extends Event {
    updateWith(detailsPromise: PaymentDetailsUpdate | PromiseLike<PaymentDetailsUpdate>): void;
}

declare var PaymentRequestUpdateEvent: {
    prototype: PaymentRequestUpdateEvent;
    new(type: string, eventInitDict?: PaymentRequestUpdateEventInit): PaymentRequestUpdateEvent;
    isInstance: IsInstance<PaymentRequestUpdateEvent>;
};

interface PaymentResponseEventMap {
    "payerdetailchange": Event;
}

/** Available only in secure contexts. */
interface PaymentResponse extends EventTarget {
    readonly details: any;
    readonly methodName: string;
    onpayerdetailchange: ((this: PaymentResponse, ev: Event) => any) | null;
    readonly payerEmail: string | null;
    readonly payerName: string | null;
    readonly payerPhone: string | null;
    readonly requestId: string;
    readonly shippingAddress: PaymentAddress | null;
    readonly shippingOption: string | null;
    complete(result?: PaymentComplete): Promise<void>;
    retry(errorFields?: PaymentValidationErrors): Promise<void>;
    toJSON(): any;
    addEventListener<K extends keyof PaymentResponseEventMap>(type: K, listener: (this: PaymentResponse, ev: PaymentResponseEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof PaymentResponseEventMap>(type: K, listener: (this: PaymentResponse, ev: PaymentResponseEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var PaymentResponse: {
    prototype: PaymentResponse;
    new(): PaymentResponse;
    isInstance: IsInstance<PaymentResponse>;
};

interface PeerConnectionImpl {
    certificate: RTCCertificate;
    readonly connectionState: RTCPeerConnectionState;
    readonly currentLocalDescription: string;
    readonly currentOfferer: boolean | null;
    readonly currentRemoteDescription: string;
    readonly duplicateFingerprintQuirk: boolean;
    readonly fingerprint: string;
    readonly iceConnectionState: RTCIceConnectionState;
    readonly iceGatheringState: RTCIceGatheringState;
    id: string;
    peerIdentity: string;
    readonly pendingLocalDescription: string;
    readonly pendingOfferer: boolean | null;
    readonly pendingRemoteDescription: string;
    readonly privacyRequested: boolean;
    readonly sctp: RTCSctpTransport | null;
    readonly signalingState: RTCSignalingState;
    addIceCandidate(candidate: string, mid: string, ufrag: string, level: number | null): void;
    addTransceiver(init: RTCRtpTransceiverInit, kind: string, sendTrack: MediaStreamTrack | null, addTrackMagic: boolean): RTCRtpTransceiver;
    chain(op: ChainedOperation): Promise<any>;
    close(): void;
    closeStreams(): void;
    createAnswer(): void;
    createDataChannel(label: string, protocol: string, type: number, ordered: boolean, maxTime: number, maxNum: number, externalNegotiated: boolean, stream: number): RTCDataChannel;
    createOffer(options?: RTCOfferOptions): void;
    createdSender(sender: RTCRtpSender): boolean;
    disablePacketDump(level: number, type: mozPacketDumpType, sending: boolean): void;
    enablePacketDump(level: number, type: mozPacketDumpType, sending: boolean): void;
    getRemoteStreams(): MediaStream[];
    getStats(selector: MediaStreamTrack | null): Promise<RTCStatsReport>;
    getTransceivers(): RTCRtpTransceiver[];
    initialize(observer: PeerConnectionObserver, window: Window): void;
    onSetDescriptionError(): void;
    onSetDescriptionSuccess(type: RTCSdpType, remote: boolean): Promise<void>;
    pluginCrash(pluginId: number, name: string): boolean;
    restartIce(): void;
    restartIceNoRenegotiationNeeded(): void;
    setConfiguration(config?: RTCConfiguration): void;
    setLocalDescription(action: number, sdp: string): void;
    setRemoteDescription(action: number, sdp: string): void;
    updateNegotiationNeeded(): void;
}

declare var PeerConnectionImpl: {
    prototype: PeerConnectionImpl;
    new(): PeerConnectionImpl;
    isInstance: IsInstance<PeerConnectionImpl>;
};

interface PeerConnectionObserver {
    fireNegotiationNeededEvent(): void;
    fireStreamEvent(stream: MediaStream): void;
    fireTrackEvent(receiver: RTCRtpReceiver, streams: MediaStream[]): void;
    notifyDataChannel(channel: RTCDataChannel): void;
    onAddIceCandidateError(error: PCErrorData): void;
    onAddIceCandidateSuccess(): void;
    onCreateAnswerError(error: PCErrorData): void;
    onCreateAnswerSuccess(answer: string): void;
    onCreateOfferError(error: PCErrorData): void;
    onCreateOfferSuccess(offer: string): void;
    onIceCandidate(level: number, mid: string, candidate: string, ufrag: string): void;
    onPacket(level: number, type: mozPacketDumpType, sending: boolean, packet: ArrayBuffer): void;
    onSetDescriptionError(error: PCErrorData): void;
    onSetDescriptionSuccess(): void;
    onStateChange(state: PCObserverStateType): void;
}

declare var PeerConnectionObserver: {
    prototype: PeerConnectionObserver;
    new(domPC: RTCPeerConnection): PeerConnectionObserver;
    isInstance: IsInstance<PeerConnectionObserver>;
};

interface PerformanceEventMap {
    "resourcetimingbufferfull": Event;
}

interface Performance extends EventTarget {
    readonly eventCounts: EventCounts;
    readonly interactionCount: number;
    readonly mozMemory: any;
    readonly navigation: PerformanceNavigation;
    onresourcetimingbufferfull: ((this: Performance, ev: Event) => any) | null;
    readonly timeOrigin: DOMHighResTimeStamp;
    readonly timing: PerformanceTiming;
    clearMarks(markName?: string): void;
    clearMeasures(measureName?: string): void;
    clearResourceTimings(): void;
    getEntries(): PerformanceEntryList;
    getEntriesByName(name: string, entryType?: string): PerformanceEntryList;
    getEntriesByType(entryType: string): PerformanceEntryList;
    mark(markName: string, markOptions?: PerformanceMarkOptions): PerformanceMark;
    measure(measureName: string, startOrMeasureOptions?: string | PerformanceMeasureOptions, endMark?: string): PerformanceMeasure;
    now(): DOMHighResTimeStamp;
    setResourceTimingBufferSize(maxSize: number): void;
    toJSON(): any;
    addEventListener<K extends keyof PerformanceEventMap>(type: K, listener: (this: Performance, ev: PerformanceEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof PerformanceEventMap>(type: K, listener: (this: Performance, ev: PerformanceEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var Performance: {
    prototype: Performance;
    new(): Performance;
    isInstance: IsInstance<Performance>;
};

interface PerformanceEntry {
    readonly duration: DOMHighResTimeStamp;
    readonly entryType: string;
    readonly name: string;
    readonly startTime: DOMHighResTimeStamp;
    toJSON(): any;
}

declare var PerformanceEntry: {
    prototype: PerformanceEntry;
    new(): PerformanceEntry;
    isInstance: IsInstance<PerformanceEntry>;
};

interface PerformanceEntryEvent extends Event {
    readonly duration: DOMHighResTimeStamp;
    readonly entryType: string;
    readonly epoch: number;
    readonly name: string;
    readonly origin: string;
    readonly startTime: DOMHighResTimeStamp;
}

declare var PerformanceEntryEvent: {
    prototype: PerformanceEntryEvent;
    new(type: string, eventInitDict?: PerformanceEntryEventInit): PerformanceEntryEvent;
    isInstance: IsInstance<PerformanceEntryEvent>;
};

interface PerformanceEventTiming extends PerformanceEntry {
    readonly cancelable: boolean;
    readonly interactionId: number;
    readonly processingEnd: DOMHighResTimeStamp;
    readonly processingStart: DOMHighResTimeStamp;
    readonly target: Node | null;
    toJSON(): any;
}

declare var PerformanceEventTiming: {
    prototype: PerformanceEventTiming;
    new(): PerformanceEventTiming;
    isInstance: IsInstance<PerformanceEventTiming>;
};

interface PerformanceMark extends PerformanceEntry {
    readonly detail: any;
}

declare var PerformanceMark: {
    prototype: PerformanceMark;
    new(markName: string, markOptions?: PerformanceMarkOptions): PerformanceMark;
    isInstance: IsInstance<PerformanceMark>;
};

interface PerformanceMeasure extends PerformanceEntry {
    readonly detail: any;
}

declare var PerformanceMeasure: {
    prototype: PerformanceMeasure;
    new(): PerformanceMeasure;
    isInstance: IsInstance<PerformanceMeasure>;
};

interface PerformanceNavigation {
    readonly redirectCount: number;
    readonly type: number;
    toJSON(): any;
    readonly TYPE_NAVIGATE: 0;
    readonly TYPE_RELOAD: 1;
    readonly TYPE_BACK_FORWARD: 2;
    readonly TYPE_RESERVED: 255;
}

declare var PerformanceNavigation: {
    prototype: PerformanceNavigation;
    new(): PerformanceNavigation;
    readonly TYPE_NAVIGATE: 0;
    readonly TYPE_RELOAD: 1;
    readonly TYPE_BACK_FORWARD: 2;
    readonly TYPE_RESERVED: 255;
    isInstance: IsInstance<PerformanceNavigation>;
};

interface PerformanceNavigationTiming extends PerformanceResourceTiming {
    readonly domComplete: DOMHighResTimeStamp;
    readonly domContentLoadedEventEnd: DOMHighResTimeStamp;
    readonly domContentLoadedEventStart: DOMHighResTimeStamp;
    readonly domInteractive: DOMHighResTimeStamp;
    readonly loadEventEnd: DOMHighResTimeStamp;
    readonly loadEventStart: DOMHighResTimeStamp;
    readonly redirectCount: number;
    readonly type: NavigationTimingType;
    readonly unloadEventEnd: DOMHighResTimeStamp;
    readonly unloadEventStart: DOMHighResTimeStamp;
    toJSON(): any;
}

declare var PerformanceNavigationTiming: {
    prototype: PerformanceNavigationTiming;
    new(): PerformanceNavigationTiming;
    isInstance: IsInstance<PerformanceNavigationTiming>;
};

interface PerformanceObserver {
    disconnect(): void;
    observe(options?: PerformanceObserverInit): void;
    takeRecords(): PerformanceEntryList;
}

declare var PerformanceObserver: {
    prototype: PerformanceObserver;
    new(callback: PerformanceObserverCallback): PerformanceObserver;
    isInstance: IsInstance<PerformanceObserver>;
    readonly supportedEntryTypes: any;
};

interface PerformanceObserverEntryList {
    getEntries(filter?: PerformanceEntryFilterOptions): PerformanceEntryList;
    getEntriesByName(name: string, entryType?: string): PerformanceEntryList;
    getEntriesByType(entryType: string): PerformanceEntryList;
}

declare var PerformanceObserverEntryList: {
    prototype: PerformanceObserverEntryList;
    new(): PerformanceObserverEntryList;
    isInstance: IsInstance<PerformanceObserverEntryList>;
};

interface PerformancePaintTiming extends PerformanceEntry, PaintTimingMixin {
    toJSON(): any;
}

declare var PerformancePaintTiming: {
    prototype: PerformancePaintTiming;
    new(): PerformancePaintTiming;
    isInstance: IsInstance<PerformancePaintTiming>;
};

interface PerformanceResourceTiming extends PerformanceEntry {
    readonly connectEnd: DOMHighResTimeStamp;
    readonly connectStart: DOMHighResTimeStamp;
    readonly contentType: string;
    readonly decodedBodySize: number;
    readonly domainLookupEnd: DOMHighResTimeStamp;
    readonly domainLookupStart: DOMHighResTimeStamp;
    readonly encodedBodySize: number;
    readonly fetchStart: DOMHighResTimeStamp;
    readonly initiatorType: string;
    readonly nextHopProtocol: string;
    readonly redirectEnd: DOMHighResTimeStamp;
    readonly redirectStart: DOMHighResTimeStamp;
    readonly renderBlockingStatus: RenderBlockingStatusType;
    readonly requestStart: DOMHighResTimeStamp;
    readonly responseEnd: DOMHighResTimeStamp;
    readonly responseStart: DOMHighResTimeStamp;
    readonly responseStatus: number;
    readonly secureConnectionStart: DOMHighResTimeStamp;
    /** Available only in secure contexts. */
    readonly serverTiming: PerformanceServerTiming[];
    readonly transferSize: number;
    readonly workerStart: DOMHighResTimeStamp;
    toJSON(): any;
}

declare var PerformanceResourceTiming: {
    prototype: PerformanceResourceTiming;
    new(): PerformanceResourceTiming;
    isInstance: IsInstance<PerformanceResourceTiming>;
};

/** Available only in secure contexts. */
interface PerformanceServerTiming {
    readonly description: string;
    readonly duration: DOMHighResTimeStamp;
    readonly name: string;
    toJSON(): any;
}

declare var PerformanceServerTiming: {
    prototype: PerformanceServerTiming;
    new(): PerformanceServerTiming;
    isInstance: IsInstance<PerformanceServerTiming>;
};

interface PerformanceTiming {
    readonly connectEnd: number;
    readonly connectStart: number;
    readonly domComplete: number;
    readonly domContentLoadedEventEnd: number;
    readonly domContentLoadedEventStart: number;
    readonly domInteractive: number;
    readonly domLoading: number;
    readonly domainLookupEnd: number;
    readonly domainLookupStart: number;
    readonly fetchStart: number;
    readonly loadEventEnd: number;
    readonly loadEventStart: number;
    readonly navigationStart: number;
    readonly redirectEnd: number;
    readonly redirectStart: number;
    readonly requestStart: number;
    readonly responseEnd: number;
    readonly responseStart: number;
    readonly secureConnectionStart: number;
    readonly timeToContentfulPaint: number;
    readonly timeToFirstInteractive: number;
    readonly timeToNonBlankPaint: number;
    readonly unloadEventEnd: number;
    readonly unloadEventStart: number;
    toJSON(): any;
}

declare var PerformanceTiming: {
    prototype: PerformanceTiming;
    new(): PerformanceTiming;
    isInstance: IsInstance<PerformanceTiming>;
};

interface PeriodicWave {
}

declare var PeriodicWave: {
    prototype: PeriodicWave;
    new(context: BaseAudioContext, options?: PeriodicWaveOptions): PeriodicWave;
    isInstance: IsInstance<PeriodicWave>;
};

interface PermissionStatusEventMap {
    "change": Event;
}

interface PermissionStatus extends EventTarget {
    readonly name: PermissionName;
    onchange: ((this: PermissionStatus, ev: Event) => any) | null;
    readonly state: PermissionState;
    readonly type: string;
    addEventListener<K extends keyof PermissionStatusEventMap>(type: K, listener: (this: PermissionStatus, ev: PermissionStatusEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof PermissionStatusEventMap>(type: K, listener: (this: PermissionStatus, ev: PermissionStatusEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var PermissionStatus: {
    prototype: PermissionStatus;
    new(): PermissionStatus;
    isInstance: IsInstance<PermissionStatus>;
};

interface Permissions {
    parseSetParameters(parameters: PermissionSetParameters): PermissionStatus;
    query(permission: any): Promise<PermissionStatus>;
}

declare var Permissions: {
    prototype: Permissions;
    new(): Permissions;
    isInstance: IsInstance<Permissions>;
};

interface PlacesBookmark extends PlacesEvent {
    readonly guid: string;
    readonly id: number;
    readonly isTagging: boolean;
    readonly itemType: number;
    readonly parentGuid: string;
    readonly parentId: number;
    readonly source: number;
    readonly url: string;
}

declare var PlacesBookmark: {
    prototype: PlacesBookmark;
    new(): PlacesBookmark;
    isInstance: IsInstance<PlacesBookmark>;
};

interface PlacesBookmarkAddition extends PlacesBookmark {
    readonly dateAdded: number;
    readonly frecency: number;
    readonly hidden: boolean;
    readonly index: number;
    readonly lastVisitDate: number | null;
    readonly tags: string;
    readonly targetFolderGuid: string;
    readonly targetFolderItemId: number;
    readonly targetFolderTitle: string;
    readonly title: string;
    readonly visitCount: number;
}

declare var PlacesBookmarkAddition: {
    prototype: PlacesBookmarkAddition;
    new(initDict: PlacesBookmarkAdditionInit): PlacesBookmarkAddition;
    isInstance: IsInstance<PlacesBookmarkAddition>;
};

interface PlacesBookmarkChanged extends PlacesBookmark {
    readonly lastModified: number;
}

declare var PlacesBookmarkChanged: {
    prototype: PlacesBookmarkChanged;
    new(): PlacesBookmarkChanged;
    isInstance: IsInstance<PlacesBookmarkChanged>;
};

interface PlacesBookmarkGuid extends PlacesBookmarkChanged {
}

declare var PlacesBookmarkGuid: {
    prototype: PlacesBookmarkGuid;
    new(initDict: PlacesBookmarkGuidInit): PlacesBookmarkGuid;
    isInstance: IsInstance<PlacesBookmarkGuid>;
};

interface PlacesBookmarkKeyword extends PlacesBookmarkChanged {
    readonly keyword: string;
}

declare var PlacesBookmarkKeyword: {
    prototype: PlacesBookmarkKeyword;
    new(initDict: PlacesBookmarkKeywordInit): PlacesBookmarkKeyword;
    isInstance: IsInstance<PlacesBookmarkKeyword>;
};

interface PlacesBookmarkMoved extends PlacesBookmark {
    readonly dateAdded: number;
    readonly frecency: number;
    readonly hidden: boolean;
    readonly index: number;
    readonly lastVisitDate: number | null;
    readonly oldIndex: number;
    readonly oldParentGuid: string;
    readonly tags: string;
    readonly title: string;
    readonly visitCount: number;
}

declare var PlacesBookmarkMoved: {
    prototype: PlacesBookmarkMoved;
    new(initDict: PlacesBookmarkMovedInit): PlacesBookmarkMoved;
    isInstance: IsInstance<PlacesBookmarkMoved>;
};

interface PlacesBookmarkRemoved extends PlacesBookmark {
    readonly index: number;
    readonly isDescendantRemoval: boolean;
    readonly title: string;
}

declare var PlacesBookmarkRemoved: {
    prototype: PlacesBookmarkRemoved;
    new(initDict: PlacesBookmarkRemovedInit): PlacesBookmarkRemoved;
    isInstance: IsInstance<PlacesBookmarkRemoved>;
};

interface PlacesBookmarkTags extends PlacesBookmarkChanged {
    readonly tags: string[];
}

declare var PlacesBookmarkTags: {
    prototype: PlacesBookmarkTags;
    new(initDict: PlacesBookmarkTagsInit): PlacesBookmarkTags;
    isInstance: IsInstance<PlacesBookmarkTags>;
};

interface PlacesBookmarkTime extends PlacesBookmarkChanged {
    readonly dateAdded: number;
}

declare var PlacesBookmarkTime: {
    prototype: PlacesBookmarkTime;
    new(initDict: PlacesBookmarkTimeInit): PlacesBookmarkTime;
    isInstance: IsInstance<PlacesBookmarkTime>;
};

interface PlacesBookmarkTitle extends PlacesBookmarkChanged {
    readonly title: string;
}

declare var PlacesBookmarkTitle: {
    prototype: PlacesBookmarkTitle;
    new(initDict: PlacesBookmarkTitleInit): PlacesBookmarkTitle;
    isInstance: IsInstance<PlacesBookmarkTitle>;
};

interface PlacesBookmarkUrl extends PlacesBookmarkChanged {
}

declare var PlacesBookmarkUrl: {
    prototype: PlacesBookmarkUrl;
    new(initDict: PlacesBookmarkUrlInit): PlacesBookmarkUrl;
    isInstance: IsInstance<PlacesBookmarkUrl>;
};

interface PlacesEvent {
    readonly type: PlacesEventType;
}

declare var PlacesEvent: {
    prototype: PlacesEvent;
    new(): PlacesEvent;
    isInstance: IsInstance<PlacesEvent>;
};

interface PlacesEventCounts {
    forEach(callbackfn: (value: number, key: string, parent: PlacesEventCounts) => void, thisArg?: any): void;
}

declare var PlacesEventCounts: {
    prototype: PlacesEventCounts;
    new(): PlacesEventCounts;
    isInstance: IsInstance<PlacesEventCounts>;
};

interface PlacesFavicon extends PlacesEvent {
    readonly faviconUrl: string;
    readonly pageGuid: string;
    readonly url: string;
}

declare var PlacesFavicon: {
    prototype: PlacesFavicon;
    new(initDict: PlacesFaviconInit): PlacesFavicon;
    isInstance: IsInstance<PlacesFavicon>;
};

interface PlacesHistoryCleared extends PlacesEvent {
}

declare var PlacesHistoryCleared: {
    prototype: PlacesHistoryCleared;
    new(): PlacesHistoryCleared;
    isInstance: IsInstance<PlacesHistoryCleared>;
};

interface PlacesPurgeCaches extends PlacesEvent {
}

declare var PlacesPurgeCaches: {
    prototype: PlacesPurgeCaches;
    new(): PlacesPurgeCaches;
    isInstance: IsInstance<PlacesPurgeCaches>;
};

interface PlacesRanking extends PlacesEvent {
}

declare var PlacesRanking: {
    prototype: PlacesRanking;
    new(): PlacesRanking;
    isInstance: IsInstance<PlacesRanking>;
};

interface PlacesVisit extends PlacesEvent {
    readonly frecency: number;
    readonly hidden: boolean;
    readonly lastKnownTitle: string | null;
    readonly pageGuid: string;
    readonly referringVisitId: number;
    readonly transitionType: number;
    readonly typedCount: number;
    readonly url: string;
    readonly visitCount: number;
    readonly visitId: number;
    readonly visitTime: number;
}

declare var PlacesVisit: {
    prototype: PlacesVisit;
    new(): PlacesVisit;
    isInstance: IsInstance<PlacesVisit>;
};

interface PlacesVisitRemoved extends PlacesEvent {
    readonly isPartialVisistsRemoval: boolean;
    readonly isRemovedFromStore: boolean;
    readonly pageGuid: string;
    readonly reason: number;
    readonly transitionType: number;
    readonly url: string;
    readonly REASON_DELETED: 0;
    readonly REASON_EXPIRED: 1;
}

declare var PlacesVisitRemoved: {
    prototype: PlacesVisitRemoved;
    new(initDict: PlacesVisitRemovedInit): PlacesVisitRemoved;
    readonly REASON_DELETED: 0;
    readonly REASON_EXPIRED: 1;
    isInstance: IsInstance<PlacesVisitRemoved>;
};

interface PlacesVisitTitle extends PlacesEvent {
    readonly pageGuid: string;
    readonly title: string;
    readonly url: string;
}

declare var PlacesVisitTitle: {
    prototype: PlacesVisitTitle;
    new(initDict: PlacesVisitTitleInit): PlacesVisitTitle;
    isInstance: IsInstance<PlacesVisitTitle>;
};

interface PlacesWeakCallbackWrapper {
}

declare var PlacesWeakCallbackWrapper: {
    prototype: PlacesWeakCallbackWrapper;
    new(callback: PlacesEventCallback): PlacesWeakCallbackWrapper;
    isInstance: IsInstance<PlacesWeakCallbackWrapper>;
};

interface Plugin {
    readonly description: string;
    readonly filename: string;
    readonly length: number;
    readonly name: string;
    item(index: number): MimeType | null;
    namedItem(name: string): MimeType | null;
    [index: number]: MimeType;
}

declare var Plugin: {
    prototype: Plugin;
    new(): Plugin;
    isInstance: IsInstance<Plugin>;
};

interface PluginArray {
    readonly length: number;
    item(index: number): Plugin | null;
    namedItem(name: string): Plugin | null;
    refresh(): void;
    [index: number]: Plugin;
}

declare var PluginArray: {
    prototype: PluginArray;
    new(): PluginArray;
    isInstance: IsInstance<PluginArray>;
};

interface PluginCrashedEvent extends Event {
    readonly gmpPlugin: boolean;
    readonly pluginDumpID: string;
    readonly pluginFilename: string | null;
    readonly pluginID: number;
    readonly pluginName: string;
    readonly submittedCrashReport: boolean;
}

declare var PluginCrashedEvent: {
    prototype: PluginCrashedEvent;
    new(type: string, eventInitDict?: PluginCrashedEventInit): PluginCrashedEvent;
    isInstance: IsInstance<PluginCrashedEvent>;
};

interface PointerEvent extends MouseEvent {
    readonly altitudeAngle: number;
    readonly azimuthAngle: number;
    readonly height: number;
    readonly isPrimary: boolean;
    readonly pointerId: number;
    readonly pointerType: string;
    readonly pressure: number;
    readonly tangentialPressure: number;
    readonly tiltX: number;
    readonly tiltY: number;
    readonly twist: number;
    readonly width: number;
    getCoalescedEvents(): PointerEvent[];
    getPredictedEvents(): PointerEvent[];
}

declare var PointerEvent: {
    prototype: PointerEvent;
    new(type: string, eventInitDict?: PointerEventInit): PointerEvent;
    isInstance: IsInstance<PointerEvent>;
};

interface PopStateEvent extends Event {
    readonly state: any;
}

declare var PopStateEvent: {
    prototype: PopStateEvent;
    new(type: string, eventInitDict?: PopStateEventInit): PopStateEvent;
    isInstance: IsInstance<PopStateEvent>;
};

interface PopoverInvokerElement {
    popoverTargetAction: string;
    popoverTargetElement: Element | null;
}

interface PopupBlockedEvent extends Event {
    readonly popupWindowFeatures: string | null;
    readonly popupWindowName: string | null;
    readonly popupWindowURI: URI | null;
    readonly requestingWindow: Window | null;
}

declare var PopupBlockedEvent: {
    prototype: PopupBlockedEvent;
    new(type: string, eventInitDict?: PopupBlockedEventInit): PopupBlockedEvent;
    isInstance: IsInstance<PopupBlockedEvent>;
};

interface PopupPositionedEvent extends Event {
    readonly alignmentOffset: number;
    readonly alignmentPosition: string;
    readonly isAnchored: boolean;
    readonly popupAlignment: string;
}

declare var PopupPositionedEvent: {
    prototype: PopupPositionedEvent;
    new(type: string, init?: PopupPositionedEventInit): PopupPositionedEvent;
    isInstance: IsInstance<PopupPositionedEvent>;
};

interface PositionStateEvent extends Event {
    readonly duration: number;
    readonly playbackRate: number;
    readonly position: number;
}

declare var PositionStateEvent: {
    prototype: PositionStateEvent;
    new(type: string, eventInitDict?: PositionStateEventInit): PositionStateEvent;
    isInstance: IsInstance<PositionStateEvent>;
};

interface PrecompiledScript {
    readonly hasReturnValue: boolean;
    readonly url: string;
    executeInGlobal(global: any, options?: ExecuteInGlobalOptions): any;
}

declare var PrecompiledScript: {
    prototype: PrecompiledScript;
    new(): PrecompiledScript;
    isInstance: IsInstance<PrecompiledScript>;
};

/** Available only in secure contexts. */
interface PrivateAttribution {
    measureConversion(options: PrivateAttributionConversionOptions): void;
    saveImpression(options: PrivateAttributionImpressionOptions): void;
}

declare var PrivateAttribution: {
    prototype: PrivateAttribution;
    new(): PrivateAttribution;
    isInstance: IsInstance<PrivateAttribution>;
};

interface ProcessMessageManager extends MessageSender, ProcessScriptLoader {
    readonly isInProcess: boolean;
    readonly osPid: number;
}

declare var ProcessMessageManager: {
    prototype: ProcessMessageManager;
    new(): ProcessMessageManager;
    isInstance: IsInstance<ProcessMessageManager>;
};

interface ProcessScriptLoader {
    getDelayedProcessScripts(): any[][];
    loadProcessScript(url: string, allowDelayedLoad: boolean): void;
    removeDelayedProcessScript(url: string): void;
}

interface ProcessingInstruction extends CharacterData, LinkStyle {
    readonly target: string;
}

declare var ProcessingInstruction: {
    prototype: ProcessingInstruction;
    new(): ProcessingInstruction;
    isInstance: IsInstance<ProcessingInstruction>;
};

interface ProgressEvent extends Event {
    readonly lengthComputable: boolean;
    readonly loaded: number;
    readonly total: number;
}

declare var ProgressEvent: {
    prototype: ProgressEvent;
    new(type: string, eventInitDict?: ProgressEventInit): ProgressEvent;
    isInstance: IsInstance<ProgressEvent>;
};

interface PromiseNativeHandler {
}

interface PromiseRejectionEvent extends Event {
    readonly promise: any;
    readonly reason: any;
}

declare var PromiseRejectionEvent: {
    prototype: PromiseRejectionEvent;
    new(type: string, eventInitDict: PromiseRejectionEventInit): PromiseRejectionEvent;
    isInstance: IsInstance<PromiseRejectionEvent>;
};

/** Available only in secure contexts. */
interface PublicKeyCredential extends Credential {
    readonly authenticatorAttachment: string | null;
    readonly rawId: ArrayBuffer;
    readonly response: AuthenticatorResponse;
    getClientExtensionResults(): AuthenticationExtensionsClientOutputs;
    toJSON(): any;
}

declare var PublicKeyCredential: {
    prototype: PublicKeyCredential;
    new(): PublicKeyCredential;
    isInstance: IsInstance<PublicKeyCredential>;
    getClientCapabilities(): Promise<PublicKeyCredentialClientCapabilities>;
    isConditionalMediationAvailable(): Promise<boolean>;
    isUserVerifyingPlatformAuthenticatorAvailable(): Promise<boolean>;
    parseCreationOptionsFromJSON(options: PublicKeyCredentialCreationOptionsJSON): PublicKeyCredentialCreationOptions;
    parseRequestOptionsFromJSON(options: PublicKeyCredentialRequestOptionsJSON): PublicKeyCredentialRequestOptions;
};

interface PushManager {
    getSubscription(): Promise<PushSubscription | null>;
    permissionState(options?: PushSubscriptionOptionsInit): Promise<PermissionState>;
    subscribe(options?: PushSubscriptionOptionsInit): Promise<PushSubscription>;
}

declare var PushManager: {
    prototype: PushManager;
    new(scope: string): PushManager;
    isInstance: IsInstance<PushManager>;
    readonly supportedContentEncodings: any;
};

interface PushManagerImpl {
    getSubscription(): Promise<PushSubscription | null>;
    permissionState(options?: PushSubscriptionOptionsInit): Promise<PermissionState>;
    subscribe(options?: PushSubscriptionOptionsInit): Promise<PushSubscription>;
}

declare var PushManagerImpl: {
    prototype: PushManagerImpl;
    new(scope: string): PushManagerImpl;
    isInstance: IsInstance<PushManagerImpl>;
};

interface PushSubscription {
    readonly endpoint: string;
    readonly expirationTime: EpochTimeStamp | null;
    readonly options: PushSubscriptionOptions;
    getKey(name: PushEncryptionKeyName): ArrayBuffer | null;
    toJSON(): PushSubscriptionJSON;
    unsubscribe(): Promise<boolean>;
}

declare var PushSubscription: {
    prototype: PushSubscription;
    new(initDict: PushSubscriptionInit): PushSubscription;
    isInstance: IsInstance<PushSubscription>;
};

interface PushSubscriptionOptions {
    readonly applicationServerKey: ArrayBuffer | null;
}

declare var PushSubscriptionOptions: {
    prototype: PushSubscriptionOptions;
    new(): PushSubscriptionOptions;
    isInstance: IsInstance<PushSubscriptionOptions>;
};

interface RTCCertificate {
    readonly expires: DOMTimeStamp;
    getFingerprints(): RTCDtlsFingerprint[];
}

declare var RTCCertificate: {
    prototype: RTCCertificate;
    new(): RTCCertificate;
    isInstance: IsInstance<RTCCertificate>;
};

interface RTCDTMFSenderEventMap {
    "tonechange": Event;
}

interface RTCDTMFSender extends EventTarget {
    readonly canInsertDTMF: boolean;
    ontonechange: ((this: RTCDTMFSender, ev: Event) => any) | null;
    readonly toneBuffer: string;
    insertDTMF(tones: string, duration?: number, interToneGap?: number): void;
    addEventListener<K extends keyof RTCDTMFSenderEventMap>(type: K, listener: (this: RTCDTMFSender, ev: RTCDTMFSenderEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof RTCDTMFSenderEventMap>(type: K, listener: (this: RTCDTMFSender, ev: RTCDTMFSenderEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var RTCDTMFSender: {
    prototype: RTCDTMFSender;
    new(): RTCDTMFSender;
    isInstance: IsInstance<RTCDTMFSender>;
};

interface RTCDTMFToneChangeEvent extends Event {
    readonly tone: string;
}

declare var RTCDTMFToneChangeEvent: {
    prototype: RTCDTMFToneChangeEvent;
    new(type: string, eventInitDict?: RTCDTMFToneChangeEventInit): RTCDTMFToneChangeEvent;
    isInstance: IsInstance<RTCDTMFToneChangeEvent>;
};

interface RTCDataChannelEventMap {
    "bufferedamountlow": Event;
    "close": Event;
    "error": Event;
    "message": Event;
    "open": Event;
}

interface RTCDataChannel extends EventTarget {
    binaryType: RTCDataChannelType;
    readonly bufferedAmount: number;
    bufferedAmountLowThreshold: number;
    readonly id: number | null;
    readonly label: string;
    readonly maxPacketLifeTime: number | null;
    readonly maxRetransmits: number | null;
    readonly negotiated: boolean;
    onbufferedamountlow: ((this: RTCDataChannel, ev: Event) => any) | null;
    onclose: ((this: RTCDataChannel, ev: Event) => any) | null;
    onerror: ((this: RTCDataChannel, ev: Event) => any) | null;
    onmessage: ((this: RTCDataChannel, ev: Event) => any) | null;
    onopen: ((this: RTCDataChannel, ev: Event) => any) | null;
    readonly ordered: boolean;
    readonly protocol: string;
    readonly readyState: RTCDataChannelState;
    readonly reliable: boolean;
    close(): void;
    send(data: string): void;
    send(data: Blob): void;
    send(data: ArrayBuffer): void;
    send(data: ArrayBufferView): void;
    addEventListener<K extends keyof RTCDataChannelEventMap>(type: K, listener: (this: RTCDataChannel, ev: RTCDataChannelEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof RTCDataChannelEventMap>(type: K, listener: (this: RTCDataChannel, ev: RTCDataChannelEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var RTCDataChannel: {
    prototype: RTCDataChannel;
    new(): RTCDataChannel;
    isInstance: IsInstance<RTCDataChannel>;
};

interface RTCDataChannelEvent extends Event {
    readonly channel: RTCDataChannel;
}

declare var RTCDataChannelEvent: {
    prototype: RTCDataChannelEvent;
    new(type: string, eventInitDict: RTCDataChannelEventInit): RTCDataChannelEvent;
    isInstance: IsInstance<RTCDataChannelEvent>;
};

interface RTCDtlsTransportEventMap {
    "statechange": Event;
}

interface RTCDtlsTransport extends EventTarget {
    readonly iceTransport: RTCIceTransport;
    onstatechange: ((this: RTCDtlsTransport, ev: Event) => any) | null;
    readonly state: RTCDtlsTransportState;
    addEventListener<K extends keyof RTCDtlsTransportEventMap>(type: K, listener: (this: RTCDtlsTransport, ev: RTCDtlsTransportEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof RTCDtlsTransportEventMap>(type: K, listener: (this: RTCDtlsTransport, ev: RTCDtlsTransportEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var RTCDtlsTransport: {
    prototype: RTCDtlsTransport;
    new(): RTCDtlsTransport;
    isInstance: IsInstance<RTCDtlsTransport>;
};

interface RTCEncodedAudioFrame {
    data: ArrayBuffer;
    readonly timestamp: number;
    getMetadata(): RTCEncodedAudioFrameMetadata;
}

declare var RTCEncodedAudioFrame: {
    prototype: RTCEncodedAudioFrame;
    new(): RTCEncodedAudioFrame;
    isInstance: IsInstance<RTCEncodedAudioFrame>;
};

interface RTCEncodedVideoFrame {
    data: ArrayBuffer;
    readonly timestamp: number;
    readonly type: RTCEncodedVideoFrameType;
    getMetadata(): RTCEncodedVideoFrameMetadata;
}

declare var RTCEncodedVideoFrame: {
    prototype: RTCEncodedVideoFrame;
    new(): RTCEncodedVideoFrame;
    isInstance: IsInstance<RTCEncodedVideoFrame>;
};

interface RTCIceCandidate {
    readonly address: string | null;
    readonly candidate: string;
    readonly component: RTCIceComponent | null;
    readonly foundation: string | null;
    readonly port: number | null;
    readonly priority: number | null;
    readonly protocol: RTCIceProtocol | null;
    readonly relatedAddress: string | null;
    readonly relatedPort: number | null;
    readonly sdpMLineIndex: number | null;
    readonly sdpMid: string | null;
    readonly tcpType: RTCIceTcpCandidateType | null;
    readonly type: RTCIceCandidateType | null;
    readonly usernameFragment: string | null;
    toJSON(): RTCIceCandidateInit;
}

declare var RTCIceCandidate: {
    prototype: RTCIceCandidate;
    new(candidateInitDict?: RTCIceCandidateInit): RTCIceCandidate;
    isInstance: IsInstance<RTCIceCandidate>;
};

interface RTCIceTransportEventMap {
    "gatheringstatechange": Event;
    "statechange": Event;
}

interface RTCIceTransport extends EventTarget {
    readonly gatheringState: RTCIceGathererState;
    ongatheringstatechange: ((this: RTCIceTransport, ev: Event) => any) | null;
    onstatechange: ((this: RTCIceTransport, ev: Event) => any) | null;
    readonly state: RTCIceTransportState;
    addEventListener<K extends keyof RTCIceTransportEventMap>(type: K, listener: (this: RTCIceTransport, ev: RTCIceTransportEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof RTCIceTransportEventMap>(type: K, listener: (this: RTCIceTransport, ev: RTCIceTransportEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var RTCIceTransport: {
    prototype: RTCIceTransport;
    new(): RTCIceTransport;
    isInstance: IsInstance<RTCIceTransport>;
};

interface RTCIdentityProviderRegistrar {
    readonly hasIdp: boolean;
    generateAssertion(contents: string, origin: string, options?: RTCIdentityProviderOptions): Promise<RTCIdentityAssertionResult>;
    register(idp: RTCIdentityProvider): void;
    validateAssertion(assertion: string, origin: string): Promise<RTCIdentityValidationResult>;
}

interface RTCPeerConnectionEventMap {
    "addstream": Event;
    "addtrack": Event;
    "connectionstatechange": Event;
    "datachannel": Event;
    "icecandidate": Event;
    "iceconnectionstatechange": Event;
    "icegatheringstatechange": Event;
    "negotiationneeded": Event;
    "signalingstatechange": Event;
    "track": Event;
}

interface RTCPeerConnection extends EventTarget {
    readonly canTrickleIceCandidates: boolean | null;
    readonly connectionState: RTCPeerConnectionState;
    readonly currentLocalDescription: RTCSessionDescription | null;
    readonly currentRemoteDescription: RTCSessionDescription | null;
    readonly iceConnectionState: RTCIceConnectionState;
    readonly iceGatheringState: RTCIceGatheringState;
    id: string;
    readonly idpLoginUrl: string | null;
    readonly localDescription: RTCSessionDescription | null;
    onaddstream: ((this: RTCPeerConnection, ev: Event) => any) | null;
    onaddtrack: ((this: RTCPeerConnection, ev: Event) => any) | null;
    onconnectionstatechange: ((this: RTCPeerConnection, ev: Event) => any) | null;
    ondatachannel: ((this: RTCPeerConnection, ev: Event) => any) | null;
    onicecandidate: ((this: RTCPeerConnection, ev: Event) => any) | null;
    oniceconnectionstatechange: ((this: RTCPeerConnection, ev: Event) => any) | null;
    onicegatheringstatechange: ((this: RTCPeerConnection, ev: Event) => any) | null;
    onnegotiationneeded: ((this: RTCPeerConnection, ev: Event) => any) | null;
    onsignalingstatechange: ((this: RTCPeerConnection, ev: Event) => any) | null;
    ontrack: ((this: RTCPeerConnection, ev: Event) => any) | null;
    readonly peerIdentity: Promise<RTCIdentityAssertion>;
    readonly pendingLocalDescription: RTCSessionDescription | null;
    readonly pendingRemoteDescription: RTCSessionDescription | null;
    readonly remoteDescription: RTCSessionDescription | null;
    readonly sctp: RTCSctpTransport | null;
    readonly signalingState: RTCSignalingState;
    addIceCandidate(candidate: RTCIceCandidateInit, successCallback: VoidFunction, failureCallback: RTCPeerConnectionErrorCallback): Promise<void>;
    addStream(stream: MediaStream): void;
    addTrack(track: MediaStreamTrack, ...streams: MediaStream[]): RTCRtpSender;
    addTransceiver(trackOrKind: MediaStreamTrack | string, init?: RTCRtpTransceiverInit): RTCRtpTransceiver;
    close(): void;
    createAnswer(successCallback: RTCSessionDescriptionCallback, failureCallback: RTCPeerConnectionErrorCallback): Promise<void>;
    createDataChannel(label: string, dataChannelDict?: RTCDataChannelInit): RTCDataChannel;
    createOffer(successCallback: RTCSessionDescriptionCallback, failureCallback: RTCPeerConnectionErrorCallback, options?: RTCOfferOptions): Promise<void>;
    getConfiguration(): RTCConfiguration;
    getIdentityAssertion(): Promise<string>;
    getLocalStreams(): MediaStream[];
    getReceivers(): RTCRtpReceiver[];
    getRemoteStreams(): MediaStream[];
    getSenders(): RTCRtpSender[];
    getStats(selector?: MediaStreamTrack | null): Promise<RTCStatsReport>;
    getTransceivers(): RTCRtpTransceiver[];
    mozDisablePacketDump(level: number, type: mozPacketDumpType, sending: boolean): void;
    mozEnablePacketDump(level: number, type: mozPacketDumpType, sending: boolean): void;
    mozSetPacketCallback(callback: mozPacketCallback): void;
    removeTrack(sender: RTCRtpSender): void;
    restartIce(): void;
    setConfiguration(configuration?: RTCConfiguration): void;
    setIdentityProvider(provider: string, options?: RTCIdentityProviderOptions): void;
    setLocalDescription(description: RTCLocalSessionDescriptionInit, successCallback: VoidFunction, failureCallback: RTCPeerConnectionErrorCallback): Promise<void>;
    setRemoteDescription(description: RTCSessionDescriptionInit, successCallback: VoidFunction, failureCallback: RTCPeerConnectionErrorCallback): Promise<void>;
    addEventListener<K extends keyof RTCPeerConnectionEventMap>(type: K, listener: (this: RTCPeerConnection, ev: RTCPeerConnectionEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof RTCPeerConnectionEventMap>(type: K, listener: (this: RTCPeerConnection, ev: RTCPeerConnectionEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var RTCPeerConnection: {
    prototype: RTCPeerConnection;
    new(configuration?: RTCConfiguration): RTCPeerConnection;
    isInstance: IsInstance<RTCPeerConnection>;
    generateCertificate(keygenAlgorithm: AlgorithmIdentifier): Promise<RTCCertificate>;
};

interface RTCPeerConnectionIceEvent extends Event {
    readonly candidate: RTCIceCandidate | null;
}

declare var RTCPeerConnectionIceEvent: {
    prototype: RTCPeerConnectionIceEvent;
    new(type: string, eventInitDict?: RTCPeerConnectionIceEventInit): RTCPeerConnectionIceEvent;
    isInstance: IsInstance<RTCPeerConnectionIceEvent>;
};

interface RTCPeerConnectionStatic {
    registerPeerConnectionLifecycleCallback(cb: PeerConnectionLifecycleCallback): void;
}

declare var RTCPeerConnectionStatic: {
    prototype: RTCPeerConnectionStatic;
    new(): RTCPeerConnectionStatic;
    isInstance: IsInstance<RTCPeerConnectionStatic>;
};

interface RTCRtpReceiver {
    jitterBufferTarget: DOMHighResTimeStamp | null;
    readonly track: MediaStreamTrack;
    transform: RTCRtpTransform | null;
    readonly transport: RTCDtlsTransport | null;
    getContributingSources(): RTCRtpContributingSource[];
    getParameters(): RTCRtpReceiveParameters;
    getStats(): Promise<RTCStatsReport>;
    getSynchronizationSources(): RTCRtpSynchronizationSource[];
    mozInsertAudioLevelForContributingSource(source: number, timestamp: DOMHighResTimeStamp, rtpTimestamp: number, hasLevel: boolean, level: number): void;
}

declare var RTCRtpReceiver: {
    prototype: RTCRtpReceiver;
    new(): RTCRtpReceiver;
    isInstance: IsInstance<RTCRtpReceiver>;
    getCapabilities(kind: string): RTCRtpCapabilities | null;
};

interface RTCRtpScriptTransform {
}

declare var RTCRtpScriptTransform: {
    prototype: RTCRtpScriptTransform;
    new(worker: Worker, options?: any, transfer?: any[]): RTCRtpScriptTransform;
    isInstance: IsInstance<RTCRtpScriptTransform>;
};

interface RTCRtpSender {
    readonly dtmf: RTCDTMFSender | null;
    readonly track: MediaStreamTrack | null;
    transform: RTCRtpTransform | null;
    readonly transport: RTCDtlsTransport | null;
    getParameters(): RTCRtpSendParameters;
    getStats(): Promise<RTCStatsReport>;
    getStreams(): MediaStream[];
    replaceTrack(withTrack: MediaStreamTrack | null): Promise<void>;
    setParameters(parameters: RTCRtpSendParameters): Promise<void>;
    setStreams(...streams: MediaStream[]): void;
    setStreamsImpl(...streams: MediaStream[]): void;
    setTrack(track: MediaStreamTrack | null): void;
}

declare var RTCRtpSender: {
    prototype: RTCRtpSender;
    new(): RTCRtpSender;
    isInstance: IsInstance<RTCRtpSender>;
    getCapabilities(kind: string): RTCRtpCapabilities | null;
};

interface RTCRtpTransceiver {
    readonly currentDirection: RTCRtpTransceiverDirection | null;
    direction: RTCRtpTransceiverDirection;
    readonly mid: string | null;
    readonly receiver: RTCRtpReceiver;
    readonly sender: RTCRtpSender;
    readonly stopped: boolean;
    getKind(): string;
    hasBeenUsedToSend(): boolean;
    setCodecPreferences(codecs: RTCRtpCodec[]): void;
    setDirectionInternal(direction: RTCRtpTransceiverDirection): void;
    stop(): void;
}

declare var RTCRtpTransceiver: {
    prototype: RTCRtpTransceiver;
    new(): RTCRtpTransceiver;
    isInstance: IsInstance<RTCRtpTransceiver>;
};

interface RTCSctpTransportEventMap {
    "statechange": Event;
}

interface RTCSctpTransport extends EventTarget {
    readonly maxChannels: number | null;
    readonly maxMessageSize: number;
    onstatechange: ((this: RTCSctpTransport, ev: Event) => any) | null;
    readonly state: RTCSctpTransportState;
    readonly transport: RTCDtlsTransport;
    addEventListener<K extends keyof RTCSctpTransportEventMap>(type: K, listener: (this: RTCSctpTransport, ev: RTCSctpTransportEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof RTCSctpTransportEventMap>(type: K, listener: (this: RTCSctpTransport, ev: RTCSctpTransportEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var RTCSctpTransport: {
    prototype: RTCSctpTransport;
    new(): RTCSctpTransport;
    isInstance: IsInstance<RTCSctpTransport>;
};

interface RTCSessionDescription {
    sdp: string;
    type: RTCSdpType;
    toJSON(): any;
}

declare var RTCSessionDescription: {
    prototype: RTCSessionDescription;
    new(descriptionInitDict: RTCSessionDescriptionInit): RTCSessionDescription;
    isInstance: IsInstance<RTCSessionDescription>;
};

interface RTCStatsReport {
    forEach(callbackfn: (value: any, key: string, parent: RTCStatsReport) => void, thisArg?: any): void;
}

declare var RTCStatsReport: {
    prototype: RTCStatsReport;
    new(): RTCStatsReport;
    isInstance: IsInstance<RTCStatsReport>;
};

interface RTCTrackEvent extends Event {
    readonly receiver: RTCRtpReceiver;
    readonly streams: MediaStream[];
    readonly track: MediaStreamTrack;
    readonly transceiver: RTCRtpTransceiver;
}

declare var RTCTrackEvent: {
    prototype: RTCTrackEvent;
    new(type: string, eventInitDict: RTCTrackEventInit): RTCTrackEvent;
    isInstance: IsInstance<RTCTrackEvent>;
};

interface RadioNodeList extends NodeList {
    value: string;
}

declare var RadioNodeList: {
    prototype: RadioNodeList;
    new(): RadioNodeList;
    isInstance: IsInstance<RadioNodeList>;
};

interface Range extends AbstractRange {
    readonly commonAncestorContainer: Node;
    cloneContents(): DocumentFragment;
    cloneRange(): Range;
    collapse(toStart?: boolean): void;
    compareBoundaryPoints(how: number, sourceRange: Range): number;
    comparePoint(node: Node, offset: number): number;
    createContextualFragment(fragment: TrustedHTML | string): DocumentFragment;
    deleteContents(): void;
    detach(): void;
    extractContents(): DocumentFragment;
    getAllowCrossShadowBoundaryClientRects(): DOMRectList | null;
    getBoundingClientRect(): DOMRect;
    getClientRects(): DOMRectList | null;
    getClientRectsAndTexts(): ClientRectsAndTexts;
    insertNode(node: Node): void;
    intersectsNode(node: Node): boolean;
    isPointInRange(node: Node, offset: number): boolean;
    selectNode(refNode: Node): void;
    selectNodeContents(refNode: Node): void;
    setEnd(refNode: Node, offset: number): void;
    setEndAfter(refNode: Node): void;
    setEndAllowCrossShadowBoundary(refNode: Node, offset: number): void;
    setEndBefore(refNode: Node): void;
    setStart(refNode: Node, offset: number): void;
    setStartAfter(refNode: Node): void;
    setStartAllowCrossShadowBoundary(refNode: Node, offset: number): void;
    setStartBefore(refNode: Node): void;
    surroundContents(newParent: Node): void;
    toString(): string;
    readonly START_TO_START: 0;
    readonly START_TO_END: 1;
    readonly END_TO_END: 2;
    readonly END_TO_START: 3;
}

declare var Range: {
    prototype: Range;
    new(): Range;
    readonly START_TO_START: 0;
    readonly START_TO_END: 1;
    readonly END_TO_END: 2;
    readonly END_TO_START: 3;
    isInstance: IsInstance<Range>;
};

interface ReadableByteStreamController {
    readonly byobRequest: ReadableStreamBYOBRequest | null;
    readonly desiredSize: number | null;
    close(): void;
    enqueue(chunk: ArrayBufferView): void;
    error(e?: any): void;
}

declare var ReadableByteStreamController: {
    prototype: ReadableByteStreamController;
    new(): ReadableByteStreamController;
    isInstance: IsInstance<ReadableByteStreamController>;
};

interface ReadableStream {
    readonly locked: boolean;
    cancel(reason?: any): Promise<void>;
    getReader(options?: ReadableStreamGetReaderOptions): ReadableStreamReader;
    pipeThrough(transform: ReadableWritablePair, options?: StreamPipeOptions): ReadableStream;
    pipeTo(destination: WritableStream, options?: StreamPipeOptions): Promise<void>;
    tee(): ReadableStream[];
}

declare var ReadableStream: {
    prototype: ReadableStream;
    new(underlyingSource?: any, strategy?: QueuingStrategy): ReadableStream;
    isInstance: IsInstance<ReadableStream>;
    from(asyncIterable: any): ReadableStream;
};

interface ReadableStreamBYOBReader extends ReadableStreamGenericReader {
    read(view: ArrayBufferView, options?: ReadableStreamBYOBReaderReadOptions): Promise<ReadableStreamReadResult>;
    releaseLock(): void;
}

declare var ReadableStreamBYOBReader: {
    prototype: ReadableStreamBYOBReader;
    new(stream: ReadableStream): ReadableStreamBYOBReader;
    isInstance: IsInstance<ReadableStreamBYOBReader>;
};

interface ReadableStreamBYOBRequest {
    readonly view: ArrayBufferView | null;
    respond(bytesWritten: number): void;
    respondWithNewView(view: ArrayBufferView): void;
}

declare var ReadableStreamBYOBRequest: {
    prototype: ReadableStreamBYOBRequest;
    new(): ReadableStreamBYOBRequest;
    isInstance: IsInstance<ReadableStreamBYOBRequest>;
};

interface ReadableStreamDefaultController {
    readonly desiredSize: number | null;
    close(): void;
    enqueue(chunk?: any): void;
    error(e?: any): void;
}

declare var ReadableStreamDefaultController: {
    prototype: ReadableStreamDefaultController;
    new(): ReadableStreamDefaultController;
    isInstance: IsInstance<ReadableStreamDefaultController>;
};

interface ReadableStreamDefaultReader extends ReadableStreamGenericReader {
    read(): Promise<ReadableStreamReadResult>;
    releaseLock(): void;
}

declare var ReadableStreamDefaultReader: {
    prototype: ReadableStreamDefaultReader;
    new(stream: ReadableStream): ReadableStreamDefaultReader;
    isInstance: IsInstance<ReadableStreamDefaultReader>;
};

interface ReadableStreamGenericReader {
    readonly closed: Promise<void>;
    cancel(reason?: any): Promise<void>;
}

interface Report {
    readonly body: ReportBody | null;
    readonly type: string;
    readonly url: string;
    toJSON(): any;
}

declare var Report: {
    prototype: Report;
    new(): Report;
    isInstance: IsInstance<Report>;
};

interface ReportBody {
    toJSON(): any;
}

declare var ReportBody: {
    prototype: ReportBody;
    new(): ReportBody;
    isInstance: IsInstance<ReportBody>;
};

interface ReportingObserver {
    disconnect(): void;
    observe(): void;
    takeRecords(): ReportList;
}

declare var ReportingObserver: {
    prototype: ReportingObserver;
    new(callback: ReportingObserverCallback, options?: ReportingObserverOptions): ReportingObserver;
    isInstance: IsInstance<ReportingObserver>;
};

interface Request extends Body {
    readonly cache: RequestCache;
    readonly credentials: RequestCredentials;
    readonly destination: RequestDestination;
    readonly headers: Headers;
    readonly integrity: string;
    readonly keepalive: boolean;
    readonly method: string;
    readonly mode: RequestMode;
    readonly mozErrors: boolean;
    readonly redirect: RequestRedirect;
    readonly referrer: string;
    readonly referrerPolicy: ReferrerPolicy;
    readonly signal: AbortSignal;
    readonly url: string;
    clone(): Request;
    overrideContentPolicyType(context: nsContentPolicyType): void;
}

declare var Request: {
    prototype: Request;
    new(input: RequestInfo | URL, init?: RequestInit): Request;
    isInstance: IsInstance<Request>;
};

interface ResizeObserver {
    disconnect(): void;
    observe(target: Element, options?: ResizeObserverOptions): void;
    unobserve(target: Element): void;
}

declare var ResizeObserver: {
    prototype: ResizeObserver;
    new(callback: ResizeObserverCallback): ResizeObserver;
    isInstance: IsInstance<ResizeObserver>;
};

interface ResizeObserverEntry {
    readonly borderBoxSize: ResizeObserverSize[];
    readonly contentBoxSize: ResizeObserverSize[];
    readonly contentRect: DOMRectReadOnly;
    readonly devicePixelContentBoxSize: ResizeObserverSize[];
    readonly target: Element;
}

declare var ResizeObserverEntry: {
    prototype: ResizeObserverEntry;
    new(): ResizeObserverEntry;
    isInstance: IsInstance<ResizeObserverEntry>;
};

interface ResizeObserverSize {
    readonly blockSize: number;
    readonly inlineSize: number;
}

declare var ResizeObserverSize: {
    prototype: ResizeObserverSize;
    new(): ResizeObserverSize;
    isInstance: IsInstance<ResizeObserverSize>;
};

interface Response extends Body {
    readonly body: ReadableStream | null;
    readonly hasCacheInfoChannel: boolean;
    readonly headers: Headers;
    readonly ok: boolean;
    readonly redirected: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly type: ResponseType;
    readonly url: string;
    clone(): Response;
    cloneUnfiltered(): Response;
}

declare var Response: {
    prototype: Response;
    new(body?: Blob | BufferSource | FormData | URLSearchParams | ReadableStream | string | null, init?: ResponseInit): Response;
    isInstance: IsInstance<Response>;
    error(): Response;
    json(data: any, init?: ResponseInit): Response;
    redirect(url: string, status?: number): Response;
};

interface SVGAElement extends SVGGraphicsElement, SVGURIReference {
    download: string;
    hreflang: string;
    ping: string;
    referrerPolicy: string;
    rel: string;
    readonly relList: DOMTokenList;
    readonly target: SVGAnimatedString;
    text: string;
    type: string;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGAElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGAElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGAElement: {
    prototype: SVGAElement;
    new(): SVGAElement;
    isInstance: IsInstance<SVGAElement>;
};

interface SVGAngle {
    readonly unitType: number;
    value: number;
    valueAsString: string;
    valueInSpecifiedUnits: number;
    convertToSpecifiedUnits(unitType: number): void;
    newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;
    readonly SVG_ANGLETYPE_UNKNOWN: 0;
    readonly SVG_ANGLETYPE_UNSPECIFIED: 1;
    readonly SVG_ANGLETYPE_DEG: 2;
    readonly SVG_ANGLETYPE_RAD: 3;
    readonly SVG_ANGLETYPE_GRAD: 4;
}

declare var SVGAngle: {
    prototype: SVGAngle;
    new(): SVGAngle;
    readonly SVG_ANGLETYPE_UNKNOWN: 0;
    readonly SVG_ANGLETYPE_UNSPECIFIED: 1;
    readonly SVG_ANGLETYPE_DEG: 2;
    readonly SVG_ANGLETYPE_RAD: 3;
    readonly SVG_ANGLETYPE_GRAD: 4;
    isInstance: IsInstance<SVGAngle>;
};

interface SVGAnimateElement extends SVGAnimationElement {
    addEventListener<K extends keyof SVGAnimationElementEventMap>(type: K, listener: (this: SVGAnimateElement, ev: SVGAnimationElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGAnimationElementEventMap>(type: K, listener: (this: SVGAnimateElement, ev: SVGAnimationElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGAnimateElement: {
    prototype: SVGAnimateElement;
    new(): SVGAnimateElement;
    isInstance: IsInstance<SVGAnimateElement>;
};

interface SVGAnimateMotionElement extends SVGAnimationElement {
    addEventListener<K extends keyof SVGAnimationElementEventMap>(type: K, listener: (this: SVGAnimateMotionElement, ev: SVGAnimationElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGAnimationElementEventMap>(type: K, listener: (this: SVGAnimateMotionElement, ev: SVGAnimationElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGAnimateMotionElement: {
    prototype: SVGAnimateMotionElement;
    new(): SVGAnimateMotionElement;
    isInstance: IsInstance<SVGAnimateMotionElement>;
};

interface SVGAnimateTransformElement extends SVGAnimationElement {
    addEventListener<K extends keyof SVGAnimationElementEventMap>(type: K, listener: (this: SVGAnimateTransformElement, ev: SVGAnimationElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGAnimationElementEventMap>(type: K, listener: (this: SVGAnimateTransformElement, ev: SVGAnimationElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGAnimateTransformElement: {
    prototype: SVGAnimateTransformElement;
    new(): SVGAnimateTransformElement;
    isInstance: IsInstance<SVGAnimateTransformElement>;
};

interface SVGAnimatedAngle {
    readonly animVal: SVGAngle;
    readonly baseVal: SVGAngle;
}

declare var SVGAnimatedAngle: {
    prototype: SVGAnimatedAngle;
    new(): SVGAnimatedAngle;
    isInstance: IsInstance<SVGAnimatedAngle>;
};

interface SVGAnimatedBoolean {
    readonly animVal: boolean;
    baseVal: boolean;
}

declare var SVGAnimatedBoolean: {
    prototype: SVGAnimatedBoolean;
    new(): SVGAnimatedBoolean;
    isInstance: IsInstance<SVGAnimatedBoolean>;
};

interface SVGAnimatedEnumeration {
    readonly animVal: number;
    baseVal: number;
}

declare var SVGAnimatedEnumeration: {
    prototype: SVGAnimatedEnumeration;
    new(): SVGAnimatedEnumeration;
    isInstance: IsInstance<SVGAnimatedEnumeration>;
};

interface SVGAnimatedInteger {
    readonly animVal: number;
    baseVal: number;
}

declare var SVGAnimatedInteger: {
    prototype: SVGAnimatedInteger;
    new(): SVGAnimatedInteger;
    isInstance: IsInstance<SVGAnimatedInteger>;
};

interface SVGAnimatedLength {
    readonly animVal: SVGLength;
    readonly baseVal: SVGLength;
}

declare var SVGAnimatedLength: {
    prototype: SVGAnimatedLength;
    new(): SVGAnimatedLength;
    isInstance: IsInstance<SVGAnimatedLength>;
};

interface SVGAnimatedLengthList {
    readonly animVal: SVGLengthList;
    readonly baseVal: SVGLengthList;
}

declare var SVGAnimatedLengthList: {
    prototype: SVGAnimatedLengthList;
    new(): SVGAnimatedLengthList;
    isInstance: IsInstance<SVGAnimatedLengthList>;
};

interface SVGAnimatedNumber {
    readonly animVal: number;
    baseVal: number;
}

declare var SVGAnimatedNumber: {
    prototype: SVGAnimatedNumber;
    new(): SVGAnimatedNumber;
    isInstance: IsInstance<SVGAnimatedNumber>;
};

interface SVGAnimatedNumberList {
    readonly animVal: SVGNumberList;
    readonly baseVal: SVGNumberList;
}

declare var SVGAnimatedNumberList: {
    prototype: SVGAnimatedNumberList;
    new(): SVGAnimatedNumberList;
    isInstance: IsInstance<SVGAnimatedNumberList>;
};

interface SVGAnimatedPoints {
    readonly animatedPoints: SVGPointList;
    readonly points: SVGPointList;
}

interface SVGAnimatedPreserveAspectRatio {
    readonly animVal: SVGPreserveAspectRatio;
    readonly baseVal: SVGPreserveAspectRatio;
}

declare var SVGAnimatedPreserveAspectRatio: {
    prototype: SVGAnimatedPreserveAspectRatio;
    new(): SVGAnimatedPreserveAspectRatio;
    isInstance: IsInstance<SVGAnimatedPreserveAspectRatio>;
};

interface SVGAnimatedRect {
    readonly animVal: SVGRect | null;
    readonly baseVal: SVGRect | null;
}

declare var SVGAnimatedRect: {
    prototype: SVGAnimatedRect;
    new(): SVGAnimatedRect;
    isInstance: IsInstance<SVGAnimatedRect>;
};

interface SVGAnimatedString {
    readonly animVal: string;
    baseVal: TrustedScriptURL | string;
}

declare var SVGAnimatedString: {
    prototype: SVGAnimatedString;
    new(): SVGAnimatedString;
    isInstance: IsInstance<SVGAnimatedString>;
};

interface SVGAnimatedTransformList {
    readonly animVal: SVGTransformList;
    readonly baseVal: SVGTransformList;
}

declare var SVGAnimatedTransformList: {
    prototype: SVGAnimatedTransformList;
    new(): SVGAnimatedTransformList;
    isInstance: IsInstance<SVGAnimatedTransformList>;
};

interface SVGAnimationElementEventMap extends SVGElementEventMap {
    "begin": Event;
    "end": Event;
    "repeat": Event;
}

interface SVGAnimationElement extends SVGElement, SVGTests {
    onbegin: ((this: SVGAnimationElement, ev: Event) => any) | null;
    onend: ((this: SVGAnimationElement, ev: Event) => any) | null;
    onrepeat: ((this: SVGAnimationElement, ev: Event) => any) | null;
    readonly targetElement: SVGElement | null;
    beginElement(): void;
    beginElementAt(offset: number): void;
    endElement(): void;
    endElementAt(offset: number): void;
    getCurrentTime(): number;
    getSimpleDuration(): number;
    getStartTime(): number;
    addEventListener<K extends keyof SVGAnimationElementEventMap>(type: K, listener: (this: SVGAnimationElement, ev: SVGAnimationElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGAnimationElementEventMap>(type: K, listener: (this: SVGAnimationElement, ev: SVGAnimationElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGAnimationElement: {
    prototype: SVGAnimationElement;
    new(): SVGAnimationElement;
    isInstance: IsInstance<SVGAnimationElement>;
};

interface SVGCircleElement extends SVGGeometryElement {
    readonly cx: SVGAnimatedLength;
    readonly cy: SVGAnimatedLength;
    readonly r: SVGAnimatedLength;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGCircleElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGCircleElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGCircleElement: {
    prototype: SVGCircleElement;
    new(): SVGCircleElement;
    isInstance: IsInstance<SVGCircleElement>;
};

interface SVGClipPathElement extends SVGElement {
    readonly clipPathUnits: SVGAnimatedEnumeration;
    readonly transform: SVGAnimatedTransformList;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGClipPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGClipPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGClipPathElement: {
    prototype: SVGClipPathElement;
    new(): SVGClipPathElement;
    isInstance: IsInstance<SVGClipPathElement>;
};

interface SVGComponentTransferFunctionElement extends SVGElement {
    readonly amplitude: SVGAnimatedNumber;
    readonly exponent: SVGAnimatedNumber;
    readonly intercept: SVGAnimatedNumber;
    readonly offset: SVGAnimatedNumber;
    readonly slope: SVGAnimatedNumber;
    readonly tableValues: SVGAnimatedNumberList;
    readonly type: SVGAnimatedEnumeration;
    readonly SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN: 0;
    readonly SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY: 1;
    readonly SVG_FECOMPONENTTRANSFER_TYPE_TABLE: 2;
    readonly SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE: 3;
    readonly SVG_FECOMPONENTTRANSFER_TYPE_LINEAR: 4;
    readonly SVG_FECOMPONENTTRANSFER_TYPE_GAMMA: 5;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGComponentTransferFunctionElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGComponentTransferFunctionElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGComponentTransferFunctionElement: {
    prototype: SVGComponentTransferFunctionElement;
    new(): SVGComponentTransferFunctionElement;
    readonly SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN: 0;
    readonly SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY: 1;
    readonly SVG_FECOMPONENTTRANSFER_TYPE_TABLE: 2;
    readonly SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE: 3;
    readonly SVG_FECOMPONENTTRANSFER_TYPE_LINEAR: 4;
    readonly SVG_FECOMPONENTTRANSFER_TYPE_GAMMA: 5;
    isInstance: IsInstance<SVGComponentTransferFunctionElement>;
};

interface SVGDefsElement extends SVGGraphicsElement {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGDefsElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGDefsElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGDefsElement: {
    prototype: SVGDefsElement;
    new(): SVGDefsElement;
    isInstance: IsInstance<SVGDefsElement>;
};

interface SVGDescElement extends SVGElement {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGDescElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGDescElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGDescElement: {
    prototype: SVGDescElement;
    new(): SVGDescElement;
    isInstance: IsInstance<SVGDescElement>;
};

interface SVGElementEventMap extends ElementEventMap, GlobalEventHandlersEventMap, OnErrorEventHandlerForNodesEventMap, TouchEventHandlersEventMap {
}

// @ts-ignore
interface SVGElement extends Element, ElementCSSInlineStyle, GlobalEventHandlers, HTMLOrForeignElement, OnErrorEventHandlerForNodes, TouchEventHandlers {
    readonly className: SVGAnimatedString;
    id: string;
    nonce: string;
    readonly ownerSVGElement: SVGSVGElement | null;
    readonly viewportElement: SVGElement | null;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGElement: {
    prototype: SVGElement;
    new(): SVGElement;
    isInstance: IsInstance<SVGElement>;
};

interface SVGEllipseElement extends SVGGeometryElement {
    readonly cx: SVGAnimatedLength;
    readonly cy: SVGAnimatedLength;
    readonly rx: SVGAnimatedLength;
    readonly ry: SVGAnimatedLength;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGEllipseElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGEllipseElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGEllipseElement: {
    prototype: SVGEllipseElement;
    new(): SVGEllipseElement;
    isInstance: IsInstance<SVGEllipseElement>;
};

interface SVGFEBlendElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly in1: SVGAnimatedString;
    readonly in2: SVGAnimatedString;
    readonly mode: SVGAnimatedEnumeration;
    readonly SVG_FEBLEND_MODE_UNKNOWN: 0;
    readonly SVG_FEBLEND_MODE_NORMAL: 1;
    readonly SVG_FEBLEND_MODE_MULTIPLY: 2;
    readonly SVG_FEBLEND_MODE_SCREEN: 3;
    readonly SVG_FEBLEND_MODE_DARKEN: 4;
    readonly SVG_FEBLEND_MODE_LIGHTEN: 5;
    readonly SVG_FEBLEND_MODE_OVERLAY: 6;
    readonly SVG_FEBLEND_MODE_COLOR_DODGE: 7;
    readonly SVG_FEBLEND_MODE_COLOR_BURN: 8;
    readonly SVG_FEBLEND_MODE_HARD_LIGHT: 9;
    readonly SVG_FEBLEND_MODE_SOFT_LIGHT: 10;
    readonly SVG_FEBLEND_MODE_DIFFERENCE: 11;
    readonly SVG_FEBLEND_MODE_EXCLUSION: 12;
    readonly SVG_FEBLEND_MODE_HUE: 13;
    readonly SVG_FEBLEND_MODE_SATURATION: 14;
    readonly SVG_FEBLEND_MODE_COLOR: 15;
    readonly SVG_FEBLEND_MODE_LUMINOSITY: 16;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEBlendElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEBlendElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEBlendElement: {
    prototype: SVGFEBlendElement;
    new(): SVGFEBlendElement;
    readonly SVG_FEBLEND_MODE_UNKNOWN: 0;
    readonly SVG_FEBLEND_MODE_NORMAL: 1;
    readonly SVG_FEBLEND_MODE_MULTIPLY: 2;
    readonly SVG_FEBLEND_MODE_SCREEN: 3;
    readonly SVG_FEBLEND_MODE_DARKEN: 4;
    readonly SVG_FEBLEND_MODE_LIGHTEN: 5;
    readonly SVG_FEBLEND_MODE_OVERLAY: 6;
    readonly SVG_FEBLEND_MODE_COLOR_DODGE: 7;
    readonly SVG_FEBLEND_MODE_COLOR_BURN: 8;
    readonly SVG_FEBLEND_MODE_HARD_LIGHT: 9;
    readonly SVG_FEBLEND_MODE_SOFT_LIGHT: 10;
    readonly SVG_FEBLEND_MODE_DIFFERENCE: 11;
    readonly SVG_FEBLEND_MODE_EXCLUSION: 12;
    readonly SVG_FEBLEND_MODE_HUE: 13;
    readonly SVG_FEBLEND_MODE_SATURATION: 14;
    readonly SVG_FEBLEND_MODE_COLOR: 15;
    readonly SVG_FEBLEND_MODE_LUMINOSITY: 16;
    isInstance: IsInstance<SVGFEBlendElement>;
};

interface SVGFEColorMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly in1: SVGAnimatedString;
    readonly type: SVGAnimatedEnumeration;
    readonly values: SVGAnimatedNumberList;
    readonly SVG_FECOLORMATRIX_TYPE_UNKNOWN: 0;
    readonly SVG_FECOLORMATRIX_TYPE_MATRIX: 1;
    readonly SVG_FECOLORMATRIX_TYPE_SATURATE: 2;
    readonly SVG_FECOLORMATRIX_TYPE_HUEROTATE: 3;
    readonly SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA: 4;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEColorMatrixElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEColorMatrixElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEColorMatrixElement: {
    prototype: SVGFEColorMatrixElement;
    new(): SVGFEColorMatrixElement;
    readonly SVG_FECOLORMATRIX_TYPE_UNKNOWN: 0;
    readonly SVG_FECOLORMATRIX_TYPE_MATRIX: 1;
    readonly SVG_FECOLORMATRIX_TYPE_SATURATE: 2;
    readonly SVG_FECOLORMATRIX_TYPE_HUEROTATE: 3;
    readonly SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA: 4;
    isInstance: IsInstance<SVGFEColorMatrixElement>;
};

interface SVGFEComponentTransferElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly in1: SVGAnimatedString;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEComponentTransferElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEComponentTransferElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEComponentTransferElement: {
    prototype: SVGFEComponentTransferElement;
    new(): SVGFEComponentTransferElement;
    isInstance: IsInstance<SVGFEComponentTransferElement>;
};

interface SVGFECompositeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly in1: SVGAnimatedString;
    readonly in2: SVGAnimatedString;
    readonly k1: SVGAnimatedNumber;
    readonly k2: SVGAnimatedNumber;
    readonly k3: SVGAnimatedNumber;
    readonly k4: SVGAnimatedNumber;
    readonly operator: SVGAnimatedEnumeration;
    readonly SVG_FECOMPOSITE_OPERATOR_UNKNOWN: 0;
    readonly SVG_FECOMPOSITE_OPERATOR_OVER: 1;
    readonly SVG_FECOMPOSITE_OPERATOR_IN: 2;
    readonly SVG_FECOMPOSITE_OPERATOR_OUT: 3;
    readonly SVG_FECOMPOSITE_OPERATOR_ATOP: 4;
    readonly SVG_FECOMPOSITE_OPERATOR_XOR: 5;
    readonly SVG_FECOMPOSITE_OPERATOR_ARITHMETIC: 6;
    readonly SVG_FECOMPOSITE_OPERATOR_LIGHTER: 7;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFECompositeElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFECompositeElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFECompositeElement: {
    prototype: SVGFECompositeElement;
    new(): SVGFECompositeElement;
    readonly SVG_FECOMPOSITE_OPERATOR_UNKNOWN: 0;
    readonly SVG_FECOMPOSITE_OPERATOR_OVER: 1;
    readonly SVG_FECOMPOSITE_OPERATOR_IN: 2;
    readonly SVG_FECOMPOSITE_OPERATOR_OUT: 3;
    readonly SVG_FECOMPOSITE_OPERATOR_ATOP: 4;
    readonly SVG_FECOMPOSITE_OPERATOR_XOR: 5;
    readonly SVG_FECOMPOSITE_OPERATOR_ARITHMETIC: 6;
    readonly SVG_FECOMPOSITE_OPERATOR_LIGHTER: 7;
    isInstance: IsInstance<SVGFECompositeElement>;
};

interface SVGFEConvolveMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly bias: SVGAnimatedNumber;
    readonly divisor: SVGAnimatedNumber;
    readonly edgeMode: SVGAnimatedEnumeration;
    readonly in1: SVGAnimatedString;
    readonly kernelMatrix: SVGAnimatedNumberList;
    readonly kernelUnitLengthX: SVGAnimatedNumber;
    readonly kernelUnitLengthY: SVGAnimatedNumber;
    readonly orderX: SVGAnimatedInteger;
    readonly orderY: SVGAnimatedInteger;
    readonly preserveAlpha: SVGAnimatedBoolean;
    readonly targetX: SVGAnimatedInteger;
    readonly targetY: SVGAnimatedInteger;
    readonly SVG_EDGEMODE_UNKNOWN: 0;
    readonly SVG_EDGEMODE_DUPLICATE: 1;
    readonly SVG_EDGEMODE_WRAP: 2;
    readonly SVG_EDGEMODE_NONE: 3;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEConvolveMatrixElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEConvolveMatrixElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEConvolveMatrixElement: {
    prototype: SVGFEConvolveMatrixElement;
    new(): SVGFEConvolveMatrixElement;
    readonly SVG_EDGEMODE_UNKNOWN: 0;
    readonly SVG_EDGEMODE_DUPLICATE: 1;
    readonly SVG_EDGEMODE_WRAP: 2;
    readonly SVG_EDGEMODE_NONE: 3;
    isInstance: IsInstance<SVGFEConvolveMatrixElement>;
};

interface SVGFEDiffuseLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly diffuseConstant: SVGAnimatedNumber;
    readonly in1: SVGAnimatedString;
    readonly kernelUnitLengthX: SVGAnimatedNumber;
    readonly kernelUnitLengthY: SVGAnimatedNumber;
    readonly surfaceScale: SVGAnimatedNumber;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDiffuseLightingElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDiffuseLightingElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEDiffuseLightingElement: {
    prototype: SVGFEDiffuseLightingElement;
    new(): SVGFEDiffuseLightingElement;
    isInstance: IsInstance<SVGFEDiffuseLightingElement>;
};

interface SVGFEDisplacementMapElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly in1: SVGAnimatedString;
    readonly in2: SVGAnimatedString;
    readonly scale: SVGAnimatedNumber;
    readonly xChannelSelector: SVGAnimatedEnumeration;
    readonly yChannelSelector: SVGAnimatedEnumeration;
    readonly SVG_CHANNEL_UNKNOWN: 0;
    readonly SVG_CHANNEL_R: 1;
    readonly SVG_CHANNEL_G: 2;
    readonly SVG_CHANNEL_B: 3;
    readonly SVG_CHANNEL_A: 4;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDisplacementMapElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDisplacementMapElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEDisplacementMapElement: {
    prototype: SVGFEDisplacementMapElement;
    new(): SVGFEDisplacementMapElement;
    readonly SVG_CHANNEL_UNKNOWN: 0;
    readonly SVG_CHANNEL_R: 1;
    readonly SVG_CHANNEL_G: 2;
    readonly SVG_CHANNEL_B: 3;
    readonly SVG_CHANNEL_A: 4;
    isInstance: IsInstance<SVGFEDisplacementMapElement>;
};

interface SVGFEDistantLightElement extends SVGElement {
    readonly azimuth: SVGAnimatedNumber;
    readonly elevation: SVGAnimatedNumber;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDistantLightElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDistantLightElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEDistantLightElement: {
    prototype: SVGFEDistantLightElement;
    new(): SVGFEDistantLightElement;
    isInstance: IsInstance<SVGFEDistantLightElement>;
};

interface SVGFEDropShadowElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly dx: SVGAnimatedNumber;
    readonly dy: SVGAnimatedNumber;
    readonly in1: SVGAnimatedString;
    readonly stdDeviationX: SVGAnimatedNumber;
    readonly stdDeviationY: SVGAnimatedNumber;
    setStdDeviation(stdDeviationX: number, stdDeviationY: number): void;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDropShadowElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDropShadowElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEDropShadowElement: {
    prototype: SVGFEDropShadowElement;
    new(): SVGFEDropShadowElement;
    isInstance: IsInstance<SVGFEDropShadowElement>;
};

interface SVGFEFloodElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFloodElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFloodElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEFloodElement: {
    prototype: SVGFEFloodElement;
    new(): SVGFEFloodElement;
    isInstance: IsInstance<SVGFEFloodElement>;
};

interface SVGFEFuncAElement extends SVGComponentTransferFunctionElement {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncAElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncAElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEFuncAElement: {
    prototype: SVGFEFuncAElement;
    new(): SVGFEFuncAElement;
    isInstance: IsInstance<SVGFEFuncAElement>;
};

interface SVGFEFuncBElement extends SVGComponentTransferFunctionElement {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncBElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncBElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEFuncBElement: {
    prototype: SVGFEFuncBElement;
    new(): SVGFEFuncBElement;
    isInstance: IsInstance<SVGFEFuncBElement>;
};

interface SVGFEFuncGElement extends SVGComponentTransferFunctionElement {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEFuncGElement: {
    prototype: SVGFEFuncGElement;
    new(): SVGFEFuncGElement;
    isInstance: IsInstance<SVGFEFuncGElement>;
};

interface SVGFEFuncRElement extends SVGComponentTransferFunctionElement {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncRElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncRElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEFuncRElement: {
    prototype: SVGFEFuncRElement;
    new(): SVGFEFuncRElement;
    isInstance: IsInstance<SVGFEFuncRElement>;
};

interface SVGFEGaussianBlurElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly in1: SVGAnimatedString;
    readonly stdDeviationX: SVGAnimatedNumber;
    readonly stdDeviationY: SVGAnimatedNumber;
    setStdDeviation(stdDeviationX: number, stdDeviationY: number): void;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEGaussianBlurElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEGaussianBlurElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEGaussianBlurElement: {
    prototype: SVGFEGaussianBlurElement;
    new(): SVGFEGaussianBlurElement;
    isInstance: IsInstance<SVGFEGaussianBlurElement>;
};

interface SVGFEImageElement extends SVGElement, SVGFilterPrimitiveStandardAttributes, SVGURIReference {
    crossOrigin: string | null;
    fetchPriority: string;
    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEImageElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEImageElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEImageElement: {
    prototype: SVGFEImageElement;
    new(): SVGFEImageElement;
    isInstance: IsInstance<SVGFEImageElement>;
};

interface SVGFEMergeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMergeElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMergeElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEMergeElement: {
    prototype: SVGFEMergeElement;
    new(): SVGFEMergeElement;
    isInstance: IsInstance<SVGFEMergeElement>;
};

interface SVGFEMergeNodeElement extends SVGElement {
    readonly in1: SVGAnimatedString;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMergeNodeElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMergeNodeElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEMergeNodeElement: {
    prototype: SVGFEMergeNodeElement;
    new(): SVGFEMergeNodeElement;
    isInstance: IsInstance<SVGFEMergeNodeElement>;
};

interface SVGFEMorphologyElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly in1: SVGAnimatedString;
    readonly operator: SVGAnimatedEnumeration;
    readonly radiusX: SVGAnimatedNumber;
    readonly radiusY: SVGAnimatedNumber;
    readonly SVG_MORPHOLOGY_OPERATOR_UNKNOWN: 0;
    readonly SVG_MORPHOLOGY_OPERATOR_ERODE: 1;
    readonly SVG_MORPHOLOGY_OPERATOR_DILATE: 2;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMorphologyElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMorphologyElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEMorphologyElement: {
    prototype: SVGFEMorphologyElement;
    new(): SVGFEMorphologyElement;
    readonly SVG_MORPHOLOGY_OPERATOR_UNKNOWN: 0;
    readonly SVG_MORPHOLOGY_OPERATOR_ERODE: 1;
    readonly SVG_MORPHOLOGY_OPERATOR_DILATE: 2;
    isInstance: IsInstance<SVGFEMorphologyElement>;
};

interface SVGFEOffsetElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly dx: SVGAnimatedNumber;
    readonly dy: SVGAnimatedNumber;
    readonly in1: SVGAnimatedString;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEOffsetElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEOffsetElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEOffsetElement: {
    prototype: SVGFEOffsetElement;
    new(): SVGFEOffsetElement;
    isInstance: IsInstance<SVGFEOffsetElement>;
};

interface SVGFEPointLightElement extends SVGElement {
    readonly x: SVGAnimatedNumber;
    readonly y: SVGAnimatedNumber;
    readonly z: SVGAnimatedNumber;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEPointLightElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEPointLightElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFEPointLightElement: {
    prototype: SVGFEPointLightElement;
    new(): SVGFEPointLightElement;
    isInstance: IsInstance<SVGFEPointLightElement>;
};

interface SVGFESpecularLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly in1: SVGAnimatedString;
    readonly kernelUnitLengthX: SVGAnimatedNumber;
    readonly kernelUnitLengthY: SVGAnimatedNumber;
    readonly specularConstant: SVGAnimatedNumber;
    readonly specularExponent: SVGAnimatedNumber;
    readonly surfaceScale: SVGAnimatedNumber;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFESpecularLightingElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFESpecularLightingElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFESpecularLightingElement: {
    prototype: SVGFESpecularLightingElement;
    new(): SVGFESpecularLightingElement;
    isInstance: IsInstance<SVGFESpecularLightingElement>;
};

interface SVGFESpotLightElement extends SVGElement {
    readonly limitingConeAngle: SVGAnimatedNumber;
    readonly pointsAtX: SVGAnimatedNumber;
    readonly pointsAtY: SVGAnimatedNumber;
    readonly pointsAtZ: SVGAnimatedNumber;
    readonly specularExponent: SVGAnimatedNumber;
    readonly x: SVGAnimatedNumber;
    readonly y: SVGAnimatedNumber;
    readonly z: SVGAnimatedNumber;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFESpotLightElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFESpotLightElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFESpotLightElement: {
    prototype: SVGFESpotLightElement;
    new(): SVGFESpotLightElement;
    isInstance: IsInstance<SVGFESpotLightElement>;
};

interface SVGFETileElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly in1: SVGAnimatedString;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFETileElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFETileElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFETileElement: {
    prototype: SVGFETileElement;
    new(): SVGFETileElement;
    isInstance: IsInstance<SVGFETileElement>;
};

interface SVGFETurbulenceElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
    readonly baseFrequencyX: SVGAnimatedNumber;
    readonly baseFrequencyY: SVGAnimatedNumber;
    readonly numOctaves: SVGAnimatedInteger;
    readonly seed: SVGAnimatedNumber;
    readonly stitchTiles: SVGAnimatedEnumeration;
    readonly type: SVGAnimatedEnumeration;
    readonly SVG_TURBULENCE_TYPE_UNKNOWN: 0;
    readonly SVG_TURBULENCE_TYPE_FRACTALNOISE: 1;
    readonly SVG_TURBULENCE_TYPE_TURBULENCE: 2;
    readonly SVG_STITCHTYPE_UNKNOWN: 0;
    readonly SVG_STITCHTYPE_STITCH: 1;
    readonly SVG_STITCHTYPE_NOSTITCH: 2;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFETurbulenceElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFETurbulenceElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFETurbulenceElement: {
    prototype: SVGFETurbulenceElement;
    new(): SVGFETurbulenceElement;
    readonly SVG_TURBULENCE_TYPE_UNKNOWN: 0;
    readonly SVG_TURBULENCE_TYPE_FRACTALNOISE: 1;
    readonly SVG_TURBULENCE_TYPE_TURBULENCE: 2;
    readonly SVG_STITCHTYPE_UNKNOWN: 0;
    readonly SVG_STITCHTYPE_STITCH: 1;
    readonly SVG_STITCHTYPE_NOSTITCH: 2;
    isInstance: IsInstance<SVGFETurbulenceElement>;
};

interface SVGFilterElement extends SVGElement, SVGURIReference {
    readonly filterUnits: SVGAnimatedEnumeration;
    readonly height: SVGAnimatedLength;
    readonly primitiveUnits: SVGAnimatedEnumeration;
    readonly width: SVGAnimatedLength;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFilterElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFilterElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGFilterElement: {
    prototype: SVGFilterElement;
    new(): SVGFilterElement;
    isInstance: IsInstance<SVGFilterElement>;
};

interface SVGFilterPrimitiveStandardAttributes {
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
    readonly width: SVGAnimatedLength;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
}

interface SVGFitToViewBox {
    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;
    readonly viewBox: SVGAnimatedRect;
}

interface SVGForeignObjectElement extends SVGGraphicsElement {
    readonly height: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGForeignObjectElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGForeignObjectElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGForeignObjectElement: {
    prototype: SVGForeignObjectElement;
    new(): SVGForeignObjectElement;
    isInstance: IsInstance<SVGForeignObjectElement>;
};

interface SVGGElement extends SVGGraphicsElement {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGGElement: {
    prototype: SVGGElement;
    new(): SVGGElement;
    isInstance: IsInstance<SVGGElement>;
};

interface SVGGeometryElement extends SVGGraphicsElement {
    readonly pathLength: SVGAnimatedNumber;
    getPointAtLength(distance: number): SVGPoint;
    getTotalLength(): number;
    isPointInFill(point?: DOMPointInit): boolean;
    isPointInStroke(point?: DOMPointInit): boolean;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGeometryElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGeometryElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGGeometryElement: {
    prototype: SVGGeometryElement;
    new(): SVGGeometryElement;
    isInstance: IsInstance<SVGGeometryElement>;
};

interface SVGGradientElement extends SVGElement, SVGURIReference {
    readonly gradientTransform: SVGAnimatedTransformList;
    readonly gradientUnits: SVGAnimatedEnumeration;
    readonly spreadMethod: SVGAnimatedEnumeration;
    readonly SVG_SPREADMETHOD_UNKNOWN: 0;
    readonly SVG_SPREADMETHOD_PAD: 1;
    readonly SVG_SPREADMETHOD_REFLECT: 2;
    readonly SVG_SPREADMETHOD_REPEAT: 3;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGradientElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGradientElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGGradientElement: {
    prototype: SVGGradientElement;
    new(): SVGGradientElement;
    readonly SVG_SPREADMETHOD_UNKNOWN: 0;
    readonly SVG_SPREADMETHOD_PAD: 1;
    readonly SVG_SPREADMETHOD_REFLECT: 2;
    readonly SVG_SPREADMETHOD_REPEAT: 3;
    isInstance: IsInstance<SVGGradientElement>;
};

interface SVGGraphicsElement extends SVGElement, SVGTests {
    readonly farthestViewportElement: SVGElement | null;
    readonly nearestViewportElement: SVGElement | null;
    readonly transform: SVGAnimatedTransformList;
    getBBox(aOptions?: SVGBoundingBoxOptions): SVGRect;
    getCTM(): SVGMatrix | null;
    getScreenCTM(): SVGMatrix | null;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGraphicsElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGraphicsElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGGraphicsElement: {
    prototype: SVGGraphicsElement;
    new(): SVGGraphicsElement;
    isInstance: IsInstance<SVGGraphicsElement>;
};

interface SVGImageElement extends SVGGraphicsElement, MozImageLoadingContent, SVGURIReference {
    crossOrigin: string | null;
    decoding: string;
    fetchPriority: string;
    readonly height: SVGAnimatedLength;
    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;
    readonly width: SVGAnimatedLength;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    decode(): Promise<void>;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGImageElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGImageElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGImageElement: {
    prototype: SVGImageElement;
    new(): SVGImageElement;
    readonly UNKNOWN_REQUEST: -1;
    readonly CURRENT_REQUEST: 0;
    readonly PENDING_REQUEST: 1;
    isInstance: IsInstance<SVGImageElement>;
};

interface SVGLength {
    readonly unitType: number;
    value: number;
    valueAsString: string;
    valueInSpecifiedUnits: number;
    convertToSpecifiedUnits(unitType: number): void;
    newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;
    readonly SVG_LENGTHTYPE_UNKNOWN: 0;
    readonly SVG_LENGTHTYPE_NUMBER: 1;
    readonly SVG_LENGTHTYPE_PERCENTAGE: 2;
    readonly SVG_LENGTHTYPE_EMS: 3;
    readonly SVG_LENGTHTYPE_EXS: 4;
    readonly SVG_LENGTHTYPE_PX: 5;
    readonly SVG_LENGTHTYPE_CM: 6;
    readonly SVG_LENGTHTYPE_MM: 7;
    readonly SVG_LENGTHTYPE_IN: 8;
    readonly SVG_LENGTHTYPE_PT: 9;
    readonly SVG_LENGTHTYPE_PC: 10;
}

declare var SVGLength: {
    prototype: SVGLength;
    new(): SVGLength;
    readonly SVG_LENGTHTYPE_UNKNOWN: 0;
    readonly SVG_LENGTHTYPE_NUMBER: 1;
    readonly SVG_LENGTHTYPE_PERCENTAGE: 2;
    readonly SVG_LENGTHTYPE_EMS: 3;
    readonly SVG_LENGTHTYPE_EXS: 4;
    readonly SVG_LENGTHTYPE_PX: 5;
    readonly SVG_LENGTHTYPE_CM: 6;
    readonly SVG_LENGTHTYPE_MM: 7;
    readonly SVG_LENGTHTYPE_IN: 8;
    readonly SVG_LENGTHTYPE_PT: 9;
    readonly SVG_LENGTHTYPE_PC: 10;
    isInstance: IsInstance<SVGLength>;
};

interface SVGLengthList {
    readonly length: number;
    readonly numberOfItems: number;
    appendItem(newItem: SVGLength): SVGLength;
    clear(): void;
    getItem(index: number): SVGLength;
    initialize(newItem: SVGLength): SVGLength;
    insertItemBefore(newItem: SVGLength, index: number): SVGLength;
    removeItem(index: number): SVGLength;
    replaceItem(newItem: SVGLength, index: number): SVGLength;
    [index: number]: SVGLength;
}

declare var SVGLengthList: {
    prototype: SVGLengthList;
    new(): SVGLengthList;
    isInstance: IsInstance<SVGLengthList>;
};

interface SVGLineElement extends SVGGeometryElement {
    readonly x1: SVGAnimatedLength;
    readonly x2: SVGAnimatedLength;
    readonly y1: SVGAnimatedLength;
    readonly y2: SVGAnimatedLength;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGLineElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGLineElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGLineElement: {
    prototype: SVGLineElement;
    new(): SVGLineElement;
    isInstance: IsInstance<SVGLineElement>;
};

interface SVGLinearGradientElement extends SVGGradientElement {
    readonly x1: SVGAnimatedLength;
    readonly x2: SVGAnimatedLength;
    readonly y1: SVGAnimatedLength;
    readonly y2: SVGAnimatedLength;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGLinearGradientElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGLinearGradientElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGLinearGradientElement: {
    prototype: SVGLinearGradientElement;
    new(): SVGLinearGradientElement;
    isInstance: IsInstance<SVGLinearGradientElement>;
};

interface SVGMPathElement extends SVGElement, SVGURIReference {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGMPathElement: {
    prototype: SVGMPathElement;
    new(): SVGMPathElement;
    isInstance: IsInstance<SVGMPathElement>;
};

interface SVGMarkerElement extends SVGElement, SVGFitToViewBox {
    readonly markerHeight: SVGAnimatedLength;
    readonly markerUnits: SVGAnimatedEnumeration;
    readonly markerWidth: SVGAnimatedLength;
    readonly orientAngle: SVGAnimatedAngle;
    readonly orientType: SVGAnimatedEnumeration;
    readonly refX: SVGAnimatedLength;
    readonly refY: SVGAnimatedLength;
    setOrientToAngle(angle: SVGAngle): void;
    setOrientToAuto(): void;
    readonly SVG_MARKERUNITS_UNKNOWN: 0;
    readonly SVG_MARKERUNITS_USERSPACEONUSE: 1;
    readonly SVG_MARKERUNITS_STROKEWIDTH: 2;
    readonly SVG_MARKER_ORIENT_UNKNOWN: 0;
    readonly SVG_MARKER_ORIENT_AUTO: 1;
    readonly SVG_MARKER_ORIENT_ANGLE: 2;
    readonly SVG_MARKER_ORIENT_AUTO_START_REVERSE: 3;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMarkerElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMarkerElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGMarkerElement: {
    prototype: SVGMarkerElement;
    new(): SVGMarkerElement;
    readonly SVG_MARKERUNITS_UNKNOWN: 0;
    readonly SVG_MARKERUNITS_USERSPACEONUSE: 1;
    readonly SVG_MARKERUNITS_STROKEWIDTH: 2;
    readonly SVG_MARKER_ORIENT_UNKNOWN: 0;
    readonly SVG_MARKER_ORIENT_AUTO: 1;
    readonly SVG_MARKER_ORIENT_ANGLE: 2;
    readonly SVG_MARKER_ORIENT_AUTO_START_REVERSE: 3;
    isInstance: IsInstance<SVGMarkerElement>;
};

interface SVGMaskElement extends SVGElement {
    readonly height: SVGAnimatedLength;
    readonly maskContentUnits: SVGAnimatedEnumeration;
    readonly maskUnits: SVGAnimatedEnumeration;
    readonly width: SVGAnimatedLength;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly SVG_MASKTYPE_LUMINANCE: 0;
    readonly SVG_MASKTYPE_ALPHA: 1;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMaskElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMaskElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGMaskElement: {
    prototype: SVGMaskElement;
    new(): SVGMaskElement;
    readonly SVG_MASKTYPE_LUMINANCE: 0;
    readonly SVG_MASKTYPE_ALPHA: 1;
    isInstance: IsInstance<SVGMaskElement>;
};

interface SVGMatrix {
    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;
    flipX(): SVGMatrix;
    flipY(): SVGMatrix;
    inverse(): SVGMatrix;
    multiply(secondMatrix: SVGMatrix): SVGMatrix;
    rotate(angle: number): SVGMatrix;
    rotateFromVector(x: number, y: number): SVGMatrix;
    scale(scaleFactor: number): SVGMatrix;
    scaleNonUniform(scaleFactorX: number, scaleFactorY: number): SVGMatrix;
    skewX(angle: number): SVGMatrix;
    skewY(angle: number): SVGMatrix;
    translate(x: number, y: number): SVGMatrix;
}

declare var SVGMatrix: {
    prototype: SVGMatrix;
    new(): SVGMatrix;
    isInstance: IsInstance<SVGMatrix>;
};

interface SVGMetadataElement extends SVGElement {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMetadataElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMetadataElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGMetadataElement: {
    prototype: SVGMetadataElement;
    new(): SVGMetadataElement;
    isInstance: IsInstance<SVGMetadataElement>;
};

interface SVGNumber {
    value: number;
}

declare var SVGNumber: {
    prototype: SVGNumber;
    new(): SVGNumber;
    isInstance: IsInstance<SVGNumber>;
};

interface SVGNumberList {
    readonly length: number;
    readonly numberOfItems: number;
    appendItem(newItem: SVGNumber): SVGNumber;
    clear(): void;
    getItem(index: number): SVGNumber;
    initialize(newItem: SVGNumber): SVGNumber;
    insertItemBefore(newItem: SVGNumber, index: number): SVGNumber;
    removeItem(index: number): SVGNumber;
    replaceItem(newItem: SVGNumber, index: number): SVGNumber;
    [index: number]: SVGNumber;
}

declare var SVGNumberList: {
    prototype: SVGNumberList;
    new(): SVGNumberList;
    isInstance: IsInstance<SVGNumberList>;
};

interface SVGPathData {
    getPathData(settings?: SVGPathDataSettings): SVGPathSegment[];
    setPathData(pathData: SVGPathSegmentInit[]): void;
}

interface SVGPathElement extends SVGGeometryElement, SVGPathData {
    getPathSegmentAtLength(distance: number): SVGPathSegment | null;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGPathElement: {
    prototype: SVGPathElement;
    new(): SVGPathElement;
    isInstance: IsInstance<SVGPathElement>;
};

interface SVGPathSegment {
    type: string;
    values: number[] | Float32Array;
}

interface SVGPatternElement extends SVGElement, SVGFitToViewBox, SVGURIReference {
    readonly height: SVGAnimatedLength;
    readonly patternContentUnits: SVGAnimatedEnumeration;
    readonly patternTransform: SVGAnimatedTransformList;
    readonly patternUnits: SVGAnimatedEnumeration;
    readonly width: SVGAnimatedLength;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPatternElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPatternElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGPatternElement: {
    prototype: SVGPatternElement;
    new(): SVGPatternElement;
    isInstance: IsInstance<SVGPatternElement>;
};

interface SVGPoint {
    x: number;
    y: number;
    matrixTransform(matrix?: DOMMatrix2DInit): SVGPoint;
}

declare var SVGPoint: {
    prototype: SVGPoint;
    new(): SVGPoint;
    isInstance: IsInstance<SVGPoint>;
};

interface SVGPointList {
    readonly length: number;
    readonly numberOfItems: number;
    appendItem(newItem: SVGPoint): SVGPoint;
    clear(): void;
    getItem(index: number): SVGPoint;
    initialize(newItem: SVGPoint): SVGPoint;
    insertItemBefore(newItem: SVGPoint, index: number): SVGPoint;
    removeItem(index: number): SVGPoint;
    replaceItem(newItem: SVGPoint, index: number): SVGPoint;
    [index: number]: SVGPoint;
}

declare var SVGPointList: {
    prototype: SVGPointList;
    new(): SVGPointList;
    isInstance: IsInstance<SVGPointList>;
};

interface SVGPolygonElement extends SVGGeometryElement, SVGAnimatedPoints {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPolygonElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPolygonElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGPolygonElement: {
    prototype: SVGPolygonElement;
    new(): SVGPolygonElement;
    isInstance: IsInstance<SVGPolygonElement>;
};

interface SVGPolylineElement extends SVGGeometryElement, SVGAnimatedPoints {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPolylineElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPolylineElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGPolylineElement: {
    prototype: SVGPolylineElement;
    new(): SVGPolylineElement;
    isInstance: IsInstance<SVGPolylineElement>;
};

interface SVGPreserveAspectRatio {
    align: number;
    meetOrSlice: number;
    readonly SVG_PRESERVEASPECTRATIO_UNKNOWN: 0;
    readonly SVG_PRESERVEASPECTRATIO_NONE: 1;
    readonly SVG_PRESERVEASPECTRATIO_XMINYMIN: 2;
    readonly SVG_PRESERVEASPECTRATIO_XMIDYMIN: 3;
    readonly SVG_PRESERVEASPECTRATIO_XMAXYMIN: 4;
    readonly SVG_PRESERVEASPECTRATIO_XMINYMID: 5;
    readonly SVG_PRESERVEASPECTRATIO_XMIDYMID: 6;
    readonly SVG_PRESERVEASPECTRATIO_XMAXYMID: 7;
    readonly SVG_PRESERVEASPECTRATIO_XMINYMAX: 8;
    readonly SVG_PRESERVEASPECTRATIO_XMIDYMAX: 9;
    readonly SVG_PRESERVEASPECTRATIO_XMAXYMAX: 10;
    readonly SVG_MEETORSLICE_UNKNOWN: 0;
    readonly SVG_MEETORSLICE_MEET: 1;
    readonly SVG_MEETORSLICE_SLICE: 2;
}

declare var SVGPreserveAspectRatio: {
    prototype: SVGPreserveAspectRatio;
    new(): SVGPreserveAspectRatio;
    readonly SVG_PRESERVEASPECTRATIO_UNKNOWN: 0;
    readonly SVG_PRESERVEASPECTRATIO_NONE: 1;
    readonly SVG_PRESERVEASPECTRATIO_XMINYMIN: 2;
    readonly SVG_PRESERVEASPECTRATIO_XMIDYMIN: 3;
    readonly SVG_PRESERVEASPECTRATIO_XMAXYMIN: 4;
    readonly SVG_PRESERVEASPECTRATIO_XMINYMID: 5;
    readonly SVG_PRESERVEASPECTRATIO_XMIDYMID: 6;
    readonly SVG_PRESERVEASPECTRATIO_XMAXYMID: 7;
    readonly SVG_PRESERVEASPECTRATIO_XMINYMAX: 8;
    readonly SVG_PRESERVEASPECTRATIO_XMIDYMAX: 9;
    readonly SVG_PRESERVEASPECTRATIO_XMAXYMAX: 10;
    readonly SVG_MEETORSLICE_UNKNOWN: 0;
    readonly SVG_MEETORSLICE_MEET: 1;
    readonly SVG_MEETORSLICE_SLICE: 2;
    isInstance: IsInstance<SVGPreserveAspectRatio>;
};

interface SVGRadialGradientElement extends SVGGradientElement {
    readonly cx: SVGAnimatedLength;
    readonly cy: SVGAnimatedLength;
    readonly fr: SVGAnimatedLength;
    readonly fx: SVGAnimatedLength;
    readonly fy: SVGAnimatedLength;
    readonly r: SVGAnimatedLength;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGRadialGradientElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGRadialGradientElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGRadialGradientElement: {
    prototype: SVGRadialGradientElement;
    new(): SVGRadialGradientElement;
    isInstance: IsInstance<SVGRadialGradientElement>;
};

interface SVGRect {
    height: number;
    width: number;
    x: number;
    y: number;
}

declare var SVGRect: {
    prototype: SVGRect;
    new(): SVGRect;
    isInstance: IsInstance<SVGRect>;
};

interface SVGRectElement extends SVGGeometryElement {
    readonly height: SVGAnimatedLength;
    readonly rx: SVGAnimatedLength;
    readonly ry: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGRectElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGRectElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGRectElement: {
    prototype: SVGRectElement;
    new(): SVGRectElement;
    isInstance: IsInstance<SVGRectElement>;
};

interface SVGSVGElement extends SVGGraphicsElement, SVGFitToViewBox, SVGZoomAndPan {
    currentScale: number;
    readonly currentTranslate: SVGPoint;
    readonly height: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    animationsPaused(): boolean;
    createSVGAngle(): SVGAngle;
    createSVGLength(): SVGLength;
    createSVGMatrix(): SVGMatrix;
    createSVGNumber(): SVGNumber;
    createSVGPoint(): SVGPoint;
    createSVGRect(): SVGRect;
    createSVGTransform(): SVGTransform;
    createSVGTransformFromMatrix(matrix?: DOMMatrix2DInit): SVGTransform;
    deselectAll(): void;
    forceRedraw(): void;
    getCurrentTime(): number;
    getElementById(elementId: string): Element | null;
    pauseAnimations(): void;
    setCurrentTime(seconds: number): void;
    suspendRedraw(maxWaitMilliseconds: number): number;
    unpauseAnimations(): void;
    unsuspendRedraw(suspendHandleID: number): void;
    unsuspendRedrawAll(): void;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGSVGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGSVGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGSVGElement: {
    prototype: SVGSVGElement;
    new(): SVGSVGElement;
    readonly SVG_ZOOMANDPAN_UNKNOWN: 0;
    readonly SVG_ZOOMANDPAN_DISABLE: 1;
    readonly SVG_ZOOMANDPAN_MAGNIFY: 2;
    isInstance: IsInstance<SVGSVGElement>;
};

interface SVGScriptElement extends SVGElement, SVGURIReference {
    async: boolean;
    crossOrigin: string | null;
    defer: boolean;
    fetchPriority: string;
    type: string;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGScriptElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGScriptElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGScriptElement: {
    prototype: SVGScriptElement;
    new(): SVGScriptElement;
    isInstance: IsInstance<SVGScriptElement>;
};

interface SVGSetElement extends SVGAnimationElement {
    addEventListener<K extends keyof SVGAnimationElementEventMap>(type: K, listener: (this: SVGSetElement, ev: SVGAnimationElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGAnimationElementEventMap>(type: K, listener: (this: SVGSetElement, ev: SVGAnimationElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGSetElement: {
    prototype: SVGSetElement;
    new(): SVGSetElement;
    isInstance: IsInstance<SVGSetElement>;
};

interface SVGStopElement extends SVGElement {
    readonly offset: SVGAnimatedNumber;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGStopElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGStopElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGStopElement: {
    prototype: SVGStopElement;
    new(): SVGStopElement;
    isInstance: IsInstance<SVGStopElement>;
};

interface SVGStringList {
    readonly length: number;
    readonly numberOfItems: number;
    appendItem(newItem: string): string;
    clear(): void;
    getItem(index: number): string;
    initialize(newItem: string): string;
    insertItemBefore(newItem: string, index: number): string;
    removeItem(index: number): string;
    replaceItem(newItem: string, index: number): string;
    [index: number]: string;
}

declare var SVGStringList: {
    prototype: SVGStringList;
    new(): SVGStringList;
    isInstance: IsInstance<SVGStringList>;
};

interface SVGStyleElement extends SVGElement, LinkStyle {
    disabled: boolean;
    media: string;
    title: string;
    type: string;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGStyleElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGStyleElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGStyleElement: {
    prototype: SVGStyleElement;
    new(): SVGStyleElement;
    isInstance: IsInstance<SVGStyleElement>;
};

interface SVGSwitchElement extends SVGGraphicsElement {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGSwitchElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGSwitchElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGSwitchElement: {
    prototype: SVGSwitchElement;
    new(): SVGSwitchElement;
    isInstance: IsInstance<SVGSwitchElement>;
};

interface SVGSymbolElement extends SVGElement, SVGFitToViewBox, SVGTests {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGSymbolElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGSymbolElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGSymbolElement: {
    prototype: SVGSymbolElement;
    new(): SVGSymbolElement;
    isInstance: IsInstance<SVGSymbolElement>;
};

interface SVGTSpanElement extends SVGTextPositioningElement {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTSpanElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTSpanElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGTSpanElement: {
    prototype: SVGTSpanElement;
    new(): SVGTSpanElement;
    isInstance: IsInstance<SVGTSpanElement>;
};

interface SVGTests {
    readonly requiredExtensions: SVGStringList;
    readonly systemLanguage: SVGStringList;
}

interface SVGTextContentElement extends SVGGraphicsElement {
    readonly lengthAdjust: SVGAnimatedEnumeration;
    readonly textLength: SVGAnimatedLength;
    getCharNumAtPosition(point?: DOMPointInit): number;
    getComputedTextLength(): number;
    getEndPositionOfChar(charnum: number): SVGPoint;
    getExtentOfChar(charnum: number): SVGRect;
    getNumberOfChars(): number;
    getRotationOfChar(charnum: number): number;
    getStartPositionOfChar(charnum: number): SVGPoint;
    getSubStringLength(charnum: number, nchars: number): number;
    selectSubString(charnum: number, nchars: number): void;
    readonly LENGTHADJUST_UNKNOWN: 0;
    readonly LENGTHADJUST_SPACING: 1;
    readonly LENGTHADJUST_SPACINGANDGLYPHS: 2;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextContentElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextContentElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGTextContentElement: {
    prototype: SVGTextContentElement;
    new(): SVGTextContentElement;
    readonly LENGTHADJUST_UNKNOWN: 0;
    readonly LENGTHADJUST_SPACING: 1;
    readonly LENGTHADJUST_SPACINGANDGLYPHS: 2;
    isInstance: IsInstance<SVGTextContentElement>;
};

interface SVGTextElement extends SVGTextPositioningElement {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGTextElement: {
    prototype: SVGTextElement;
    new(): SVGTextElement;
    isInstance: IsInstance<SVGTextElement>;
};

interface SVGTextPathElement extends SVGTextContentElement, SVGURIReference {
    readonly method: SVGAnimatedEnumeration;
    readonly spacing: SVGAnimatedEnumeration;
    readonly startOffset: SVGAnimatedLength;
    readonly TEXTPATH_METHODTYPE_UNKNOWN: 0;
    readonly TEXTPATH_METHODTYPE_ALIGN: 1;
    readonly TEXTPATH_METHODTYPE_STRETCH: 2;
    readonly TEXTPATH_SPACINGTYPE_UNKNOWN: 0;
    readonly TEXTPATH_SPACINGTYPE_AUTO: 1;
    readonly TEXTPATH_SPACINGTYPE_EXACT: 2;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGTextPathElement: {
    prototype: SVGTextPathElement;
    new(): SVGTextPathElement;
    readonly TEXTPATH_METHODTYPE_UNKNOWN: 0;
    readonly TEXTPATH_METHODTYPE_ALIGN: 1;
    readonly TEXTPATH_METHODTYPE_STRETCH: 2;
    readonly TEXTPATH_SPACINGTYPE_UNKNOWN: 0;
    readonly TEXTPATH_SPACINGTYPE_AUTO: 1;
    readonly TEXTPATH_SPACINGTYPE_EXACT: 2;
    isInstance: IsInstance<SVGTextPathElement>;
};

interface SVGTextPositioningElement extends SVGTextContentElement {
    readonly dx: SVGAnimatedLengthList;
    readonly dy: SVGAnimatedLengthList;
    readonly rotate: SVGAnimatedNumberList;
    readonly x: SVGAnimatedLengthList;
    readonly y: SVGAnimatedLengthList;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextPositioningElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextPositioningElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGTextPositioningElement: {
    prototype: SVGTextPositioningElement;
    new(): SVGTextPositioningElement;
    isInstance: IsInstance<SVGTextPositioningElement>;
};

interface SVGTitleElement extends SVGElement {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTitleElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTitleElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGTitleElement: {
    prototype: SVGTitleElement;
    new(): SVGTitleElement;
    isInstance: IsInstance<SVGTitleElement>;
};

interface SVGTransform {
    readonly angle: number;
    readonly matrix: SVGMatrix;
    readonly type: number;
    setMatrix(matrix?: DOMMatrix2DInit): void;
    setRotate(angle: number, cx: number, cy: number): void;
    setScale(sx: number, sy: number): void;
    setSkewX(angle: number): void;
    setSkewY(angle: number): void;
    setTranslate(tx: number, ty: number): void;
    readonly SVG_TRANSFORM_UNKNOWN: 0;
    readonly SVG_TRANSFORM_MATRIX: 1;
    readonly SVG_TRANSFORM_TRANSLATE: 2;
    readonly SVG_TRANSFORM_SCALE: 3;
    readonly SVG_TRANSFORM_ROTATE: 4;
    readonly SVG_TRANSFORM_SKEWX: 5;
    readonly SVG_TRANSFORM_SKEWY: 6;
}

declare var SVGTransform: {
    prototype: SVGTransform;
    new(): SVGTransform;
    readonly SVG_TRANSFORM_UNKNOWN: 0;
    readonly SVG_TRANSFORM_MATRIX: 1;
    readonly SVG_TRANSFORM_TRANSLATE: 2;
    readonly SVG_TRANSFORM_SCALE: 3;
    readonly SVG_TRANSFORM_ROTATE: 4;
    readonly SVG_TRANSFORM_SKEWX: 5;
    readonly SVG_TRANSFORM_SKEWY: 6;
    isInstance: IsInstance<SVGTransform>;
};

interface SVGTransformList {
    readonly length: number;
    readonly numberOfItems: number;
    appendItem(newItem: SVGTransform): SVGTransform;
    clear(): void;
    consolidate(): SVGTransform | null;
    createSVGTransformFromMatrix(matrix?: DOMMatrix2DInit): SVGTransform;
    getItem(index: number): SVGTransform;
    initialize(newItem: SVGTransform): SVGTransform;
    insertItemBefore(newItem: SVGTransform, index: number): SVGTransform;
    removeItem(index: number): SVGTransform;
    replaceItem(newItem: SVGTransform, index: number): SVGTransform;
    [index: number]: SVGTransform;
}

declare var SVGTransformList: {
    prototype: SVGTransformList;
    new(): SVGTransformList;
    isInstance: IsInstance<SVGTransformList>;
};

interface SVGURIReference {
    readonly href: SVGAnimatedString;
}

interface SVGUnitTypes {
    readonly SVG_UNIT_TYPE_UNKNOWN: 0;
    readonly SVG_UNIT_TYPE_USERSPACEONUSE: 1;
    readonly SVG_UNIT_TYPE_OBJECTBOUNDINGBOX: 2;
}

declare var SVGUnitTypes: {
    prototype: SVGUnitTypes;
    new(): SVGUnitTypes;
    readonly SVG_UNIT_TYPE_UNKNOWN: 0;
    readonly SVG_UNIT_TYPE_USERSPACEONUSE: 1;
    readonly SVG_UNIT_TYPE_OBJECTBOUNDINGBOX: 2;
    isInstance: IsInstance<SVGUnitTypes>;
};

interface SVGUseElement extends SVGGraphicsElement, SVGURIReference {
    readonly height: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGUseElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGUseElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGUseElement: {
    prototype: SVGUseElement;
    new(): SVGUseElement;
    isInstance: IsInstance<SVGUseElement>;
};

interface SVGViewElement extends SVGElement, SVGFitToViewBox, SVGZoomAndPan {
    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGViewElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGViewElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SVGViewElement: {
    prototype: SVGViewElement;
    new(): SVGViewElement;
    readonly SVG_ZOOMANDPAN_UNKNOWN: 0;
    readonly SVG_ZOOMANDPAN_DISABLE: 1;
    readonly SVG_ZOOMANDPAN_MAGNIFY: 2;
    isInstance: IsInstance<SVGViewElement>;
};

interface SVGZoomAndPan {
    zoomAndPan: number;
    readonly SVG_ZOOMANDPAN_UNKNOWN: 0;
    readonly SVG_ZOOMANDPAN_DISABLE: 1;
    readonly SVG_ZOOMANDPAN_MAGNIFY: 2;
}

interface Sanitizer {
    allowAttribute(attribute: SanitizerAttribute): void;
    allowElement(element: SanitizerElementWithAttributes): void;
    get(): SanitizerConfig;
    removeAttribute(attribute: SanitizerAttribute): void;
    removeElement(element: SanitizerElement): void;
    removeUnsafe(): void;
    replaceElementWithChildren(element: SanitizerElement): void;
    setComments(allow: boolean): void;
    setDataAttributes(allow: boolean): void;
}

declare var Sanitizer: {
    prototype: Sanitizer;
    new(configuration?: SanitizerConfig | SanitizerPresets): Sanitizer;
    isInstance: IsInstance<Sanitizer>;
};

interface Scheduler {
    postTask(callback: SchedulerPostTaskCallback, options?: SchedulerPostTaskOptions): Promise<any>;
    yield(): Promise<void>;
}

declare var Scheduler: {
    prototype: Scheduler;
    new(): Scheduler;
    isInstance: IsInstance<Scheduler>;
};

interface ScreenEventMap {
    "change": Event;
    "mozorientationchange": Event;
}

interface Screen extends EventTarget {
    readonly availHeight: number;
    readonly availLeft: number;
    readonly availTop: number;
    readonly availWidth: number;
    readonly colorDepth: number;
    readonly colorGamut: ScreenColorGamut;
    readonly height: number;
    readonly left: number;
    readonly luminance: ScreenLuminance | null;
    readonly mozOrientation: string;
    onchange: ((this: Screen, ev: Event) => any) | null;
    onmozorientationchange: ((this: Screen, ev: Event) => any) | null;
    readonly orientation: ScreenOrientation;
    readonly pixelDepth: number;
    readonly top: number;
    readonly width: number;
    mozLockOrientation(orientation: string): boolean;
    mozLockOrientation(orientation: string[]): boolean;
    mozUnlockOrientation(): void;
    addEventListener<K extends keyof ScreenEventMap>(type: K, listener: (this: Screen, ev: ScreenEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof ScreenEventMap>(type: K, listener: (this: Screen, ev: ScreenEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var Screen: {
    prototype: Screen;
    new(): Screen;
    isInstance: IsInstance<Screen>;
};

interface ScreenLuminance {
    readonly max: number;
    readonly maxAverage: number;
    readonly min: number;
}

declare var ScreenLuminance: {
    prototype: ScreenLuminance;
    new(): ScreenLuminance;
    isInstance: IsInstance<ScreenLuminance>;
};

interface ScreenOrientationEventMap {
    "change": Event;
}

interface ScreenOrientation extends EventTarget {
    readonly angle: number;
    onchange: ((this: ScreenOrientation, ev: Event) => any) | null;
    readonly type: OrientationType;
    lock(orientation: OrientationLockType): Promise<void>;
    unlock(): void;
    addEventListener<K extends keyof ScreenOrientationEventMap>(type: K, listener: (this: ScreenOrientation, ev: ScreenOrientationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof ScreenOrientationEventMap>(type: K, listener: (this: ScreenOrientation, ev: ScreenOrientationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var ScreenOrientation: {
    prototype: ScreenOrientation;
    new(): ScreenOrientation;
    isInstance: IsInstance<ScreenOrientation>;
};

interface ScriptProcessorNodeEventMap {
    "audioprocess": Event;
}

interface ScriptProcessorNode extends AudioNode, AudioNodePassThrough {
    readonly bufferSize: number;
    onaudioprocess: ((this: ScriptProcessorNode, ev: Event) => any) | null;
    addEventListener<K extends keyof ScriptProcessorNodeEventMap>(type: K, listener: (this: ScriptProcessorNode, ev: ScriptProcessorNodeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof ScriptProcessorNodeEventMap>(type: K, listener: (this: ScriptProcessorNode, ev: ScriptProcessorNodeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var ScriptProcessorNode: {
    prototype: ScriptProcessorNode;
    new(): ScriptProcessorNode;
    isInstance: IsInstance<ScriptProcessorNode>;
};

interface ScrollAreaEvent extends UIEvent {
    readonly height: number;
    readonly width: number;
    readonly x: number;
    readonly y: number;
    initScrollAreaEvent(type: string, canBubble?: boolean, cancelable?: boolean, view?: Window | null, detail?: number, x?: number, y?: number, width?: number, height?: number): void;
}

declare var ScrollAreaEvent: {
    prototype: ScrollAreaEvent;
    new(): ScrollAreaEvent;
    isInstance: IsInstance<ScrollAreaEvent>;
};

interface SecurityPolicyViolationEvent extends Event {
    readonly blockedURI: string;
    readonly columnNumber: number;
    readonly disposition: SecurityPolicyViolationEventDisposition;
    readonly documentURI: string;
    readonly effectiveDirective: string;
    readonly lineNumber: number;
    readonly originalPolicy: string;
    readonly referrer: string;
    readonly sample: string;
    readonly sourceFile: string;
    readonly statusCode: number;
    readonly violatedDirective: string;
}

declare var SecurityPolicyViolationEvent: {
    prototype: SecurityPolicyViolationEvent;
    new(type: string, eventInitDict?: SecurityPolicyViolationEventInit): SecurityPolicyViolationEvent;
    isInstance: IsInstance<SecurityPolicyViolationEvent>;
};

interface Selection {
    readonly anchorNode: Node | null;
    readonly anchorOffset: number;
    readonly areNormalAndCrossShadowBoundaryRangesCollapsed: boolean;
    caretBidiLevel: number | null;
    readonly direction: string;
    readonly focusNode: Node | null;
    readonly focusOffset: number;
    interlinePosition: boolean;
    readonly isCollapsed: boolean;
    readonly mayCrossShadowBoundaryFocusNode: Node | null;
    readonly rangeCount: number;
    readonly selectionType: number;
    readonly type: string;
    GetRangesForInterval(beginNode: Node, beginOffset: number, endNode: Node, endOffset: number, allowAdjacent: boolean): Range[];
    addRange(range: Range): void;
    addSelectionListener(newListener: nsISelectionListener): void;
    collapse(node: Node | null, offset?: number): void;
    collapseToEnd(): void;
    collapseToStart(): void;
    containsNode(node: Node, allowPartialContainment?: boolean): boolean;
    deleteFromDocument(): void;
    empty(): void;
    extend(node: Node, offset?: number): void;
    getComposedRanges(...shadowRoots: ShadowRoot[]): StaticRange[];
    getRangeAt(index: number): Range;
    modify(alter?: string, direction?: string, granularity?: string): void;
    removeAllRanges(): void;
    removeRange(range: Range): void;
    removeSelectionListener(listenerToRemove: nsISelectionListener): void;
    resetColors(): void;
    selectAllChildren(node: Node): void;
    setBaseAndExtent(anchorNode: Node, anchorOffset: number, focusNode: Node, focusOffset: number): void;
    setColors(aForegroundColor: string, aBackgroundColor: string, aAltForegroundColor: string, aAltBackgroundColor: string): void;
    setPosition(node: Node | null, offset?: number): void;
    toStringWithFormat(formatType: string, flags: number, wrapColumn: number): string;
    toString(): string;
}

declare var Selection: {
    prototype: Selection;
    new(): Selection;
    isInstance: IsInstance<Selection>;
};

interface ServiceWorkerEventMap extends AbstractWorkerEventMap {
    "statechange": Event;
}

interface ServiceWorker extends EventTarget, AbstractWorker {
    onstatechange: ((this: ServiceWorker, ev: Event) => any) | null;
    readonly scriptURL: string;
    readonly state: ServiceWorkerState;
    postMessage(message: any, transferable: any[]): void;
    postMessage(message: any, options?: StructuredSerializeOptions): void;
    addEventListener<K extends keyof ServiceWorkerEventMap>(type: K, listener: (this: ServiceWorker, ev: ServiceWorkerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof ServiceWorkerEventMap>(type: K, listener: (this: ServiceWorker, ev: ServiceWorkerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var ServiceWorker: {
    prototype: ServiceWorker;
    new(): ServiceWorker;
    isInstance: IsInstance<ServiceWorker>;
};

interface ServiceWorkerContainerEventMap {
    "controllerchange": Event;
    "message": Event;
    "messageerror": Event;
}

interface ServiceWorkerContainer extends EventTarget {
    readonly controller: ServiceWorker | null;
    oncontrollerchange: ((this: ServiceWorkerContainer, ev: Event) => any) | null;
    onmessage: ((this: ServiceWorkerContainer, ev: Event) => any) | null;
    onmessageerror: ((this: ServiceWorkerContainer, ev: Event) => any) | null;
    readonly ready: Promise<ServiceWorkerRegistration>;
    getRegistration(documentURL?: string | URL): Promise<ServiceWorkerRegistration | undefined>;
    getRegistrations(): Promise<ServiceWorkerRegistration[]>;
    register(scriptURL: TrustedScriptURL | string, options?: RegistrationOptions): Promise<ServiceWorkerRegistration>;
    startMessages(): void;
    addEventListener<K extends keyof ServiceWorkerContainerEventMap>(type: K, listener: (this: ServiceWorkerContainer, ev: ServiceWorkerContainerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof ServiceWorkerContainerEventMap>(type: K, listener: (this: ServiceWorkerContainer, ev: ServiceWorkerContainerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var ServiceWorkerContainer: {
    prototype: ServiceWorkerContainer;
    new(): ServiceWorkerContainer;
    isInstance: IsInstance<ServiceWorkerContainer>;
};

interface ServiceWorkerRegistrationEventMap {
    "updatefound": Event;
}

interface ServiceWorkerRegistration extends EventTarget {
    readonly active: ServiceWorker | null;
    readonly cookies: CookieStoreManager;
    readonly installing: ServiceWorker | null;
    readonly navigationPreload: NavigationPreloadManager;
    onupdatefound: ((this: ServiceWorkerRegistration, ev: Event) => any) | null;
    readonly pushManager: PushManager;
    readonly scope: string;
    readonly updateViaCache: ServiceWorkerUpdateViaCache;
    readonly waiting: ServiceWorker | null;
    getNotifications(filter?: GetNotificationOptions): Promise<Notification[]>;
    showNotification(title: string, options?: NotificationOptions): Promise<void>;
    unregister(): Promise<boolean>;
    update(): Promise<void>;
    addEventListener<K extends keyof ServiceWorkerRegistrationEventMap>(type: K, listener: (this: ServiceWorkerRegistration, ev: ServiceWorkerRegistrationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof ServiceWorkerRegistrationEventMap>(type: K, listener: (this: ServiceWorkerRegistration, ev: ServiceWorkerRegistrationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var ServiceWorkerRegistration: {
    prototype: ServiceWorkerRegistration;
    new(): ServiceWorkerRegistration;
    isInstance: IsInstance<ServiceWorkerRegistration>;
};

interface SessionStoreFormData {
    readonly children: (SessionStoreFormData | null)[] | null;
    readonly id: Record<string, FormDataValue> | null;
    readonly innerHTML: string | null;
    readonly url: string | null;
    readonly xpath: Record<string, FormDataValue> | null;
    toJSON(): any;
}

declare var SessionStoreFormData: {
    prototype: SessionStoreFormData;
    new(): SessionStoreFormData;
    isInstance: IsInstance<SessionStoreFormData>;
};

interface SessionStoreScrollData {
    readonly children: (SessionStoreScrollData | null)[] | null;
    readonly scroll: string | null;
    toJSON(): any;
}

declare var SessionStoreScrollData: {
    prototype: SessionStoreScrollData;
    new(): SessionStoreScrollData;
    isInstance: IsInstance<SessionStoreScrollData>;
};

interface ShadowRootEventMap {
    "slotchange": Event;
}

interface ShadowRoot extends DocumentFragment, DocumentOrShadowRoot {
    readonly clonable: boolean;
    readonly delegatesFocus: boolean;
    readonly host: Element;
    innerHTML: TrustedHTML | string;
    readonly mode: ShadowRootMode;
    onslotchange: ((this: ShadowRoot, ev: Event) => any) | null;
    readonly serializable: boolean;
    readonly slotAssignment: SlotAssignmentMode;
    createElementAndAppendChildAt(parentNode: Node, localName: string): Node;
    getElementById(elementId: string): Element | null;
    getHTML(options?: GetHTMLOptions): string;
    importNodeAndAppendChildAt(parentNode: Node, node: Node, deep?: boolean): Node;
    isUAWidget(): boolean;
    setHTML(aInnerHTML: string, options?: SetHTMLOptions): void;
    setHTMLUnsafe(html: TrustedHTML | string, options?: SetHTMLUnsafeOptions): void;
    setIsUAWidget(): void;
    addEventListener<K extends keyof ShadowRootEventMap>(type: K, listener: (this: ShadowRoot, ev: ShadowRootEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof ShadowRootEventMap>(type: K, listener: (this: ShadowRoot, ev: ShadowRootEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var ShadowRoot: {
    prototype: ShadowRoot;
    new(): ShadowRoot;
    isInstance: IsInstance<ShadowRoot>;
};

interface SharedWorker extends EventTarget, AbstractWorker {
    readonly port: MessagePort;
    addEventListener<K extends keyof AbstractWorkerEventMap>(type: K, listener: (this: SharedWorker, ev: AbstractWorkerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof AbstractWorkerEventMap>(type: K, listener: (this: SharedWorker, ev: AbstractWorkerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SharedWorker: {
    prototype: SharedWorker;
    new(scriptURL: TrustedScriptURL | string, options?: string | WorkerOptions): SharedWorker;
    isInstance: IsInstance<SharedWorker>;
};

interface SimpleGestureEvent extends MouseEvent {
    allowedDirections: number;
    readonly clickCount: number;
    readonly delta: number;
    readonly direction: number;
    initSimpleGestureEvent(typeArg: string, canBubbleArg?: boolean, cancelableArg?: boolean, viewArg?: Window | null, detailArg?: number, screenXArg?: number, screenYArg?: number, clientXArg?: number, clientYArg?: number, ctrlKeyArg?: boolean, altKeyArg?: boolean, shiftKeyArg?: boolean, metaKeyArg?: boolean, buttonArg?: number, relatedTargetArg?: EventTarget | null, allowedDirectionsArg?: number, directionArg?: number, deltaArg?: number, clickCount?: number): void;
    readonly DIRECTION_UP: 1;
    readonly DIRECTION_DOWN: 2;
    readonly DIRECTION_LEFT: 4;
    readonly DIRECTION_RIGHT: 8;
    readonly ROTATION_COUNTERCLOCKWISE: 1;
    readonly ROTATION_CLOCKWISE: 2;
}

declare var SimpleGestureEvent: {
    prototype: SimpleGestureEvent;
    new(): SimpleGestureEvent;
    readonly DIRECTION_UP: 1;
    readonly DIRECTION_DOWN: 2;
    readonly DIRECTION_LEFT: 4;
    readonly DIRECTION_RIGHT: 8;
    readonly ROTATION_COUNTERCLOCKWISE: 1;
    readonly ROTATION_CLOCKWISE: 2;
    isInstance: IsInstance<SimpleGestureEvent>;
};

interface SourceBufferEventMap {
    "abort": Event;
    "error": Event;
    "update": Event;
    "updateend": Event;
    "updatestart": Event;
}

interface SourceBuffer extends EventTarget {
    appendWindowEnd: number;
    appendWindowStart: number;
    readonly buffered: TimeRanges;
    mode: SourceBufferAppendMode;
    onabort: ((this: SourceBuffer, ev: Event) => any) | null;
    onerror: ((this: SourceBuffer, ev: Event) => any) | null;
    onupdate: ((this: SourceBuffer, ev: Event) => any) | null;
    onupdateend: ((this: SourceBuffer, ev: Event) => any) | null;
    onupdatestart: ((this: SourceBuffer, ev: Event) => any) | null;
    timestampOffset: number;
    readonly updating: boolean;
    abort(): void;
    appendBuffer(data: ArrayBuffer): void;
    appendBuffer(data: ArrayBufferView): void;
    appendBufferAsync(data: ArrayBuffer): Promise<void>;
    appendBufferAsync(data: ArrayBufferView): Promise<void>;
    changeType(type: string): void;
    remove(start: number, end: number): void;
    removeAsync(start: number, end: number): Promise<void>;
    addEventListener<K extends keyof SourceBufferEventMap>(type: K, listener: (this: SourceBuffer, ev: SourceBufferEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SourceBufferEventMap>(type: K, listener: (this: SourceBuffer, ev: SourceBufferEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SourceBuffer: {
    prototype: SourceBuffer;
    new(): SourceBuffer;
    isInstance: IsInstance<SourceBuffer>;
};

interface SourceBufferListEventMap {
    "addsourcebuffer": Event;
    "removesourcebuffer": Event;
}

interface SourceBufferList extends EventTarget {
    readonly length: number;
    onaddsourcebuffer: ((this: SourceBufferList, ev: Event) => any) | null;
    onremovesourcebuffer: ((this: SourceBufferList, ev: Event) => any) | null;
    addEventListener<K extends keyof SourceBufferListEventMap>(type: K, listener: (this: SourceBufferList, ev: SourceBufferListEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SourceBufferListEventMap>(type: K, listener: (this: SourceBufferList, ev: SourceBufferListEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    [index: number]: SourceBuffer;
}

declare var SourceBufferList: {
    prototype: SourceBufferList;
    new(): SourceBufferList;
    isInstance: IsInstance<SourceBufferList>;
};

interface SpeechGrammar {
    src: string;
    weight: number;
}

declare var SpeechGrammar: {
    prototype: SpeechGrammar;
    new(): SpeechGrammar;
    isInstance: IsInstance<SpeechGrammar>;
};

interface SpeechGrammarList {
    readonly length: number;
    addFromString(string: string, weight?: number): void;
    addFromURI(src: string, weight?: number): void;
    item(index: number): SpeechGrammar;
    [index: number]: SpeechGrammar;
}

declare var SpeechGrammarList: {
    prototype: SpeechGrammarList;
    new(): SpeechGrammarList;
    isInstance: IsInstance<SpeechGrammarList>;
};

interface SpeechRecognitionEventMap {
    "audioend": Event;
    "audiostart": Event;
    "end": Event;
    "error": Event;
    "nomatch": Event;
    "result": Event;
    "soundend": Event;
    "soundstart": Event;
    "speechend": Event;
    "speechstart": Event;
    "start": Event;
}

interface SpeechRecognition extends EventTarget {
    continuous: boolean;
    grammars: SpeechGrammarList;
    interimResults: boolean;
    lang: string;
    maxAlternatives: number;
    onaudioend: ((this: SpeechRecognition, ev: Event) => any) | null;
    onaudiostart: ((this: SpeechRecognition, ev: Event) => any) | null;
    onend: ((this: SpeechRecognition, ev: Event) => any) | null;
    onerror: ((this: SpeechRecognition, ev: Event) => any) | null;
    onnomatch: ((this: SpeechRecognition, ev: Event) => any) | null;
    onresult: ((this: SpeechRecognition, ev: Event) => any) | null;
    onsoundend: ((this: SpeechRecognition, ev: Event) => any) | null;
    onsoundstart: ((this: SpeechRecognition, ev: Event) => any) | null;
    onspeechend: ((this: SpeechRecognition, ev: Event) => any) | null;
    onspeechstart: ((this: SpeechRecognition, ev: Event) => any) | null;
    onstart: ((this: SpeechRecognition, ev: Event) => any) | null;
    serviceURI: string;
    abort(): void;
    start(stream?: MediaStream): void;
    stop(): void;
    addEventListener<K extends keyof SpeechRecognitionEventMap>(type: K, listener: (this: SpeechRecognition, ev: SpeechRecognitionEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SpeechRecognitionEventMap>(type: K, listener: (this: SpeechRecognition, ev: SpeechRecognitionEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SpeechRecognition: {
    prototype: SpeechRecognition;
    new(): SpeechRecognition;
    isInstance: IsInstance<SpeechRecognition>;
};

interface SpeechRecognitionAlternative {
    readonly confidence: number;
    readonly transcript: string;
}

declare var SpeechRecognitionAlternative: {
    prototype: SpeechRecognitionAlternative;
    new(): SpeechRecognitionAlternative;
    isInstance: IsInstance<SpeechRecognitionAlternative>;
};

interface SpeechRecognitionError extends Event {
    readonly error: SpeechRecognitionErrorCode;
    readonly message: string | null;
}

declare var SpeechRecognitionError: {
    prototype: SpeechRecognitionError;
    new(type: string, eventInitDict?: SpeechRecognitionErrorInit): SpeechRecognitionError;
    isInstance: IsInstance<SpeechRecognitionError>;
};

interface SpeechRecognitionEvent extends Event {
    readonly emma: Document | null;
    readonly interpretation: any;
    readonly resultIndex: number;
    readonly results: SpeechRecognitionResultList | null;
}

declare var SpeechRecognitionEvent: {
    prototype: SpeechRecognitionEvent;
    new(type: string, eventInitDict?: SpeechRecognitionEventInit): SpeechRecognitionEvent;
    isInstance: IsInstance<SpeechRecognitionEvent>;
};

interface SpeechRecognitionResult {
    readonly isFinal: boolean;
    readonly length: number;
    item(index: number): SpeechRecognitionAlternative;
    [index: number]: SpeechRecognitionAlternative;
}

declare var SpeechRecognitionResult: {
    prototype: SpeechRecognitionResult;
    new(): SpeechRecognitionResult;
    isInstance: IsInstance<SpeechRecognitionResult>;
};

interface SpeechRecognitionResultList {
    readonly length: number;
    item(index: number): SpeechRecognitionResult;
    [index: number]: SpeechRecognitionResult;
}

declare var SpeechRecognitionResultList: {
    prototype: SpeechRecognitionResultList;
    new(): SpeechRecognitionResultList;
    isInstance: IsInstance<SpeechRecognitionResultList>;
};

interface SpeechSynthesisEventMap {
    "voiceschanged": Event;
}

interface SpeechSynthesis extends EventTarget {
    onvoiceschanged: ((this: SpeechSynthesis, ev: Event) => any) | null;
    readonly paused: boolean;
    readonly pending: boolean;
    readonly speaking: boolean;
    cancel(): void;
    forceEnd(): void;
    getVoices(): SpeechSynthesisVoice[];
    pause(): void;
    resume(): void;
    speak(utterance: SpeechSynthesisUtterance): void;
    addEventListener<K extends keyof SpeechSynthesisEventMap>(type: K, listener: (this: SpeechSynthesis, ev: SpeechSynthesisEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SpeechSynthesisEventMap>(type: K, listener: (this: SpeechSynthesis, ev: SpeechSynthesisEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SpeechSynthesis: {
    prototype: SpeechSynthesis;
    new(): SpeechSynthesis;
    isInstance: IsInstance<SpeechSynthesis>;
};

interface SpeechSynthesisErrorEvent extends SpeechSynthesisEvent {
    readonly error: SpeechSynthesisErrorCode;
}

declare var SpeechSynthesisErrorEvent: {
    prototype: SpeechSynthesisErrorEvent;
    new(type: string, eventInitDict: SpeechSynthesisErrorEventInit): SpeechSynthesisErrorEvent;
    isInstance: IsInstance<SpeechSynthesisErrorEvent>;
};

interface SpeechSynthesisEvent extends Event {
    readonly charIndex: number;
    readonly charLength: number | null;
    readonly elapsedTime: number;
    readonly name: string | null;
    readonly utterance: SpeechSynthesisUtterance;
}

declare var SpeechSynthesisEvent: {
    prototype: SpeechSynthesisEvent;
    new(type: string, eventInitDict: SpeechSynthesisEventInit): SpeechSynthesisEvent;
    isInstance: IsInstance<SpeechSynthesisEvent>;
};

interface SpeechSynthesisGetter {
    readonly speechSynthesis: SpeechSynthesis;
}

interface SpeechSynthesisUtteranceEventMap {
    "boundary": Event;
    "end": Event;
    "error": Event;
    "mark": Event;
    "pause": Event;
    "resume": Event;
    "start": Event;
}

interface SpeechSynthesisUtterance extends EventTarget {
    readonly chosenVoiceURI: string;
    lang: string;
    onboundary: ((this: SpeechSynthesisUtterance, ev: Event) => any) | null;
    onend: ((this: SpeechSynthesisUtterance, ev: Event) => any) | null;
    onerror: ((this: SpeechSynthesisUtterance, ev: Event) => any) | null;
    onmark: ((this: SpeechSynthesisUtterance, ev: Event) => any) | null;
    onpause: ((this: SpeechSynthesisUtterance, ev: Event) => any) | null;
    onresume: ((this: SpeechSynthesisUtterance, ev: Event) => any) | null;
    onstart: ((this: SpeechSynthesisUtterance, ev: Event) => any) | null;
    pitch: number;
    rate: number;
    text: string;
    voice: SpeechSynthesisVoice | null;
    volume: number;
    addEventListener<K extends keyof SpeechSynthesisUtteranceEventMap>(type: K, listener: (this: SpeechSynthesisUtterance, ev: SpeechSynthesisUtteranceEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof SpeechSynthesisUtteranceEventMap>(type: K, listener: (this: SpeechSynthesisUtterance, ev: SpeechSynthesisUtteranceEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var SpeechSynthesisUtterance: {
    prototype: SpeechSynthesisUtterance;
    new(): SpeechSynthesisUtterance;
    new(text: string): SpeechSynthesisUtterance;
    isInstance: IsInstance<SpeechSynthesisUtterance>;
};

interface SpeechSynthesisVoice {
    readonly default: boolean;
    readonly lang: string;
    readonly localService: boolean;
    readonly name: string;
    readonly voiceURI: string;
}

declare var SpeechSynthesisVoice: {
    prototype: SpeechSynthesisVoice;
    new(): SpeechSynthesisVoice;
    isInstance: IsInstance<SpeechSynthesisVoice>;
};

interface StaticRange extends AbstractRange {
}

declare var StaticRange: {
    prototype: StaticRange;
    new(init: StaticRangeInit): StaticRange;
    isInstance: IsInstance<StaticRange>;
};

interface StereoPannerNode extends AudioNode, AudioNodePassThrough {
    readonly pan: AudioParam;
}

declare var StereoPannerNode: {
    prototype: StereoPannerNode;
    new(context: BaseAudioContext, options?: StereoPannerOptions): StereoPannerNode;
    isInstance: IsInstance<StereoPannerNode>;
};

interface Storage {
    readonly hasSnapshot: boolean;
    readonly length: number;
    readonly snapshotUsage: number;
    beginExplicitSnapshot(): void;
    checkpointExplicitSnapshot(): void;
    clear(): void;
    close(): void;
    endExplicitSnapshot(): void;
    getItem(key: string): string | null;
    key(index: number): string | null;
    open(): void;
    removeItem(key: string): void;
    setItem(key: string, value: string): void;
}

declare var Storage: {
    prototype: Storage;
    new(): Storage;
    isInstance: IsInstance<Storage>;
};

interface StorageEvent extends Event {
    readonly key: string | null;
    readonly newValue: string | null;
    readonly oldValue: string | null;
    readonly storageArea: Storage | null;
    readonly url: string;
    initStorageEvent(type: string, canBubble?: boolean, cancelable?: boolean, key?: string | null, oldValue?: string | null, newValue?: string | null, url?: string | URL, storageArea?: Storage | null): void;
}

declare var StorageEvent: {
    prototype: StorageEvent;
    new(type: string, eventInitDict?: StorageEventInit): StorageEvent;
    isInstance: IsInstance<StorageEvent>;
};

/** Available only in secure contexts. */
interface StorageManager {
    estimate(): Promise<StorageEstimate>;
    getDirectory(): Promise<FileSystemDirectoryHandle>;
    persist(): Promise<boolean>;
    persisted(): Promise<boolean>;
    shutdown(): void;
}

declare var StorageManager: {
    prototype: StorageManager;
    new(): StorageManager;
    isInstance: IsInstance<StorageManager>;
};

interface StreamFilterEventMap {
    "data": Event;
    "error": Event;
    "start": Event;
    "stop": Event;
}

interface StreamFilter extends EventTarget {
    readonly error: string;
    ondata: ((this: StreamFilter, ev: Event) => any) | null;
    onerror: ((this: StreamFilter, ev: Event) => any) | null;
    onstart: ((this: StreamFilter, ev: Event) => any) | null;
    onstop: ((this: StreamFilter, ev: Event) => any) | null;
    readonly status: StreamFilterStatus;
    close(): void;
    disconnect(): void;
    resume(): void;
    suspend(): void;
    write(data: ArrayBuffer | Uint8Array): void;
    addEventListener<K extends keyof StreamFilterEventMap>(type: K, listener: (this: StreamFilter, ev: StreamFilterEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof StreamFilterEventMap>(type: K, listener: (this: StreamFilter, ev: StreamFilterEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var StreamFilter: {
    prototype: StreamFilter;
    new(): StreamFilter;
    isInstance: IsInstance<StreamFilter>;
    create(requestId: number, addonId: string): StreamFilter;
};

interface StreamFilterDataEvent extends Event {
    readonly data: ArrayBuffer;
}

declare var StreamFilterDataEvent: {
    prototype: StreamFilterDataEvent;
    new(type: string, eventInitDict?: StreamFilterDataEventInit): StreamFilterDataEvent;
    isInstance: IsInstance<StreamFilterDataEvent>;
};

interface StructuredCloneHolder {
    readonly dataSize: number;
    deserialize(global: any, keepData?: boolean): any;
}

declare var StructuredCloneHolder: {
    prototype: StructuredCloneHolder;
    new(name: string, anonymizedName: string | null, data: any, global?: any): StructuredCloneHolder;
    isInstance: IsInstance<StructuredCloneHolder>;
};

interface StructuredCloneTester {
    readonly deserializable: boolean;
    readonly serializable: boolean;
}

declare var StructuredCloneTester: {
    prototype: StructuredCloneTester;
    new(serializable: boolean, deserializable: boolean): StructuredCloneTester;
    isInstance: IsInstance<StructuredCloneTester>;
};

interface StyleSheet {
    readonly associatedDocument: Document | null;
    readonly constructed: boolean;
    disabled: boolean;
    readonly href: string | null;
    readonly media: MediaList;
    readonly ownerNode: Node | null;
    readonly parentStyleSheet: StyleSheet | null;
    readonly sourceMapURL: string;
    readonly sourceURL: string;
    readonly title: string | null;
    readonly type: string;
}

declare var StyleSheet: {
    prototype: StyleSheet;
    new(): StyleSheet;
    isInstance: IsInstance<StyleSheet>;
};

interface StyleSheetApplicableStateChangeEvent extends Event {
    readonly applicable: boolean;
    readonly stylesheet: CSSStyleSheet | null;
}

declare var StyleSheetApplicableStateChangeEvent: {
    prototype: StyleSheetApplicableStateChangeEvent;
    new(type: string, eventInitDict?: StyleSheetApplicableStateChangeEventInit): StyleSheetApplicableStateChangeEvent;
    isInstance: IsInstance<StyleSheetApplicableStateChangeEvent>;
};

interface StyleSheetList {
    readonly length: number;
    item(index: number): CSSStyleSheet | null;
    [index: number]: CSSStyleSheet;
}

declare var StyleSheetList: {
    prototype: StyleSheetList;
    new(): StyleSheetList;
    isInstance: IsInstance<StyleSheetList>;
};

interface StyleSheetRemovedEvent extends Event {
    readonly stylesheet: CSSStyleSheet | null;
}

declare var StyleSheetRemovedEvent: {
    prototype: StyleSheetRemovedEvent;
    new(type: string, eventInitDict?: StyleSheetRemovedEventInit): StyleSheetRemovedEvent;
    isInstance: IsInstance<StyleSheetRemovedEvent>;
};

interface SubmitEvent extends Event {
    readonly submitter: HTMLElement | null;
}

declare var SubmitEvent: {
    prototype: SubmitEvent;
    new(type: string, eventInitDict?: SubmitEventInit): SubmitEvent;
    isInstance: IsInstance<SubmitEvent>;
};

/** Available only in secure contexts. */
interface SubtleCrypto {
    decrypt(algorithm: AlgorithmIdentifier, key: CryptoKey, data: BufferSource): Promise<any>;
    deriveBits(algorithm: AlgorithmIdentifier, baseKey: CryptoKey, length?: number | null): Promise<any>;
    deriveKey(algorithm: AlgorithmIdentifier, baseKey: CryptoKey, derivedKeyType: AlgorithmIdentifier, extractable: boolean, keyUsages: KeyUsage[]): Promise<any>;
    digest(algorithm: AlgorithmIdentifier, data: BufferSource): Promise<any>;
    encrypt(algorithm: AlgorithmIdentifier, key: CryptoKey, data: BufferSource): Promise<any>;
    exportKey(format: KeyFormat, key: CryptoKey): Promise<any>;
    generateKey(algorithm: AlgorithmIdentifier, extractable: boolean, keyUsages: KeyUsage[]): Promise<any>;
    importKey(format: KeyFormat, keyData: any, algorithm: AlgorithmIdentifier, extractable: boolean, keyUsages: KeyUsage[]): Promise<any>;
    sign(algorithm: AlgorithmIdentifier, key: CryptoKey, data: BufferSource): Promise<any>;
    unwrapKey(format: KeyFormat, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier, unwrappedKeyAlgorithm: AlgorithmIdentifier, extractable: boolean, keyUsages: KeyUsage[]): Promise<any>;
    verify(algorithm: AlgorithmIdentifier, key: CryptoKey, signature: BufferSource, data: BufferSource): Promise<any>;
    wrapKey(format: KeyFormat, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: AlgorithmIdentifier): Promise<any>;
}

declare var SubtleCrypto: {
    prototype: SubtleCrypto;
    new(): SubtleCrypto;
    isInstance: IsInstance<SubtleCrypto>;
};

interface SyncMessageSender extends MessageSender, SyncMessageSenderMixin {
}

declare var SyncMessageSender: {
    prototype: SyncMessageSender;
    new(): SyncMessageSender;
    isInstance: IsInstance<SyncMessageSender>;
};

interface SyncMessageSenderMixin {
    sendSyncMessage(messageName?: string | null, obj?: any): any[];
}

interface TCPServerSocketEventMap {
    "connect": Event;
    "error": Event;
}

interface TCPServerSocket extends EventTarget {
    readonly localPort: number;
    onconnect: ((this: TCPServerSocket, ev: Event) => any) | null;
    onerror: ((this: TCPServerSocket, ev: Event) => any) | null;
    close(): void;
    addEventListener<K extends keyof TCPServerSocketEventMap>(type: K, listener: (this: TCPServerSocket, ev: TCPServerSocketEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof TCPServerSocketEventMap>(type: K, listener: (this: TCPServerSocket, ev: TCPServerSocketEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var TCPServerSocket: {
    prototype: TCPServerSocket;
    new(port: number, options?: ServerSocketOptions, backlog?: number): TCPServerSocket;
    isInstance: IsInstance<TCPServerSocket>;
};

interface TCPServerSocketEvent extends Event {
    readonly socket: TCPSocket;
}

declare var TCPServerSocketEvent: {
    prototype: TCPServerSocketEvent;
    new(type: string, eventInitDict?: TCPServerSocketEventInit): TCPServerSocketEvent;
    isInstance: IsInstance<TCPServerSocketEvent>;
};

interface TCPSocketEventMap {
    "close": Event;
    "data": Event;
    "drain": Event;
    "error": Event;
    "open": Event;
}

interface TCPSocket extends EventTarget {
    readonly binaryType: TCPSocketBinaryType;
    readonly bufferedAmount: number;
    readonly host: string;
    onclose: ((this: TCPSocket, ev: Event) => any) | null;
    ondata: ((this: TCPSocket, ev: Event) => any) | null;
    ondrain: ((this: TCPSocket, ev: Event) => any) | null;
    onerror: ((this: TCPSocket, ev: Event) => any) | null;
    onopen: ((this: TCPSocket, ev: Event) => any) | null;
    readonly port: number;
    readonly readyState: TCPReadyState;
    readonly ssl: boolean;
    readonly transport: nsISocketTransport | null;
    close(): void;
    closeImmediately(): void;
    resume(): void;
    send(data: string): boolean;
    send(data: ArrayBuffer, byteOffset?: number, byteLength?: number): boolean;
    suspend(): void;
    upgradeToSecure(): void;
    addEventListener<K extends keyof TCPSocketEventMap>(type: K, listener: (this: TCPSocket, ev: TCPSocketEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof TCPSocketEventMap>(type: K, listener: (this: TCPSocket, ev: TCPSocketEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var TCPSocket: {
    prototype: TCPSocket;
    new(host: string, port: number, options?: SocketOptions): TCPSocket;
    isInstance: IsInstance<TCPSocket>;
};

interface TCPSocketErrorEvent extends Event {
    readonly errorCode: number;
    readonly message: string;
    readonly name: string;
}

declare var TCPSocketErrorEvent: {
    prototype: TCPSocketErrorEvent;
    new(type: string, eventInitDict?: TCPSocketErrorEventInit): TCPSocketErrorEvent;
    isInstance: IsInstance<TCPSocketErrorEvent>;
};

interface TCPSocketEvent extends Event {
    readonly data: any;
}

declare var TCPSocketEvent: {
    prototype: TCPSocketEvent;
    new(type: string, eventInitDict?: TCPSocketEventInit): TCPSocketEvent;
    isInstance: IsInstance<TCPSocketEvent>;
};

interface TaskController extends AbortController {
    setPriority(priority: TaskPriority): void;
}

declare var TaskController: {
    prototype: TaskController;
    new(init?: TaskControllerInit): TaskController;
    isInstance: IsInstance<TaskController>;
};

interface TaskPriorityChangeEvent extends Event {
    readonly previousPriority: TaskPriority;
}

declare var TaskPriorityChangeEvent: {
    prototype: TaskPriorityChangeEvent;
    new(type: string, priorityChangeEventInitDict: TaskPriorityChangeEventInit): TaskPriorityChangeEvent;
    isInstance: IsInstance<TaskPriorityChangeEvent>;
};

interface TaskSignalEventMap extends AbortSignalEventMap {
    "prioritychange": Event;
}

interface TaskSignal extends AbortSignal {
    onprioritychange: ((this: TaskSignal, ev: Event) => any) | null;
    readonly priority: TaskPriority;
    addEventListener<K extends keyof TaskSignalEventMap>(type: K, listener: (this: TaskSignal, ev: TaskSignalEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof TaskSignalEventMap>(type: K, listener: (this: TaskSignal, ev: TaskSignalEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var TaskSignal: {
    prototype: TaskSignal;
    new(): TaskSignal;
    isInstance: IsInstance<TaskSignal>;
    any(signals: AbortSignal[], init?: TaskSignalAnyInit): TaskSignal;
};

interface TestFunctions {
    allowSharedArrayBuffer: ArrayBuffer;
    allowSharedArrayBufferView: ArrayBufferView;
    arrayBuffer: ArrayBuffer;
    arrayBufferView: ArrayBufferView;
    clampedNullableOctet: number | null;
    enforcedNullableOctet: number | null;
    readonly one: number;
    sequenceOfAllowSharedArrayBuffer: ArrayBuffer[];
    sequenceOfAllowSharedArrayBufferView: ArrayBufferView[];
    sequenceOfArrayBuffer: ArrayBuffer[];
    sequenceOfArrayBufferView: ArrayBufferView[];
    readonly two: number;
    readonly wrapperCachedNonISupportsObject: WrapperCachedNonISupportsTestInterface;
    getLongLiteralString(): string;
    getMediumLiteralString(): string;
    getShortLiteralString(): string;
    getStringDataAsAString(): string;
    getStringDataAsAString(length: number): string;
    getStringDataAsDOMString(length?: number): string;
    getStringType(str: string): StringType;
    getStringbufferString(input: string): string;
    setStringData(arg: string): void;
    staticAndNonStaticOverload(): boolean;
    staticAndNonStaticOverload(foo?: number): boolean;
    stringbufferMatchesStored(str: string): boolean;
    testAllowShared(buffer: ArrayBufferView): void;
    testAllowShared(buffer: ArrayBuffer): void;
    testDictWithAllowShared(buffer?: DictWithAllowSharedBufferSource): void;
    testNotAllowShared(buffer: ArrayBufferView): void;
    testNotAllowShared(buffer: ArrayBuffer): void;
    testNotAllowShared(buffer: string): void;
    testThrowNsresult(): void;
    testThrowNsresultFromNative(): void;
    testUnionOfAllowSharedBufferSource(foo: AllowSharedBufferSource): void;
    testUnionOfBufferSource(foo: ArrayBuffer | ArrayBufferView | string): void;
    testUnionWithAllowShared(foo: Int8Array | Int16Array): void;
    toJSON(): any;
}

declare var TestFunctions: {
    prototype: TestFunctions;
    new(): TestFunctions;
    isInstance: IsInstance<TestFunctions>;
    passThroughCallbackPromise(callback: PromiseReturner): Promise<any>;
    passThroughPromise(arg: any): Promise<any>;
    throwToRejectPromise(): Promise<any>;
    throwUncatchableException(): void;
};

interface TestInterfaceAsyncIterableDouble {
}

declare var TestInterfaceAsyncIterableDouble: {
    prototype: TestInterfaceAsyncIterableDouble;
    new(): TestInterfaceAsyncIterableDouble;
    isInstance: IsInstance<TestInterfaceAsyncIterableDouble>;
};

interface TestInterfaceAsyncIterableDoubleUnion {
}

declare var TestInterfaceAsyncIterableDoubleUnion: {
    prototype: TestInterfaceAsyncIterableDoubleUnion;
    new(): TestInterfaceAsyncIterableDoubleUnion;
    isInstance: IsInstance<TestInterfaceAsyncIterableDoubleUnion>;
};

interface TestInterfaceAsyncIterableSingle {
}

declare var TestInterfaceAsyncIterableSingle: {
    prototype: TestInterfaceAsyncIterableSingle;
    new(options?: TestInterfaceAsyncIterableSingleOptions): TestInterfaceAsyncIterableSingle;
    isInstance: IsInstance<TestInterfaceAsyncIterableSingle>;
};

interface TestInterfaceAsyncIterableSingleWithArgs {
    readonly returnCallCount: number;
    readonly returnLastCalledWith: any;
}

declare var TestInterfaceAsyncIterableSingleWithArgs: {
    prototype: TestInterfaceAsyncIterableSingleWithArgs;
    new(): TestInterfaceAsyncIterableSingleWithArgs;
    isInstance: IsInstance<TestInterfaceAsyncIterableSingleWithArgs>;
};

interface TestInterfaceIterableDouble {
    forEach(callbackfn: (value: string, key: string, parent: TestInterfaceIterableDouble) => void, thisArg?: any): void;
}

declare var TestInterfaceIterableDouble: {
    prototype: TestInterfaceIterableDouble;
    new(): TestInterfaceIterableDouble;
    isInstance: IsInstance<TestInterfaceIterableDouble>;
};

interface TestInterfaceIterableDoubleUnion {
    forEach(callbackfn: (value: string | number, key: string, parent: TestInterfaceIterableDoubleUnion) => void, thisArg?: any): void;
}

declare var TestInterfaceIterableDoubleUnion: {
    prototype: TestInterfaceIterableDoubleUnion;
    new(): TestInterfaceIterableDoubleUnion;
    isInstance: IsInstance<TestInterfaceIterableDoubleUnion>;
};

interface TestInterfaceIterableSingle {
    readonly length: number;
    forEach(callbackfn: (value: number, key: number, parent: TestInterfaceIterableSingle) => void, thisArg?: any): void;
    [index: number]: number;
}

declare var TestInterfaceIterableSingle: {
    prototype: TestInterfaceIterableSingle;
    new(): TestInterfaceIterableSingle;
    isInstance: IsInstance<TestInterfaceIterableSingle>;
};

interface TestInterfaceJSEventMap {
    "something": Event;
}

interface TestInterfaceJS extends EventTarget {
    readonly anyArg: any;
    anyAttr: any;
    readonly objectArg: any;
    objectAttr: any;
    onsomething: ((this: TestInterfaceJS, ev: Event) => any) | null;
    anySequenceLength(seq: any[]): number;
    convertSVS(svs: string): string;
    getCallerPrincipal(): string;
    getDictionaryArg(): TestInterfaceJSDictionary;
    getDictionaryAttr(): TestInterfaceJSDictionary;
    objectSequenceLength(seq: any[]): number;
    pingPongAny(arg: any): any;
    pingPongDictionary(dict?: TestInterfaceJSDictionary): TestInterfaceJSDictionary;
    pingPongDictionaryOrLong(dictOrLong?: TestInterfaceJSUnionableDictionary | number): number;
    pingPongNullableUnion(something: TestInterfaceJS | number | null): TestInterfaceJS | number | null;
    pingPongObject(obj: any): any;
    pingPongObjectOrString(objOrString: any): any;
    pingPongRecord(rec: Record<string, any>): string;
    pingPongUnion(something: TestInterfaceJS | number): TestInterfaceJS | number;
    pingPongUnionContainingNull(something: TestInterfaceJS | string): string | TestInterfaceJS;
    returnBadUnion(): Location | TestInterfaceJS;
    setDictionaryAttr(dict?: TestInterfaceJSDictionary): void;
    testPromiseWithDOMExceptionThrowingPromiseInit(): Promise<void>;
    testPromiseWithDOMExceptionThrowingThenFunction(): Promise<void>;
    testPromiseWithDOMExceptionThrowingThenable(): Promise<void>;
    testPromiseWithThrowingChromePromiseInit(): Promise<void>;
    testPromiseWithThrowingChromeThenFunction(): Promise<void>;
    testPromiseWithThrowingChromeThenable(): Promise<void>;
    testPromiseWithThrowingContentPromiseInit(func: Function): Promise<void>;
    testPromiseWithThrowingContentThenFunction(func: AnyCallback): Promise<void>;
    testPromiseWithThrowingContentThenable(thenable: any): Promise<void>;
    testSequenceOverload(arg: string[]): void;
    testSequenceOverload(arg: string): void;
    testSequenceUnion(arg: string[] | string): void;
    testThrowCallbackError(callback: Function): void;
    testThrowDOMException(): void;
    testThrowError(): void;
    testThrowSelfHosted(): void;
    testThrowTypeError(): void;
    testThrowXraySelfHosted(): void;
    addEventListener<K extends keyof TestInterfaceJSEventMap>(type: K, listener: (this: TestInterfaceJS, ev: TestInterfaceJSEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof TestInterfaceJSEventMap>(type: K, listener: (this: TestInterfaceJS, ev: TestInterfaceJSEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var TestInterfaceJS: {
    prototype: TestInterfaceJS;
    new(anyArg?: any, objectArg?: any, dictionaryArg?: TestInterfaceJSDictionary): TestInterfaceJS;
    isInstance: IsInstance<TestInterfaceJS>;
};

interface TestInterfaceLength {
}

declare var TestInterfaceLength: {
    prototype: TestInterfaceLength;
    new(arg: boolean): TestInterfaceLength;
    isInstance: IsInstance<TestInterfaceLength>;
};

interface TestInterfaceMaplike {
    clearInternal(): void;
    deleteInternal(aKey: string): boolean;
    getInternal(aKey: string): number;
    hasInternal(aKey: string): boolean;
    setInternal(aKey: string, aValue: number): void;
    forEach(callbackfn: (value: number, key: string, parent: TestInterfaceMaplike) => void, thisArg?: any): void;
}

declare var TestInterfaceMaplike: {
    prototype: TestInterfaceMaplike;
    new(): TestInterfaceMaplike;
    isInstance: IsInstance<TestInterfaceMaplike>;
};

interface TestInterfaceMaplikeJSObject {
    clearInternal(): void;
    deleteInternal(aKey: string): boolean;
    getInternal(aKey: string): any;
    hasInternal(aKey: string): boolean;
    setInternal(aKey: string, aObject: any): void;
    forEach(callbackfn: (value: any, key: string, parent: TestInterfaceMaplikeJSObject) => void, thisArg?: any): void;
}

declare var TestInterfaceMaplikeJSObject: {
    prototype: TestInterfaceMaplikeJSObject;
    new(): TestInterfaceMaplikeJSObject;
    isInstance: IsInstance<TestInterfaceMaplikeJSObject>;
};

interface TestInterfaceMaplikeObject {
    clearInternal(): void;
    deleteInternal(aKey: string): boolean;
    getInternal(aKey: string): TestInterfaceMaplike | null;
    hasInternal(aKey: string): boolean;
    setInternal(aKey: string): void;
    forEach(callbackfn: (value: TestInterfaceMaplike, key: string, parent: TestInterfaceMaplikeObject) => void, thisArg?: any): void;
}

declare var TestInterfaceMaplikeObject: {
    prototype: TestInterfaceMaplikeObject;
    new(): TestInterfaceMaplikeObject;
    isInstance: IsInstance<TestInterfaceMaplikeObject>;
};

interface TestInterfaceObservableArray {
    observableArrayBoolean: boolean[];
    observableArrayInterface: TestInterfaceObservableArray[];
    observableArrayObject: any[];
    booleanAppendElementInternal(value: boolean): void;
    booleanElementAtInternal(index: number): boolean;
    booleanLengthInternal(): number;
    booleanRemoveLastElementInternal(): void;
    booleanReplaceElementAtInternal(index: number, value: boolean): void;
    interfaceAppendElementInternal(value: TestInterfaceObservableArray): void;
    interfaceElementAtInternal(index: number): TestInterfaceObservableArray;
    interfaceLengthInternal(): number;
    interfaceRemoveLastElementInternal(): void;
    interfaceReplaceElementAtInternal(index: number, value: TestInterfaceObservableArray): void;
    objectAppendElementInternal(value: any): void;
    objectElementAtInternal(index: number): any;
    objectLengthInternal(): number;
    objectRemoveLastElementInternal(): void;
    objectReplaceElementAtInternal(index: number, value: any): void;
}

declare var TestInterfaceObservableArray: {
    prototype: TestInterfaceObservableArray;
    new(callbacks?: ObservableArrayCallbacks): TestInterfaceObservableArray;
    isInstance: IsInstance<TestInterfaceObservableArray>;
};

interface TestInterfaceSetlike {
    forEach(callbackfn: (value: string, key: string, parent: TestInterfaceSetlike) => void, thisArg?: any): void;
}

declare var TestInterfaceSetlike: {
    prototype: TestInterfaceSetlike;
    new(): TestInterfaceSetlike;
    isInstance: IsInstance<TestInterfaceSetlike>;
};

interface TestInterfaceSetlikeNode {
    forEach(callbackfn: (value: Node, key: Node, parent: TestInterfaceSetlikeNode) => void, thisArg?: any): void;
}

declare var TestInterfaceSetlikeNode: {
    prototype: TestInterfaceSetlikeNode;
    new(): TestInterfaceSetlikeNode;
    isInstance: IsInstance<TestInterfaceSetlikeNode>;
};

interface TestReflectedHTMLAttribute {
    reflectedHTMLAttribute: Element[] | null;
    setReflectedHTMLAttributeValue(seq: Element[]): void;
}

declare var TestReflectedHTMLAttribute: {
    prototype: TestReflectedHTMLAttribute;
    new(): TestReflectedHTMLAttribute;
    isInstance: IsInstance<TestReflectedHTMLAttribute>;
};

interface TestTrialInterface {
}

declare var TestTrialInterface: {
    prototype: TestTrialInterface;
    new(): TestTrialInterface;
    isInstance: IsInstance<TestTrialInterface>;
};

interface TestingDeprecatedInterface {
    readonly deprecatedAttribute: boolean;
    deprecatedMethod(): void;
}

declare var TestingDeprecatedInterface: {
    prototype: TestingDeprecatedInterface;
    new(): TestingDeprecatedInterface;
    isInstance: IsInstance<TestingDeprecatedInterface>;
};

interface Text extends CharacterData, GeometryUtils {
    readonly assignedSlot: HTMLSlotElement | null;
    readonly openOrClosedAssignedSlot: HTMLSlotElement | null;
    readonly wholeText: string;
    splitText(offset: number): Text;
}

declare var Text: {
    prototype: Text;
    new(data?: string): Text;
    isInstance: IsInstance<Text>;
};

interface TextClause {
    readonly endOffset: number;
    readonly isCaret: boolean;
    readonly isTargetClause: boolean;
    readonly startOffset: number;
}

declare var TextClause: {
    prototype: TextClause;
    new(): TextClause;
    isInstance: IsInstance<TextClause>;
};

interface TextDecoder extends TextDecoderCommon {
    decode(input?: BufferSource, options?: TextDecodeOptions): string;
}

declare var TextDecoder: {
    prototype: TextDecoder;
    new(label?: string, options?: TextDecoderOptions): TextDecoder;
    isInstance: IsInstance<TextDecoder>;
};

interface TextDecoderCommon {
    readonly encoding: string;
    readonly fatal: boolean;
    readonly ignoreBOM: boolean;
}

interface TextDecoderStream extends GenericTransformStream, TextDecoderCommon {
}

declare var TextDecoderStream: {
    prototype: TextDecoderStream;
    new(label?: string, options?: TextDecoderOptions): TextDecoderStream;
    isInstance: IsInstance<TextDecoderStream>;
};

interface TextEncoder extends TextEncoderCommon {
    encode(input?: string): Uint8Array;
    encodeInto(source: JSString, destination: Uint8Array): TextEncoderEncodeIntoResult;
}

declare var TextEncoder: {
    prototype: TextEncoder;
    new(): TextEncoder;
    isInstance: IsInstance<TextEncoder>;
};

interface TextEncoderCommon {
    readonly encoding: string;
}

interface TextEncoderStream extends GenericTransformStream, TextEncoderCommon {
}

declare var TextEncoderStream: {
    prototype: TextEncoderStream;
    new(): TextEncoderStream;
    isInstance: IsInstance<TextEncoderStream>;
};

interface TextEvent extends UIEvent {
    readonly data: string;
    initTextEvent(type: string, bubbles?: boolean, cancelable?: boolean, view?: Window | null, data?: string): void;
}

declare var TextEvent: {
    prototype: TextEvent;
    new(): TextEvent;
    isInstance: IsInstance<TextEvent>;
};

interface TextMetrics {
    readonly actualBoundingBoxAscent: number;
    readonly actualBoundingBoxDescent: number;
    readonly actualBoundingBoxLeft: number;
    readonly actualBoundingBoxRight: number;
    readonly alphabeticBaseline: number;
    readonly emHeightAscent: number;
    readonly emHeightDescent: number;
    readonly fontBoundingBoxAscent: number;
    readonly fontBoundingBoxDescent: number;
    readonly hangingBaseline: number;
    readonly ideographicBaseline: number;
    readonly width: number;
}

declare var TextMetrics: {
    prototype: TextMetrics;
    new(): TextMetrics;
    isInstance: IsInstance<TextMetrics>;
};

interface TextTrackEventMap {
    "cuechange": Event;
}

interface TextTrack extends EventTarget {
    readonly activeCues: TextTrackCueList | null;
    readonly cues: TextTrackCueList | null;
    readonly id: string;
    readonly inBandMetadataTrackDispatchType: string;
    readonly kind: TextTrackKind;
    readonly label: string;
    readonly language: string;
    mode: TextTrackMode;
    oncuechange: ((this: TextTrack, ev: Event) => any) | null;
    readonly textTrackList: TextTrackList | null;
    addCue(cue: VTTCue): void;
    removeCue(cue: VTTCue): void;
    addEventListener<K extends keyof TextTrackEventMap>(type: K, listener: (this: TextTrack, ev: TextTrackEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof TextTrackEventMap>(type: K, listener: (this: TextTrack, ev: TextTrackEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var TextTrack: {
    prototype: TextTrack;
    new(): TextTrack;
    isInstance: IsInstance<TextTrack>;
};

interface TextTrackCueEventMap {
    "enter": Event;
    "exit": Event;
}

interface TextTrackCue extends EventTarget {
    endTime: number;
    id: string;
    onenter: ((this: TextTrackCue, ev: Event) => any) | null;
    onexit: ((this: TextTrackCue, ev: Event) => any) | null;
    pauseOnExit: boolean;
    startTime: number;
    readonly track: TextTrack | null;
    addEventListener<K extends keyof TextTrackCueEventMap>(type: K, listener: (this: TextTrackCue, ev: TextTrackCueEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof TextTrackCueEventMap>(type: K, listener: (this: TextTrackCue, ev: TextTrackCueEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var TextTrackCue: {
    prototype: TextTrackCue;
    new(): TextTrackCue;
    isInstance: IsInstance<TextTrackCue>;
};

interface TextTrackCueList {
    readonly length: number;
    getCueById(id: string): VTTCue | null;
    [index: number]: VTTCue;
}

declare var TextTrackCueList: {
    prototype: TextTrackCueList;
    new(): TextTrackCueList;
    isInstance: IsInstance<TextTrackCueList>;
};

interface TextTrackListEventMap {
    "addtrack": Event;
    "change": Event;
    "removetrack": Event;
}

interface TextTrackList extends EventTarget {
    readonly length: number;
    readonly mediaElement: HTMLMediaElement | null;
    onaddtrack: ((this: TextTrackList, ev: Event) => any) | null;
    onchange: ((this: TextTrackList, ev: Event) => any) | null;
    onremovetrack: ((this: TextTrackList, ev: Event) => any) | null;
    getTrackById(id: string): TextTrack | null;
    addEventListener<K extends keyof TextTrackListEventMap>(type: K, listener: (this: TextTrackList, ev: TextTrackListEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof TextTrackListEventMap>(type: K, listener: (this: TextTrackList, ev: TextTrackListEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    [index: number]: TextTrack;
}

declare var TextTrackList: {
    prototype: TextTrackList;
    new(): TextTrackList;
    isInstance: IsInstance<TextTrackList>;
};

interface TimeEvent extends Event {
    readonly detail: number;
    readonly view: WindowProxy | null;
    initTimeEvent(aType: string, aView?: Window | null, aDetail?: number): void;
}

declare var TimeEvent: {
    prototype: TimeEvent;
    new(): TimeEvent;
    isInstance: IsInstance<TimeEvent>;
};

interface TimeRanges {
    readonly length: number;
    end(index: number): number;
    start(index: number): number;
}

declare var TimeRanges: {
    prototype: TimeRanges;
    new(): TimeRanges;
    isInstance: IsInstance<TimeRanges>;
};

interface ToggleEvent extends Event {
    readonly newState: string;
    readonly oldState: string;
}

declare var ToggleEvent: {
    prototype: ToggleEvent;
    new(type: string, eventInitDict?: ToggleEventInit): ToggleEvent;
    isInstance: IsInstance<ToggleEvent>;
};

interface Touch {
    readonly clientX: number;
    readonly clientY: number;
    readonly force: number;
    readonly identifier: number;
    readonly pageX: number;
    readonly pageY: number;
    readonly radiusX: number;
    readonly radiusY: number;
    readonly rotationAngle: number;
    readonly screenX: number;
    readonly screenY: number;
    readonly target: EventTarget | null;
}

declare var Touch: {
    prototype: Touch;
    new(touchInitDict: TouchInit): Touch;
    isInstance: IsInstance<Touch>;
};

interface TouchEvent extends UIEvent {
    readonly altKey: boolean;
    readonly changedTouches: TouchList;
    readonly ctrlKey: boolean;
    readonly metaKey: boolean;
    readonly shiftKey: boolean;
    readonly targetTouches: TouchList;
    readonly touches: TouchList;
    initTouchEvent(type: string, canBubble?: boolean, cancelable?: boolean, view?: Window | null, detail?: number, ctrlKey?: boolean, altKey?: boolean, shiftKey?: boolean, metaKey?: boolean, touches?: TouchList | null, targetTouches?: TouchList | null, changedTouches?: TouchList | null): void;
}

declare var TouchEvent: {
    prototype: TouchEvent;
    new(type: string, eventInitDict?: TouchEventInit): TouchEvent;
    isInstance: IsInstance<TouchEvent>;
};

interface TouchEventHandlersEventMap {
    "touchcancel": Event;
    "touchend": Event;
    "touchmove": Event;
    "touchstart": Event;
}

interface TouchEventHandlers {
    ontouchcancel: ((this: TouchEventHandlers, ev: Event) => any) | null;
    ontouchend: ((this: TouchEventHandlers, ev: Event) => any) | null;
    ontouchmove: ((this: TouchEventHandlers, ev: Event) => any) | null;
    ontouchstart: ((this: TouchEventHandlers, ev: Event) => any) | null;
    addEventListener<K extends keyof TouchEventHandlersEventMap>(type: K, listener: (this: TouchEventHandlers, ev: TouchEventHandlersEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof TouchEventHandlersEventMap>(type: K, listener: (this: TouchEventHandlers, ev: TouchEventHandlersEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

interface TouchList {
    readonly length: number;
    item(index: number): Touch | null;
    [index: number]: Touch;
}

declare var TouchList: {
    prototype: TouchList;
    new(): TouchList;
    isInstance: IsInstance<TouchList>;
};

interface TrackEvent extends Event {
    readonly track: VideoTrack | AudioTrack | TextTrack | null;
}

declare var TrackEvent: {
    prototype: TrackEvent;
    new(type: string, eventInitDict?: TrackEventInit): TrackEvent;
    isInstance: IsInstance<TrackEvent>;
};

interface TransformStream {
    readonly readable: ReadableStream;
    readonly writable: WritableStream;
}

declare var TransformStream: {
    prototype: TransformStream;
    new(transformer?: any, writableStrategy?: QueuingStrategy, readableStrategy?: QueuingStrategy): TransformStream;
    isInstance: IsInstance<TransformStream>;
};

interface TransformStreamDefaultController {
    readonly desiredSize: number | null;
    enqueue(chunk?: any): void;
    error(reason?: any): void;
    terminate(): void;
}

declare var TransformStreamDefaultController: {
    prototype: TransformStreamDefaultController;
    new(): TransformStreamDefaultController;
    isInstance: IsInstance<TransformStreamDefaultController>;
};

interface TransitionEvent extends Event {
    readonly elapsedTime: number;
    readonly propertyName: string;
    readonly pseudoElement: string;
}

declare var TransitionEvent: {
    prototype: TransitionEvent;
    new(type: string, eventInitDict?: TransitionEventInit): TransitionEvent;
    isInstance: IsInstance<TransitionEvent>;
};

interface TreeColumn {
    readonly columns: TreeColumns | null;
    readonly cycler: boolean;
    readonly editable: boolean;
    readonly element: Element;
    readonly id: string;
    readonly index: number;
    readonly previousColumn: TreeColumn | null;
    readonly primary: boolean;
    readonly type: number;
    readonly width: number;
    readonly x: number;
    getNext(): TreeColumn | null;
    getPrevious(): TreeColumn | null;
    invalidate(): void;
    readonly TYPE_TEXT: 1;
    readonly TYPE_CHECKBOX: 2;
}

declare var TreeColumn: {
    prototype: TreeColumn;
    new(): TreeColumn;
    readonly TYPE_TEXT: 1;
    readonly TYPE_CHECKBOX: 2;
    isInstance: IsInstance<TreeColumn>;
};

interface TreeColumns {
    readonly count: number;
    readonly length: number;
    readonly tree: XULTreeElement | null;
    getColumnAt(index: number): TreeColumn | null;
    getColumnFor(element: Element | null): TreeColumn | null;
    getFirstColumn(): TreeColumn | null;
    getKeyColumn(): TreeColumn | null;
    getLastColumn(): TreeColumn | null;
    getNamedColumn(name: string): TreeColumn | null;
    getPrimaryColumn(): TreeColumn | null;
    getSortedColumn(): TreeColumn | null;
    invalidateColumns(): void;
    [index: number]: TreeColumn;
}

declare var TreeColumns: {
    prototype: TreeColumns;
    new(): TreeColumns;
    isInstance: IsInstance<TreeColumns>;
};

interface TreeContentView extends TreeView {
    getIndexOfItem(item: Element | null): number;
    getItemAtIndex(row: number): Element | null;
}

declare var TreeContentView: {
    prototype: TreeContentView;
    new(): TreeContentView;
    readonly DROP_BEFORE: -1;
    readonly DROP_ON: 0;
    readonly DROP_AFTER: 1;
    isInstance: IsInstance<TreeContentView>;
};

interface TreeView {
    readonly rowCount: number;
    selection: nsITreeSelection | null;
    canDrop(row: number, orientation: number, dataTransfer: DataTransfer | null): boolean;
    cycleCell(row: number, column: TreeColumn): void;
    cycleHeader(column: TreeColumn): void;
    drop(row: number, orientation: number, dataTransfer: DataTransfer | null): void;
    getCellProperties(row: number, column: TreeColumn): string;
    getCellText(row: number, column: TreeColumn): string;
    getCellValue(row: number, column: TreeColumn): string;
    getColumnProperties(column: TreeColumn): string;
    getImageSrc(row: number, column: TreeColumn): string;
    getLevel(row: number): number;
    getParentIndex(row: number): number;
    getRowProperties(row: number): string;
    hasNextSibling(row: number, afterIndex: number): boolean;
    isContainer(row: number): boolean;
    isContainerEmpty(row: number): boolean;
    isContainerOpen(row: number): boolean;
    isEditable(row: number, column: TreeColumn): boolean;
    isSeparator(row: number): boolean;
    isSorted(): boolean;
    selectionChanged(): void;
    setCellText(row: number, column: TreeColumn, value: string): void;
    setCellValue(row: number, column: TreeColumn, value: string): void;
    setTree(tree: XULTreeElement | null): void;
    toggleOpenState(row: number): void;
    readonly DROP_BEFORE: -1;
    readonly DROP_ON: 0;
    readonly DROP_AFTER: 1;
}

interface TreeWalker {
    currentNode: Node;
    readonly filter: NodeFilter | null;
    readonly root: Node;
    readonly whatToShow: number;
    firstChild(): Node | null;
    lastChild(): Node | null;
    nextNode(): Node | null;
    nextSibling(): Node | null;
    parentNode(): Node | null;
    previousNode(): Node | null;
    previousSibling(): Node | null;
}

declare var TreeWalker: {
    prototype: TreeWalker;
    new(): TreeWalker;
    isInstance: IsInstance<TreeWalker>;
};

interface TrustedHTML {
    toJSON(): string;
    toString(): string;
}

declare var TrustedHTML: {
    prototype: TrustedHTML;
    new(): TrustedHTML;
    isInstance: IsInstance<TrustedHTML>;
};

type TrustedScript = string & {
    toJSON(): string;
    toString(): string;
};

declare var TrustedScript: {
    prototype: TrustedScript;
    new(): TrustedScript;
    isInstance: IsInstance<TrustedScript>;
};

interface TrustedScriptURL {
    toJSON(): string;
    toString(): string;
}

declare var TrustedScriptURL: {
    prototype: TrustedScriptURL;
    new(): TrustedScriptURL;
    isInstance: IsInstance<TrustedScriptURL>;
};

interface TrustedTypePolicy {
    readonly name: string;
    createHTML(input: string, ...arguments: any[]): TrustedHTML;
    createScript(input: string, ...arguments: any[]): TrustedScript;
    createScriptURL(input: string, ...arguments: any[]): TrustedScriptURL;
}

declare var TrustedTypePolicy: {
    prototype: TrustedTypePolicy;
    new(): TrustedTypePolicy;
    isInstance: IsInstance<TrustedTypePolicy>;
};

interface TrustedTypePolicyFactory {
    readonly defaultPolicy: TrustedTypePolicy | null;
    readonly emptyHTML: TrustedHTML;
    readonly emptyScript: TrustedScript;
    createPolicy(policyName: string, policyOptions?: TrustedTypePolicyOptions): TrustedTypePolicy;
    getAttributeType(tagName: string, attribute: string, elementNs?: string | null, attrNs?: string | null): string | null;
    getPropertyType(tagName: string, property: string, elementNs?: string | null): string | null;
    isHTML(value: any): boolean;
    isScript(value: any): boolean;
    isScriptURL(value: any): boolean;
}

declare var TrustedTypePolicyFactory: {
    prototype: TrustedTypePolicyFactory;
    new(): TrustedTypePolicyFactory;
    isInstance: IsInstance<TrustedTypePolicyFactory>;
};

interface UDPMessageEvent extends Event {
    readonly data: any;
    readonly remoteAddress: string;
    readonly remotePort: number;
}

declare var UDPMessageEvent: {
    prototype: UDPMessageEvent;
    new(type: string, eventInitDict?: UDPMessageEventInit): UDPMessageEvent;
    isInstance: IsInstance<UDPMessageEvent>;
};

interface UDPSocketEventMap {
    "message": Event;
}

interface UDPSocket extends EventTarget {
    readonly addressReuse: boolean;
    readonly closed: Promise<void>;
    readonly localAddress: string | null;
    readonly localPort: number | null;
    readonly loopback: boolean;
    onmessage: ((this: UDPSocket, ev: Event) => any) | null;
    readonly opened: Promise<void>;
    readonly readyState: SocketReadyState;
    readonly remoteAddress: string | null;
    readonly remotePort: number | null;
    close(): Promise<void>;
    joinMulticastGroup(multicastGroupAddress: string): void;
    leaveMulticastGroup(multicastGroupAddress: string): void;
    send(data: string | Blob | ArrayBuffer | ArrayBufferView, remoteAddress?: string | null, remotePort?: number | null): boolean;
    addEventListener<K extends keyof UDPSocketEventMap>(type: K, listener: (this: UDPSocket, ev: UDPSocketEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof UDPSocketEventMap>(type: K, listener: (this: UDPSocket, ev: UDPSocketEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var UDPSocket: {
    prototype: UDPSocket;
    new(options?: UDPOptions): UDPSocket;
    isInstance: IsInstance<UDPSocket>;
};

interface UIEvent extends Event {
    readonly detail: number;
    readonly layerX: number;
    readonly layerY: number;
    readonly rangeOffset: number;
    readonly rangeParent: Node | null;
    readonly view: WindowProxy | null;
    readonly which: number;
    initUIEvent(aType: string, aCanBubble?: boolean, aCancelable?: boolean, aView?: Window | null, aDetail?: number): void;
    readonly SCROLL_PAGE_UP: -32768;
    readonly SCROLL_PAGE_DOWN: 32768;
}

declare var UIEvent: {
    prototype: UIEvent;
    new(type: string, eventInitDict?: UIEventInit): UIEvent;
    readonly SCROLL_PAGE_UP: -32768;
    readonly SCROLL_PAGE_DOWN: 32768;
    isInstance: IsInstance<UIEvent>;
};

interface URL {
    readonly URI: URI;
    hash: string;
    host: string;
    hostname: string;
    href: string;
    toString(): string;
    readonly origin: string;
    password: string;
    pathname: string;
    port: string;
    protocol: string;
    search: string;
    readonly searchParams: URLSearchParams;
    username: string;
    toJSON(): string;
}

declare var URL: {
    prototype: URL;
    new(url: string, base?: string): URL;
    isInstance: IsInstance<URL>;
    canParse(url: string, base?: string): boolean;
    createObjectURL(obj: Blob | MediaSource): string;
    fromURI(uri: URI): URL;
    isBoundToBlob(url: string): boolean;
    parse(url: string, base?: string): URL | null;
    revokeObjectURL(url: string): void;
};

type webkitURL = URL;
declare var webkitURL: typeof URL;

interface URLSearchParams {
    readonly size: number;
    append(name: string, value: string): void;
    delete(name: string, value?: string): void;
    get(name: string): string | null;
    getAll(name: string): string[];
    has(name: string, value?: string): boolean;
    set(name: string, value: string): void;
    sort(): void;
    toString(): string;
    forEach(callbackfn: (value: string, key: string, parent: URLSearchParams) => void, thisArg?: any): void;
}

declare var URLSearchParams: {
    prototype: URLSearchParams;
    new(init?: string[][] | Record<string, string> | string): URLSearchParams;
    isInstance: IsInstance<URLSearchParams>;
};

interface UniFFIPointer {
}

declare var UniFFIPointer: {
    prototype: UniFFIPointer;
    new(): UniFFIPointer;
    isInstance: IsInstance<UniFFIPointer>;
};

interface UserActivation {
    readonly hasBeenActive: boolean;
    readonly isActive: boolean;
}

declare var UserActivation: {
    prototype: UserActivation;
    new(): UserActivation;
    isInstance: IsInstance<UserActivation>;
};

interface UserProximityEvent extends Event {
    readonly near: boolean;
}

declare var UserProximityEvent: {
    prototype: UserProximityEvent;
    new(type: string, eventInitDict?: UserProximityEventInit): UserProximityEvent;
    isInstance: IsInstance<UserProximityEvent>;
};

/** Available only in secure contexts. */
interface VRDisplay extends EventTarget {
    readonly capabilities: VRDisplayCapabilities;
    depthFar: number;
    depthNear: number;
    readonly displayId: number;
    readonly displayName: string;
    groupMask: number;
    readonly isConnected: boolean;
    readonly isPresenting: boolean;
    readonly presentingGroups: number;
    readonly stageParameters: VRStageParameters | null;
    cancelAnimationFrame(handle: number): void;
    exitPresent(): Promise<void>;
    getEyeParameters(whichEye: VREye): VREyeParameters;
    getFrameData(frameData: VRFrameData): boolean;
    getLayers(): VRLayer[];
    getPose(): VRPose;
    requestAnimationFrame(callback: FrameRequestCallback): number;
    requestPresent(layers: VRLayer[]): Promise<void>;
    resetPose(): void;
    submitFrame(): void;
}

declare var VRDisplay: {
    prototype: VRDisplay;
    new(): VRDisplay;
    isInstance: IsInstance<VRDisplay>;
};

/** Available only in secure contexts. */
interface VRDisplayCapabilities {
    readonly canPresent: boolean;
    readonly hasExternalDisplay: boolean;
    readonly hasOrientation: boolean;
    readonly hasPosition: boolean;
    readonly maxLayers: number;
}

declare var VRDisplayCapabilities: {
    prototype: VRDisplayCapabilities;
    new(): VRDisplayCapabilities;
    isInstance: IsInstance<VRDisplayCapabilities>;
};

/** Available only in secure contexts. */
interface VRDisplayEvent extends Event {
    readonly display: VRDisplay;
    readonly reason: VRDisplayEventReason | null;
}

declare var VRDisplayEvent: {
    prototype: VRDisplayEvent;
    new(type: string, eventInitDict: VRDisplayEventInit): VRDisplayEvent;
    isInstance: IsInstance<VRDisplayEvent>;
};

/** Available only in secure contexts. */
interface VREyeParameters {
    readonly fieldOfView: VRFieldOfView;
    readonly offset: Float32Array;
    readonly renderHeight: number;
    readonly renderWidth: number;
}

declare var VREyeParameters: {
    prototype: VREyeParameters;
    new(): VREyeParameters;
    isInstance: IsInstance<VREyeParameters>;
};

/** Available only in secure contexts. */
interface VRFieldOfView {
    readonly downDegrees: number;
    readonly leftDegrees: number;
    readonly rightDegrees: number;
    readonly upDegrees: number;
}

declare var VRFieldOfView: {
    prototype: VRFieldOfView;
    new(): VRFieldOfView;
    isInstance: IsInstance<VRFieldOfView>;
};

/** Available only in secure contexts. */
interface VRFrameData {
    readonly leftProjectionMatrix: Float32Array;
    readonly leftViewMatrix: Float32Array;
    readonly pose: VRPose;
    readonly rightProjectionMatrix: Float32Array;
    readonly rightViewMatrix: Float32Array;
    readonly timestamp: DOMHighResTimeStamp;
}

declare var VRFrameData: {
    prototype: VRFrameData;
    new(): VRFrameData;
    isInstance: IsInstance<VRFrameData>;
};

interface VRMockController {
    axisCount: number;
    buttonCount: number;
    capAngularAcceleration: boolean;
    capLinearAcceleration: boolean;
    capOrientation: boolean;
    capPosition: boolean;
    hand: GamepadHand;
    hapticCount: number;
    clear(): void;
    create(): void;
    setAxisValue(axisIdx: number, value: number): void;
    setButtonPressed(buttonIdx: number, pressed: boolean): void;
    setButtonTouched(buttonIdx: number, touched: boolean): void;
    setButtonTrigger(buttonIdx: number, trigger: number): void;
    setPose(position: Float32Array | null, linearVelocity: Float32Array | null, linearAcceleration: Float32Array | null, orientation: Float32Array | null, angularVelocity: Float32Array | null, angularAcceleration: Float32Array | null): void;
}

declare var VRMockController: {
    prototype: VRMockController;
    new(): VRMockController;
    isInstance: IsInstance<VRMockController>;
};

interface VRMockDisplay {
    capAngularAcceleration: boolean;
    capExternal: boolean;
    capLinearAcceleration: boolean;
    capMountDetection: boolean;
    capOrientation: boolean;
    capPosition: boolean;
    capPositionEmulated: boolean;
    capPresent: boolean;
    capStageParameters: boolean;
    create(): void;
    setConnected(connected: boolean): void;
    setEyeFOV(eye: VREye, upDegree: number, rightDegree: number, downDegree: number, leftDegree: number): void;
    setEyeOffset(eye: VREye, offsetX: number, offsetY: number, offsetZ: number): void;
    setEyeResolution(renderWidth: number, renderHeight: number): void;
    setMounted(mounted: boolean): void;
    setPose(position: Float32Array | null, linearVelocity: Float32Array | null, linearAcceleration: Float32Array | null, orientation: Float32Array | null, angularVelocity: Float32Array | null, angularAcceleration: Float32Array | null): void;
    setSittingToStandingTransform(sittingToStandingTransform: Float32Array): void;
    setStageSize(width: number, height: number): void;
}

declare var VRMockDisplay: {
    prototype: VRMockDisplay;
    new(): VRMockDisplay;
    isInstance: IsInstance<VRMockDisplay>;
};

/** Available only in secure contexts. */
interface VRPose {
    readonly angularAcceleration: Float32Array | null;
    readonly angularVelocity: Float32Array | null;
    readonly linearAcceleration: Float32Array | null;
    readonly linearVelocity: Float32Array | null;
    readonly orientation: Float32Array | null;
    readonly position: Float32Array | null;
}

declare var VRPose: {
    prototype: VRPose;
    new(): VRPose;
    isInstance: IsInstance<VRPose>;
};

interface VRServiceTest {
    acknowledgeFrame(): void;
    captureFrame(): void;
    clearAll(): void;
    commit(): void;
    end(): void;
    getVRController(controllerIdx: number): VRMockController;
    getVRDisplay(): VRMockDisplay;
    rejectFrame(): void;
    reset(): Promise<void>;
    run(): Promise<void>;
    startTimer(): void;
    stopTimer(): void;
    timeout(duration: number): void;
    wait(duration: number): void;
    waitHapticIntensity(controllerIdx: number, hapticIdx: number, intensity: number): void;
    waitPresentationEnd(): void;
    waitPresentationStart(): void;
    waitSubmit(): void;
}

declare var VRServiceTest: {
    prototype: VRServiceTest;
    new(): VRServiceTest;
    isInstance: IsInstance<VRServiceTest>;
};

/** Available only in secure contexts. */
interface VRStageParameters {
    readonly sittingToStandingTransform: Float32Array;
    readonly sizeX: number;
    readonly sizeZ: number;
}

declare var VRStageParameters: {
    prototype: VRStageParameters;
    new(): VRStageParameters;
    isInstance: IsInstance<VRStageParameters>;
};

interface VTTCue extends TextTrackCue {
    align: AlignSetting;
    readonly computedLine: number;
    readonly computedPosition: number;
    readonly computedPositionAlign: PositionAlignSetting;
    displayState: HTMLDivElement | null;
    readonly getActive: boolean;
    readonly hasBeenReset: boolean;
    line: number | AutoKeyword;
    lineAlign: LineAlignSetting;
    position: number | AutoKeyword;
    positionAlign: PositionAlignSetting;
    region: VTTRegion | null;
    size: number;
    snapToLines: boolean;
    text: string;
    vertical: DirectionSetting;
    getCueAsHTML(): DocumentFragment;
    addEventListener<K extends keyof TextTrackCueEventMap>(type: K, listener: (this: VTTCue, ev: TextTrackCueEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof TextTrackCueEventMap>(type: K, listener: (this: VTTCue, ev: TextTrackCueEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var VTTCue: {
    prototype: VTTCue;
    new(startTime: number, endTime: number, text: string): VTTCue;
    isInstance: IsInstance<VTTCue>;
};

interface VTTRegion {
    id: string;
    lines: number;
    regionAnchorX: number;
    regionAnchorY: number;
    scroll: ScrollSetting;
    viewportAnchorX: number;
    viewportAnchorY: number;
    width: number;
}

declare var VTTRegion: {
    prototype: VTTRegion;
    new(): VTTRegion;
    isInstance: IsInstance<VTTRegion>;
};

interface ValidityState {
    readonly badInput: boolean;
    readonly customError: boolean;
    readonly patternMismatch: boolean;
    readonly rangeOverflow: boolean;
    readonly rangeUnderflow: boolean;
    readonly stepMismatch: boolean;
    readonly tooLong: boolean;
    readonly tooShort: boolean;
    readonly typeMismatch: boolean;
    readonly valid: boolean;
    readonly valueMissing: boolean;
}

declare var ValidityState: {
    prototype: ValidityState;
    new(): ValidityState;
    isInstance: IsInstance<ValidityState>;
};

interface VideoColorSpace {
    readonly fullRange: boolean | null;
    readonly matrix: VideoMatrixCoefficients | null;
    readonly primaries: VideoColorPrimaries | null;
    readonly transfer: VideoTransferCharacteristics | null;
    toJSON(): any;
}

declare var VideoColorSpace: {
    prototype: VideoColorSpace;
    new(init?: VideoColorSpaceInit): VideoColorSpace;
    isInstance: IsInstance<VideoColorSpace>;
};

interface VideoDecoderEventMap {
    "dequeue": Event;
}

/** Available only in secure contexts. */
interface VideoDecoder extends EventTarget {
    readonly decodeQueueSize: number;
    ondequeue: ((this: VideoDecoder, ev: Event) => any) | null;
    readonly state: CodecState;
    close(): void;
    configure(config: VideoDecoderConfig): void;
    decode(chunk: EncodedVideoChunk): void;
    flush(): Promise<void>;
    reset(): void;
    addEventListener<K extends keyof VideoDecoderEventMap>(type: K, listener: (this: VideoDecoder, ev: VideoDecoderEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof VideoDecoderEventMap>(type: K, listener: (this: VideoDecoder, ev: VideoDecoderEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var VideoDecoder: {
    prototype: VideoDecoder;
    new(init: VideoDecoderInit): VideoDecoder;
    isInstance: IsInstance<VideoDecoder>;
    isConfigSupported(config: VideoDecoderConfig): Promise<VideoDecoderSupport>;
};

interface VideoEncoderEventMap {
    "dequeue": Event;
}

/** Available only in secure contexts. */
interface VideoEncoder extends EventTarget {
    readonly encodeQueueSize: number;
    ondequeue: ((this: VideoEncoder, ev: Event) => any) | null;
    readonly state: CodecState;
    close(): void;
    configure(config: VideoEncoderConfig): void;
    encode(frame: VideoFrame, options?: VideoEncoderEncodeOptions): void;
    flush(): Promise<void>;
    reset(): void;
    addEventListener<K extends keyof VideoEncoderEventMap>(type: K, listener: (this: VideoEncoder, ev: VideoEncoderEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof VideoEncoderEventMap>(type: K, listener: (this: VideoEncoder, ev: VideoEncoderEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var VideoEncoder: {
    prototype: VideoEncoder;
    new(init: VideoEncoderInit): VideoEncoder;
    isInstance: IsInstance<VideoEncoder>;
    isConfigSupported(config: VideoEncoderConfig): Promise<VideoEncoderSupport>;
};

interface VideoFrame {
    readonly codedHeight: number;
    readonly codedRect: DOMRectReadOnly | null;
    readonly codedWidth: number;
    readonly colorSpace: VideoColorSpace;
    readonly displayHeight: number;
    readonly displayWidth: number;
    readonly duration: number | null;
    readonly format: VideoPixelFormat | null;
    readonly timestamp: number;
    readonly visibleRect: DOMRectReadOnly | null;
    allocationSize(options?: VideoFrameCopyToOptions): number;
    clone(): VideoFrame;
    close(): void;
    copyTo(destination: AllowSharedBufferSource, options?: VideoFrameCopyToOptions): Promise<PlaneLayout[]>;
}

declare var VideoFrame: {
    prototype: VideoFrame;
    new(imageElement: HTMLImageElement, init?: VideoFrameInit): VideoFrame;
    new(svgImageElement: SVGImageElement, init?: VideoFrameInit): VideoFrame;
    new(canvasElement: HTMLCanvasElement, init?: VideoFrameInit): VideoFrame;
    new(videoElement: HTMLVideoElement, init?: VideoFrameInit): VideoFrame;
    new(offscreenCanvas: OffscreenCanvas, init?: VideoFrameInit): VideoFrame;
    new(imageBitmap: ImageBitmap, init?: VideoFrameInit): VideoFrame;
    new(videoFrame: VideoFrame, init?: VideoFrameInit): VideoFrame;
    new(bufferView: ArrayBufferView, init: VideoFrameBufferInit): VideoFrame;
    new(buffer: ArrayBuffer, init: VideoFrameBufferInit): VideoFrame;
    isInstance: IsInstance<VideoFrame>;
};

interface VideoPlaybackQuality {
    readonly creationTime: DOMHighResTimeStamp;
    readonly droppedVideoFrames: number;
    readonly totalVideoFrames: number;
}

declare var VideoPlaybackQuality: {
    prototype: VideoPlaybackQuality;
    new(): VideoPlaybackQuality;
    isInstance: IsInstance<VideoPlaybackQuality>;
};

interface VideoTrack {
    readonly id: string;
    readonly kind: string;
    readonly label: string;
    readonly language: string;
    selected: boolean;
}

declare var VideoTrack: {
    prototype: VideoTrack;
    new(): VideoTrack;
    isInstance: IsInstance<VideoTrack>;
};

interface VideoTrackListEventMap {
    "addtrack": Event;
    "change": Event;
    "removetrack": Event;
}

interface VideoTrackList extends EventTarget {
    readonly length: number;
    onaddtrack: ((this: VideoTrackList, ev: Event) => any) | null;
    onchange: ((this: VideoTrackList, ev: Event) => any) | null;
    onremovetrack: ((this: VideoTrackList, ev: Event) => any) | null;
    readonly selectedIndex: number;
    getTrackById(id: string): VideoTrack | null;
    addEventListener<K extends keyof VideoTrackListEventMap>(type: K, listener: (this: VideoTrackList, ev: VideoTrackListEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof VideoTrackListEventMap>(type: K, listener: (this: VideoTrackList, ev: VideoTrackListEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    [index: number]: VideoTrack;
}

declare var VideoTrackList: {
    prototype: VideoTrackList;
    new(): VideoTrackList;
    isInstance: IsInstance<VideoTrackList>;
};

interface ViewTransition {
    readonly finished: Promise<void>;
    readonly ready: Promise<void>;
    readonly updateCallbackDone: Promise<void>;
    skipTransition(): void;
}

declare var ViewTransition: {
    prototype: ViewTransition;
    new(): ViewTransition;
    isInstance: IsInstance<ViewTransition>;
};

interface VisualViewportEventMap {
    "resize": Event;
    "scroll": Event;
}

interface VisualViewport extends EventTarget {
    readonly height: number;
    readonly offsetLeft: number;
    readonly offsetTop: number;
    onresize: ((this: VisualViewport, ev: Event) => any) | null;
    onscroll: ((this: VisualViewport, ev: Event) => any) | null;
    readonly pageLeft: number;
    readonly pageTop: number;
    readonly scale: number;
    readonly width: number;
    addEventListener<K extends keyof VisualViewportEventMap>(type: K, listener: (this: VisualViewport, ev: VisualViewportEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof VisualViewportEventMap>(type: K, listener: (this: VisualViewport, ev: VisualViewportEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var VisualViewport: {
    prototype: VisualViewport;
    new(): VisualViewport;
    isInstance: IsInstance<VisualViewport>;
};

interface WEBGL_color_buffer_float {
    readonly RGBA32F_EXT: 0x8814;
    readonly RGB32F_EXT: 0x8815;
    readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211;
    readonly UNSIGNED_NORMALIZED_EXT: 0x8C17;
}

interface WEBGL_compressed_texture_astc {
    getSupportedProfiles(): string[] | null;
    readonly COMPRESSED_RGBA_ASTC_4x4_KHR: 0x93B0;
    readonly COMPRESSED_RGBA_ASTC_5x4_KHR: 0x93B1;
    readonly COMPRESSED_RGBA_ASTC_5x5_KHR: 0x93B2;
    readonly COMPRESSED_RGBA_ASTC_6x5_KHR: 0x93B3;
    readonly COMPRESSED_RGBA_ASTC_6x6_KHR: 0x93B4;
    readonly COMPRESSED_RGBA_ASTC_8x5_KHR: 0x93B5;
    readonly COMPRESSED_RGBA_ASTC_8x6_KHR: 0x93B6;
    readonly COMPRESSED_RGBA_ASTC_8x8_KHR: 0x93B7;
    readonly COMPRESSED_RGBA_ASTC_10x5_KHR: 0x93B8;
    readonly COMPRESSED_RGBA_ASTC_10x6_KHR: 0x93B9;
    readonly COMPRESSED_RGBA_ASTC_10x8_KHR: 0x93BA;
    readonly COMPRESSED_RGBA_ASTC_10x10_KHR: 0x93BB;
    readonly COMPRESSED_RGBA_ASTC_12x10_KHR: 0x93BC;
    readonly COMPRESSED_RGBA_ASTC_12x12_KHR: 0x93BD;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: 0x93D0;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: 0x93D1;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: 0x93D2;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: 0x93D3;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: 0x93D4;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: 0x93D5;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: 0x93D6;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: 0x93D7;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: 0x93D8;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: 0x93D9;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: 0x93DA;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: 0x93DB;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: 0x93DC;
    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: 0x93DD;
}

interface WEBGL_compressed_texture_etc {
    readonly COMPRESSED_R11_EAC: 0x9270;
    readonly COMPRESSED_SIGNED_R11_EAC: 0x9271;
    readonly COMPRESSED_RG11_EAC: 0x9272;
    readonly COMPRESSED_SIGNED_RG11_EAC: 0x9273;
    readonly COMPRESSED_RGB8_ETC2: 0x9274;
    readonly COMPRESSED_SRGB8_ETC2: 0x9275;
    readonly COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9276;
    readonly COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9277;
    readonly COMPRESSED_RGBA8_ETC2_EAC: 0x9278;
    readonly COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9279;
}

interface WEBGL_compressed_texture_etc1 {
    readonly COMPRESSED_RGB_ETC1_WEBGL: 0x8D64;
}

interface WEBGL_compressed_texture_pvrtc {
    readonly COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8C00;
    readonly COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8C01;
    readonly COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8C02;
    readonly COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8C03;
}

interface WEBGL_compressed_texture_s3tc {
    readonly COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83F0;
    readonly COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83F1;
    readonly COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83F2;
    readonly COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83F3;
}

interface WEBGL_compressed_texture_s3tc_srgb {
    readonly COMPRESSED_SRGB_S3TC_DXT1_EXT: 0x8C4C;
    readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 0x8C4D;
    readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 0x8C4E;
    readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 0x8C4F;
}

interface WEBGL_debug_renderer_info {
    readonly UNMASKED_VENDOR_WEBGL: 0x9245;
    readonly UNMASKED_RENDERER_WEBGL: 0x9246;
}

interface WEBGL_debug_shaders {
    getTranslatedShaderSource(shader: WebGLShader): string;
}

interface WEBGL_depth_texture {
    readonly UNSIGNED_INT_24_8_WEBGL: 0x84FA;
}

interface WEBGL_draw_buffers {
    drawBuffersWEBGL(buffers: GLenum[]): void;
    readonly COLOR_ATTACHMENT0_WEBGL: 0x8CE0;
    readonly COLOR_ATTACHMENT1_WEBGL: 0x8CE1;
    readonly COLOR_ATTACHMENT2_WEBGL: 0x8CE2;
    readonly COLOR_ATTACHMENT3_WEBGL: 0x8CE3;
    readonly COLOR_ATTACHMENT4_WEBGL: 0x8CE4;
    readonly COLOR_ATTACHMENT5_WEBGL: 0x8CE5;
    readonly COLOR_ATTACHMENT6_WEBGL: 0x8CE6;
    readonly COLOR_ATTACHMENT7_WEBGL: 0x8CE7;
    readonly COLOR_ATTACHMENT8_WEBGL: 0x8CE8;
    readonly COLOR_ATTACHMENT9_WEBGL: 0x8CE9;
    readonly COLOR_ATTACHMENT10_WEBGL: 0x8CEA;
    readonly COLOR_ATTACHMENT11_WEBGL: 0x8CEB;
    readonly COLOR_ATTACHMENT12_WEBGL: 0x8CEC;
    readonly COLOR_ATTACHMENT13_WEBGL: 0x8CED;
    readonly COLOR_ATTACHMENT14_WEBGL: 0x8CEE;
    readonly COLOR_ATTACHMENT15_WEBGL: 0x8CEF;
    readonly DRAW_BUFFER0_WEBGL: 0x8825;
    readonly DRAW_BUFFER1_WEBGL: 0x8826;
    readonly DRAW_BUFFER2_WEBGL: 0x8827;
    readonly DRAW_BUFFER3_WEBGL: 0x8828;
    readonly DRAW_BUFFER4_WEBGL: 0x8829;
    readonly DRAW_BUFFER5_WEBGL: 0x882A;
    readonly DRAW_BUFFER6_WEBGL: 0x882B;
    readonly DRAW_BUFFER7_WEBGL: 0x882C;
    readonly DRAW_BUFFER8_WEBGL: 0x882D;
    readonly DRAW_BUFFER9_WEBGL: 0x882E;
    readonly DRAW_BUFFER10_WEBGL: 0x882F;
    readonly DRAW_BUFFER11_WEBGL: 0x8830;
    readonly DRAW_BUFFER12_WEBGL: 0x8831;
    readonly DRAW_BUFFER13_WEBGL: 0x8832;
    readonly DRAW_BUFFER14_WEBGL: 0x8833;
    readonly DRAW_BUFFER15_WEBGL: 0x8834;
    readonly MAX_COLOR_ATTACHMENTS_WEBGL: 0x8CDF;
    readonly MAX_DRAW_BUFFERS_WEBGL: 0x8824;
}

interface WEBGL_explicit_present {
    present(): void;
}

interface WEBGL_lose_context {
    loseContext(): void;
    restoreContext(): void;
}

interface WEBGL_provoking_vertex {
    provokingVertexWEBGL(provokeMode: GLenum): void;
    readonly FIRST_VERTEX_CONVENTION_WEBGL: 0x8E4D;
    readonly LAST_VERTEX_CONVENTION_WEBGL: 0x8E4E;
    readonly PROVOKING_VERTEX_WEBGL: 0x8E4F;
}

/** Available only in secure contexts. */
interface WGSLLanguageFeatures {
    forEach(callbackfn: (value: string, key: string, parent: WGSLLanguageFeatures) => void, thisArg?: any): void;
}

declare var WGSLLanguageFeatures: {
    prototype: WGSLLanguageFeatures;
    new(): WGSLLanguageFeatures;
    isInstance: IsInstance<WGSLLanguageFeatures>;
};

/** Available only in secure contexts. */
interface WakeLock {
    request(type?: WakeLockType): Promise<WakeLockSentinel>;
}

declare var WakeLock: {
    prototype: WakeLock;
    new(): WakeLock;
    isInstance: IsInstance<WakeLock>;
};

interface WakeLockSentinelEventMap {
    "release": Event;
}

/** Available only in secure contexts. */
interface WakeLockSentinel extends EventTarget {
    onrelease: ((this: WakeLockSentinel, ev: Event) => any) | null;
    readonly released: boolean;
    readonly type: WakeLockType;
    release(): Promise<void>;
    addEventListener<K extends keyof WakeLockSentinelEventMap>(type: K, listener: (this: WakeLockSentinel, ev: WakeLockSentinelEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof WakeLockSentinelEventMap>(type: K, listener: (this: WakeLockSentinel, ev: WakeLockSentinelEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var WakeLockSentinel: {
    prototype: WakeLockSentinel;
    new(): WakeLockSentinel;
    isInstance: IsInstance<WakeLockSentinel>;
};

interface WaveShaperNode extends AudioNode, AudioNodePassThrough {
    curve: Float32Array | null;
    oversample: OverSampleType;
}

declare var WaveShaperNode: {
    prototype: WaveShaperNode;
    new(context: BaseAudioContext, options?: WaveShaperOptions): WaveShaperNode;
    isInstance: IsInstance<WaveShaperNode>;
};

interface WebBrowserPersistable {
    startPersistence(aContext: BrowsingContext | null, aRecv: nsIWebBrowserPersistDocumentReceiver): void;
}

interface WebExtensionContentScript extends MozDocumentMatcher {
    readonly cssPaths: string[];
    readonly jsPaths: string[];
    readonly runAt: ContentScriptRunAt;
    readonly world: ContentScriptExecutionWorld;
    readonly worldId: string | null;
}

declare var WebExtensionContentScript: {
    prototype: WebExtensionContentScript;
    new(extension: WebExtensionPolicy, options: WebExtensionContentScriptInit): WebExtensionContentScript;
    isInstance: IsInstance<WebExtensionContentScript>;
};

interface WebExtensionPolicy {
    active: boolean;
    allowedOrigins: MatchPatternSet;
    readonly baseCSP: string;
    readonly baseURL: string;
    readonly browsingContextGroupId: number;
    readonly contentScripts: WebExtensionContentScript[];
    readonly extensionPageCSP: string;
    readonly id: string;
    ignoreQuarantine: boolean;
    readonly isPrivileged: boolean;
    readonly manifestVersion: number;
    readonly mozExtensionHostname: string;
    readonly name: string;
    permissions: string[];
    readonly privateBrowsingAllowed: boolean;
    readonly readyPromise: any;
    readonly temporarilyInstalled: boolean;
    readonly type: string;
    canAccessURI(uri: URI, explicit?: boolean, checkRestricted?: boolean, allowFilePermission?: boolean): boolean;
    canAccessWindow(window: WindowProxy): boolean;
    getURL(path?: string): string;
    hasPermission(permission: string): boolean;
    injectContentScripts(): void;
    isManifestBackgroundWorker(workerURL: string): boolean;
    isWebAccessiblePath(pathname: string): boolean;
    localize(unlocalizedText: string): string;
    quarantinedFromURI(uri: URI): boolean;
    registerContentScript(script: WebExtensionContentScript): void;
    sourceMayAccessPath(sourceURI: URI, pathname: string): boolean;
    unregisterContentScript(script: WebExtensionContentScript): void;
}

declare var WebExtensionPolicy: {
    prototype: WebExtensionPolicy;
    new(options: WebExtensionInit): WebExtensionPolicy;
    readonly backgroundServiceWorkerEnabled: boolean;
    readonly isExtensionProcess: boolean;
    isInstance: IsInstance<WebExtensionPolicy>;
    readonly quarantinedDomainsEnabled: boolean;
    readonly useRemoteWebExtensions: boolean;
    getActiveExtensions(): WebExtensionPolicy[];
    getByHostname(hostname: string): WebExtensionPolicy | null;
    getByID(id: string): WebExtensionPolicy | null;
    getByURI(uri: URI): WebExtensionPolicy | null;
    isQuarantinedURI(uri: URI): boolean;
    isRestrictedURI(uri: URI): boolean;
};

interface WebGL2RenderingContext extends WebGL2RenderingContextBase, WebGLRenderingContextBase {
}

declare var WebGL2RenderingContext: {
    prototype: WebGL2RenderingContext;
    new(): WebGL2RenderingContext;
    readonly READ_BUFFER: 0x0C02;
    readonly UNPACK_ROW_LENGTH: 0x0CF2;
    readonly UNPACK_SKIP_ROWS: 0x0CF3;
    readonly UNPACK_SKIP_PIXELS: 0x0CF4;
    readonly PACK_ROW_LENGTH: 0x0D02;
    readonly PACK_SKIP_ROWS: 0x0D03;
    readonly PACK_SKIP_PIXELS: 0x0D04;
    readonly COLOR: 0x1800;
    readonly DEPTH: 0x1801;
    readonly STENCIL: 0x1802;
    readonly RED: 0x1903;
    readonly RGB8: 0x8051;
    readonly RGBA8: 0x8058;
    readonly RGB10_A2: 0x8059;
    readonly TEXTURE_BINDING_3D: 0x806A;
    readonly UNPACK_SKIP_IMAGES: 0x806D;
    readonly UNPACK_IMAGE_HEIGHT: 0x806E;
    readonly TEXTURE_3D: 0x806F;
    readonly TEXTURE_WRAP_R: 0x8072;
    readonly MAX_3D_TEXTURE_SIZE: 0x8073;
    readonly UNSIGNED_INT_2_10_10_10_REV: 0x8368;
    readonly MAX_ELEMENTS_VERTICES: 0x80E8;
    readonly MAX_ELEMENTS_INDICES: 0x80E9;
    readonly TEXTURE_MIN_LOD: 0x813A;
    readonly TEXTURE_MAX_LOD: 0x813B;
    readonly TEXTURE_BASE_LEVEL: 0x813C;
    readonly TEXTURE_MAX_LEVEL: 0x813D;
    readonly MIN: 0x8007;
    readonly MAX: 0x8008;
    readonly DEPTH_COMPONENT24: 0x81A6;
    readonly MAX_TEXTURE_LOD_BIAS: 0x84FD;
    readonly TEXTURE_COMPARE_MODE: 0x884C;
    readonly TEXTURE_COMPARE_FUNC: 0x884D;
    readonly CURRENT_QUERY: 0x8865;
    readonly QUERY_RESULT: 0x8866;
    readonly QUERY_RESULT_AVAILABLE: 0x8867;
    readonly STREAM_READ: 0x88E1;
    readonly STREAM_COPY: 0x88E2;
    readonly STATIC_READ: 0x88E5;
    readonly STATIC_COPY: 0x88E6;
    readonly DYNAMIC_READ: 0x88E9;
    readonly DYNAMIC_COPY: 0x88EA;
    readonly MAX_DRAW_BUFFERS: 0x8824;
    readonly DRAW_BUFFER0: 0x8825;
    readonly DRAW_BUFFER1: 0x8826;
    readonly DRAW_BUFFER2: 0x8827;
    readonly DRAW_BUFFER3: 0x8828;
    readonly DRAW_BUFFER4: 0x8829;
    readonly DRAW_BUFFER5: 0x882A;
    readonly DRAW_BUFFER6: 0x882B;
    readonly DRAW_BUFFER7: 0x882C;
    readonly DRAW_BUFFER8: 0x882D;
    readonly DRAW_BUFFER9: 0x882E;
    readonly DRAW_BUFFER10: 0x882F;
    readonly DRAW_BUFFER11: 0x8830;
    readonly DRAW_BUFFER12: 0x8831;
    readonly DRAW_BUFFER13: 0x8832;
    readonly DRAW_BUFFER14: 0x8833;
    readonly DRAW_BUFFER15: 0x8834;
    readonly MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8B49;
    readonly MAX_VERTEX_UNIFORM_COMPONENTS: 0x8B4A;
    readonly SAMPLER_3D: 0x8B5F;
    readonly SAMPLER_2D_SHADOW: 0x8B62;
    readonly FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B;
    readonly PIXEL_PACK_BUFFER: 0x88EB;
    readonly PIXEL_UNPACK_BUFFER: 0x88EC;
    readonly PIXEL_PACK_BUFFER_BINDING: 0x88ED;
    readonly PIXEL_UNPACK_BUFFER_BINDING: 0x88EF;
    readonly FLOAT_MAT2x3: 0x8B65;
    readonly FLOAT_MAT2x4: 0x8B66;
    readonly FLOAT_MAT3x2: 0x8B67;
    readonly FLOAT_MAT3x4: 0x8B68;
    readonly FLOAT_MAT4x2: 0x8B69;
    readonly FLOAT_MAT4x3: 0x8B6A;
    readonly SRGB: 0x8C40;
    readonly SRGB8: 0x8C41;
    readonly SRGB8_ALPHA8: 0x8C43;
    readonly COMPARE_REF_TO_TEXTURE: 0x884E;
    readonly RGBA32F: 0x8814;
    readonly RGB32F: 0x8815;
    readonly RGBA16F: 0x881A;
    readonly RGB16F: 0x881B;
    readonly VERTEX_ATTRIB_ARRAY_INTEGER: 0x88FD;
    readonly MAX_ARRAY_TEXTURE_LAYERS: 0x88FF;
    readonly MIN_PROGRAM_TEXEL_OFFSET: 0x8904;
    readonly MAX_PROGRAM_TEXEL_OFFSET: 0x8905;
    readonly MAX_VARYING_COMPONENTS: 0x8B4B;
    readonly TEXTURE_2D_ARRAY: 0x8C1A;
    readonly TEXTURE_BINDING_2D_ARRAY: 0x8C1D;
    readonly R11F_G11F_B10F: 0x8C3A;
    readonly UNSIGNED_INT_10F_11F_11F_REV: 0x8C3B;
    readonly RGB9_E5: 0x8C3D;
    readonly UNSIGNED_INT_5_9_9_9_REV: 0x8C3E;
    readonly TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8C7F;
    readonly MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8C80;
    readonly TRANSFORM_FEEDBACK_VARYINGS: 0x8C83;
    readonly TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84;
    readonly TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85;
    readonly TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88;
    readonly RASTERIZER_DISCARD: 0x8C89;
    readonly MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A;
    readonly MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B;
    readonly INTERLEAVED_ATTRIBS: 0x8C8C;
    readonly SEPARATE_ATTRIBS: 0x8C8D;
    readonly TRANSFORM_FEEDBACK_BUFFER: 0x8C8E;
    readonly TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F;
    readonly RGBA32UI: 0x8D70;
    readonly RGB32UI: 0x8D71;
    readonly RGBA16UI: 0x8D76;
    readonly RGB16UI: 0x8D77;
    readonly RGBA8UI: 0x8D7C;
    readonly RGB8UI: 0x8D7D;
    readonly RGBA32I: 0x8D82;
    readonly RGB32I: 0x8D83;
    readonly RGBA16I: 0x8D88;
    readonly RGB16I: 0x8D89;
    readonly RGBA8I: 0x8D8E;
    readonly RGB8I: 0x8D8F;
    readonly RED_INTEGER: 0x8D94;
    readonly RGB_INTEGER: 0x8D98;
    readonly RGBA_INTEGER: 0x8D99;
    readonly SAMPLER_2D_ARRAY: 0x8DC1;
    readonly SAMPLER_2D_ARRAY_SHADOW: 0x8DC4;
    readonly SAMPLER_CUBE_SHADOW: 0x8DC5;
    readonly UNSIGNED_INT_VEC2: 0x8DC6;
    readonly UNSIGNED_INT_VEC3: 0x8DC7;
    readonly UNSIGNED_INT_VEC4: 0x8DC8;
    readonly INT_SAMPLER_2D: 0x8DCA;
    readonly INT_SAMPLER_3D: 0x8DCB;
    readonly INT_SAMPLER_CUBE: 0x8DCC;
    readonly INT_SAMPLER_2D_ARRAY: 0x8DCF;
    readonly UNSIGNED_INT_SAMPLER_2D: 0x8DD2;
    readonly UNSIGNED_INT_SAMPLER_3D: 0x8DD3;
    readonly UNSIGNED_INT_SAMPLER_CUBE: 0x8DD4;
    readonly UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7;
    readonly DEPTH_COMPONENT32F: 0x8CAC;
    readonly DEPTH32F_STENCIL8: 0x8CAD;
    readonly FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8DAD;
    readonly FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210;
    readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211;
    readonly FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212;
    readonly FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213;
    readonly FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214;
    readonly FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215;
    readonly FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216;
    readonly FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217;
    readonly FRAMEBUFFER_DEFAULT: 0x8218;
    readonly UNSIGNED_INT_24_8: 0x84FA;
    readonly DEPTH24_STENCIL8: 0x88F0;
    readonly UNSIGNED_NORMALIZED: 0x8C17;
    readonly DRAW_FRAMEBUFFER_BINDING: 0x8CA6;
    readonly READ_FRAMEBUFFER: 0x8CA8;
    readonly DRAW_FRAMEBUFFER: 0x8CA9;
    readonly READ_FRAMEBUFFER_BINDING: 0x8CAA;
    readonly RENDERBUFFER_SAMPLES: 0x8CAB;
    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8CD4;
    readonly MAX_COLOR_ATTACHMENTS: 0x8CDF;
    readonly COLOR_ATTACHMENT1: 0x8CE1;
    readonly COLOR_ATTACHMENT2: 0x8CE2;
    readonly COLOR_ATTACHMENT3: 0x8CE3;
    readonly COLOR_ATTACHMENT4: 0x8CE4;
    readonly COLOR_ATTACHMENT5: 0x8CE5;
    readonly COLOR_ATTACHMENT6: 0x8CE6;
    readonly COLOR_ATTACHMENT7: 0x8CE7;
    readonly COLOR_ATTACHMENT8: 0x8CE8;
    readonly COLOR_ATTACHMENT9: 0x8CE9;
    readonly COLOR_ATTACHMENT10: 0x8CEA;
    readonly COLOR_ATTACHMENT11: 0x8CEB;
    readonly COLOR_ATTACHMENT12: 0x8CEC;
    readonly COLOR_ATTACHMENT13: 0x8CED;
    readonly COLOR_ATTACHMENT14: 0x8CEE;
    readonly COLOR_ATTACHMENT15: 0x8CEF;
    readonly FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8D56;
    readonly MAX_SAMPLES: 0x8D57;
    readonly HALF_FLOAT: 0x140B;
    readonly RG: 0x8227;
    readonly RG_INTEGER: 0x8228;
    readonly R8: 0x8229;
    readonly RG8: 0x822B;
    readonly R16F: 0x822D;
    readonly R32F: 0x822E;
    readonly RG16F: 0x822F;
    readonly RG32F: 0x8230;
    readonly R8I: 0x8231;
    readonly R8UI: 0x8232;
    readonly R16I: 0x8233;
    readonly R16UI: 0x8234;
    readonly R32I: 0x8235;
    readonly R32UI: 0x8236;
    readonly RG8I: 0x8237;
    readonly RG8UI: 0x8238;
    readonly RG16I: 0x8239;
    readonly RG16UI: 0x823A;
    readonly RG32I: 0x823B;
    readonly RG32UI: 0x823C;
    readonly VERTEX_ARRAY_BINDING: 0x85B5;
    readonly R8_SNORM: 0x8F94;
    readonly RG8_SNORM: 0x8F95;
    readonly RGB8_SNORM: 0x8F96;
    readonly RGBA8_SNORM: 0x8F97;
    readonly SIGNED_NORMALIZED: 0x8F9C;
    readonly COPY_READ_BUFFER: 0x8F36;
    readonly COPY_WRITE_BUFFER: 0x8F37;
    readonly COPY_READ_BUFFER_BINDING: 0x8F36;
    readonly COPY_WRITE_BUFFER_BINDING: 0x8F37;
    readonly UNIFORM_BUFFER: 0x8A11;
    readonly UNIFORM_BUFFER_BINDING: 0x8A28;
    readonly UNIFORM_BUFFER_START: 0x8A29;
    readonly UNIFORM_BUFFER_SIZE: 0x8A2A;
    readonly MAX_VERTEX_UNIFORM_BLOCKS: 0x8A2B;
    readonly MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8A2D;
    readonly MAX_COMBINED_UNIFORM_BLOCKS: 0x8A2E;
    readonly MAX_UNIFORM_BUFFER_BINDINGS: 0x8A2F;
    readonly MAX_UNIFORM_BLOCK_SIZE: 0x8A30;
    readonly MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8A31;
    readonly MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8A33;
    readonly UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8A34;
    readonly ACTIVE_UNIFORM_BLOCKS: 0x8A36;
    readonly UNIFORM_TYPE: 0x8A37;
    readonly UNIFORM_SIZE: 0x8A38;
    readonly UNIFORM_BLOCK_INDEX: 0x8A3A;
    readonly UNIFORM_OFFSET: 0x8A3B;
    readonly UNIFORM_ARRAY_STRIDE: 0x8A3C;
    readonly UNIFORM_MATRIX_STRIDE: 0x8A3D;
    readonly UNIFORM_IS_ROW_MAJOR: 0x8A3E;
    readonly UNIFORM_BLOCK_BINDING: 0x8A3F;
    readonly UNIFORM_BLOCK_DATA_SIZE: 0x8A40;
    readonly UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42;
    readonly UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43;
    readonly UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44;
    readonly UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46;
    readonly INVALID_INDEX: 0xFFFFFFFF;
    readonly MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122;
    readonly MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125;
    readonly MAX_SERVER_WAIT_TIMEOUT: 0x9111;
    readonly OBJECT_TYPE: 0x9112;
    readonly SYNC_CONDITION: 0x9113;
    readonly SYNC_STATUS: 0x9114;
    readonly SYNC_FLAGS: 0x9115;
    readonly SYNC_FENCE: 0x9116;
    readonly SYNC_GPU_COMMANDS_COMPLETE: 0x9117;
    readonly UNSIGNALED: 0x9118;
    readonly SIGNALED: 0x9119;
    readonly ALREADY_SIGNALED: 0x911A;
    readonly TIMEOUT_EXPIRED: 0x911B;
    readonly CONDITION_SATISFIED: 0x911C;
    readonly WAIT_FAILED: 0x911D;
    readonly SYNC_FLUSH_COMMANDS_BIT: 0x00000001;
    readonly VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88FE;
    readonly ANY_SAMPLES_PASSED: 0x8C2F;
    readonly ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8D6A;
    readonly SAMPLER_BINDING: 0x8919;
    readonly RGB10_A2UI: 0x906F;
    readonly INT_2_10_10_10_REV: 0x8D9F;
    readonly TRANSFORM_FEEDBACK: 0x8E22;
    readonly TRANSFORM_FEEDBACK_PAUSED: 0x8E23;
    readonly TRANSFORM_FEEDBACK_ACTIVE: 0x8E24;
    readonly TRANSFORM_FEEDBACK_BINDING: 0x8E25;
    readonly TEXTURE_IMMUTABLE_FORMAT: 0x912F;
    readonly MAX_ELEMENT_INDEX: 0x8D6B;
    readonly TEXTURE_IMMUTABLE_LEVELS: 0x82DF;
    readonly TIMEOUT_IGNORED: -1;
    readonly MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247;
    readonly DEPTH_BUFFER_BIT: 0x00000100;
    readonly STENCIL_BUFFER_BIT: 0x00000400;
    readonly COLOR_BUFFER_BIT: 0x00004000;
    readonly POINTS: 0x0000;
    readonly LINES: 0x0001;
    readonly LINE_LOOP: 0x0002;
    readonly LINE_STRIP: 0x0003;
    readonly TRIANGLES: 0x0004;
    readonly TRIANGLE_STRIP: 0x0005;
    readonly TRIANGLE_FAN: 0x0006;
    readonly ZERO: 0;
    readonly ONE: 1;
    readonly SRC_COLOR: 0x0300;
    readonly ONE_MINUS_SRC_COLOR: 0x0301;
    readonly SRC_ALPHA: 0x0302;
    readonly ONE_MINUS_SRC_ALPHA: 0x0303;
    readonly DST_ALPHA: 0x0304;
    readonly ONE_MINUS_DST_ALPHA: 0x0305;
    readonly DST_COLOR: 0x0306;
    readonly ONE_MINUS_DST_COLOR: 0x0307;
    readonly SRC_ALPHA_SATURATE: 0x0308;
    readonly FUNC_ADD: 0x8006;
    readonly BLEND_EQUATION: 0x8009;
    readonly BLEND_EQUATION_RGB: 0x8009;
    readonly BLEND_EQUATION_ALPHA: 0x883D;
    readonly FUNC_SUBTRACT: 0x800A;
    readonly FUNC_REVERSE_SUBTRACT: 0x800B;
    readonly BLEND_DST_RGB: 0x80C8;
    readonly BLEND_SRC_RGB: 0x80C9;
    readonly BLEND_DST_ALPHA: 0x80CA;
    readonly BLEND_SRC_ALPHA: 0x80CB;
    readonly CONSTANT_COLOR: 0x8001;
    readonly ONE_MINUS_CONSTANT_COLOR: 0x8002;
    readonly CONSTANT_ALPHA: 0x8003;
    readonly ONE_MINUS_CONSTANT_ALPHA: 0x8004;
    readonly BLEND_COLOR: 0x8005;
    readonly ARRAY_BUFFER: 0x8892;
    readonly ELEMENT_ARRAY_BUFFER: 0x8893;
    readonly ARRAY_BUFFER_BINDING: 0x8894;
    readonly ELEMENT_ARRAY_BUFFER_BINDING: 0x8895;
    readonly STREAM_DRAW: 0x88E0;
    readonly STATIC_DRAW: 0x88E4;
    readonly DYNAMIC_DRAW: 0x88E8;
    readonly BUFFER_SIZE: 0x8764;
    readonly BUFFER_USAGE: 0x8765;
    readonly CURRENT_VERTEX_ATTRIB: 0x8626;
    readonly FRONT: 0x0404;
    readonly BACK: 0x0405;
    readonly FRONT_AND_BACK: 0x0408;
    readonly CULL_FACE: 0x0B44;
    readonly BLEND: 0x0BE2;
    readonly DITHER: 0x0BD0;
    readonly STENCIL_TEST: 0x0B90;
    readonly DEPTH_TEST: 0x0B71;
    readonly SCISSOR_TEST: 0x0C11;
    readonly POLYGON_OFFSET_FILL: 0x8037;
    readonly SAMPLE_ALPHA_TO_COVERAGE: 0x809E;
    readonly SAMPLE_COVERAGE: 0x80A0;
    readonly NO_ERROR: 0;
    readonly INVALID_ENUM: 0x0500;
    readonly INVALID_VALUE: 0x0501;
    readonly INVALID_OPERATION: 0x0502;
    readonly OUT_OF_MEMORY: 0x0505;
    readonly CW: 0x0900;
    readonly CCW: 0x0901;
    readonly LINE_WIDTH: 0x0B21;
    readonly ALIASED_POINT_SIZE_RANGE: 0x846D;
    readonly ALIASED_LINE_WIDTH_RANGE: 0x846E;
    readonly CULL_FACE_MODE: 0x0B45;
    readonly FRONT_FACE: 0x0B46;
    readonly DEPTH_RANGE: 0x0B70;
    readonly DEPTH_WRITEMASK: 0x0B72;
    readonly DEPTH_CLEAR_VALUE: 0x0B73;
    readonly DEPTH_FUNC: 0x0B74;
    readonly STENCIL_CLEAR_VALUE: 0x0B91;
    readonly STENCIL_FUNC: 0x0B92;
    readonly STENCIL_FAIL: 0x0B94;
    readonly STENCIL_PASS_DEPTH_FAIL: 0x0B95;
    readonly STENCIL_PASS_DEPTH_PASS: 0x0B96;
    readonly STENCIL_REF: 0x0B97;
    readonly STENCIL_VALUE_MASK: 0x0B93;
    readonly STENCIL_WRITEMASK: 0x0B98;
    readonly STENCIL_BACK_FUNC: 0x8800;
    readonly STENCIL_BACK_FAIL: 0x8801;
    readonly STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802;
    readonly STENCIL_BACK_PASS_DEPTH_PASS: 0x8803;
    readonly STENCIL_BACK_REF: 0x8CA3;
    readonly STENCIL_BACK_VALUE_MASK: 0x8CA4;
    readonly STENCIL_BACK_WRITEMASK: 0x8CA5;
    readonly VIEWPORT: 0x0BA2;
    readonly SCISSOR_BOX: 0x0C10;
    readonly COLOR_CLEAR_VALUE: 0x0C22;
    readonly COLOR_WRITEMASK: 0x0C23;
    readonly UNPACK_ALIGNMENT: 0x0CF5;
    readonly PACK_ALIGNMENT: 0x0D05;
    readonly MAX_TEXTURE_SIZE: 0x0D33;
    readonly MAX_VIEWPORT_DIMS: 0x0D3A;
    readonly SUBPIXEL_BITS: 0x0D50;
    readonly RED_BITS: 0x0D52;
    readonly GREEN_BITS: 0x0D53;
    readonly BLUE_BITS: 0x0D54;
    readonly ALPHA_BITS: 0x0D55;
    readonly DEPTH_BITS: 0x0D56;
    readonly STENCIL_BITS: 0x0D57;
    readonly POLYGON_OFFSET_UNITS: 0x2A00;
    readonly POLYGON_OFFSET_FACTOR: 0x8038;
    readonly TEXTURE_BINDING_2D: 0x8069;
    readonly SAMPLE_BUFFERS: 0x80A8;
    readonly SAMPLES: 0x80A9;
    readonly SAMPLE_COVERAGE_VALUE: 0x80AA;
    readonly SAMPLE_COVERAGE_INVERT: 0x80AB;
    readonly COMPRESSED_TEXTURE_FORMATS: 0x86A3;
    readonly DONT_CARE: 0x1100;
    readonly FASTEST: 0x1101;
    readonly NICEST: 0x1102;
    readonly GENERATE_MIPMAP_HINT: 0x8192;
    readonly BYTE: 0x1400;
    readonly UNSIGNED_BYTE: 0x1401;
    readonly SHORT: 0x1402;
    readonly UNSIGNED_SHORT: 0x1403;
    readonly INT: 0x1404;
    readonly UNSIGNED_INT: 0x1405;
    readonly FLOAT: 0x1406;
    readonly DEPTH_COMPONENT: 0x1902;
    readonly ALPHA: 0x1906;
    readonly RGB: 0x1907;
    readonly RGBA: 0x1908;
    readonly LUMINANCE: 0x1909;
    readonly LUMINANCE_ALPHA: 0x190A;
    readonly UNSIGNED_SHORT_4_4_4_4: 0x8033;
    readonly UNSIGNED_SHORT_5_5_5_1: 0x8034;
    readonly UNSIGNED_SHORT_5_6_5: 0x8363;
    readonly FRAGMENT_SHADER: 0x8B30;
    readonly VERTEX_SHADER: 0x8B31;
    readonly MAX_VERTEX_ATTRIBS: 0x8869;
    readonly MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB;
    readonly MAX_VARYING_VECTORS: 0x8DFC;
    readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D;
    readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C;
    readonly MAX_TEXTURE_IMAGE_UNITS: 0x8872;
    readonly MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD;
    readonly SHADER_TYPE: 0x8B4F;
    readonly DELETE_STATUS: 0x8B80;
    readonly LINK_STATUS: 0x8B82;
    readonly VALIDATE_STATUS: 0x8B83;
    readonly ATTACHED_SHADERS: 0x8B85;
    readonly ACTIVE_UNIFORMS: 0x8B86;
    readonly ACTIVE_ATTRIBUTES: 0x8B89;
    readonly SHADING_LANGUAGE_VERSION: 0x8B8C;
    readonly CURRENT_PROGRAM: 0x8B8D;
    readonly NEVER: 0x0200;
    readonly LESS: 0x0201;
    readonly EQUAL: 0x0202;
    readonly LEQUAL: 0x0203;
    readonly GREATER: 0x0204;
    readonly NOTEQUAL: 0x0205;
    readonly GEQUAL: 0x0206;
    readonly ALWAYS: 0x0207;
    readonly KEEP: 0x1E00;
    readonly REPLACE: 0x1E01;
    readonly INCR: 0x1E02;
    readonly DECR: 0x1E03;
    readonly INVERT: 0x150A;
    readonly INCR_WRAP: 0x8507;
    readonly DECR_WRAP: 0x8508;
    readonly VENDOR: 0x1F00;
    readonly RENDERER: 0x1F01;
    readonly VERSION: 0x1F02;
    readonly NEAREST: 0x2600;
    readonly LINEAR: 0x2601;
    readonly NEAREST_MIPMAP_NEAREST: 0x2700;
    readonly LINEAR_MIPMAP_NEAREST: 0x2701;
    readonly NEAREST_MIPMAP_LINEAR: 0x2702;
    readonly LINEAR_MIPMAP_LINEAR: 0x2703;
    readonly TEXTURE_MAG_FILTER: 0x2800;
    readonly TEXTURE_MIN_FILTER: 0x2801;
    readonly TEXTURE_WRAP_S: 0x2802;
    readonly TEXTURE_WRAP_T: 0x2803;
    readonly TEXTURE_2D: 0x0DE1;
    readonly TEXTURE: 0x1702;
    readonly TEXTURE_CUBE_MAP: 0x8513;
    readonly TEXTURE_BINDING_CUBE_MAP: 0x8514;
    readonly TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515;
    readonly TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516;
    readonly TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517;
    readonly TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518;
    readonly TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519;
    readonly TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A;
    readonly MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C;
    readonly TEXTURE0: 0x84C0;
    readonly TEXTURE1: 0x84C1;
    readonly TEXTURE2: 0x84C2;
    readonly TEXTURE3: 0x84C3;
    readonly TEXTURE4: 0x84C4;
    readonly TEXTURE5: 0x84C5;
    readonly TEXTURE6: 0x84C6;
    readonly TEXTURE7: 0x84C7;
    readonly TEXTURE8: 0x84C8;
    readonly TEXTURE9: 0x84C9;
    readonly TEXTURE10: 0x84CA;
    readonly TEXTURE11: 0x84CB;
    readonly TEXTURE12: 0x84CC;
    readonly TEXTURE13: 0x84CD;
    readonly TEXTURE14: 0x84CE;
    readonly TEXTURE15: 0x84CF;
    readonly TEXTURE16: 0x84D0;
    readonly TEXTURE17: 0x84D1;
    readonly TEXTURE18: 0x84D2;
    readonly TEXTURE19: 0x84D3;
    readonly TEXTURE20: 0x84D4;
    readonly TEXTURE21: 0x84D5;
    readonly TEXTURE22: 0x84D6;
    readonly TEXTURE23: 0x84D7;
    readonly TEXTURE24: 0x84D8;
    readonly TEXTURE25: 0x84D9;
    readonly TEXTURE26: 0x84DA;
    readonly TEXTURE27: 0x84DB;
    readonly TEXTURE28: 0x84DC;
    readonly TEXTURE29: 0x84DD;
    readonly TEXTURE30: 0x84DE;
    readonly TEXTURE31: 0x84DF;
    readonly ACTIVE_TEXTURE: 0x84E0;
    readonly REPEAT: 0x2901;
    readonly CLAMP_TO_EDGE: 0x812F;
    readonly MIRRORED_REPEAT: 0x8370;
    readonly FLOAT_VEC2: 0x8B50;
    readonly FLOAT_VEC3: 0x8B51;
    readonly FLOAT_VEC4: 0x8B52;
    readonly INT_VEC2: 0x8B53;
    readonly INT_VEC3: 0x8B54;
    readonly INT_VEC4: 0x8B55;
    readonly BOOL: 0x8B56;
    readonly BOOL_VEC2: 0x8B57;
    readonly BOOL_VEC3: 0x8B58;
    readonly BOOL_VEC4: 0x8B59;
    readonly FLOAT_MAT2: 0x8B5A;
    readonly FLOAT_MAT3: 0x8B5B;
    readonly FLOAT_MAT4: 0x8B5C;
    readonly SAMPLER_2D: 0x8B5E;
    readonly SAMPLER_CUBE: 0x8B60;
    readonly VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622;
    readonly VERTEX_ATTRIB_ARRAY_SIZE: 0x8623;
    readonly VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624;
    readonly VERTEX_ATTRIB_ARRAY_TYPE: 0x8625;
    readonly VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A;
    readonly VERTEX_ATTRIB_ARRAY_POINTER: 0x8645;
    readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F;
    readonly IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A;
    readonly IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B;
    readonly COMPILE_STATUS: 0x8B81;
    readonly LOW_FLOAT: 0x8DF0;
    readonly MEDIUM_FLOAT: 0x8DF1;
    readonly HIGH_FLOAT: 0x8DF2;
    readonly LOW_INT: 0x8DF3;
    readonly MEDIUM_INT: 0x8DF4;
    readonly HIGH_INT: 0x8DF5;
    readonly FRAMEBUFFER: 0x8D40;
    readonly RENDERBUFFER: 0x8D41;
    readonly RGBA4: 0x8056;
    readonly RGB5_A1: 0x8057;
    readonly RGB565: 0x8D62;
    readonly DEPTH_COMPONENT16: 0x81A5;
    readonly STENCIL_INDEX8: 0x8D48;
    readonly DEPTH_STENCIL: 0x84F9;
    readonly RENDERBUFFER_WIDTH: 0x8D42;
    readonly RENDERBUFFER_HEIGHT: 0x8D43;
    readonly RENDERBUFFER_INTERNAL_FORMAT: 0x8D44;
    readonly RENDERBUFFER_RED_SIZE: 0x8D50;
    readonly RENDERBUFFER_GREEN_SIZE: 0x8D51;
    readonly RENDERBUFFER_BLUE_SIZE: 0x8D52;
    readonly RENDERBUFFER_ALPHA_SIZE: 0x8D53;
    readonly RENDERBUFFER_DEPTH_SIZE: 0x8D54;
    readonly RENDERBUFFER_STENCIL_SIZE: 0x8D55;
    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0;
    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1;
    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2;
    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3;
    readonly COLOR_ATTACHMENT0: 0x8CE0;
    readonly DEPTH_ATTACHMENT: 0x8D00;
    readonly STENCIL_ATTACHMENT: 0x8D20;
    readonly DEPTH_STENCIL_ATTACHMENT: 0x821A;
    readonly NONE: 0;
    readonly FRAMEBUFFER_COMPLETE: 0x8CD5;
    readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6;
    readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7;
    readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9;
    readonly FRAMEBUFFER_UNSUPPORTED: 0x8CDD;
    readonly FRAMEBUFFER_BINDING: 0x8CA6;
    readonly RENDERBUFFER_BINDING: 0x8CA7;
    readonly MAX_RENDERBUFFER_SIZE: 0x84E8;
    readonly INVALID_FRAMEBUFFER_OPERATION: 0x0506;
    readonly UNPACK_FLIP_Y_WEBGL: 0x9240;
    readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241;
    readonly CONTEXT_LOST_WEBGL: 0x9242;
    readonly UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243;
    readonly BROWSER_DEFAULT_WEBGL: 0x9244;
    isInstance: IsInstance<WebGL2RenderingContext>;
};

interface WebGL2RenderingContextBase {
    beginQuery(target: GLenum, query: WebGLQuery): void;
    beginTransformFeedback(primitiveMode: GLenum): void;
    bindBufferBase(target: GLenum, index: GLuint, buffer: WebGLBuffer | null): void;
    bindBufferRange(target: GLenum, index: GLuint, buffer: WebGLBuffer | null, offset: GLintptr, size: GLsizeiptr): void;
    bindSampler(unit: GLuint, sampler: WebGLSampler | null): void;
    bindTransformFeedback(target: GLenum, tf: WebGLTransformFeedback | null): void;
    bindVertexArray(array: WebGLVertexArrayObject | null): void;
    blitFramebuffer(srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum): void;
    bufferData(target: GLenum, size: GLsizeiptr, usage: GLenum): void;
    bufferData(target: GLenum, srcData: ArrayBuffer | null, usage: GLenum): void;
    bufferData(target: GLenum, srcData: ArrayBufferView, usage: GLenum): void;
    bufferData(target: GLenum, srcData: ArrayBufferView, usage: GLenum, srcOffset: GLuint, length?: GLuint): void;
    bufferSubData(target: GLenum, offset: GLintptr, srcData: ArrayBuffer): void;
    bufferSubData(target: GLenum, offset: GLintptr, srcData: ArrayBufferView): void;
    bufferSubData(target: GLenum, dstByteOffset: GLintptr, srcData: ArrayBufferView, srcOffset: GLuint, length?: GLuint): void;
    clearBufferfi(buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint): void;
    clearBufferfv(buffer: GLenum, drawbuffer: GLint, values: Float32List, srcOffset?: GLuint): void;
    clearBufferiv(buffer: GLenum, drawbuffer: GLint, values: Int32List, srcOffset?: GLuint): void;
    clearBufferuiv(buffer: GLenum, drawbuffer: GLint, values: Uint32List, srcOffset?: GLuint): void;
    clientWaitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLuint64): GLenum;
    compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr): void;
    compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, srcData: ArrayBufferView, srcOffset?: GLuint, srcLengthOverride?: GLuint): void;
    compressedTexImage3D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr): void;
    compressedTexImage3D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, srcData: ArrayBufferView, srcOffset?: GLuint, srcLengthOverride?: GLuint): void;
    compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, offset: GLintptr): void;
    compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, srcData: ArrayBufferView, srcOffset?: GLuint, srcLengthOverride?: GLuint): void;
    compressedTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, offset: GLintptr): void;
    compressedTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, srcData: ArrayBufferView, srcOffset?: GLuint, srcLengthOverride?: GLuint): void;
    copyBufferSubData(readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr): void;
    copyTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
    createQuery(): WebGLQuery;
    createSampler(): WebGLSampler;
    createTransformFeedback(): WebGLTransformFeedback;
    createVertexArray(): WebGLVertexArrayObject;
    deleteQuery(query: WebGLQuery | null): void;
    deleteSampler(sampler: WebGLSampler | null): void;
    deleteSync(sync: WebGLSync | null): void;
    deleteTransformFeedback(tf: WebGLTransformFeedback | null): void;
    deleteVertexArray(vertexArray: WebGLVertexArrayObject | null): void;
    drawArraysInstanced(mode: GLenum, first: GLint, count: GLsizei, instanceCount: GLsizei): void;
    drawBuffers(buffers: GLenum[]): void;
    drawElementsInstanced(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, instanceCount: GLsizei): void;
    drawRangeElements(mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type: GLenum, offset: GLintptr): void;
    endQuery(target: GLenum): void;
    endTransformFeedback(): void;
    fenceSync(condition: GLenum, flags: GLbitfield): WebGLSync | null;
    framebufferTextureLayer(target: GLenum, attachment: GLenum, texture: WebGLTexture | null, level: GLint, layer: GLint): void;
    getActiveUniformBlockName(program: WebGLProgram, uniformBlockIndex: GLuint): string | null;
    getActiveUniformBlockParameter(program: WebGLProgram, uniformBlockIndex: GLuint, pname: GLenum): any;
    getActiveUniforms(program: WebGLProgram, uniformIndices: GLuint[], pname: GLenum): any;
    getBufferSubData(target: GLenum, srcByteOffset: GLintptr, dstData: ArrayBufferView, dstOffset?: GLuint, length?: GLuint): void;
    getFragDataLocation(program: WebGLProgram, name: string): GLint;
    getIndexedParameter(target: GLenum, index: GLuint): any;
    getInternalformatParameter(target: GLenum, internalformat: GLenum, pname: GLenum): any;
    getQuery(target: GLenum, pname: GLenum): any;
    getQueryParameter(query: WebGLQuery, pname: GLenum): any;
    getSamplerParameter(sampler: WebGLSampler, pname: GLenum): any;
    getSyncParameter(sync: WebGLSync, pname: GLenum): any;
    getTransformFeedbackVarying(program: WebGLProgram, index: GLuint): WebGLActiveInfo | null;
    getUniformBlockIndex(program: WebGLProgram, uniformBlockName: string): GLuint;
    getUniformIndices(program: WebGLProgram, uniformNames: string[]): GLuint[] | null;
    invalidateFramebuffer(target: GLenum, attachments: GLenum[]): void;
    invalidateSubFramebuffer(target: GLenum, attachments: GLenum[], x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
    isQuery(query: WebGLQuery | null): GLboolean;
    isSampler(sampler: WebGLSampler | null): GLboolean;
    isSync(sync: WebGLSync | null): GLboolean;
    isTransformFeedback(tf: WebGLTransformFeedback | null): GLboolean;
    isVertexArray(vertexArray: WebGLVertexArrayObject | null): GLboolean;
    pauseTransformFeedback(): void;
    readBuffer(src: GLenum): void;
    readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, dstData: ArrayBufferView | null): void;
    readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, offset: GLintptr): void;
    readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, dstData: ArrayBufferView, dstOffset: GLuint): void;
    renderbufferStorageMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void;
    resumeTransformFeedback(): void;
    samplerParameterf(sampler: WebGLSampler, pname: GLenum, param: GLfloat): void;
    samplerParameteri(sampler: WebGLSampler, pname: GLenum, param: GLint): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pixels: ArrayBufferView | null): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: HTMLCanvasElement): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: HTMLImageElement): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: HTMLVideoElement): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: ImageBitmap): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: ImageData): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: OffscreenCanvas): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: VideoFrame): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pboOffset: GLintptr): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, source: HTMLCanvasElement): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, source: HTMLImageElement): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, source: HTMLVideoElement): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, source: ImageBitmap): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, source: ImageData): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, source: OffscreenCanvas): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, source: VideoFrame): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, srcData: ArrayBufferView, srcOffset: GLuint): void;
    texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, pboOffset: GLintptr): void;
    texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, source: HTMLCanvasElement): void;
    texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, source: HTMLImageElement): void;
    texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, source: HTMLVideoElement): void;
    texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, source: ImageBitmap): void;
    texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, source: ImageData): void;
    texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, source: OffscreenCanvas): void;
    texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, source: VideoFrame): void;
    texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, srcData: ArrayBufferView | null): void;
    texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, srcData: ArrayBufferView, srcOffset: GLuint): void;
    texStorage2D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void;
    texStorage3D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView | null): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: HTMLCanvasElement): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: HTMLImageElement): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: HTMLVideoElement): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: ImageBitmap): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: ImageData): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: OffscreenCanvas): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: VideoFrame): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pboOffset: GLintptr): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, source: HTMLCanvasElement): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, source: HTMLImageElement): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, source: HTMLVideoElement): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, source: ImageBitmap): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, source: ImageData): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, source: OffscreenCanvas): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, source: VideoFrame): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, srcData: ArrayBufferView, srcOffset: GLuint): void;
    texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, pboOffset: GLintptr): void;
    texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, source: HTMLCanvasElement): void;
    texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, source: HTMLImageElement): void;
    texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, source: HTMLVideoElement): void;
    texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, source: ImageBitmap): void;
    texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, source: ImageData): void;
    texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, source: OffscreenCanvas): void;
    texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, source: VideoFrame): void;
    texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, srcData: ArrayBufferView | null, srcOffset?: GLuint): void;
    transformFeedbackVaryings(program: WebGLProgram, varyings: string[], bufferMode: GLenum): void;
    uniform1fv(location: WebGLUniformLocation | null, data: Float32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform1iv(location: WebGLUniformLocation | null, data: Int32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform1ui(location: WebGLUniformLocation | null, v0: GLuint): void;
    uniform1uiv(location: WebGLUniformLocation | null, data: Uint32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform2fv(location: WebGLUniformLocation | null, data: Float32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform2iv(location: WebGLUniformLocation | null, data: Int32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform2ui(location: WebGLUniformLocation | null, v0: GLuint, v1: GLuint): void;
    uniform2uiv(location: WebGLUniformLocation | null, data: Uint32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform3fv(location: WebGLUniformLocation | null, data: Float32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform3iv(location: WebGLUniformLocation | null, data: Int32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform3ui(location: WebGLUniformLocation | null, v0: GLuint, v1: GLuint, v2: GLuint): void;
    uniform3uiv(location: WebGLUniformLocation | null, data: Uint32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform4fv(location: WebGLUniformLocation | null, data: Float32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform4iv(location: WebGLUniformLocation | null, data: Int32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform4ui(location: WebGLUniformLocation | null, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint): void;
    uniform4uiv(location: WebGLUniformLocation | null, data: Uint32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint): void;
    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Float32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix2x3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Float32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix2x4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Float32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Float32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix3x2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Float32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix3x4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Float32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Float32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix4x2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Float32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix4x3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Float32List, srcOffset?: GLuint, srcLength?: GLuint): void;
    vertexAttribDivisor(index: GLuint, divisor: GLuint): void;
    vertexAttribI4i(index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint): void;
    vertexAttribI4iv(index: GLuint, values: Int32List): void;
    vertexAttribI4ui(index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint): void;
    vertexAttribI4uiv(index: GLuint, values: Uint32List): void;
    vertexAttribIPointer(index: GLuint, size: GLint, type: GLenum, stride: GLsizei, offset: GLintptr): void;
    waitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLint64): void;
    readonly READ_BUFFER: 0x0C02;
    readonly UNPACK_ROW_LENGTH: 0x0CF2;
    readonly UNPACK_SKIP_ROWS: 0x0CF3;
    readonly UNPACK_SKIP_PIXELS: 0x0CF4;
    readonly PACK_ROW_LENGTH: 0x0D02;
    readonly PACK_SKIP_ROWS: 0x0D03;
    readonly PACK_SKIP_PIXELS: 0x0D04;
    readonly COLOR: 0x1800;
    readonly DEPTH: 0x1801;
    readonly STENCIL: 0x1802;
    readonly RED: 0x1903;
    readonly RGB8: 0x8051;
    readonly RGBA8: 0x8058;
    readonly RGB10_A2: 0x8059;
    readonly TEXTURE_BINDING_3D: 0x806A;
    readonly UNPACK_SKIP_IMAGES: 0x806D;
    readonly UNPACK_IMAGE_HEIGHT: 0x806E;
    readonly TEXTURE_3D: 0x806F;
    readonly TEXTURE_WRAP_R: 0x8072;
    readonly MAX_3D_TEXTURE_SIZE: 0x8073;
    readonly UNSIGNED_INT_2_10_10_10_REV: 0x8368;
    readonly MAX_ELEMENTS_VERTICES: 0x80E8;
    readonly MAX_ELEMENTS_INDICES: 0x80E9;
    readonly TEXTURE_MIN_LOD: 0x813A;
    readonly TEXTURE_MAX_LOD: 0x813B;
    readonly TEXTURE_BASE_LEVEL: 0x813C;
    readonly TEXTURE_MAX_LEVEL: 0x813D;
    readonly MIN: 0x8007;
    readonly MAX: 0x8008;
    readonly DEPTH_COMPONENT24: 0x81A6;
    readonly MAX_TEXTURE_LOD_BIAS: 0x84FD;
    readonly TEXTURE_COMPARE_MODE: 0x884C;
    readonly TEXTURE_COMPARE_FUNC: 0x884D;
    readonly CURRENT_QUERY: 0x8865;
    readonly QUERY_RESULT: 0x8866;
    readonly QUERY_RESULT_AVAILABLE: 0x8867;
    readonly STREAM_READ: 0x88E1;
    readonly STREAM_COPY: 0x88E2;
    readonly STATIC_READ: 0x88E5;
    readonly STATIC_COPY: 0x88E6;
    readonly DYNAMIC_READ: 0x88E9;
    readonly DYNAMIC_COPY: 0x88EA;
    readonly MAX_DRAW_BUFFERS: 0x8824;
    readonly DRAW_BUFFER0: 0x8825;
    readonly DRAW_BUFFER1: 0x8826;
    readonly DRAW_BUFFER2: 0x8827;
    readonly DRAW_BUFFER3: 0x8828;
    readonly DRAW_BUFFER4: 0x8829;
    readonly DRAW_BUFFER5: 0x882A;
    readonly DRAW_BUFFER6: 0x882B;
    readonly DRAW_BUFFER7: 0x882C;
    readonly DRAW_BUFFER8: 0x882D;
    readonly DRAW_BUFFER9: 0x882E;
    readonly DRAW_BUFFER10: 0x882F;
    readonly DRAW_BUFFER11: 0x8830;
    readonly DRAW_BUFFER12: 0x8831;
    readonly DRAW_BUFFER13: 0x8832;
    readonly DRAW_BUFFER14: 0x8833;
    readonly DRAW_BUFFER15: 0x8834;
    readonly MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8B49;
    readonly MAX_VERTEX_UNIFORM_COMPONENTS: 0x8B4A;
    readonly SAMPLER_3D: 0x8B5F;
    readonly SAMPLER_2D_SHADOW: 0x8B62;
    readonly FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B;
    readonly PIXEL_PACK_BUFFER: 0x88EB;
    readonly PIXEL_UNPACK_BUFFER: 0x88EC;
    readonly PIXEL_PACK_BUFFER_BINDING: 0x88ED;
    readonly PIXEL_UNPACK_BUFFER_BINDING: 0x88EF;
    readonly FLOAT_MAT2x3: 0x8B65;
    readonly FLOAT_MAT2x4: 0x8B66;
    readonly FLOAT_MAT3x2: 0x8B67;
    readonly FLOAT_MAT3x4: 0x8B68;
    readonly FLOAT_MAT4x2: 0x8B69;
    readonly FLOAT_MAT4x3: 0x8B6A;
    readonly SRGB: 0x8C40;
    readonly SRGB8: 0x8C41;
    readonly SRGB8_ALPHA8: 0x8C43;
    readonly COMPARE_REF_TO_TEXTURE: 0x884E;
    readonly RGBA32F: 0x8814;
    readonly RGB32F: 0x8815;
    readonly RGBA16F: 0x881A;
    readonly RGB16F: 0x881B;
    readonly VERTEX_ATTRIB_ARRAY_INTEGER: 0x88FD;
    readonly MAX_ARRAY_TEXTURE_LAYERS: 0x88FF;
    readonly MIN_PROGRAM_TEXEL_OFFSET: 0x8904;
    readonly MAX_PROGRAM_TEXEL_OFFSET: 0x8905;
    readonly MAX_VARYING_COMPONENTS: 0x8B4B;
    readonly TEXTURE_2D_ARRAY: 0x8C1A;
    readonly TEXTURE_BINDING_2D_ARRAY: 0x8C1D;
    readonly R11F_G11F_B10F: 0x8C3A;
    readonly UNSIGNED_INT_10F_11F_11F_REV: 0x8C3B;
    readonly RGB9_E5: 0x8C3D;
    readonly UNSIGNED_INT_5_9_9_9_REV: 0x8C3E;
    readonly TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8C7F;
    readonly MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8C80;
    readonly TRANSFORM_FEEDBACK_VARYINGS: 0x8C83;
    readonly TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84;
    readonly TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85;
    readonly TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88;
    readonly RASTERIZER_DISCARD: 0x8C89;
    readonly MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A;
    readonly MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B;
    readonly INTERLEAVED_ATTRIBS: 0x8C8C;
    readonly SEPARATE_ATTRIBS: 0x8C8D;
    readonly TRANSFORM_FEEDBACK_BUFFER: 0x8C8E;
    readonly TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F;
    readonly RGBA32UI: 0x8D70;
    readonly RGB32UI: 0x8D71;
    readonly RGBA16UI: 0x8D76;
    readonly RGB16UI: 0x8D77;
    readonly RGBA8UI: 0x8D7C;
    readonly RGB8UI: 0x8D7D;
    readonly RGBA32I: 0x8D82;
    readonly RGB32I: 0x8D83;
    readonly RGBA16I: 0x8D88;
    readonly RGB16I: 0x8D89;
    readonly RGBA8I: 0x8D8E;
    readonly RGB8I: 0x8D8F;
    readonly RED_INTEGER: 0x8D94;
    readonly RGB_INTEGER: 0x8D98;
    readonly RGBA_INTEGER: 0x8D99;
    readonly SAMPLER_2D_ARRAY: 0x8DC1;
    readonly SAMPLER_2D_ARRAY_SHADOW: 0x8DC4;
    readonly SAMPLER_CUBE_SHADOW: 0x8DC5;
    readonly UNSIGNED_INT_VEC2: 0x8DC6;
    readonly UNSIGNED_INT_VEC3: 0x8DC7;
    readonly UNSIGNED_INT_VEC4: 0x8DC8;
    readonly INT_SAMPLER_2D: 0x8DCA;
    readonly INT_SAMPLER_3D: 0x8DCB;
    readonly INT_SAMPLER_CUBE: 0x8DCC;
    readonly INT_SAMPLER_2D_ARRAY: 0x8DCF;
    readonly UNSIGNED_INT_SAMPLER_2D: 0x8DD2;
    readonly UNSIGNED_INT_SAMPLER_3D: 0x8DD3;
    readonly UNSIGNED_INT_SAMPLER_CUBE: 0x8DD4;
    readonly UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7;
    readonly DEPTH_COMPONENT32F: 0x8CAC;
    readonly DEPTH32F_STENCIL8: 0x8CAD;
    readonly FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8DAD;
    readonly FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210;
    readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211;
    readonly FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212;
    readonly FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213;
    readonly FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214;
    readonly FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215;
    readonly FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216;
    readonly FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217;
    readonly FRAMEBUFFER_DEFAULT: 0x8218;
    readonly UNSIGNED_INT_24_8: 0x84FA;
    readonly DEPTH24_STENCIL8: 0x88F0;
    readonly UNSIGNED_NORMALIZED: 0x8C17;
    readonly DRAW_FRAMEBUFFER_BINDING: 0x8CA6;
    readonly READ_FRAMEBUFFER: 0x8CA8;
    readonly DRAW_FRAMEBUFFER: 0x8CA9;
    readonly READ_FRAMEBUFFER_BINDING: 0x8CAA;
    readonly RENDERBUFFER_SAMPLES: 0x8CAB;
    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8CD4;
    readonly MAX_COLOR_ATTACHMENTS: 0x8CDF;
    readonly COLOR_ATTACHMENT1: 0x8CE1;
    readonly COLOR_ATTACHMENT2: 0x8CE2;
    readonly COLOR_ATTACHMENT3: 0x8CE3;
    readonly COLOR_ATTACHMENT4: 0x8CE4;
    readonly COLOR_ATTACHMENT5: 0x8CE5;
    readonly COLOR_ATTACHMENT6: 0x8CE6;
    readonly COLOR_ATTACHMENT7: 0x8CE7;
    readonly COLOR_ATTACHMENT8: 0x8CE8;
    readonly COLOR_ATTACHMENT9: 0x8CE9;
    readonly COLOR_ATTACHMENT10: 0x8CEA;
    readonly COLOR_ATTACHMENT11: 0x8CEB;
    readonly COLOR_ATTACHMENT12: 0x8CEC;
    readonly COLOR_ATTACHMENT13: 0x8CED;
    readonly COLOR_ATTACHMENT14: 0x8CEE;
    readonly COLOR_ATTACHMENT15: 0x8CEF;
    readonly FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8D56;
    readonly MAX_SAMPLES: 0x8D57;
    readonly HALF_FLOAT: 0x140B;
    readonly RG: 0x8227;
    readonly RG_INTEGER: 0x8228;
    readonly R8: 0x8229;
    readonly RG8: 0x822B;
    readonly R16F: 0x822D;
    readonly R32F: 0x822E;
    readonly RG16F: 0x822F;
    readonly RG32F: 0x8230;
    readonly R8I: 0x8231;
    readonly R8UI: 0x8232;
    readonly R16I: 0x8233;
    readonly R16UI: 0x8234;
    readonly R32I: 0x8235;
    readonly R32UI: 0x8236;
    readonly RG8I: 0x8237;
    readonly RG8UI: 0x8238;
    readonly RG16I: 0x8239;
    readonly RG16UI: 0x823A;
    readonly RG32I: 0x823B;
    readonly RG32UI: 0x823C;
    readonly VERTEX_ARRAY_BINDING: 0x85B5;
    readonly R8_SNORM: 0x8F94;
    readonly RG8_SNORM: 0x8F95;
    readonly RGB8_SNORM: 0x8F96;
    readonly RGBA8_SNORM: 0x8F97;
    readonly SIGNED_NORMALIZED: 0x8F9C;
    readonly COPY_READ_BUFFER: 0x8F36;
    readonly COPY_WRITE_BUFFER: 0x8F37;
    readonly COPY_READ_BUFFER_BINDING: 0x8F36;
    readonly COPY_WRITE_BUFFER_BINDING: 0x8F37;
    readonly UNIFORM_BUFFER: 0x8A11;
    readonly UNIFORM_BUFFER_BINDING: 0x8A28;
    readonly UNIFORM_BUFFER_START: 0x8A29;
    readonly UNIFORM_BUFFER_SIZE: 0x8A2A;
    readonly MAX_VERTEX_UNIFORM_BLOCKS: 0x8A2B;
    readonly MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8A2D;
    readonly MAX_COMBINED_UNIFORM_BLOCKS: 0x8A2E;
    readonly MAX_UNIFORM_BUFFER_BINDINGS: 0x8A2F;
    readonly MAX_UNIFORM_BLOCK_SIZE: 0x8A30;
    readonly MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8A31;
    readonly MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8A33;
    readonly UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8A34;
    readonly ACTIVE_UNIFORM_BLOCKS: 0x8A36;
    readonly UNIFORM_TYPE: 0x8A37;
    readonly UNIFORM_SIZE: 0x8A38;
    readonly UNIFORM_BLOCK_INDEX: 0x8A3A;
    readonly UNIFORM_OFFSET: 0x8A3B;
    readonly UNIFORM_ARRAY_STRIDE: 0x8A3C;
    readonly UNIFORM_MATRIX_STRIDE: 0x8A3D;
    readonly UNIFORM_IS_ROW_MAJOR: 0x8A3E;
    readonly UNIFORM_BLOCK_BINDING: 0x8A3F;
    readonly UNIFORM_BLOCK_DATA_SIZE: 0x8A40;
    readonly UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42;
    readonly UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43;
    readonly UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44;
    readonly UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46;
    readonly INVALID_INDEX: 0xFFFFFFFF;
    readonly MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122;
    readonly MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125;
    readonly MAX_SERVER_WAIT_TIMEOUT: 0x9111;
    readonly OBJECT_TYPE: 0x9112;
    readonly SYNC_CONDITION: 0x9113;
    readonly SYNC_STATUS: 0x9114;
    readonly SYNC_FLAGS: 0x9115;
    readonly SYNC_FENCE: 0x9116;
    readonly SYNC_GPU_COMMANDS_COMPLETE: 0x9117;
    readonly UNSIGNALED: 0x9118;
    readonly SIGNALED: 0x9119;
    readonly ALREADY_SIGNALED: 0x911A;
    readonly TIMEOUT_EXPIRED: 0x911B;
    readonly CONDITION_SATISFIED: 0x911C;
    readonly WAIT_FAILED: 0x911D;
    readonly SYNC_FLUSH_COMMANDS_BIT: 0x00000001;
    readonly VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88FE;
    readonly ANY_SAMPLES_PASSED: 0x8C2F;
    readonly ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8D6A;
    readonly SAMPLER_BINDING: 0x8919;
    readonly RGB10_A2UI: 0x906F;
    readonly INT_2_10_10_10_REV: 0x8D9F;
    readonly TRANSFORM_FEEDBACK: 0x8E22;
    readonly TRANSFORM_FEEDBACK_PAUSED: 0x8E23;
    readonly TRANSFORM_FEEDBACK_ACTIVE: 0x8E24;
    readonly TRANSFORM_FEEDBACK_BINDING: 0x8E25;
    readonly TEXTURE_IMMUTABLE_FORMAT: 0x912F;
    readonly MAX_ELEMENT_INDEX: 0x8D6B;
    readonly TEXTURE_IMMUTABLE_LEVELS: 0x82DF;
    readonly TIMEOUT_IGNORED: -1;
    readonly MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247;
}

interface WebGLActiveInfo {
    readonly name: string;
    readonly size: GLint;
    readonly type: GLenum;
}

declare var WebGLActiveInfo: {
    prototype: WebGLActiveInfo;
    new(): WebGLActiveInfo;
    isInstance: IsInstance<WebGLActiveInfo>;
};

interface WebGLBuffer {
}

declare var WebGLBuffer: {
    prototype: WebGLBuffer;
    new(): WebGLBuffer;
    isInstance: IsInstance<WebGLBuffer>;
};

interface WebGLContextEvent extends Event {
    readonly statusMessage: string;
}

declare var WebGLContextEvent: {
    prototype: WebGLContextEvent;
    new(type: string, eventInit?: WebGLContextEventInit): WebGLContextEvent;
    isInstance: IsInstance<WebGLContextEvent>;
};

interface WebGLFramebuffer {
}

declare var WebGLFramebuffer: {
    prototype: WebGLFramebuffer;
    new(): WebGLFramebuffer;
    isInstance: IsInstance<WebGLFramebuffer>;
};

interface WebGLProgram {
}

declare var WebGLProgram: {
    prototype: WebGLProgram;
    new(): WebGLProgram;
    isInstance: IsInstance<WebGLProgram>;
};

interface WebGLQuery {
}

declare var WebGLQuery: {
    prototype: WebGLQuery;
    new(): WebGLQuery;
    isInstance: IsInstance<WebGLQuery>;
};

interface WebGLRenderbuffer {
}

declare var WebGLRenderbuffer: {
    prototype: WebGLRenderbuffer;
    new(): WebGLRenderbuffer;
    isInstance: IsInstance<WebGLRenderbuffer>;
};

interface WebGLRenderingContext extends WebGLRenderingContextBase {
    bufferData(target: GLenum, size: GLsizeiptr, usage: GLenum): void;
    bufferData(target: GLenum, data: ArrayBuffer | null, usage: GLenum): void;
    bufferData(target: GLenum, data: ArrayBufferView, usage: GLenum): void;
    bufferSubData(target: GLenum, offset: GLintptr, data: ArrayBuffer): void;
    bufferSubData(target: GLenum, offset: GLintptr, data: ArrayBufferView): void;
    compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView): void;
    compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView): void;
    readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView | null): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pixels: ArrayBufferView | null): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, pixels: ImageBitmap): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, pixels: ImageData): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, image: HTMLImageElement): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, canvas: HTMLCanvasElement): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, video: HTMLVideoElement): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, canvas: OffscreenCanvas): void;
    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, videoFrame: VideoFrame): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView | null): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, pixels: ImageBitmap): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, pixels: ImageData): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, image: HTMLImageElement): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, canvas: HTMLCanvasElement): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, video: HTMLVideoElement): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, canvas: OffscreenCanvas): void;
    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, videoFrame: VideoFrame): void;
    uniform1fv(location: WebGLUniformLocation | null, data: Float32List): void;
    uniform1iv(location: WebGLUniformLocation | null, data: Int32List): void;
    uniform2fv(location: WebGLUniformLocation | null, data: Float32List): void;
    uniform2iv(location: WebGLUniformLocation | null, data: Int32List): void;
    uniform3fv(location: WebGLUniformLocation | null, data: Float32List): void;
    uniform3iv(location: WebGLUniformLocation | null, data: Int32List): void;
    uniform4fv(location: WebGLUniformLocation | null, data: Float32List): void;
    uniform4iv(location: WebGLUniformLocation | null, data: Int32List): void;
    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Float32List): void;
    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Float32List): void;
    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Float32List): void;
}

declare var WebGLRenderingContext: {
    prototype: WebGLRenderingContext;
    new(): WebGLRenderingContext;
    readonly DEPTH_BUFFER_BIT: 0x00000100;
    readonly STENCIL_BUFFER_BIT: 0x00000400;
    readonly COLOR_BUFFER_BIT: 0x00004000;
    readonly POINTS: 0x0000;
    readonly LINES: 0x0001;
    readonly LINE_LOOP: 0x0002;
    readonly LINE_STRIP: 0x0003;
    readonly TRIANGLES: 0x0004;
    readonly TRIANGLE_STRIP: 0x0005;
    readonly TRIANGLE_FAN: 0x0006;
    readonly ZERO: 0;
    readonly ONE: 1;
    readonly SRC_COLOR: 0x0300;
    readonly ONE_MINUS_SRC_COLOR: 0x0301;
    readonly SRC_ALPHA: 0x0302;
    readonly ONE_MINUS_SRC_ALPHA: 0x0303;
    readonly DST_ALPHA: 0x0304;
    readonly ONE_MINUS_DST_ALPHA: 0x0305;
    readonly DST_COLOR: 0x0306;
    readonly ONE_MINUS_DST_COLOR: 0x0307;
    readonly SRC_ALPHA_SATURATE: 0x0308;
    readonly FUNC_ADD: 0x8006;
    readonly BLEND_EQUATION: 0x8009;
    readonly BLEND_EQUATION_RGB: 0x8009;
    readonly BLEND_EQUATION_ALPHA: 0x883D;
    readonly FUNC_SUBTRACT: 0x800A;
    readonly FUNC_REVERSE_SUBTRACT: 0x800B;
    readonly BLEND_DST_RGB: 0x80C8;
    readonly BLEND_SRC_RGB: 0x80C9;
    readonly BLEND_DST_ALPHA: 0x80CA;
    readonly BLEND_SRC_ALPHA: 0x80CB;
    readonly CONSTANT_COLOR: 0x8001;
    readonly ONE_MINUS_CONSTANT_COLOR: 0x8002;
    readonly CONSTANT_ALPHA: 0x8003;
    readonly ONE_MINUS_CONSTANT_ALPHA: 0x8004;
    readonly BLEND_COLOR: 0x8005;
    readonly ARRAY_BUFFER: 0x8892;
    readonly ELEMENT_ARRAY_BUFFER: 0x8893;
    readonly ARRAY_BUFFER_BINDING: 0x8894;
    readonly ELEMENT_ARRAY_BUFFER_BINDING: 0x8895;
    readonly STREAM_DRAW: 0x88E0;
    readonly STATIC_DRAW: 0x88E4;
    readonly DYNAMIC_DRAW: 0x88E8;
    readonly BUFFER_SIZE: 0x8764;
    readonly BUFFER_USAGE: 0x8765;
    readonly CURRENT_VERTEX_ATTRIB: 0x8626;
    readonly FRONT: 0x0404;
    readonly BACK: 0x0405;
    readonly FRONT_AND_BACK: 0x0408;
    readonly CULL_FACE: 0x0B44;
    readonly BLEND: 0x0BE2;
    readonly DITHER: 0x0BD0;
    readonly STENCIL_TEST: 0x0B90;
    readonly DEPTH_TEST: 0x0B71;
    readonly SCISSOR_TEST: 0x0C11;
    readonly POLYGON_OFFSET_FILL: 0x8037;
    readonly SAMPLE_ALPHA_TO_COVERAGE: 0x809E;
    readonly SAMPLE_COVERAGE: 0x80A0;
    readonly NO_ERROR: 0;
    readonly INVALID_ENUM: 0x0500;
    readonly INVALID_VALUE: 0x0501;
    readonly INVALID_OPERATION: 0x0502;
    readonly OUT_OF_MEMORY: 0x0505;
    readonly CW: 0x0900;
    readonly CCW: 0x0901;
    readonly LINE_WIDTH: 0x0B21;
    readonly ALIASED_POINT_SIZE_RANGE: 0x846D;
    readonly ALIASED_LINE_WIDTH_RANGE: 0x846E;
    readonly CULL_FACE_MODE: 0x0B45;
    readonly FRONT_FACE: 0x0B46;
    readonly DEPTH_RANGE: 0x0B70;
    readonly DEPTH_WRITEMASK: 0x0B72;
    readonly DEPTH_CLEAR_VALUE: 0x0B73;
    readonly DEPTH_FUNC: 0x0B74;
    readonly STENCIL_CLEAR_VALUE: 0x0B91;
    readonly STENCIL_FUNC: 0x0B92;
    readonly STENCIL_FAIL: 0x0B94;
    readonly STENCIL_PASS_DEPTH_FAIL: 0x0B95;
    readonly STENCIL_PASS_DEPTH_PASS: 0x0B96;
    readonly STENCIL_REF: 0x0B97;
    readonly STENCIL_VALUE_MASK: 0x0B93;
    readonly STENCIL_WRITEMASK: 0x0B98;
    readonly STENCIL_BACK_FUNC: 0x8800;
    readonly STENCIL_BACK_FAIL: 0x8801;
    readonly STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802;
    readonly STENCIL_BACK_PASS_DEPTH_PASS: 0x8803;
    readonly STENCIL_BACK_REF: 0x8CA3;
    readonly STENCIL_BACK_VALUE_MASK: 0x8CA4;
    readonly STENCIL_BACK_WRITEMASK: 0x8CA5;
    readonly VIEWPORT: 0x0BA2;
    readonly SCISSOR_BOX: 0x0C10;
    readonly COLOR_CLEAR_VALUE: 0x0C22;
    readonly COLOR_WRITEMASK: 0x0C23;
    readonly UNPACK_ALIGNMENT: 0x0CF5;
    readonly PACK_ALIGNMENT: 0x0D05;
    readonly MAX_TEXTURE_SIZE: 0x0D33;
    readonly MAX_VIEWPORT_DIMS: 0x0D3A;
    readonly SUBPIXEL_BITS: 0x0D50;
    readonly RED_BITS: 0x0D52;
    readonly GREEN_BITS: 0x0D53;
    readonly BLUE_BITS: 0x0D54;
    readonly ALPHA_BITS: 0x0D55;
    readonly DEPTH_BITS: 0x0D56;
    readonly STENCIL_BITS: 0x0D57;
    readonly POLYGON_OFFSET_UNITS: 0x2A00;
    readonly POLYGON_OFFSET_FACTOR: 0x8038;
    readonly TEXTURE_BINDING_2D: 0x8069;
    readonly SAMPLE_BUFFERS: 0x80A8;
    readonly SAMPLES: 0x80A9;
    readonly SAMPLE_COVERAGE_VALUE: 0x80AA;
    readonly SAMPLE_COVERAGE_INVERT: 0x80AB;
    readonly COMPRESSED_TEXTURE_FORMATS: 0x86A3;
    readonly DONT_CARE: 0x1100;
    readonly FASTEST: 0x1101;
    readonly NICEST: 0x1102;
    readonly GENERATE_MIPMAP_HINT: 0x8192;
    readonly BYTE: 0x1400;
    readonly UNSIGNED_BYTE: 0x1401;
    readonly SHORT: 0x1402;
    readonly UNSIGNED_SHORT: 0x1403;
    readonly INT: 0x1404;
    readonly UNSIGNED_INT: 0x1405;
    readonly FLOAT: 0x1406;
    readonly DEPTH_COMPONENT: 0x1902;
    readonly ALPHA: 0x1906;
    readonly RGB: 0x1907;
    readonly RGBA: 0x1908;
    readonly LUMINANCE: 0x1909;
    readonly LUMINANCE_ALPHA: 0x190A;
    readonly UNSIGNED_SHORT_4_4_4_4: 0x8033;
    readonly UNSIGNED_SHORT_5_5_5_1: 0x8034;
    readonly UNSIGNED_SHORT_5_6_5: 0x8363;
    readonly FRAGMENT_SHADER: 0x8B30;
    readonly VERTEX_SHADER: 0x8B31;
    readonly MAX_VERTEX_ATTRIBS: 0x8869;
    readonly MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB;
    readonly MAX_VARYING_VECTORS: 0x8DFC;
    readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D;
    readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C;
    readonly MAX_TEXTURE_IMAGE_UNITS: 0x8872;
    readonly MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD;
    readonly SHADER_TYPE: 0x8B4F;
    readonly DELETE_STATUS: 0x8B80;
    readonly LINK_STATUS: 0x8B82;
    readonly VALIDATE_STATUS: 0x8B83;
    readonly ATTACHED_SHADERS: 0x8B85;
    readonly ACTIVE_UNIFORMS: 0x8B86;
    readonly ACTIVE_ATTRIBUTES: 0x8B89;
    readonly SHADING_LANGUAGE_VERSION: 0x8B8C;
    readonly CURRENT_PROGRAM: 0x8B8D;
    readonly NEVER: 0x0200;
    readonly LESS: 0x0201;
    readonly EQUAL: 0x0202;
    readonly LEQUAL: 0x0203;
    readonly GREATER: 0x0204;
    readonly NOTEQUAL: 0x0205;
    readonly GEQUAL: 0x0206;
    readonly ALWAYS: 0x0207;
    readonly KEEP: 0x1E00;
    readonly REPLACE: 0x1E01;
    readonly INCR: 0x1E02;
    readonly DECR: 0x1E03;
    readonly INVERT: 0x150A;
    readonly INCR_WRAP: 0x8507;
    readonly DECR_WRAP: 0x8508;
    readonly VENDOR: 0x1F00;
    readonly RENDERER: 0x1F01;
    readonly VERSION: 0x1F02;
    readonly NEAREST: 0x2600;
    readonly LINEAR: 0x2601;
    readonly NEAREST_MIPMAP_NEAREST: 0x2700;
    readonly LINEAR_MIPMAP_NEAREST: 0x2701;
    readonly NEAREST_MIPMAP_LINEAR: 0x2702;
    readonly LINEAR_MIPMAP_LINEAR: 0x2703;
    readonly TEXTURE_MAG_FILTER: 0x2800;
    readonly TEXTURE_MIN_FILTER: 0x2801;
    readonly TEXTURE_WRAP_S: 0x2802;
    readonly TEXTURE_WRAP_T: 0x2803;
    readonly TEXTURE_2D: 0x0DE1;
    readonly TEXTURE: 0x1702;
    readonly TEXTURE_CUBE_MAP: 0x8513;
    readonly TEXTURE_BINDING_CUBE_MAP: 0x8514;
    readonly TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515;
    readonly TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516;
    readonly TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517;
    readonly TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518;
    readonly TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519;
    readonly TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A;
    readonly MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C;
    readonly TEXTURE0: 0x84C0;
    readonly TEXTURE1: 0x84C1;
    readonly TEXTURE2: 0x84C2;
    readonly TEXTURE3: 0x84C3;
    readonly TEXTURE4: 0x84C4;
    readonly TEXTURE5: 0x84C5;
    readonly TEXTURE6: 0x84C6;
    readonly TEXTURE7: 0x84C7;
    readonly TEXTURE8: 0x84C8;
    readonly TEXTURE9: 0x84C9;
    readonly TEXTURE10: 0x84CA;
    readonly TEXTURE11: 0x84CB;
    readonly TEXTURE12: 0x84CC;
    readonly TEXTURE13: 0x84CD;
    readonly TEXTURE14: 0x84CE;
    readonly TEXTURE15: 0x84CF;
    readonly TEXTURE16: 0x84D0;
    readonly TEXTURE17: 0x84D1;
    readonly TEXTURE18: 0x84D2;
    readonly TEXTURE19: 0x84D3;
    readonly TEXTURE20: 0x84D4;
    readonly TEXTURE21: 0x84D5;
    readonly TEXTURE22: 0x84D6;
    readonly TEXTURE23: 0x84D7;
    readonly TEXTURE24: 0x84D8;
    readonly TEXTURE25: 0x84D9;
    readonly TEXTURE26: 0x84DA;
    readonly TEXTURE27: 0x84DB;
    readonly TEXTURE28: 0x84DC;
    readonly TEXTURE29: 0x84DD;
    readonly TEXTURE30: 0x84DE;
    readonly TEXTURE31: 0x84DF;
    readonly ACTIVE_TEXTURE: 0x84E0;
    readonly REPEAT: 0x2901;
    readonly CLAMP_TO_EDGE: 0x812F;
    readonly MIRRORED_REPEAT: 0x8370;
    readonly FLOAT_VEC2: 0x8B50;
    readonly FLOAT_VEC3: 0x8B51;
    readonly FLOAT_VEC4: 0x8B52;
    readonly INT_VEC2: 0x8B53;
    readonly INT_VEC3: 0x8B54;
    readonly INT_VEC4: 0x8B55;
    readonly BOOL: 0x8B56;
    readonly BOOL_VEC2: 0x8B57;
    readonly BOOL_VEC3: 0x8B58;
    readonly BOOL_VEC4: 0x8B59;
    readonly FLOAT_MAT2: 0x8B5A;
    readonly FLOAT_MAT3: 0x8B5B;
    readonly FLOAT_MAT4: 0x8B5C;
    readonly SAMPLER_2D: 0x8B5E;
    readonly SAMPLER_CUBE: 0x8B60;
    readonly VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622;
    readonly VERTEX_ATTRIB_ARRAY_SIZE: 0x8623;
    readonly VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624;
    readonly VERTEX_ATTRIB_ARRAY_TYPE: 0x8625;
    readonly VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A;
    readonly VERTEX_ATTRIB_ARRAY_POINTER: 0x8645;
    readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F;
    readonly IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A;
    readonly IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B;
    readonly COMPILE_STATUS: 0x8B81;
    readonly LOW_FLOAT: 0x8DF0;
    readonly MEDIUM_FLOAT: 0x8DF1;
    readonly HIGH_FLOAT: 0x8DF2;
    readonly LOW_INT: 0x8DF3;
    readonly MEDIUM_INT: 0x8DF4;
    readonly HIGH_INT: 0x8DF5;
    readonly FRAMEBUFFER: 0x8D40;
    readonly RENDERBUFFER: 0x8D41;
    readonly RGBA4: 0x8056;
    readonly RGB5_A1: 0x8057;
    readonly RGB565: 0x8D62;
    readonly DEPTH_COMPONENT16: 0x81A5;
    readonly STENCIL_INDEX8: 0x8D48;
    readonly DEPTH_STENCIL: 0x84F9;
    readonly RENDERBUFFER_WIDTH: 0x8D42;
    readonly RENDERBUFFER_HEIGHT: 0x8D43;
    readonly RENDERBUFFER_INTERNAL_FORMAT: 0x8D44;
    readonly RENDERBUFFER_RED_SIZE: 0x8D50;
    readonly RENDERBUFFER_GREEN_SIZE: 0x8D51;
    readonly RENDERBUFFER_BLUE_SIZE: 0x8D52;
    readonly RENDERBUFFER_ALPHA_SIZE: 0x8D53;
    readonly RENDERBUFFER_DEPTH_SIZE: 0x8D54;
    readonly RENDERBUFFER_STENCIL_SIZE: 0x8D55;
    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0;
    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1;
    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2;
    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3;
    readonly COLOR_ATTACHMENT0: 0x8CE0;
    readonly DEPTH_ATTACHMENT: 0x8D00;
    readonly STENCIL_ATTACHMENT: 0x8D20;
    readonly DEPTH_STENCIL_ATTACHMENT: 0x821A;
    readonly NONE: 0;
    readonly FRAMEBUFFER_COMPLETE: 0x8CD5;
    readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6;
    readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7;
    readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9;
    readonly FRAMEBUFFER_UNSUPPORTED: 0x8CDD;
    readonly FRAMEBUFFER_BINDING: 0x8CA6;
    readonly RENDERBUFFER_BINDING: 0x8CA7;
    readonly MAX_RENDERBUFFER_SIZE: 0x84E8;
    readonly INVALID_FRAMEBUFFER_OPERATION: 0x0506;
    readonly UNPACK_FLIP_Y_WEBGL: 0x9240;
    readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241;
    readonly CONTEXT_LOST_WEBGL: 0x9242;
    readonly UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243;
    readonly BROWSER_DEFAULT_WEBGL: 0x9244;
    isInstance: IsInstance<WebGLRenderingContext>;
};

interface WebGLRenderingContextBase {
    readonly canvas: CanvasSource | null;
    drawingBufferColorSpace: PredefinedColorSpace;
    readonly drawingBufferHeight: GLsizei;
    readonly drawingBufferWidth: GLsizei;
    unpackColorSpace: PredefinedColorSpace;
    activeTexture(texture: GLenum): void;
    attachShader(program: WebGLProgram, shader: WebGLShader): void;
    bindAttribLocation(program: WebGLProgram, index: GLuint, name: string): void;
    bindBuffer(target: GLenum, buffer: WebGLBuffer | null): void;
    bindFramebuffer(target: GLenum, framebuffer: WebGLFramebuffer | null): void;
    bindRenderbuffer(target: GLenum, renderbuffer: WebGLRenderbuffer | null): void;
    bindTexture(target: GLenum, texture: WebGLTexture | null): void;
    blendColor(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat): void;
    blendEquation(mode: GLenum): void;
    blendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum): void;
    blendFunc(sfactor: GLenum, dfactor: GLenum): void;
    blendFuncSeparate(srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum): void;
    checkFramebufferStatus(target: GLenum): GLenum;
    clear(mask: GLbitfield): void;
    clearColor(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat): void;
    clearDepth(depth: GLclampf): void;
    clearStencil(s: GLint): void;
    colorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean): void;
    compileShader(shader: WebGLShader): void;
    copyTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint): void;
    copyTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
    createBuffer(): WebGLBuffer;
    createFramebuffer(): WebGLFramebuffer;
    createProgram(): WebGLProgram;
    createRenderbuffer(): WebGLRenderbuffer;
    createShader(type: GLenum): WebGLShader | null;
    createTexture(): WebGLTexture;
    cullFace(mode: GLenum): void;
    deleteBuffer(buffer: WebGLBuffer | null): void;
    deleteFramebuffer(framebuffer: WebGLFramebuffer | null): void;
    deleteProgram(program: WebGLProgram | null): void;
    deleteRenderbuffer(renderbuffer: WebGLRenderbuffer | null): void;
    deleteShader(shader: WebGLShader | null): void;
    deleteTexture(texture: WebGLTexture | null): void;
    depthFunc(func: GLenum): void;
    depthMask(flag: GLboolean): void;
    depthRange(zNear: GLclampf, zFar: GLclampf): void;
    detachShader(program: WebGLProgram, shader: WebGLShader): void;
    disable(cap: GLenum): void;
    disableVertexAttribArray(index: GLuint): void;
    drawArrays(mode: GLenum, first: GLint, count: GLsizei): void;
    drawElements(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr): void;
    enable(cap: GLenum): void;
    enableVertexAttribArray(index: GLuint): void;
    finish(): void;
    flush(): void;
    framebufferRenderbuffer(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: WebGLRenderbuffer | null): void;
    framebufferTexture2D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: WebGLTexture | null, level: GLint): void;
    frontFace(mode: GLenum): void;
    generateMipmap(target: GLenum): void;
    getActiveAttrib(program: WebGLProgram, index: GLuint): WebGLActiveInfo | null;
    getActiveUniform(program: WebGLProgram, index: GLuint): WebGLActiveInfo | null;
    getAttachedShaders(program: WebGLProgram): WebGLShader[] | null;
    getAttribLocation(program: WebGLProgram, name: string): GLint;
    getBufferParameter(target: GLenum, pname: GLenum): any;
    getContextAttributes(): WebGLContextAttributes | null;
    getError(): GLenum;
    getExtension(name: string): any;
    getFramebufferAttachmentParameter(target: GLenum, attachment: GLenum, pname: GLenum): any;
    getParameter(pname: GLenum): any;
    getProgramInfoLog(program: WebGLProgram): string | null;
    getProgramParameter(program: WebGLProgram, pname: GLenum): any;
    getRenderbufferParameter(target: GLenum, pname: GLenum): any;
    getShaderInfoLog(shader: WebGLShader): string | null;
    getShaderParameter(shader: WebGLShader, pname: GLenum): any;
    getShaderPrecisionFormat(shadertype: GLenum, precisiontype: GLenum): WebGLShaderPrecisionFormat | null;
    getShaderSource(shader: WebGLShader): string | null;
    getSupportedExtensions(): string[] | null;
    getTexParameter(target: GLenum, pname: GLenum): any;
    getUniform(program: WebGLProgram, location: WebGLUniformLocation): any;
    getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation | null;
    getVertexAttrib(index: GLuint, pname: GLenum): any;
    getVertexAttribOffset(index: GLuint, pname: GLenum): GLintptr;
    hint(target: GLenum, mode: GLenum): void;
    isBuffer(buffer: WebGLBuffer | null): GLboolean;
    isContextLost(): boolean;
    isEnabled(cap: GLenum): GLboolean;
    isFramebuffer(framebuffer: WebGLFramebuffer | null): GLboolean;
    isProgram(program: WebGLProgram | null): GLboolean;
    isRenderbuffer(renderbuffer: WebGLRenderbuffer | null): GLboolean;
    isShader(shader: WebGLShader | null): GLboolean;
    isTexture(texture: WebGLTexture | null): GLboolean;
    lineWidth(width: GLfloat): void;
    linkProgram(program: WebGLProgram): void;
    makeXRCompatible(): Promise<void>;
    pixelStorei(pname: GLenum, param: GLint): void;
    polygonOffset(factor: GLfloat, units: GLfloat): void;
    renderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei): void;
    sampleCoverage(value: GLclampf, invert: GLboolean): void;
    scissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
    shaderSource(shader: WebGLShader, source: string): void;
    stencilFunc(func: GLenum, ref: GLint, mask: GLuint): void;
    stencilFuncSeparate(face: GLenum, func: GLenum, ref: GLint, mask: GLuint): void;
    stencilMask(mask: GLuint): void;
    stencilMaskSeparate(face: GLenum, mask: GLuint): void;
    stencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum): void;
    stencilOpSeparate(face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum): void;
    texParameterf(target: GLenum, pname: GLenum, param: GLfloat): void;
    texParameteri(target: GLenum, pname: GLenum, param: GLint): void;
    uniform1f(location: WebGLUniformLocation | null, x: GLfloat): void;
    uniform1i(location: WebGLUniformLocation | null, x: GLint): void;
    uniform2f(location: WebGLUniformLocation | null, x: GLfloat, y: GLfloat): void;
    uniform2i(location: WebGLUniformLocation | null, x: GLint, y: GLint): void;
    uniform3f(location: WebGLUniformLocation | null, x: GLfloat, y: GLfloat, z: GLfloat): void;
    uniform3i(location: WebGLUniformLocation | null, x: GLint, y: GLint, z: GLint): void;
    uniform4f(location: WebGLUniformLocation | null, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;
    uniform4i(location: WebGLUniformLocation | null, x: GLint, y: GLint, z: GLint, w: GLint): void;
    useProgram(program: WebGLProgram | null): void;
    validateProgram(program: WebGLProgram): void;
    vertexAttrib1f(indx: GLuint, x: GLfloat): void;
    vertexAttrib1fv(indx: GLuint, values: Float32List): void;
    vertexAttrib2f(indx: GLuint, x: GLfloat, y: GLfloat): void;
    vertexAttrib2fv(indx: GLuint, values: Float32List): void;
    vertexAttrib3f(indx: GLuint, x: GLfloat, y: GLfloat, z: GLfloat): void;
    vertexAttrib3fv(indx: GLuint, values: Float32List): void;
    vertexAttrib4f(indx: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;
    vertexAttrib4fv(indx: GLuint, values: Float32List): void;
    vertexAttribPointer(indx: GLuint, size: GLint, type: GLenum, normalized: GLboolean, stride: GLsizei, offset: GLintptr): void;
    viewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
    readonly DEPTH_BUFFER_BIT: 0x00000100;
    readonly STENCIL_BUFFER_BIT: 0x00000400;
    readonly COLOR_BUFFER_BIT: 0x00004000;
    readonly POINTS: 0x0000;
    readonly LINES: 0x0001;
    readonly LINE_LOOP: 0x0002;
    readonly LINE_STRIP: 0x0003;
    readonly TRIANGLES: 0x0004;
    readonly TRIANGLE_STRIP: 0x0005;
    readonly TRIANGLE_FAN: 0x0006;
    readonly ZERO: 0;
    readonly ONE: 1;
    readonly SRC_COLOR: 0x0300;
    readonly ONE_MINUS_SRC_COLOR: 0x0301;
    readonly SRC_ALPHA: 0x0302;
    readonly ONE_MINUS_SRC_ALPHA: 0x0303;
    readonly DST_ALPHA: 0x0304;
    readonly ONE_MINUS_DST_ALPHA: 0x0305;
    readonly DST_COLOR: 0x0306;
    readonly ONE_MINUS_DST_COLOR: 0x0307;
    readonly SRC_ALPHA_SATURATE: 0x0308;
    readonly FUNC_ADD: 0x8006;
    readonly BLEND_EQUATION: 0x8009;
    readonly BLEND_EQUATION_RGB: 0x8009;
    readonly BLEND_EQUATION_ALPHA: 0x883D;
    readonly FUNC_SUBTRACT: 0x800A;
    readonly FUNC_REVERSE_SUBTRACT: 0x800B;
    readonly BLEND_DST_RGB: 0x80C8;
    readonly BLEND_SRC_RGB: 0x80C9;
    readonly BLEND_DST_ALPHA: 0x80CA;
    readonly BLEND_SRC_ALPHA: 0x80CB;
    readonly CONSTANT_COLOR: 0x8001;
    readonly ONE_MINUS_CONSTANT_COLOR: 0x8002;
    readonly CONSTANT_ALPHA: 0x8003;
    readonly ONE_MINUS_CONSTANT_ALPHA: 0x8004;
    readonly BLEND_COLOR: 0x8005;
    readonly ARRAY_BUFFER: 0x8892;
    readonly ELEMENT_ARRAY_BUFFER: 0x8893;
    readonly ARRAY_BUFFER_BINDING: 0x8894;
    readonly ELEMENT_ARRAY_BUFFER_BINDING: 0x8895;
    readonly STREAM_DRAW: 0x88E0;
    readonly STATIC_DRAW: 0x88E4;
    readonly DYNAMIC_DRAW: 0x88E8;
    readonly BUFFER_SIZE: 0x8764;
    readonly BUFFER_USAGE: 0x8765;
    readonly CURRENT_VERTEX_ATTRIB: 0x8626;
    readonly FRONT: 0x0404;
    readonly BACK: 0x0405;
    readonly FRONT_AND_BACK: 0x0408;
    readonly CULL_FACE: 0x0B44;
    readonly BLEND: 0x0BE2;
    readonly DITHER: 0x0BD0;
    readonly STENCIL_TEST: 0x0B90;
    readonly DEPTH_TEST: 0x0B71;
    readonly SCISSOR_TEST: 0x0C11;
    readonly POLYGON_OFFSET_FILL: 0x8037;
    readonly SAMPLE_ALPHA_TO_COVERAGE: 0x809E;
    readonly SAMPLE_COVERAGE: 0x80A0;
    readonly NO_ERROR: 0;
    readonly INVALID_ENUM: 0x0500;
    readonly INVALID_VALUE: 0x0501;
    readonly INVALID_OPERATION: 0x0502;
    readonly OUT_OF_MEMORY: 0x0505;
    readonly CW: 0x0900;
    readonly CCW: 0x0901;
    readonly LINE_WIDTH: 0x0B21;
    readonly ALIASED_POINT_SIZE_RANGE: 0x846D;
    readonly ALIASED_LINE_WIDTH_RANGE: 0x846E;
    readonly CULL_FACE_MODE: 0x0B45;
    readonly FRONT_FACE: 0x0B46;
    readonly DEPTH_RANGE: 0x0B70;
    readonly DEPTH_WRITEMASK: 0x0B72;
    readonly DEPTH_CLEAR_VALUE: 0x0B73;
    readonly DEPTH_FUNC: 0x0B74;
    readonly STENCIL_CLEAR_VALUE: 0x0B91;
    readonly STENCIL_FUNC: 0x0B92;
    readonly STENCIL_FAIL: 0x0B94;
    readonly STENCIL_PASS_DEPTH_FAIL: 0x0B95;
    readonly STENCIL_PASS_DEPTH_PASS: 0x0B96;
    readonly STENCIL_REF: 0x0B97;
    readonly STENCIL_VALUE_MASK: 0x0B93;
    readonly STENCIL_WRITEMASK: 0x0B98;
    readonly STENCIL_BACK_FUNC: 0x8800;
    readonly STENCIL_BACK_FAIL: 0x8801;
    readonly STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802;
    readonly STENCIL_BACK_PASS_DEPTH_PASS: 0x8803;
    readonly STENCIL_BACK_REF: 0x8CA3;
    readonly STENCIL_BACK_VALUE_MASK: 0x8CA4;
    readonly STENCIL_BACK_WRITEMASK: 0x8CA5;
    readonly VIEWPORT: 0x0BA2;
    readonly SCISSOR_BOX: 0x0C10;
    readonly COLOR_CLEAR_VALUE: 0x0C22;
    readonly COLOR_WRITEMASK: 0x0C23;
    readonly UNPACK_ALIGNMENT: 0x0CF5;
    readonly PACK_ALIGNMENT: 0x0D05;
    readonly MAX_TEXTURE_SIZE: 0x0D33;
    readonly MAX_VIEWPORT_DIMS: 0x0D3A;
    readonly SUBPIXEL_BITS: 0x0D50;
    readonly RED_BITS: 0x0D52;
    readonly GREEN_BITS: 0x0D53;
    readonly BLUE_BITS: 0x0D54;
    readonly ALPHA_BITS: 0x0D55;
    readonly DEPTH_BITS: 0x0D56;
    readonly STENCIL_BITS: 0x0D57;
    readonly POLYGON_OFFSET_UNITS: 0x2A00;
    readonly POLYGON_OFFSET_FACTOR: 0x8038;
    readonly TEXTURE_BINDING_2D: 0x8069;
    readonly SAMPLE_BUFFERS: 0x80A8;
    readonly SAMPLES: 0x80A9;
    readonly SAMPLE_COVERAGE_VALUE: 0x80AA;
    readonly SAMPLE_COVERAGE_INVERT: 0x80AB;
    readonly COMPRESSED_TEXTURE_FORMATS: 0x86A3;
    readonly DONT_CARE: 0x1100;
    readonly FASTEST: 0x1101;
    readonly NICEST: 0x1102;
    readonly GENERATE_MIPMAP_HINT: 0x8192;
    readonly BYTE: 0x1400;
    readonly UNSIGNED_BYTE: 0x1401;
    readonly SHORT: 0x1402;
    readonly UNSIGNED_SHORT: 0x1403;
    readonly INT: 0x1404;
    readonly UNSIGNED_INT: 0x1405;
    readonly FLOAT: 0x1406;
    readonly DEPTH_COMPONENT: 0x1902;
    readonly ALPHA: 0x1906;
    readonly RGB: 0x1907;
    readonly RGBA: 0x1908;
    readonly LUMINANCE: 0x1909;
    readonly LUMINANCE_ALPHA: 0x190A;
    readonly UNSIGNED_SHORT_4_4_4_4: 0x8033;
    readonly UNSIGNED_SHORT_5_5_5_1: 0x8034;
    readonly UNSIGNED_SHORT_5_6_5: 0x8363;
    readonly FRAGMENT_SHADER: 0x8B30;
    readonly VERTEX_SHADER: 0x8B31;
    readonly MAX_VERTEX_ATTRIBS: 0x8869;
    readonly MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB;
    readonly MAX_VARYING_VECTORS: 0x8DFC;
    readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D;
    readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C;
    readonly MAX_TEXTURE_IMAGE_UNITS: 0x8872;
    readonly MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD;
    readonly SHADER_TYPE: 0x8B4F;
    readonly DELETE_STATUS: 0x8B80;
    readonly LINK_STATUS: 0x8B82;
    readonly VALIDATE_STATUS: 0x8B83;
    readonly ATTACHED_SHADERS: 0x8B85;
    readonly ACTIVE_UNIFORMS: 0x8B86;
    readonly ACTIVE_ATTRIBUTES: 0x8B89;
    readonly SHADING_LANGUAGE_VERSION: 0x8B8C;
    readonly CURRENT_PROGRAM: 0x8B8D;
    readonly NEVER: 0x0200;
    readonly LESS: 0x0201;
    readonly EQUAL: 0x0202;
    readonly LEQUAL: 0x0203;
    readonly GREATER: 0x0204;
    readonly NOTEQUAL: 0x0205;
    readonly GEQUAL: 0x0206;
    readonly ALWAYS: 0x0207;
    readonly KEEP: 0x1E00;
    readonly REPLACE: 0x1E01;
    readonly INCR: 0x1E02;
    readonly DECR: 0x1E03;
    readonly INVERT: 0x150A;
    readonly INCR_WRAP: 0x8507;
    readonly DECR_WRAP: 0x8508;
    readonly VENDOR: 0x1F00;
    readonly RENDERER: 0x1F01;
    readonly VERSION: 0x1F02;
    readonly NEAREST: 0x2600;
    readonly LINEAR: 0x2601;
    readonly NEAREST_MIPMAP_NEAREST: 0x2700;
    readonly LINEAR_MIPMAP_NEAREST: 0x2701;
    readonly NEAREST_MIPMAP_LINEAR: 0x2702;
    readonly LINEAR_MIPMAP_LINEAR: 0x2703;
    readonly TEXTURE_MAG_FILTER: 0x2800;
    readonly TEXTURE_MIN_FILTER: 0x2801;
    readonly TEXTURE_WRAP_S: 0x2802;
    readonly TEXTURE_WRAP_T: 0x2803;
    readonly TEXTURE_2D: 0x0DE1;
    readonly TEXTURE: 0x1702;
    readonly TEXTURE_CUBE_MAP: 0x8513;
    readonly TEXTURE_BINDING_CUBE_MAP: 0x8514;
    readonly TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515;
    readonly TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516;
    readonly TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517;
    readonly TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518;
    readonly TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519;
    readonly TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A;
    readonly MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C;
    readonly TEXTURE0: 0x84C0;
    readonly TEXTURE1: 0x84C1;
    readonly TEXTURE2: 0x84C2;
    readonly TEXTURE3: 0x84C3;
    readonly TEXTURE4: 0x84C4;
    readonly TEXTURE5: 0x84C5;
    readonly TEXTURE6: 0x84C6;
    readonly TEXTURE7: 0x84C7;
    readonly TEXTURE8: 0x84C8;
    readonly TEXTURE9: 0x84C9;
    readonly TEXTURE10: 0x84CA;
    readonly TEXTURE11: 0x84CB;
    readonly TEXTURE12: 0x84CC;
    readonly TEXTURE13: 0x84CD;
    readonly TEXTURE14: 0x84CE;
    readonly TEXTURE15: 0x84CF;
    readonly TEXTURE16: 0x84D0;
    readonly TEXTURE17: 0x84D1;
    readonly TEXTURE18: 0x84D2;
    readonly TEXTURE19: 0x84D3;
    readonly TEXTURE20: 0x84D4;
    readonly TEXTURE21: 0x84D5;
    readonly TEXTURE22: 0x84D6;
    readonly TEXTURE23: 0x84D7;
    readonly TEXTURE24: 0x84D8;
    readonly TEXTURE25: 0x84D9;
    readonly TEXTURE26: 0x84DA;
    readonly TEXTURE27: 0x84DB;
    readonly TEXTURE28: 0x84DC;
    readonly TEXTURE29: 0x84DD;
    readonly TEXTURE30: 0x84DE;
    readonly TEXTURE31: 0x84DF;
    readonly ACTIVE_TEXTURE: 0x84E0;
    readonly REPEAT: 0x2901;
    readonly CLAMP_TO_EDGE: 0x812F;
    readonly MIRRORED_REPEAT: 0x8370;
    readonly FLOAT_VEC2: 0x8B50;
    readonly FLOAT_VEC3: 0x8B51;
    readonly FLOAT_VEC4: 0x8B52;
    readonly INT_VEC2: 0x8B53;
    readonly INT_VEC3: 0x8B54;
    readonly INT_VEC4: 0x8B55;
    readonly BOOL: 0x8B56;
    readonly BOOL_VEC2: 0x8B57;
    readonly BOOL_VEC3: 0x8B58;
    readonly BOOL_VEC4: 0x8B59;
    readonly FLOAT_MAT2: 0x8B5A;
    readonly FLOAT_MAT3: 0x8B5B;
    readonly FLOAT_MAT4: 0x8B5C;
    readonly SAMPLER_2D: 0x8B5E;
    readonly SAMPLER_CUBE: 0x8B60;
    readonly VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622;
    readonly VERTEX_ATTRIB_ARRAY_SIZE: 0x8623;
    readonly VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624;
    readonly VERTEX_ATTRIB_ARRAY_TYPE: 0x8625;
    readonly VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A;
    readonly VERTEX_ATTRIB_ARRAY_POINTER: 0x8645;
    readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F;
    readonly IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A;
    readonly IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B;
    readonly COMPILE_STATUS: 0x8B81;
    readonly LOW_FLOAT: 0x8DF0;
    readonly MEDIUM_FLOAT: 0x8DF1;
    readonly HIGH_FLOAT: 0x8DF2;
    readonly LOW_INT: 0x8DF3;
    readonly MEDIUM_INT: 0x8DF4;
    readonly HIGH_INT: 0x8DF5;
    readonly FRAMEBUFFER: 0x8D40;
    readonly RENDERBUFFER: 0x8D41;
    readonly RGBA4: 0x8056;
    readonly RGB5_A1: 0x8057;
    readonly RGB565: 0x8D62;
    readonly DEPTH_COMPONENT16: 0x81A5;
    readonly STENCIL_INDEX8: 0x8D48;
    readonly DEPTH_STENCIL: 0x84F9;
    readonly RENDERBUFFER_WIDTH: 0x8D42;
    readonly RENDERBUFFER_HEIGHT: 0x8D43;
    readonly RENDERBUFFER_INTERNAL_FORMAT: 0x8D44;
    readonly RENDERBUFFER_RED_SIZE: 0x8D50;
    readonly RENDERBUFFER_GREEN_SIZE: 0x8D51;
    readonly RENDERBUFFER_BLUE_SIZE: 0x8D52;
    readonly RENDERBUFFER_ALPHA_SIZE: 0x8D53;
    readonly RENDERBUFFER_DEPTH_SIZE: 0x8D54;
    readonly RENDERBUFFER_STENCIL_SIZE: 0x8D55;
    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0;
    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1;
    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2;
    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3;
    readonly COLOR_ATTACHMENT0: 0x8CE0;
    readonly DEPTH_ATTACHMENT: 0x8D00;
    readonly STENCIL_ATTACHMENT: 0x8D20;
    readonly DEPTH_STENCIL_ATTACHMENT: 0x821A;
    readonly NONE: 0;
    readonly FRAMEBUFFER_COMPLETE: 0x8CD5;
    readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6;
    readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7;
    readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9;
    readonly FRAMEBUFFER_UNSUPPORTED: 0x8CDD;
    readonly FRAMEBUFFER_BINDING: 0x8CA6;
    readonly RENDERBUFFER_BINDING: 0x8CA7;
    readonly MAX_RENDERBUFFER_SIZE: 0x84E8;
    readonly INVALID_FRAMEBUFFER_OPERATION: 0x0506;
    readonly UNPACK_FLIP_Y_WEBGL: 0x9240;
    readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241;
    readonly CONTEXT_LOST_WEBGL: 0x9242;
    readonly UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243;
    readonly BROWSER_DEFAULT_WEBGL: 0x9244;
}

interface WebGLSampler {
}

declare var WebGLSampler: {
    prototype: WebGLSampler;
    new(): WebGLSampler;
    isInstance: IsInstance<WebGLSampler>;
};

interface WebGLShader {
}

declare var WebGLShader: {
    prototype: WebGLShader;
    new(): WebGLShader;
    isInstance: IsInstance<WebGLShader>;
};

interface WebGLShaderPrecisionFormat {
    readonly precision: GLint;
    readonly rangeMax: GLint;
    readonly rangeMin: GLint;
}

declare var WebGLShaderPrecisionFormat: {
    prototype: WebGLShaderPrecisionFormat;
    new(): WebGLShaderPrecisionFormat;
    isInstance: IsInstance<WebGLShaderPrecisionFormat>;
};

interface WebGLSync {
}

declare var WebGLSync: {
    prototype: WebGLSync;
    new(): WebGLSync;
    isInstance: IsInstance<WebGLSync>;
};

interface WebGLTexture {
}

declare var WebGLTexture: {
    prototype: WebGLTexture;
    new(): WebGLTexture;
    isInstance: IsInstance<WebGLTexture>;
};

interface WebGLTransformFeedback {
}

declare var WebGLTransformFeedback: {
    prototype: WebGLTransformFeedback;
    new(): WebGLTransformFeedback;
    isInstance: IsInstance<WebGLTransformFeedback>;
};

interface WebGLUniformLocation {
}

declare var WebGLUniformLocation: {
    prototype: WebGLUniformLocation;
    new(): WebGLUniformLocation;
    isInstance: IsInstance<WebGLUniformLocation>;
};

interface WebGLVertexArrayObject {
}

declare var WebGLVertexArrayObject: {
    prototype: WebGLVertexArrayObject;
    new(): WebGLVertexArrayObject;
    isInstance: IsInstance<WebGLVertexArrayObject>;
};

interface WebSocketEventMap {
    "close": Event;
    "error": Event;
    "message": Event;
    "open": Event;
}

interface WebSocket extends EventTarget {
    binaryType: BinaryType;
    readonly bufferedAmount: number;
    readonly extensions: string;
    onclose: ((this: WebSocket, ev: Event) => any) | null;
    onerror: ((this: WebSocket, ev: Event) => any) | null;
    onmessage: ((this: WebSocket, ev: Event) => any) | null;
    onopen: ((this: WebSocket, ev: Event) => any) | null;
    readonly protocol: string;
    readonly readyState: number;
    readonly url: string;
    close(code?: number, reason?: string): void;
    send(data: string): void;
    send(data: Blob): void;
    send(data: ArrayBuffer): void;
    send(data: ArrayBufferView): void;
    readonly CONNECTING: 0;
    readonly OPEN: 1;
    readonly CLOSING: 2;
    readonly CLOSED: 3;
    addEventListener<K extends keyof WebSocketEventMap>(type: K, listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof WebSocketEventMap>(type: K, listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var WebSocket: {
    prototype: WebSocket;
    new(url: string, protocols?: string | string[]): WebSocket;
    readonly CONNECTING: 0;
    readonly OPEN: 1;
    readonly CLOSING: 2;
    readonly CLOSED: 3;
    isInstance: IsInstance<WebSocket>;
    createServerWebSocket(url: string, protocols: string[], transportProvider: nsITransportProvider, negotiatedExtensions: string): WebSocket;
};

/** Available only in secure contexts. */
interface WebTransport {
    readonly closed: Promise<WebTransportCloseInfo>;
    readonly congestionControl: WebTransportCongestionControl;
    readonly datagrams: WebTransportDatagramDuplexStream;
    readonly incomingBidirectionalStreams: ReadableStream;
    readonly incomingUnidirectionalStreams: ReadableStream;
    readonly ready: Promise<void>;
    readonly reliability: WebTransportReliabilityMode;
    close(closeInfo?: WebTransportCloseInfo): void;
    createBidirectionalStream(options?: WebTransportSendStreamOptions): Promise<WebTransportBidirectionalStream>;
    createUnidirectionalStream(options?: WebTransportSendStreamOptions): Promise<WritableStream>;
    getStats(): Promise<WebTransportStats>;
}

declare var WebTransport: {
    prototype: WebTransport;
    new(url: string | URL, options?: WebTransportOptions): WebTransport;
    isInstance: IsInstance<WebTransport>;
};

/** Available only in secure contexts. */
interface WebTransportBidirectionalStream {
    readonly readable: WebTransportReceiveStream;
    readonly writable: WebTransportSendStream;
}

declare var WebTransportBidirectionalStream: {
    prototype: WebTransportBidirectionalStream;
    new(): WebTransportBidirectionalStream;
    isInstance: IsInstance<WebTransportBidirectionalStream>;
};

/** Available only in secure contexts. */
interface WebTransportDatagramDuplexStream {
    incomingHighWaterMark: number;
    incomingMaxAge: number;
    readonly maxDatagramSize: number;
    outgoingHighWaterMark: number;
    outgoingMaxAge: number;
    readonly readable: ReadableStream;
    readonly writable: WritableStream;
}

declare var WebTransportDatagramDuplexStream: {
    prototype: WebTransportDatagramDuplexStream;
    new(): WebTransportDatagramDuplexStream;
    isInstance: IsInstance<WebTransportDatagramDuplexStream>;
};

/** Available only in secure contexts. */
interface WebTransportError extends DOMException {
    readonly source: WebTransportErrorSource;
    readonly streamErrorCode: number | null;
}

declare var WebTransportError: {
    prototype: WebTransportError;
    new(init?: WebTransportErrorInit): WebTransportError;
    isInstance: IsInstance<WebTransportError>;
};

/** Available only in secure contexts. */
interface WebTransportReceiveStream extends ReadableStream {
    getStats(): Promise<WebTransportReceiveStreamStats>;
}

declare var WebTransportReceiveStream: {
    prototype: WebTransportReceiveStream;
    new(): WebTransportReceiveStream;
    isInstance: IsInstance<WebTransportReceiveStream>;
};

/** Available only in secure contexts. */
interface WebTransportSendStream extends WritableStream {
    sendOrder: number | null;
    getStats(): Promise<WebTransportSendStreamStats>;
}

declare var WebTransportSendStream: {
    prototype: WebTransportSendStream;
    new(): WebTransportSendStream;
    isInstance: IsInstance<WebTransportSendStream>;
};

interface WheelEvent extends MouseEvent {
    readonly deltaMode: number;
    readonly deltaX: number;
    readonly deltaY: number;
    readonly deltaZ: number;
    readonly wheelDelta: number;
    readonly wheelDeltaX: number;
    readonly wheelDeltaY: number;
    readonly DOM_DELTA_PIXEL: 0x00;
    readonly DOM_DELTA_LINE: 0x01;
    readonly DOM_DELTA_PAGE: 0x02;
}

declare var WheelEvent: {
    prototype: WheelEvent;
    new(type: string, eventInitDict?: WheelEventInit): WheelEvent;
    readonly DOM_DELTA_PIXEL: 0x00;
    readonly DOM_DELTA_LINE: 0x01;
    readonly DOM_DELTA_PAGE: 0x02;
    isInstance: IsInstance<WheelEvent>;
};

interface WindowEventMap extends GlobalEventHandlersEventMap, OnErrorEventHandlerForWindowEventMap, TouchEventHandlersEventMap, WindowEventHandlersEventMap {
    "devicelight": Event;
    "devicemotion": Event;
    "deviceorientation": Event;
    "deviceorientationabsolute": Event;
    "orientationchange": Event;
    "userproximity": Event;
    "vrdisplayactivate": Event;
    "vrdisplayconnect": Event;
    "vrdisplaydeactivate": Event;
    "vrdisplaydisconnect": Event;
    "vrdisplaypresentchange": Event;
}

interface Window extends EventTarget, AnimationFrameProvider, GlobalCrypto, GlobalEventHandlers, OnErrorEventHandlerForWindow, SpeechSynthesisGetter, TouchEventHandlers, WindowEventHandlers, WindowLocalStorage, WindowOrWorkerGlobalScope, WindowSessionStorage {
    readonly Glean: GleanImpl;
    readonly GleanPings: GleanPingsImpl;
    readonly InstallTrigger: InstallTriggerImpl | null;
    browserDOMWindow: nsIBrowserDOMWindow | null;
    readonly browsingContext: BrowsingContext;
    readonly clientInformation: Navigator;
    readonly clientPrincipal: Principal | null;
    readonly closed: boolean;
    readonly content: any;
    readonly controllers: XULControllers;
    readonly cookieStore: CookieStore;
    readonly customElements: CustomElementRegistry;
    readonly desktopToDeviceScale: number;
    readonly devicePixelRatio: number;
    readonly docShell: nsIDocShell | null;
    readonly document: Document;
    readonly event: Event | undefined;
    readonly external: External;
    readonly frameElement: Element | null;
    readonly frames: WindowProxy;
    fullScreen: boolean;
    readonly history: History;
    readonly innerHeight: number;
    readonly innerWidth: number;
    readonly intlUtils: IntlUtils;
    readonly isChromeWindow: boolean;
    readonly isFullyOccluded: boolean;
    readonly isInFullScreenTransition: boolean;
    readonly length: number;
    readonly location: Location;
    readonly locationbar: BarProp;
    readonly menubar: BarProp;
    readonly messageManager: ChromeMessageBroadcaster;
    readonly mozInnerScreenX: number;
    readonly mozInnerScreenY: number;
    name: string;
    readonly navigation: Navigation;
    readonly navigator: Navigator;
    ondevicelight: ((this: Window, ev: Event) => any) | null;
    ondevicemotion: ((this: Window, ev: Event) => any) | null;
    ondeviceorientation: ((this: Window, ev: Event) => any) | null;
    ondeviceorientationabsolute: ((this: Window, ev: Event) => any) | null;
    onorientationchange: ((this: Window, ev: Event) => any) | null;
    onuserproximity: ((this: Window, ev: Event) => any) | null;
    onvrdisplayactivate: ((this: Window, ev: Event) => any) | null;
    onvrdisplayconnect: ((this: Window, ev: Event) => any) | null;
    onvrdisplaydeactivate: ((this: Window, ev: Event) => any) | null;
    onvrdisplaydisconnect: ((this: Window, ev: Event) => any) | null;
    onvrdisplaypresentchange: ((this: Window, ev: Event) => any) | null;
    opener: any;
    readonly orientation: number;
    readonly originAgentCluster: boolean;
    readonly outerHeight: number;
    readonly outerWidth: number;
    readonly pageXOffset: number;
    readonly pageYOffset: number;
    readonly paintWorklet: Worklet;
    readonly parent: WindowProxy | null;
    readonly performance: Performance | null;
    readonly personalbar: BarProp;
    readonly realFrameElement: Element | null;
    readonly screen: Screen;
    readonly screenEdgeSlopX: number;
    readonly screenEdgeSlopY: number;
    readonly screenLeft: number;
    readonly screenTop: number;
    readonly screenX: number;
    readonly screenY: number;
    readonly scrollMaxX: number;
    readonly scrollMaxY: number;
    readonly scrollMinX: number;
    readonly scrollMinY: number;
    readonly scrollX: number;
    readonly scrollY: number;
    readonly scrollbars: BarProp;
    readonly self: WindowProxy;
    status: string;
    readonly statusbar: BarProp;
    readonly toolbar: BarProp;
    readonly top: WindowProxy | null;
    readonly visualViewport: VisualViewport;
    readonly window: WindowProxy;
    readonly windowGlobalChild: WindowGlobalChild | null;
    readonly windowRoot: WindowRoot | null;
    readonly windowState: number;
    readonly windowUtils: nsIDOMWindowUtils;
    alert(): void;
    alert(message: string): void;
    blur(): void;
    cancelIdleCallback(handle: number): void;
    captureEvents(): void;
    close(): void;
    confirm(message?: string): boolean;
    dump(str: string): void;
    find(str?: string, caseSensitive?: boolean, backwards?: boolean, wrapAround?: boolean, wholeWord?: boolean, searchInFrames?: boolean, showDialog?: boolean): boolean;
    focus(): void;
    getAttention(): void;
    getAttentionWithCycleCount(aCycleCount: number): void;
    getComputedStyle(elt: Element, pseudoElt?: string | null): CSSStyleDeclaration | null;
    getDefaultComputedStyle(elt: Element, pseudoElt?: string): CSSStyleDeclaration | null;
    getGroupMessageManager(aGroup: string): ChromeMessageBroadcaster;
    getInterface(iid: any): any;
    getRegionalPrefsLocales(): string[];
    getSelection(): Selection | null;
    getWebExposedLocales(): string[];
    getWorkspaceID(): string;
    matchMedia(query: string): MediaQueryList | null;
    maximize(): void;
    minimize(): void;
    moveBy(x: number, y: number): void;
    moveTo(x: number, y: number): void;
    moveToWorkspace(workspaceID: string): void;
    mozScrollSnap(): void;
    notifyDefaultButtonLoaded(defaultButton: Element): void;
    open(url?: string | URL, target?: string, features?: string): WindowProxy | null;
    openDialog(url?: string, name?: string, options?: string, ...extraArguments: any[]): WindowProxy | null;
    postMessage(message: any, targetOrigin: string, transfer?: any[]): void;
    postMessage(message: any, options?: WindowPostMessageOptions): void;
    print(): void;
    printPreview(settings?: nsIPrintSettings | null, listener?: nsIWebProgressListener | null, docShellToPreviewInto?: nsIDocShell | null): WindowProxy | null;
    promiseDocumentFlushed(callback: PromiseDocumentFlushedCallback): Promise<any>;
    prompt(message?: string, _default?: string): string | null;
    releaseEvents(): void;
    requestIdleCallback(callback: IdleRequestCallback, options?: IdleRequestOptions): number;
    resizeBy(x: number, y: number): void;
    resizeTo(x: number, y: number): void;
    restore(): void;
    scroll(x: number, y: number): void;
    scroll(options?: ScrollToOptions): void;
    scrollBy(x: number, y: number): void;
    scrollBy(options?: ScrollToOptions): void;
    scrollByLines(numLines: number, options?: ScrollOptions): void;
    scrollByPages(numPages: number, options?: ScrollOptions): void;
    scrollTo(x: number, y: number): void;
    scrollTo(options?: ScrollToOptions): void;
    setCursor(cursor: string): void;
    setResizable(resizable: boolean): void;
    setScrollMarks(marks: number[], onHorizontalScrollbar?: boolean): void;
    shouldReportForServiceWorkerScope(aScope: string): boolean;
    sizeToContent(constraints?: SizeToContentConstraints): void;
    stop(): void;
    updateCommands(action: string): void;
    readonly STATE_MAXIMIZED: 1;
    readonly STATE_MINIMIZED: 2;
    readonly STATE_NORMAL: 3;
    readonly STATE_FULLSCREEN: 4;
    addEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    [name: string]: any;
}

declare var Window: {
    prototype: Window;
    new(): Window;
    readonly STATE_MAXIMIZED: 1;
    readonly STATE_MINIMIZED: 2;
    readonly STATE_NORMAL: 3;
    readonly STATE_FULLSCREEN: 4;
    isInstance: IsInstance<Window>;
};

interface WindowContext {
    allowJavascript: boolean;
    readonly browsingContext: BrowsingContext | null;
    readonly hasBeforeUnload: boolean;
    readonly innerWindowId: number;
    readonly isInBFCache: boolean;
    readonly isInProcess: boolean;
    readonly isLocalIP: boolean;
    readonly overriddenFingerprintingSettings: nsIRFPTargetSetIDL | null;
    readonly parentWindowContext: WindowContext | null;
    readonly shouldResistFingerprinting: boolean;
    readonly topWindowContext: WindowContext;
    readonly usingStorageAccess: boolean;
    readonly windowGlobalChild: WindowGlobalChild | null;
}

declare var WindowContext: {
    prototype: WindowContext;
    new(): WindowContext;
    isInstance: IsInstance<WindowContext>;
};

interface WindowEventHandlersEventMap {
    "afterprint": Event;
    "beforeprint": Event;
    "beforeunload": Event;
    "gamepadconnected": Event;
    "gamepaddisconnected": Event;
    "hashchange": Event;
    "languagechange": Event;
    "message": Event;
    "messageerror": Event;
    "offline": Event;
    "online": Event;
    "pagehide": Event;
    "pageshow": Event;
    "popstate": Event;
    "rejectionhandled": Event;
    "storage": Event;
    "unhandledrejection": Event;
    "unload": Event;
}

interface WindowEventHandlers {
    onafterprint: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onbeforeprint: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onbeforeunload: ((this: WindowEventHandlers, ev: Event) => any) | null;
    ongamepadconnected: ((this: WindowEventHandlers, ev: Event) => any) | null;
    ongamepaddisconnected: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onhashchange: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onlanguagechange: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onmessage: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onmessageerror: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onoffline: ((this: WindowEventHandlers, ev: Event) => any) | null;
    ononline: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onpagehide: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onpageshow: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onpopstate: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onrejectionhandled: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onstorage: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onunhandledrejection: ((this: WindowEventHandlers, ev: Event) => any) | null;
    onunload: ((this: WindowEventHandlers, ev: Event) => any) | null;
    addEventListener<K extends keyof WindowEventHandlersEventMap>(type: K, listener: (this: WindowEventHandlers, ev: WindowEventHandlersEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof WindowEventHandlersEventMap>(type: K, listener: (this: WindowEventHandlers, ev: WindowEventHandlersEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

interface WindowGlobalChild {
    readonly browsingContext: BrowsingContext;
    readonly contentParentId: number;
    readonly contentWindow: WindowProxy | null;
    readonly innerWindowId: number;
    readonly isClosed: boolean;
    readonly isCurrentGlobal: boolean;
    readonly isInProcess: boolean;
    readonly isProcessRoot: boolean;
    readonly outerWindowId: number;
    readonly parentActor: WindowGlobalParent | null;
    readonly sameOriginWithTop: boolean;
    readonly windowContext: WindowContext;
    findBrowsingContextWithName(name: string): BrowsingContext | null;
    getActor(name: string): JSWindowActorChild;
    getExistingActor(name: string): JSWindowActorChild | null;
}

declare var WindowGlobalChild: {
    prototype: WindowGlobalChild;
    new(): WindowGlobalChild;
    isInstance: IsInstance<WindowGlobalChild>;
    getByInnerWindowId(innerWIndowId: number): WindowGlobalChild | null;
};

interface WindowGlobalParent extends WindowContext {
    readonly childActor: WindowGlobalChild | null;
    readonly contentBlockingAllowListPrincipal: Principal | null;
    readonly contentBlockingEvents: number;
    readonly contentBlockingLog: string;
    readonly contentParentId: number;
    readonly cookieJarSettings: nsICookieJarSettings | null;
    readonly documentPrincipal: Principal;
    readonly documentStoragePrincipal: Principal;
    readonly documentTitle: string;
    readonly documentURI: URI | null;
    readonly domProcess: nsIDOMProcessParent | null;
    fullscreen: boolean;
    readonly isActiveInTab: boolean;
    readonly isClosed: boolean;
    readonly isCurrentGlobal: boolean;
    readonly isInitialDocument: boolean;
    readonly isProcessRoot: boolean;
    readonly osPid: number;
    readonly outerWindowId: number;
    readonly rootFrameLoader: FrameLoader | null;
    drawSnapshot(rect: DOMRect | null, scale: number, backgroundColor: string, resetScrollPosition?: boolean): Promise<ImageBitmap>;
    getActor(name: string): JSWindowActorParent;
    getExistingActor(name: string): JSWindowActorParent | null;
    hasActivePeerConnections(): boolean;
    permitUnload(action?: PermitUnloadAction, timeout?: number): Promise<boolean>;
}

declare var WindowGlobalParent: {
    prototype: WindowGlobalParent;
    new(): WindowGlobalParent;
    isInstance: IsInstance<WindowGlobalParent>;
    getByInnerWindowId(innerWindowId: number): WindowGlobalParent | null;
};

interface WindowLocalStorage {
    readonly localStorage: Storage | null;
}

interface WindowOrWorkerGlobalScope {
    readonly caches: CacheStorage;
    readonly crossOriginIsolated: boolean;
    readonly indexedDB: IDBFactory | null;
    readonly isSecureContext: boolean;
    readonly origin: string;
    readonly scheduler: Scheduler;
    readonly trustedTypes: TrustedTypePolicyFactory;
    atob(atob: string): string;
    btoa(btoa: string): string;
    clearInterval(handle?: number): void;
    clearTimeout(handle?: number): void;
    createImageBitmap(aImage: ImageBitmapSource, aOptions?: ImageBitmapOptions): Promise<ImageBitmap>;
    createImageBitmap(aImage: ImageBitmapSource, aSx: number, aSy: number, aSw: number, aSh: number, aOptions?: ImageBitmapOptions): Promise<ImageBitmap>;
    fetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
    queueMicrotask(callback: VoidFunction): void;
    reportError(e: any): void;
    setInterval(handler: TimerHandler, timeout?: number, ...unused: any[]): number;
    setTimeout(handler: TimerHandler, timeout?: number, ...arguments: any[]): number;
    structuredClone(value: any, options?: StructuredSerializeOptions): any;
}

interface WindowRoot extends EventTarget {
}

declare var WindowRoot: {
    prototype: WindowRoot;
    new(): WindowRoot;
    isInstance: IsInstance<WindowRoot>;
};

interface WindowSessionStorage {
    readonly sessionStorage: Storage | null;
}

interface WorkerEventMap extends AbstractWorkerEventMap {
    "message": Event;
    "messageerror": Event;
}

interface Worker extends EventTarget, AbstractWorker {
    onmessage: ((this: Worker, ev: Event) => any) | null;
    onmessageerror: ((this: Worker, ev: Event) => any) | null;
    postMessage(message: any, transfer: any[]): void;
    postMessage(message: any, aOptions?: StructuredSerializeOptions): void;
    terminate(): void;
    addEventListener<K extends keyof WorkerEventMap>(type: K, listener: (this: Worker, ev: WorkerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof WorkerEventMap>(type: K, listener: (this: Worker, ev: WorkerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var Worker: {
    prototype: Worker;
    new(scriptURL: TrustedScriptURL | string, options?: WorkerOptions): Worker;
    isInstance: IsInstance<Worker>;
};

/** Available only in secure contexts. */
interface Worklet {
    addModule(moduleURL: string | URL, options?: WorkletOptions): Promise<void>;
}

declare var Worklet: {
    prototype: Worklet;
    new(): Worklet;
    isInstance: IsInstance<Worklet>;
};

interface WrapperCachedNonISupportsTestInterface {
}

declare var WrapperCachedNonISupportsTestInterface: {
    prototype: WrapperCachedNonISupportsTestInterface;
    new(): WrapperCachedNonISupportsTestInterface;
    isInstance: IsInstance<WrapperCachedNonISupportsTestInterface>;
};

interface WritableStream {
    readonly locked: boolean;
    abort(reason?: any): Promise<void>;
    close(): Promise<void>;
    getWriter(): WritableStreamDefaultWriter;
}

declare var WritableStream: {
    prototype: WritableStream;
    new(underlyingSink?: any, strategy?: QueuingStrategy): WritableStream;
    isInstance: IsInstance<WritableStream>;
};

interface WritableStreamDefaultController {
    readonly signal: AbortSignal;
    error(e?: any): void;
}

declare var WritableStreamDefaultController: {
    prototype: WritableStreamDefaultController;
    new(): WritableStreamDefaultController;
    isInstance: IsInstance<WritableStreamDefaultController>;
};

interface WritableStreamDefaultWriter {
    readonly closed: Promise<void>;
    readonly desiredSize: number | null;
    readonly ready: Promise<void>;
    abort(reason?: any): Promise<void>;
    close(): Promise<void>;
    releaseLock(): void;
    write(chunk?: any): Promise<void>;
}

declare var WritableStreamDefaultWriter: {
    prototype: WritableStreamDefaultWriter;
    new(stream: WritableStream): WritableStreamDefaultWriter;
    isInstance: IsInstance<WritableStreamDefaultWriter>;
};

interface XMLDocument extends Document {
    addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: XMLDocument, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: XMLDocument, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XMLDocument: {
    prototype: XMLDocument;
    new(): XMLDocument;
    isInstance: IsInstance<XMLDocument>;
};

interface XMLHttpRequestEventMap extends XMLHttpRequestEventTargetEventMap {
    "readystatechange": Event;
}

interface XMLHttpRequest extends XMLHttpRequestEventTarget {
    readonly channel: MozChannel | null;
    readonly errorCode: number;
    readonly mozAnon: boolean;
    mozBackgroundRequest: boolean;
    readonly mozSystem: boolean;
    onreadystatechange: ((this: XMLHttpRequest, ev: Event) => any) | null;
    readonly readyState: number;
    readonly response: any;
    readonly responseText: string | null;
    responseType: XMLHttpRequestResponseType;
    readonly responseURL: string;
    readonly responseXML: Document | null;
    readonly status: number;
    readonly statusText: string;
    timeout: number;
    readonly upload: XMLHttpRequestUpload;
    withCredentials: boolean;
    abort(): void;
    getAllResponseHeaders(): string;
    getInterface(iid: any): any;
    getResponseHeader(header: string): string | null;
    open(method: string, url: string): void;
    open(method: string, url: string, async: boolean, user?: string | null, password?: string | null): void;
    overrideMimeType(mime: string): void;
    send(body?: Document | XMLHttpRequestBodyInit | null): void;
    sendInputStream(body: InputStream): void;
    setOriginAttributes(originAttributes?: OriginAttributesDictionary): void;
    setRequestHeader(header: string, value: string): void;
    readonly UNSENT: 0;
    readonly OPENED: 1;
    readonly HEADERS_RECEIVED: 2;
    readonly LOADING: 3;
    readonly DONE: 4;
    addEventListener<K extends keyof XMLHttpRequestEventMap>(type: K, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XMLHttpRequestEventMap>(type: K, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XMLHttpRequest: {
    prototype: XMLHttpRequest;
    new(params?: MozXMLHttpRequestParameters): XMLHttpRequest;
    new(ignored: string): XMLHttpRequest;
    readonly UNSENT: 0;
    readonly OPENED: 1;
    readonly HEADERS_RECEIVED: 2;
    readonly LOADING: 3;
    readonly DONE: 4;
    isInstance: IsInstance<XMLHttpRequest>;
};

interface XMLHttpRequestEventTargetEventMap {
    "abort": Event;
    "error": Event;
    "load": Event;
    "loadend": Event;
    "loadstart": Event;
    "progress": Event;
    "timeout": Event;
}

interface XMLHttpRequestEventTarget extends EventTarget {
    onabort: ((this: XMLHttpRequestEventTarget, ev: Event) => any) | null;
    onerror: ((this: XMLHttpRequestEventTarget, ev: Event) => any) | null;
    onload: ((this: XMLHttpRequestEventTarget, ev: Event) => any) | null;
    onloadend: ((this: XMLHttpRequestEventTarget, ev: Event) => any) | null;
    onloadstart: ((this: XMLHttpRequestEventTarget, ev: Event) => any) | null;
    onprogress: ((this: XMLHttpRequestEventTarget, ev: Event) => any) | null;
    ontimeout: ((this: XMLHttpRequestEventTarget, ev: Event) => any) | null;
    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XMLHttpRequestEventTarget: {
    prototype: XMLHttpRequestEventTarget;
    new(): XMLHttpRequestEventTarget;
    isInstance: IsInstance<XMLHttpRequestEventTarget>;
};

interface XMLHttpRequestUpload extends XMLHttpRequestEventTarget {
    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XMLHttpRequestUpload: {
    prototype: XMLHttpRequestUpload;
    new(): XMLHttpRequestUpload;
    isInstance: IsInstance<XMLHttpRequestUpload>;
};

interface XMLSerializer {
    serializeToStream(root: Node, stream: OutputStream, charset: string | null): void;
    serializeToString(root: Node): string;
}

declare var XMLSerializer: {
    prototype: XMLSerializer;
    new(): XMLSerializer;
    isInstance: IsInstance<XMLSerializer>;
};

interface XPathEvaluator extends XPathEvaluatorMixin {
}

declare var XPathEvaluator: {
    prototype: XPathEvaluator;
    new(): XPathEvaluator;
    isInstance: IsInstance<XPathEvaluator>;
};

interface XPathEvaluatorMixin {
    createExpression(expression: string, resolver?: XPathNSResolver | null): XPathExpression;
    createNSResolver(nodeResolver: Node): Node;
    evaluate(expression: string, contextNode: Node, resolver?: XPathNSResolver | null, type?: number, result?: any): XPathResult;
}

interface XPathExpression {
    evaluate(contextNode: Node, type?: number, result?: any): XPathResult;
    evaluateWithContext(contextNode: Node, contextPosition: number, contextSize: number, type?: number, result?: any): XPathResult;
}

declare var XPathExpression: {
    prototype: XPathExpression;
    new(): XPathExpression;
    isInstance: IsInstance<XPathExpression>;
};

interface XPathResult {
    readonly booleanValue: boolean;
    readonly invalidIteratorState: boolean;
    readonly numberValue: number;
    readonly resultType: number;
    readonly singleNodeValue: Node | null;
    readonly snapshotLength: number;
    readonly stringValue: string;
    iterateNext(): Node | null;
    snapshotItem(index: number): Node | null;
    readonly ANY_TYPE: 0;
    readonly NUMBER_TYPE: 1;
    readonly STRING_TYPE: 2;
    readonly BOOLEAN_TYPE: 3;
    readonly UNORDERED_NODE_ITERATOR_TYPE: 4;
    readonly ORDERED_NODE_ITERATOR_TYPE: 5;
    readonly UNORDERED_NODE_SNAPSHOT_TYPE: 6;
    readonly ORDERED_NODE_SNAPSHOT_TYPE: 7;
    readonly ANY_UNORDERED_NODE_TYPE: 8;
    readonly FIRST_ORDERED_NODE_TYPE: 9;
}

declare var XPathResult: {
    prototype: XPathResult;
    new(): XPathResult;
    readonly ANY_TYPE: 0;
    readonly NUMBER_TYPE: 1;
    readonly STRING_TYPE: 2;
    readonly BOOLEAN_TYPE: 3;
    readonly UNORDERED_NODE_ITERATOR_TYPE: 4;
    readonly ORDERED_NODE_ITERATOR_TYPE: 5;
    readonly UNORDERED_NODE_SNAPSHOT_TYPE: 6;
    readonly ORDERED_NODE_SNAPSHOT_TYPE: 7;
    readonly ANY_UNORDERED_NODE_TYPE: 8;
    readonly FIRST_ORDERED_NODE_TYPE: 9;
    isInstance: IsInstance<XPathResult>;
};

/** Available only in secure contexts. */
interface XRBoundedReferenceSpace extends XRReferenceSpace {
    readonly boundsGeometry: DOMPointReadOnly[];
    addEventListener<K extends keyof XRReferenceSpaceEventMap>(type: K, listener: (this: XRBoundedReferenceSpace, ev: XRReferenceSpaceEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XRReferenceSpaceEventMap>(type: K, listener: (this: XRBoundedReferenceSpace, ev: XRReferenceSpaceEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XRBoundedReferenceSpace: {
    prototype: XRBoundedReferenceSpace;
    new(): XRBoundedReferenceSpace;
    isInstance: IsInstance<XRBoundedReferenceSpace>;
};

/** Available only in secure contexts. */
interface XRFrame {
    readonly session: XRSession;
    getPose(space: XRSpace, baseSpace: XRSpace): XRPose | null;
    getViewerPose(referenceSpace: XRReferenceSpace): XRViewerPose | null;
}

declare var XRFrame: {
    prototype: XRFrame;
    new(): XRFrame;
    isInstance: IsInstance<XRFrame>;
};

/** Available only in secure contexts. */
interface XRInputSource {
    readonly gamepad: Gamepad | null;
    readonly gripSpace: XRSpace | null;
    readonly handedness: XRHandedness;
    readonly profiles: string[];
    readonly targetRayMode: XRTargetRayMode;
    readonly targetRaySpace: XRSpace;
}

declare var XRInputSource: {
    prototype: XRInputSource;
    new(): XRInputSource;
    isInstance: IsInstance<XRInputSource>;
};

/** Available only in secure contexts. */
interface XRInputSourceArray {
    readonly length: number;
    forEach(callbackfn: (value: XRInputSource, key: number, parent: XRInputSourceArray) => void, thisArg?: any): void;
    [index: number]: XRInputSource;
}

declare var XRInputSourceArray: {
    prototype: XRInputSourceArray;
    new(): XRInputSourceArray;
    isInstance: IsInstance<XRInputSourceArray>;
};

/** Available only in secure contexts. */
interface XRInputSourceEvent extends Event {
    readonly frame: XRFrame;
    readonly inputSource: XRInputSource;
}

declare var XRInputSourceEvent: {
    prototype: XRInputSourceEvent;
    new(type: string, eventInitDict: XRInputSourceEventInit): XRInputSourceEvent;
    isInstance: IsInstance<XRInputSourceEvent>;
};

/** Available only in secure contexts. */
interface XRInputSourcesChangeEvent extends Event {
    readonly added: XRInputSource[];
    readonly removed: XRInputSource[];
    readonly session: XRSession;
}

declare var XRInputSourcesChangeEvent: {
    prototype: XRInputSourcesChangeEvent;
    new(type: string, eventInitDict: XRInputSourcesChangeEventInit): XRInputSourcesChangeEvent;
    isInstance: IsInstance<XRInputSourcesChangeEvent>;
};

/** Available only in secure contexts. */
interface XRPose {
    readonly emulatedPosition: boolean;
    readonly transform: XRRigidTransform;
}

declare var XRPose: {
    prototype: XRPose;
    new(): XRPose;
    isInstance: IsInstance<XRPose>;
};

interface XRReferenceSpaceEventMap {
    "reset": Event;
}

/** Available only in secure contexts. */
interface XRReferenceSpace extends XRSpace {
    onreset: ((this: XRReferenceSpace, ev: Event) => any) | null;
    getOffsetReferenceSpace(originOffset: XRRigidTransform): XRReferenceSpace;
    addEventListener<K extends keyof XRReferenceSpaceEventMap>(type: K, listener: (this: XRReferenceSpace, ev: XRReferenceSpaceEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XRReferenceSpaceEventMap>(type: K, listener: (this: XRReferenceSpace, ev: XRReferenceSpaceEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XRReferenceSpace: {
    prototype: XRReferenceSpace;
    new(): XRReferenceSpace;
    isInstance: IsInstance<XRReferenceSpace>;
};

/** Available only in secure contexts. */
interface XRReferenceSpaceEvent extends Event {
    readonly referenceSpace: XRReferenceSpace;
    readonly transform: XRRigidTransform | null;
}

declare var XRReferenceSpaceEvent: {
    prototype: XRReferenceSpaceEvent;
    new(type: string, eventInitDict: XRReferenceSpaceEventInit): XRReferenceSpaceEvent;
    isInstance: IsInstance<XRReferenceSpaceEvent>;
};

/** Available only in secure contexts. */
interface XRRenderState {
    readonly baseLayer: XRWebGLLayer | null;
    readonly depthFar: number;
    readonly depthNear: number;
    readonly inlineVerticalFieldOfView: number | null;
}

declare var XRRenderState: {
    prototype: XRRenderState;
    new(): XRRenderState;
    isInstance: IsInstance<XRRenderState>;
};

/** Available only in secure contexts. */
interface XRRigidTransform {
    readonly inverse: XRRigidTransform;
    readonly matrix: Float32Array;
    readonly orientation: DOMPointReadOnly;
    readonly position: DOMPointReadOnly;
}

declare var XRRigidTransform: {
    prototype: XRRigidTransform;
    new(position?: DOMPointInit, orientation?: DOMPointInit): XRRigidTransform;
    isInstance: IsInstance<XRRigidTransform>;
};

interface XRSessionEventMap {
    "end": Event;
    "inputsourceschange": Event;
    "select": Event;
    "selectend": Event;
    "selectstart": Event;
    "squeeze": Event;
    "squeezeend": Event;
    "squeezestart": Event;
    "visibilitychange": Event;
}

/** Available only in secure contexts. */
interface XRSession extends EventTarget {
    readonly frameRate: number | null;
    readonly inputSources: XRInputSourceArray;
    onend: ((this: XRSession, ev: Event) => any) | null;
    oninputsourceschange: ((this: XRSession, ev: Event) => any) | null;
    onselect: ((this: XRSession, ev: Event) => any) | null;
    onselectend: ((this: XRSession, ev: Event) => any) | null;
    onselectstart: ((this: XRSession, ev: Event) => any) | null;
    onsqueeze: ((this: XRSession, ev: Event) => any) | null;
    onsqueezeend: ((this: XRSession, ev: Event) => any) | null;
    onsqueezestart: ((this: XRSession, ev: Event) => any) | null;
    onvisibilitychange: ((this: XRSession, ev: Event) => any) | null;
    readonly renderState: XRRenderState;
    readonly supportedFrameRates: Float32Array | null;
    readonly visibilityState: XRVisibilityState;
    cancelAnimationFrame(handle: number): void;
    end(): Promise<void>;
    requestAnimationFrame(callback: XRFrameRequestCallback): number;
    requestReferenceSpace(type: XRReferenceSpaceType): Promise<XRReferenceSpace>;
    updateRenderState(state?: XRRenderStateInit): void;
    updateTargetFrameRate(rate: number): Promise<void>;
    addEventListener<K extends keyof XRSessionEventMap>(type: K, listener: (this: XRSession, ev: XRSessionEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XRSessionEventMap>(type: K, listener: (this: XRSession, ev: XRSessionEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XRSession: {
    prototype: XRSession;
    new(): XRSession;
    isInstance: IsInstance<XRSession>;
};

/** Available only in secure contexts. */
interface XRSessionEvent extends Event {
    readonly session: XRSession;
}

declare var XRSessionEvent: {
    prototype: XRSessionEvent;
    new(type: string, eventInitDict: XRSessionEventInit): XRSessionEvent;
    isInstance: IsInstance<XRSessionEvent>;
};

/** Available only in secure contexts. */
interface XRSpace extends EventTarget {
}

declare var XRSpace: {
    prototype: XRSpace;
    new(): XRSpace;
    isInstance: IsInstance<XRSpace>;
};

interface XRSystemEventMap {
    "devicechange": Event;
}

/** Available only in secure contexts. */
interface XRSystem extends EventTarget {
    ondevicechange: ((this: XRSystem, ev: Event) => any) | null;
    isSessionSupported(mode: XRSessionMode): Promise<boolean>;
    requestSession(mode: XRSessionMode, options?: XRSessionInit): Promise<XRSession>;
    addEventListener<K extends keyof XRSystemEventMap>(type: K, listener: (this: XRSystem, ev: XRSystemEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XRSystemEventMap>(type: K, listener: (this: XRSystem, ev: XRSystemEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XRSystem: {
    prototype: XRSystem;
    new(): XRSystem;
    isInstance: IsInstance<XRSystem>;
};

/** Available only in secure contexts. */
interface XRView {
    readonly eye: XREye;
    readonly projectionMatrix: Float32Array;
    readonly transform: XRRigidTransform;
}

declare var XRView: {
    prototype: XRView;
    new(): XRView;
    isInstance: IsInstance<XRView>;
};

/** Available only in secure contexts. */
interface XRViewerPose extends XRPose {
    readonly views: XRView[];
}

declare var XRViewerPose: {
    prototype: XRViewerPose;
    new(): XRViewerPose;
    isInstance: IsInstance<XRViewerPose>;
};

/** Available only in secure contexts. */
interface XRViewport {
    readonly height: number;
    readonly width: number;
    readonly x: number;
    readonly y: number;
}

declare var XRViewport: {
    prototype: XRViewport;
    new(): XRViewport;
    isInstance: IsInstance<XRViewport>;
};

/** Available only in secure contexts. */
interface XRWebGLLayer {
    readonly antialias: boolean;
    readonly framebuffer: WebGLFramebuffer | null;
    readonly framebufferHeight: number;
    readonly framebufferWidth: number;
    readonly ignoreDepthValues: boolean;
    getViewport(view: XRView): XRViewport | null;
}

declare var XRWebGLLayer: {
    prototype: XRWebGLLayer;
    new(session: XRSession, context: XRWebGLRenderingContext, layerInit?: XRWebGLLayerInit): XRWebGLLayer;
    isInstance: IsInstance<XRWebGLLayer>;
    getNativeFramebufferScaleFactor(session: XRSession): number;
};

interface XSLTProcessor {
    flags: number;
    clearParameters(): void;
    getParameter(namespaceURI: string | null, localName: string): XSLTParameterValue | null;
    importStylesheet(style: Node): void;
    removeParameter(namespaceURI: string | null, localName: string): void;
    reset(): void;
    setParameter(namespaceURI: string | null, localName: string, value: XSLTParameterValue): void;
    transformToDocument(source: Node): Document;
    transformToFragment(source: Node, output: Document): DocumentFragment;
    readonly DISABLE_ALL_LOADS: 1;
}

declare var XSLTProcessor: {
    prototype: XSLTProcessor;
    new(): XSLTProcessor;
    readonly DISABLE_ALL_LOADS: 1;
    isInstance: IsInstance<XSLTProcessor>;
};

interface XULCommandEvent extends UIEvent {
    readonly altKey: boolean;
    readonly button: number;
    readonly ctrlKey: boolean;
    readonly inputSource: number;
    readonly metaKey: boolean;
    readonly shiftKey: boolean;
    readonly sourceEvent: Event | null;
    initCommandEvent(type: string, canBubble?: boolean, cancelable?: boolean, view?: Window | null, detail?: number, ctrlKey?: boolean, altKey?: boolean, shiftKey?: boolean, metaKey?: boolean, buttonArg?: number, sourceEvent?: Event | null, inputSource?: number): void;
}

declare var XULCommandEvent: {
    prototype: XULCommandEvent;
    new(): XULCommandEvent;
    isInstance: IsInstance<XULCommandEvent>;
};

interface XULElementEventMap extends ElementEventMap, GlobalEventHandlersEventMap, OnErrorEventHandlerForNodesEventMap, TouchEventHandlersEventMap {
}

interface XULElement extends Element, ElementCSSInlineStyle, GlobalEventHandlers, HTMLOrForeignElement, OnErrorEventHandlerForNodes, TouchEventHandlers {
    collapsed: boolean;
    contextMenu: string;
    readonly controllers: XULControllers;
    hidden: boolean;
    menu: string;
    observes: string;
    src: string;
    tooltip: string;
    tooltipText: string;
    click(): void;
    doCommand(): void;
    hasMenu(): boolean;
    openMenu(open: boolean): void;
    addEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULElement, ev: XULElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULElement, ev: XULElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XULElement: {
    prototype: XULElement;
    new(): XULElement;
    isInstance: IsInstance<XULElement>;
};

interface XULFrameElement extends XULElement, MozFrameLoaderOwner {
    readonly browserId: number;
    readonly contentDocument: Document | null;
    readonly contentWindow: WindowProxy | null;
    readonly docShell: nsIDocShell | null;
    openWindowInfo: nsIOpenWindowInfo | null;
    readonly webNavigation: nsIWebNavigation | null;
    addEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULFrameElement, ev: XULElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULFrameElement, ev: XULElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XULFrameElement: {
    prototype: XULFrameElement;
    new(): XULFrameElement;
    isInstance: IsInstance<XULFrameElement>;
};

interface XULMenuElement extends XULElement {
    activeChild: Element | null;
    readonly openedWithKey: boolean;
    handleKeyPress(keyEvent: KeyboardEvent): boolean;
    addEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULMenuElement, ev: XULElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULMenuElement, ev: XULElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XULMenuElement: {
    prototype: XULMenuElement;
    new(): XULMenuElement;
    isInstance: IsInstance<XULMenuElement>;
};

interface XULPopupElement extends XULElement {
    readonly anchorNode: Element | null;
    readonly isWaylandDragSource: boolean;
    readonly isWaylandPopup: boolean;
    label: string;
    position: string;
    readonly state: string;
    readonly triggerNode: Node | null;
    activateItem(itemElement: Element, options?: ActivateMenuItemOptions): void;
    getOuterScreenRect(): DOMRect;
    hidePopup(cancel?: boolean): void;
    moveTo(left: number, top: number): void;
    moveToAnchor(anchorElement?: Element | null, position?: string, x?: number, y?: number, attributesOverride?: boolean): void;
    openPopup(anchorElement?: Element | null, options?: StringOrOpenPopupOptions, x?: number, y?: number, isContextMenu?: boolean, attributesOverride?: boolean, triggerEvent?: Event | null): void;
    openPopupAtScreen(x?: number, y?: number, isContextMenu?: boolean, triggerEvent?: Event | null): void;
    openPopupAtScreenRect(position?: string, x?: number, y?: number, width?: number, height?: number, isContextMenu?: boolean, attributesOverride?: boolean, triggerEvent?: Event | null): void;
    setConstraintRect(rect: DOMRectReadOnly): void;
    sizeTo(width: number, height: number): void;
    addEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULPopupElement, ev: XULElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULPopupElement, ev: XULElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XULPopupElement: {
    prototype: XULPopupElement;
    new(): XULPopupElement;
    isInstance: IsInstance<XULPopupElement>;
};

interface XULResizerElement extends XULElement {
    addEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULResizerElement, ev: XULElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULResizerElement, ev: XULElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XULResizerElement: {
    prototype: XULResizerElement;
    new(): XULResizerElement;
    isInstance: IsInstance<XULResizerElement>;
};

interface XULTextElement extends XULElement {
    accessKey: string;
    disabled: boolean;
    value: string;
    addEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULTextElement, ev: XULElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULTextElement, ev: XULElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XULTextElement: {
    prototype: XULTextElement;
    new(): XULTextElement;
    isInstance: IsInstance<XULTextElement>;
};

interface XULTreeElement extends XULElement {
    readonly columns: TreeColumns | null;
    focused: boolean;
    readonly rowHeight: number;
    readonly rowWidth: number;
    readonly treeBody: Element | null;
    view: MozTreeView | null;
    beginUpdateBatch(): void;
    clearStyleAndImageCaches(): void;
    endUpdateBatch(): void;
    ensureCellIsVisible(row: number, col: TreeColumn | null): void;
    ensureRowIsVisible(index: number): void;
    getCellAt(x: number, y: number): TreeCellInfo;
    getCoordsForCellItem(row: number, col: TreeColumn, element: string): DOMRect | null;
    getFirstVisibleRow(): number;
    getLastVisibleRow(): number;
    getPageLength(): number;
    getRowAt(x: number, y: number): number;
    invalidate(): void;
    invalidateCell(row: number, col: TreeColumn | null): void;
    invalidateColumn(col: TreeColumn | null): void;
    invalidateRange(startIndex: number, endIndex: number): void;
    invalidateRow(index: number): void;
    isCellCropped(row: number, col: TreeColumn | null): boolean;
    removeImageCacheEntry(row: number, col: TreeColumn): void;
    rowCountChanged(index: number, count: number): void;
    scrollByLines(numLines: number): void;
    scrollByPages(numPages: number): void;
    scrollToRow(index: number): void;
    addEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULTreeElement, ev: XULElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof XULElementEventMap>(type: K, listener: (this: XULTreeElement, ev: XULElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

declare var XULTreeElement: {
    prototype: XULTreeElement;
    new(): XULTreeElement;
    isInstance: IsInstance<XULTreeElement>;
};

declare namespace APZHitResultFlags {
}

declare namespace AddonManagerPermissions {
    function isHostPermitted(host: string): boolean;
}

declare namespace CSS {
    var highlights: HighlightRegistry;
    function escape(ident: string): string;
    function registerProperty(definition: PropertyDefinition): void;
    function supports(property: string, value: string): boolean;
    function supports(conditionText: string): boolean;
}

declare namespace ChromeUtils {
    var aliveUtilityProcesses: number;
    var domProcessChild: nsIDOMProcessChild | null;
    var recentJSDevError: any;
    function CreateOriginAttributesFromOriginSuffix(suffix: string): OriginAttributesDictionary;
    function addProfilerMarker(name: string, options?: ProfilerMarkerOptions | DOMHighResTimeStamp, text?: string): void;
    function androidMoveTaskToBack(): void;
    function base64URLDecode(string: string, options: Base64URLDecodeOptions): ArrayBuffer;
    function base64URLEncode(source: BufferSource, options: Base64URLEncodeOptions): string;
    function callFunctionAndLogException(targetGlobal: any, func: any): any;
    function clearMessagingLayerSecurityState(): void;
    function clearMessagingLayerSecurityStateByPrincipal(principal: Principal): void;
    function clearMessagingLayerSecurityStateBySite(schemelessSite: string, pattern?: OriginAttributesPatternDictionary): void;
    function clearRecentJSDevError(): void;
    function clearResourceCache(options?: ClearResourceCacheOptions): void;
    function collectPerfStats(): Promise<string>;
    function collectScrollingData(): Promise<InteractionData>;
    function compileScript(url: string, options?: CompileScriptOptionsDictionary): Promise<PrecompiledScript>;
    function consumeInteractionData(): Record<string, InteractionData>;
    function createCSPFromHeader(header: string, selfURI: URI, loadingPrincipal: Principal): ContentSecurityPolicy;
    function createError(message: string, stack?: any): any;
    function createOriginAttributesFromOrigin(origin: string): OriginAttributesDictionary;
    function dateNow(): number;
    function defineESModuleGetters(aTarget: any, aModules: any, aOptions?: ImportESModuleOptionsDictionary): void;
    function defineLazyGetter(aTarget: any, aName: any, aLambda: any): void;
    function endWheelTransaction(): void;
    function ensureHeadlessContentProcess(aRemoteType: string): Promise<nsIContentParentKeepAlive>;
    function ensureJSOracleStarted(): void;
    function fillNonDefaultOriginAttributes(originAttrs?: OriginAttributesDictionary): OriginAttributesDictionary;
    function generateQI(interfaces: any[]): MozQueryInterface;
    function getAllDOMProcesses(): nsIDOMProcessParent[];
    function getAllPossibleUtilityActorNames(): string[];
    function getBaseDomainFromPartitionKey(partitionKey: string): string;
    function getCallerLocation(principal: Principal): any;
    function getClassName(obj: any, unwrap?: boolean): string;
    function getFormAutofillConfidences(elements: Element[]): FormAutofillConfidences[];
    function getGMPContentDecryptionModuleInformation(): Promise<CDMInformation[]>;
    function getLibcConstants(): LibcConstants;
    function getObjectNodeId(obj: any): NodeId;
    function getPartitionKeyFromURL(topLevelUrl: string, subresourceUrl: string, foreignContext?: boolean): string;
    function getPopupControlState(): PopupBlockerState;
    function getWMFContentDecryptionModuleInformation(): Promise<CDMInformation[]>;
    function getXPCOMErrorName(aErrorCode: number): string;
    function hasReportingHeaderForOrigin(aOrigin: string): boolean;
    function idleDispatch(callback: IdleRequestCallback, options?: IdleRequestOptions): void;
    function importESModule(aResourceURI: string, aOptions?: ImportESModuleOptionsDictionary): any;
    function isClassifierBlockingErrorCode(aError: number): boolean;
    function isDOMObject(obj: any, unwrap?: boolean): boolean;
    function isDarkBackground(element: Element): boolean;
    function isDevToolsOpened(): boolean;
    function isISOStyleDate(str: string): boolean;
    function isJSIdentifier(str: string): boolean;
    function isOriginAttributesEqual(aA?: OriginAttributesDictionary, aB?: OriginAttributesDictionary): boolean;
    function lastExternalProtocolIframeAllowed(): number;
    function nondeterministicGetWeakMapKeys(map: any): any;
    function nondeterministicGetWeakSetKeys(aSet: any): any;
    function notifyDevToolsClosed(): void;
    function notifyDevToolsOpened(): void;
    function originAttributesMatchPattern(originAttrs?: OriginAttributesDictionary, pattern?: OriginAttributesPatternDictionary): boolean;
    function originAttributesToSuffix(originAttrs?: OriginAttributesDictionary): string;
    function privateNoteIntentionalCrash(): void;
    function readHeapSnapshot(filePath: string): HeapSnapshot;
    function registerProcessActor(aName: string, aOptions?: ProcessActorOptions): void;
    function registerWindowActor(aName: string, aOptions?: WindowActorOptions): void;
    function releaseAssert(condition: boolean, message?: string): void;
    function requestProcInfo(): Promise<ParentProcInfoDictionary>;
    function resetLastExternalProtocolIframeAllowed(): void;
    function saveHeapSnapshot(boundaries?: HeapSnapshotBoundaries): string;
    function saveHeapSnapshotGetId(boundaries?: HeapSnapshotBoundaries): string;
    function setPerfStatsCollectionMask(aCollectionMask: number): void;
    function shallowClone(obj: any, target?: any): any;
    function shouldResistFingerprinting(target: JSRFPTarget, overriddenFingerprintingSettings: nsIRFPTargetSetIDL | null, isPBM?: boolean): boolean;
    function unregisterProcessActor(aName: string): void;
    function unregisterWindowActor(aName: string): void;
    function unwaiveXrays(val: any): any;
    function vsyncEnabled(): boolean;
    function waiveXrays(val: any): any;
}

declare namespace FuzzingFunctions {
    function crash(reason?: string): void;
    function cycleCollect(): void;
    function enableAccessibility(): void;
    function garbageCollect(): void;
    function garbageCollectCompacting(): void;
    function memoryPressure(): void;
    function signalIPCReady(): void;
    function spinEventLoopFor(aMilliseconds: number): void;
    function synthesizeKeyboardEvents(aKeyValue: string, aDictionary?: KeyboardEventInit): void;
}

declare namespace GPUBufferUsage {
}

declare namespace GPUColorWrite {
}

declare namespace GPUMapMode {
}

declare namespace GPUShaderStage {
}

declare namespace GPUTextureUsage {
}

declare namespace IOUtils {
    var profileBeforeChange: any;
    var sendTelemetry: any;
    function computeHexDigest(path: string, method: HashAlgorithm): Promise<string>;
    function copy(sourcePath: string, destPath: string, options?: CopyOptions): Promise<void>;
    function createUniqueDirectory(parent: string, prefix: string, permissions?: number): Promise<string>;
    function createUniqueFile(parent: string, prefix: string, permissions?: number): Promise<string>;
    function delMacXAttr(path: string, attr: string): Promise<void>;
    function exists(path: string): Promise<boolean>;
    function getChildren(path: string, options?: GetChildrenOptions): Promise<string[]>;
    function getDirectory(...components: string[]): Promise<nsIFile>;
    function getFile(...components: string[]): Promise<nsIFile>;
    function getMacXAttr(path: string, attr: string): Promise<Uint8Array>;
    function getWindowsAttributes(path: string): Promise<WindowsFileAttributes>;
    function hasChildren(path: string, options?: HasChildrenOptions): Promise<boolean>;
    function hasMacXAttr(path: string, attr: string): Promise<boolean>;
    function makeDirectory(path: string, options?: MakeDirectoryOptions): Promise<void>;
    function move(sourcePath: string, destPath: string, options?: MoveOptions): Promise<void>;
    function read(path: string, opts?: ReadOptions): Promise<Uint8Array>;
    function readJSON(path: string, opts?: ReadUTF8Options): Promise<any>;
    function readUTF8(path: string, opts?: ReadUTF8Options): Promise<string>;
    function remove(path: string, options?: RemoveOptions): Promise<void>;
    function setAccessTime(path: string, access?: number): Promise<number>;
    function setMacXAttr(path: string, attr: string, value: Uint8Array): Promise<void>;
    function setModificationTime(path: string, modification?: number): Promise<number>;
    function setPermissions(path: string, permissions: number, honorUmask?: boolean): Promise<void>;
    function setWindowsAttributes(path: string, attrs?: WindowsFileAttributes): Promise<void>;
    function stat(path: string): Promise<FileInfo>;
    function write(path: string, data: Uint8Array, options?: WriteOptions): Promise<number>;
    function writeJSON(path: string, value: any, options?: WriteOptions): Promise<number>;
    function writeUTF8(path: string, string: string, options?: WriteOptions): Promise<number>;
}

declare namespace InspectorUtils {
    function addPseudoClassLock(element: Element, pseudoClass: string, enabled?: boolean): void;
    function clearPseudoClassLocks(element: Element): void;
    function colorTo(fromColor: string, toColorSpace: string): InspectorColorToResult | null;
    function colorToRGBA(colorString: string, doc?: Document | null): InspectorRGBATuple | null;
    function containingBlockOf(element: Element): Element | null;
    function cssPropertyIsShorthand(property: string): boolean;
    function cssPropertySupportsType(property: string, type: InspectorPropertyType): boolean;
    function getAllStyleSheets(document: Document, documentOnly?: boolean): StyleSheet[];
    function getBlockLineCounts(element: Element): number[] | null;
    function getCSSPropertyNames(options?: PropertyNamesOptions): string[];
    function getCSSPropertyPrefs(): PropertyPref[];
    function getCSSPseudoElementNames(): string[];
    function getCSSRegisteredProperties(document: Document): InspectorCSSPropertyDefinition[];
    function getCSSRegisteredProperty(document: Document, name: string): InspectorCSSPropertyDefinition | null;
    function getCSSValuesForProperty(property: string): string[];
    function getChildrenForNode(node: Node, showingAnonymousContent: boolean, includeAssignedNodes: boolean): Node[];
    function getContentState(element: Element): number;
    function getMatchingCSSRules(element: Element, pseudo?: string, relevantLinkVisited?: boolean, withStartingStyle?: boolean): CSSRule[];
    function getOverflowingChildrenOfElement(element: Element): NodeList;
    function getParentForNode(node: Node, showingAnonymousContent: boolean): Node | null;
    function getRegisteredCssHighlights(document: Document, activeOnly?: boolean): string[];
    function getRelativeRuleLine(rule: CSSRule): number;
    function getRuleBodyText(initialText: string): string | null;
    function getRuleColumn(rule: CSSRule): number;
    function getRuleIndex(rule: CSSRule): number[];
    function getRuleLine(rule: CSSRule): number;
    function getStyleSheetRuleCountAndAtRules(sheet: CSSStyleSheet): InspectorStyleSheetRuleCountAndAtRulesResult;
    function getSubpropertiesForCSSProperty(property: string): string[];
    function getUsedFontFaces(range: Range, maxRanges?: number, skipCollapsedWhitespace?: boolean): InspectorFontFace[];
    function hasPseudoClassLock(element: Element, pseudoClass: string): boolean;
    function hasRulesModifiedByCSSOM(sheet: CSSStyleSheet): boolean;
    function isCustomElementName(name: string | null, namespaceURI: string | null): boolean;
    function isElementThemed(element: Element): boolean;
    function isIgnorableWhitespace(dataNode: CharacterData): boolean;
    function isInheritedProperty(document: Document, property: string): boolean;
    function isUsedColorSchemeDark(element: Element): boolean;
    function isValidCSSColor(colorString: string): boolean;
    function parseStyleSheet(sheet: CSSStyleSheet, input: string): void;
    function removeContentState(element: Element, state: number, clearActiveDocument?: boolean): boolean;
    function removePseudoClassLock(element: Element, pseudoClass: string): void;
    function replaceBlockRuleBodyTextInStylesheet(styleSheetText: string, line: number, column: number, newBodyText: string): string | null;
    function rgbToColorName(r: number, g: number, b: number): string;
    function setContentState(element: Element, state: number): boolean;
    function supports(conditionText: string, options?: SupportsOptions): boolean;
    function valueMatchesSyntax(document: Document, value: string, syntax: string): boolean;
}

declare namespace L10nOverlays {
    function translateElement(element: Element, translation?: L10nMessage): L10nOverlaysError[] | null;
}

declare namespace MediaControlService {
    function generateMediaControlKey(aKey: MediaControlKey, aSeekValue?: number): void;
    function getCurrentActiveMediaMetadata(): MediaMetadataInit;
    function getCurrentMediaSessionPlaybackState(): MediaSessionPlaybackState;
}

declare namespace Nyx {
    function getRawData(): ArrayBuffer;
    function isEnabled(aFuzzerName: string): boolean;
    function isReplay(): boolean;
    function isStarted(): boolean;
    function log(aMsg: string): void;
    function release(): void;
    function start(): void;
}

declare namespace PathUtils {
    var localProfileDir: string;
    var profileDir: string;
    var tempDir: string;
    var xulLibraryPath: string;
    function filename(path: string): string;
    function isAbsolute(path: string): boolean;
    function join(...components: string[]): string;
    function joinRelative(base: string, relativePath: string): string;
    function normalize(path: string): string;
    function parent(path: string, depth?: number): string | null;
    function split(path: string): string[];
    function splitRelative(path: string, options?: SplitRelativeOptions): string[];
    function toExtendedWindowsPath(path: string): string;
    function toFileURI(path: string): string;
}

declare namespace PlacesObservers {
    var counts: PlacesEventCounts;
    function addListener(eventTypes: PlacesEventType[], listener: PlacesEventCallback): void;
    function addListener(eventTypes: PlacesEventType[], listener: PlacesWeakCallbackWrapper): void;
    function notifyListeners(events: PlacesEvent[]): void;
    function removeListener(eventTypes: PlacesEventType[], listener: PlacesEventCallback): void;
    function removeListener(eventTypes: PlacesEventType[], listener: PlacesWeakCallbackWrapper): void;
}

declare namespace PromiseDebugging {
    function addUncaughtRejectionObserver(o: UncaughtRejectionObserver): void;
    function getAllocationStack(p: any): any;
    function getFullfillmentStack(p: any): any;
    function getPromiseID(p: any): string;
    function getRejectionStack(p: any): any;
    function getState(p: any): PromiseDebuggingStateHolder;
    function removeUncaughtRejectionObserver(o: UncaughtRejectionObserver): boolean;
}

declare namespace SessionStoreUtils {
    function addDynamicFrameFilteredListener(target: EventTarget, type: string, listener: any, useCapture: boolean, mozSystemGroup?: boolean): nsISupports | null;
    function collectDocShellCapabilities(docShell: nsIDocShell): string;
    function collectFormData(window: WindowProxy): CollectedData | null;
    function collectScrollPosition(window: WindowProxy): CollectedData | null;
    function constructSessionStoreRestoreData(): nsISessionStoreRestoreData;
    function forEachNonDynamicChildFrame(window: WindowProxy, callback: SessionStoreUtilsFrameCallback): void;
    function initializeRestore(browsingContext: CanonicalBrowsingContext, data: nsISessionStoreRestoreData | null): Promise<void>;
    function removeDynamicFrameFilteredListener(target: EventTarget, type: string, listener: nsISupports, useCapture: boolean, mozSystemGroup?: boolean): void;
    function restoreDocShellCapabilities(docShell: nsIDocShell, disallowCapabilities: string): void;
    function restoreDocShellState(browsingContext: CanonicalBrowsingContext, url: string | null, docShellCaps: string | null): Promise<void>;
    function restoreFormData(document: Document, data?: CollectedData): boolean;
    function restoreScrollPosition(frame: Window, data?: CollectedData): void;
    function restoreSessionStorageFromParent(browsingContext: CanonicalBrowsingContext, sessionStorage: Record<string, Record<string, string>>): void;
}

declare namespace TestUtils {
    function gc(): Promise<void>;
}

declare namespace UniFFIScaffolding {
    function callAsync(id: UniFFIFunctionId, ...args: UniFFIScaffoldingValue[]): Promise<UniFFIScaffoldingCallResult>;
    function callAsyncWrapper(id: UniFFIFunctionId, ...args: UniFFIScaffoldingValue[]): Promise<UniFFIScaffoldingCallResult>;
    function callSync(id: UniFFIFunctionId, ...args: UniFFIScaffoldingValue[]): UniFFIScaffoldingCallResult;
    function deregisterCallbackHandler(interfaceId: UniFFICallbackInterfaceId): void;
    function readPointer(id: UniFFIPointerId, buff: ArrayBuffer, position: number): UniFFIPointer;
    function registerCallbackHandler(interfaceId: UniFFICallbackInterfaceId, handler: UniFFICallbackHandler): void;
    function writePointer(id: UniFFIPointerId, ptr: UniFFIPointer, buff: ArrayBuffer, position: number): void;
}

declare namespace UserInteraction {
    function cancel(id: string, obj?: any): boolean;
    function finish(id: string, obj?: any, additionalText?: string): boolean;
    function running(id: string, obj?: any): boolean;
    function start(id: string, value: string, obj?: any): boolean;
    function update(id: string, value: string, obj?: any): boolean;
}

declare namespace WebrtcGlobalInformation {
    var aecDebug: boolean;
    var aecDebugLogDir: string;
    function clearAllStats(): void;
    function clearLogging(): void;
    function getAllStats(callback: WebrtcGlobalStatisticsCallback, pcIdFilter?: string): void;
    function getLogging(pattern: string, callback: WebrtcGlobalLoggingCallback): void;
    function getMediaContext(): WebrtcGlobalMediaContext;
    function getStatsHistoryPcIds(callback: WebrtcGlobalStatisticsHistoryPcIdsCallback): void;
    function getStatsHistorySince(callback: WebrtcGlobalStatisticsHistoryCallback, pcIdFilter: string, after?: DOMHighResTimeStamp, sdpAfter?: DOMHighResTimeStamp): void;
}

interface Console {
    assert(condition?: boolean, ...data: any[]): void;
    clear(): void;
    count(label?: string): void;
    countReset(label?: string): void;
    createInstance(options?: ConsoleInstanceOptions): ConsoleInstance;
    debug(...data: any[]): void;
    dir(...data: any[]): void;
    dirxml(...data: any[]): void;
    error(...data: any[]): void;
    exception(...data: any[]): void;
    group(...data: any[]): void;
    groupCollapsed(...data: any[]): void;
    groupEnd(): void;
    info(...data: any[]): void;
    log(...data: any[]): void;
    profile(...data: any[]): void;
    profileEnd(...data: any[]): void;
    table(...data: any[]): void;
    time(label?: string): void;
    timeEnd(label?: string): void;
    timeLog(label?: string, ...data: any[]): void;
    timeStamp(data?: any): void;
    trace(...data: any[]): void;
    warn(...data: any[]): void;
}

declare var console: Console;

interface AnyCallback {
    (value: any): any;
}

interface AudioDataOutputCallback {
    (output: AudioData): void;
}

interface BlobCallback {
    (blob: Blob | null): void;
}

interface ChainedOperation {
    (): any;
}

interface ConsoleInstanceDumpCallback {
    (message: string): void;
}

interface CreateHTMLCallback {
    (input: string, ...arguments: any[]): string | null;
}

interface CreateScriptCallback {
    (input: string, ...arguments: any[]): string | null;
}

interface CreateScriptURLCallback {
    (input: string, ...arguments: any[]): string | null;
}

interface CustomElementConstructor {
    (): any;
}

interface CustomElementCreationCallback {
    (name: string): void;
}

interface DebuggerNotificationCallback {
    (n: DebuggerNotification): void;
}

interface DecodeErrorCallback {
    (error: DOMException): void;
}

interface DecodeSuccessCallback {
    (decodedData: AudioBuffer): void;
}

interface EncodedAudioChunkOutputCallback {
    (output: EncodedAudioChunk, metadata?: EncodedAudioChunkMetadata): void;
}

interface EncodedVideoChunkOutputCallback {
    (chunk: EncodedVideoChunk, metadata?: EncodedVideoChunkMetadata): void;
}

interface ErrorCallback {
    (err: DOMException): void;
}

interface FileCallback {
    (file: File): void;
}

interface FileSystemEntriesCallback {
    (entries: FileSystemEntry[]): void;
}

interface FileSystemEntryCallback {
    (entry: FileSystemEntry): void;
}

interface FontFaceSetForEachCallback {
    (value: FontFace, key: FontFace, set: FontFaceSet): void;
}

interface FrameRequestCallback {
    (time: DOMHighResTimeStamp): void;
}

interface FunctionStringCallback {
    (data: string): void;
}

interface GenerateAssertionCallback {
    (contents: string, origin: string, options: RTCIdentityProviderOptions): RTCIdentityAssertionResult | PromiseLike<RTCIdentityAssertionResult>;
}

interface IdleRequestCallback {
    (deadline: IdleDeadline): void;
}

interface InstallTriggerCallback {
    (url: string, status: number): void;
}

interface IntersectionCallback {
    (entries: IntersectionObserverEntry[], observer: IntersectionObserver): void;
}

interface LockGrantedCallback {
    (lock: Lock | null): any;
}

interface MediaSessionActionHandler {
    (details: MediaSessionActionDetails): void;
}

interface MutationCallback {
    (mutations: MutationRecord[], observer: MutationObserver): void;
}

interface NavigationInterceptHandler {
    (): void | PromiseLike<void>;
}

interface NavigatorUserMediaErrorCallback {
    (error: MediaStreamError): void;
}

interface NavigatorUserMediaSuccessCallback {
    (stream: MediaStream): void;
}

interface NotificationPermissionCallback {
    (permission: NotificationPermission): void;
}

interface OnBeforeUnloadEventHandlerNonNull {
    (event: Event): string | null;
}

interface OnErrorEventHandlerNonNull {
    (event: Event | string, source?: string, lineno?: number, column?: number, error?: any): any;
}

interface PeerConnectionLifecycleCallback {
    (pc: RTCPeerConnection, windowId: number, eventType: RTCLifecycleEvent): void;
}

interface PerformanceObserverCallback {
    (entries: PerformanceObserverEntryList, observer: PerformanceObserver): void;
}

interface PlacesEventCallback {
    (events: PlacesEvent[]): void;
}

interface PositionCallback {
    (position: GeolocationPosition): void;
}

interface PositionErrorCallback {
    (positionError: GeolocationPositionError): void;
}

interface PrintCallback {
    (ctx: MozCanvasPrintState): void;
}

interface PromiseDocumentFlushedCallback {
    (): any;
}

interface PromiseReturner {
    (): any;
}

interface QueuingStrategySize {
    (chunk?: any): number;
}

interface RTCPeerConnectionErrorCallback {
    (error: DOMException): void;
}

interface RTCSessionDescriptionCallback {
    (description: RTCSessionDescriptionInit): void;
}

interface ReportingObserverCallback {
    (reports: Report[], observer: ReportingObserver): void;
}

interface ResizeObserverCallback {
    (entries: ResizeObserverEntry[], observer: ResizeObserver): void;
}

interface SchedulerPostTaskCallback {
    (): any;
}

interface SessionStoreUtilsFrameCallback {
    (frame: WindowProxy, index: number): void;
}

interface SetDeleteBooleanCallback {
    (value: boolean, index: number): void;
}

interface SetDeleteInterfaceCallback {
    (value: TestInterfaceObservableArray, index: number): void;
}

interface SetDeleteObjectCallback {
    (value: any, index: number): void;
}

interface TestThrowingCallback {
    (): void;
}

interface ValidateAssertionCallback {
    (assertion: string, origin: string): RTCIdentityValidationResult | PromiseLike<RTCIdentityValidationResult>;
}

interface VideoFrameOutputCallback {
    (output: VideoFrame): void;
}

interface VideoFrameRequestCallback {
    (now: DOMHighResTimeStamp, metadata: VideoFrameCallbackMetadata): void;
}

interface ViewTransitionUpdateCallback {
    (): any;
}

interface VoidFunction {
    (): void;
}

interface WebCodecsErrorCallback {
    (error: DOMException): void;
}

interface WebExtensionLocalizeCallback {
    (unlocalizedText: string): string;
}

interface WebrtcGlobalLoggingCallback {
    (logMessages: string[]): void;
}

interface WebrtcGlobalStatisticsCallback {
    (reports: WebrtcGlobalStatisticsReport): void;
}

interface WebrtcGlobalStatisticsHistoryCallback {
    (reports: WebrtcGlobalStatisticsReport): void;
}

interface WebrtcGlobalStatisticsHistoryPcIdsCallback {
    (pcIds: string[]): void;
}

interface XRFrameRequestCallback {
    (time: DOMHighResTimeStamp, frame: XRFrame): void;
}

interface mozPacketCallback {
    (level: number, type: mozPacketDumpType, sending: boolean, packet: ArrayBuffer): void;
}

interface HTMLElementTagNameMap {
    "a": HTMLAnchorElement;
    "abbr": HTMLElement;
    "acronym": HTMLElement;
    "address": HTMLElement;
    "applet": HTMLUnknownElement;
    "area": HTMLAreaElement;
    "article": HTMLElement;
    "aside": HTMLElement;
    "audio": HTMLAudioElement;
    "b": HTMLElement;
    "base": HTMLBaseElement;
    "basefont": HTMLElement;
    "bdi": HTMLElement;
    "bdo": HTMLElement;
    "bgsound": HTMLUnknownElement;
    "big": HTMLElement;
    "blockquote": HTMLQuoteElement;
    "body": HTMLBodyElement;
    "br": HTMLBRElement;
    "button": HTMLButtonElement;
    "canvas": HTMLCanvasElement;
    "caption": HTMLTableCaptionElement;
    "center": HTMLElement;
    "cite": HTMLElement;
    "code": HTMLElement;
    "col": HTMLTableColElement;
    "colgroup": HTMLTableColElement;
    "data": HTMLDataElement;
    "datalist": HTMLDataListElement;
    "dd": HTMLElement;
    "del": HTMLModElement;
    "details": HTMLDetailsElement;
    "dfn": HTMLElement;
    "dialog": HTMLDialogElement;
    "dir": HTMLDirectoryElement;
    "div": HTMLDivElement;
    "dl": HTMLDListElement;
    "dt": HTMLElement;
    "em": HTMLElement;
    "embed": HTMLEmbedElement;
    "fieldset": HTMLFieldSetElement;
    "figcaption": HTMLElement;
    "figure": HTMLElement;
    "font": HTMLFontElement;
    "footer": HTMLElement;
    "form": HTMLFormElement;
    "frame": HTMLFrameElement;
    "frameset": HTMLFrameSetElement;
    "h1": HTMLHeadingElement;
    "h2": HTMLHeadingElement;
    "h3": HTMLHeadingElement;
    "h4": HTMLHeadingElement;
    "h5": HTMLHeadingElement;
    "h6": HTMLHeadingElement;
    "head": HTMLHeadElement;
    "header": HTMLElement;
    "hgroup": HTMLElement;
    "hr": HTMLHRElement;
    "html": HTMLHtmlElement;
    "i": HTMLElement;
    "iframe": HTMLIFrameElement;
    "image": HTMLElement;
    "img": HTMLImageElement;
    "input": HTMLInputElement;
    "ins": HTMLModElement;
    "kbd": HTMLElement;
    "keygen": HTMLUnknownElement;
    "label": HTMLLabelElement;
    "legend": HTMLLegendElement;
    "li": HTMLLIElement;
    "link": HTMLLinkElement;
    "listing": HTMLPreElement;
    "main": HTMLElement;
    "map": HTMLMapElement;
    "mark": HTMLElement;
    "marquee": HTMLMarqueeElement;
    "menu": HTMLMenuElement;
    "meta": HTMLMetaElement;
    "meter": HTMLMeterElement;
    "multicol": HTMLUnknownElement;
    "nav": HTMLElement;
    "nobr": HTMLElement;
    "noembed": HTMLElement;
    "noframes": HTMLElement;
    "noscript": HTMLElement;
    "object": HTMLObjectElement;
    "ol": HTMLOListElement;
    "optgroup": HTMLOptGroupElement;
    "option": HTMLOptionElement;
    "output": HTMLOutputElement;
    "p": HTMLParagraphElement;
    "param": HTMLParamElement;
    "picture": HTMLPictureElement;
    "plaintext": HTMLElement;
    "pre": HTMLPreElement;
    "progress": HTMLProgressElement;
    "q": HTMLQuoteElement;
    "rb": HTMLElement;
    "rp": HTMLElement;
    "rt": HTMLElement;
    "rtc": HTMLElement;
    "ruby": HTMLElement;
    "s": HTMLElement;
    "samp": HTMLElement;
    "script": HTMLScriptElement;
    "search": HTMLElement;
    "section": HTMLElement;
    "select": HTMLSelectElement;
    "slot": HTMLSlotElement;
    "small": HTMLElement;
    "source": HTMLSourceElement;
    "span": HTMLSpanElement;
    "strike": HTMLElement;
    "strong": HTMLElement;
    "style": HTMLStyleElement;
    "sub": HTMLElement;
    "summary": HTMLElement;
    "sup": HTMLElement;
    "table": HTMLTableElement;
    "tbody": HTMLTableSectionElement;
    "td": HTMLTableCellElement;
    "template": HTMLTemplateElement;
    "textarea": HTMLTextAreaElement;
    "tfoot": HTMLTableSectionElement;
    "th": HTMLTableCellElement;
    "thead": HTMLTableSectionElement;
    "time": HTMLTimeElement;
    "title": HTMLTitleElement;
    "tr": HTMLTableRowElement;
    "track": HTMLTrackElement;
    "tt": HTMLElement;
    "u": HTMLElement;
    "ul": HTMLUListElement;
    "var": HTMLElement;
    "video": HTMLVideoElement;
    "wbr": HTMLElement;
    "xmp": HTMLPreElement;
}

interface HTMLElementDeprecatedTagNameMap {
}

interface SVGElementTagNameMap {
}

interface MathMLElementTagNameMap {
}

/** @deprecated Directly use HTMLElementTagNameMap or SVGElementTagNameMap as appropriate, instead. */
type ElementTagNameMap = HTMLElementTagNameMap & Pick<SVGElementTagNameMap, Exclude<keyof SVGElementTagNameMap, keyof HTMLElementTagNameMap>>;

declare var Audio: {
    new(src?: string): HTMLAudioElement;
};
declare var Image: {
    new(width?: number, height?: number): HTMLImageElement;
};
declare var Option: {
    new(text?: string, value?: string, defaultSelected?: boolean, selected?: boolean): HTMLOptionElement;
};
declare var webkitSpeechGrammar: {
    new(): SpeechGrammar;
};
declare var webkitSpeechGrammarList: {
    new(): SpeechGrammarList;
};
declare var webkitSpeechRecognition: {
    new(): SpeechRecognition;
};

// Moved to lib.gecko.dom-vars.d.ts

declare function removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
type AlgorithmIdentifier = any;
type AllowSharedBufferSource = ArrayBuffer | ArrayBufferView;
type Base64URLString = string;
type BinaryData = ArrayBuffer | ArrayBufferView;
type BlobPart = BufferSource | Blob | string;
type BodyInit = XMLHttpRequestBodyInit;
type BufferSource = ArrayBufferView | ArrayBuffer;
type COSEAlgorithmIdentifier = number;
type CanvasImageSource = HTMLOrSVGImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas | ImageBitmap | VideoFrame;
type CanvasSource = HTMLCanvasElement | OffscreenCanvas;
type ClipboardItemData = Promise<ClipboardItemDataType>;
type ClipboardItemDataType = string | Blob;
type ClipboardItems = ClipboardItem[];
type CollectedFormDataValue = any;
type ConstrainBoolean = boolean | ConstrainBooleanParameters;
type ConstrainDOMString = string | string[] | ConstrainDOMStringParameters;
type ConstrainDouble = number | ConstrainDoubleRange;
type ConstrainLong = number | ConstrainLongRange;
type ContentSecurityPolicy = nsIContentSecurityPolicy;
type Cookie = nsICookie;
type CookieList = CookieListItem[];
type DOMHighResTimeStamp = number;
type DOMTimeStamp = number;
type EpochTimeStamp = number;
type FileSystemWriteChunkType = BufferSource | Blob | string | WriteParams;
type Float32List = Float32Array | GLfloat[];
type FormDataEntryValue = Blob | Directory | string;
type FormDataValue = any;
type GLbitfield = number;
type GLboolean = boolean;
type GLclampf = number;
type GLenum = number;
type GLfloat = number;
type GLint = number;
type GLint64 = number;
type GLintptr = number;
type GLsizei = number;
type GLsizeiptr = number;
type GLuint = number;
type GLuint64 = number;
type GPUBindingResource = GPUSampler | GPUTextureView | GPUBufferBinding;
type GPUBufferDynamicOffset = number;
type GPUBufferUsageFlags = number;
type GPUColor = number[] | GPUColorDict;
type GPUColorWriteFlags = number;
type GPUCopyExternalImageSource = ImageBitmap | HTMLImageElement | HTMLCanvasElement | OffscreenCanvas;
type GPUDepthBias = number;
type GPUExtent3D = GPUIntegerCoordinate[] | GPUExtent3DDict;
type GPUFlagsConstant = number;
type GPUIndex32 = number;
type GPUIntegerCoordinate = number;
type GPUIntegerCoordinateOut = number;
type GPUMapModeFlags = number;
type GPUOrigin2D = GPUIntegerCoordinate[] | GPUOrigin2DDict;
type GPUOrigin3D = GPUIntegerCoordinate[] | GPUOrigin3DDict;
type GPUPipelineConstantValue = number;
type GPUSampleMask = number;
type GPUShaderStageFlags = number;
type GPUSignedOffset32 = number;
type GPUSize32 = number;
type GPUSize32Out = number;
type GPUSize64 = number;
type GPUSize64Out = number;
type GPUStencilValue = number;
type GPUTextureUsageFlags = number;
type GeometryNode = Text | Element | Document;
type HTMLOrSVGImageElement = HTMLImageElement | SVGImageElement;
type HeadersInit = string[][] | Record<string, string>;
type ImageBitmapSource = CanvasImageSource | Blob | CanvasRenderingContext2D | ImageData;
type ImageBufferSource = AllowSharedBufferSource | ReadableStream;
type InputStream = nsIInputStream;
type Int32List = Int32Array | GLint[];
type KeyFormat = string;
type KeyType = string;
type KeyUsage = string;
type L10nArgs = Record<string, string | number | null>;
type L10nKey = string | L10nIdArgs;
type L10nResourceId = string | ResourceId;
type LoadContext = nsILoadContext;
type LoadInfo = nsILoadInfo;
type MLSBytesOrUint8Array = MLSBytes | Uint8Array;
type MLSBytesOrUint8ArrayOrUTF8String = MLSBytes | Uint8Array | string;
type MLSClientId = MLSBytes;
type MLSCredential = MLSBytes;
type MLSGroupEpoch = MLSBytes;
type MLSGroupId = MLSBytes;
type MLSKeyPackage = MLSBytes;
type MLSProposal = MLSBytes;
type MatchGlobOrString = MatchGlob | string;
type MatchPatternSetOrStringSequence = MatchPatternSet | string[];
type MessageEventSource = WindowProxy | MessagePort | ServiceWorker;
type MozChannel = nsIChannel;
type MozTreeView = nsITreeView;
type NodeId = number;
type NodeSize = number;
type OffscreenRenderingContext = OffscreenCanvasRenderingContext2D | ImageBitmapRenderingContext | WebGLRenderingContext | WebGL2RenderingContext | GPUCanvasContext;
type OnBeforeUnloadEventHandler = OnBeforeUnloadEventHandlerNonNull | null;
type OnErrorEventHandler = OnErrorEventHandlerNonNull | null;
type OutputStream = nsIOutputStream;
type PerformanceEntryList = PerformanceEntry[];
type Principal = nsIPrincipal;
type PublicKeyCredentialClientCapabilities = Record<string, boolean>;
type RTCRtpTransform = RTCRtpScriptTransform;
type ReadableStreamReader = ReadableStreamDefaultReader | ReadableStreamBYOBReader;
type ReferrerInfo = nsIReferrerInfo;
type RemoteTab = nsIRemoteTab;
type ReportList = Report[];
type RequestInfo = Request | string;
type SanitizerAttribute = string | SanitizerAttributeNamespace;
type SanitizerElement = string | SanitizerElementNamespace;
type SanitizerElementWithAttributes = string | SanitizerElementNamespaceWithAttributes;
type StackFrame = nsIStackFrame;
type StringOrOpenPopupOptions = string | OpenPopupOptions;
type StructuredClonable = any;
type TimerHandler = Function | TrustedScript | string;
type TrustedType = TrustedHTML | TrustedScript | TrustedScriptURL;
type URI = nsIURI;
type Uint32List = Uint32Array | GLuint[];
type UniFFICallbackInterfaceId = number;
type UniFFICallbackObjectHandle = number;
type UniFFIFunctionId = number;
type UniFFIPointerId = number;
type UniFFIScaffoldingValue = number | ArrayBuffer | UniFFIPointer;
type UnrestrictedDoubleOrKeyframeAnimationOptions = number | KeyframeAnimationOptions;
type VibratePattern = number | number[];
type XMLHttpRequestBodyInit = Blob | BufferSource | FormData | URLSearchParams | string;
type XRWebGLRenderingContext = WebGLRenderingContext | WebGL2RenderingContext;
type XSLTParameterValue = number | boolean | string | Node | Node[] | XPathResult;
type XULCommandDispatcher = nsIDOMXULCommandDispatcher;
type XULControllers = nsIControllers;
type nsContentPolicyType = number;
type AlignSetting = "center" | "end" | "left" | "right" | "start";
type AlphaOption = "discard" | "keep";
type AnimationPlayState = "finished" | "idle" | "paused" | "running";
type AnimationReplaceState = "active" | "persisted" | "removed";
type AudioContextState = "closed" | "running" | "suspended";
type AudioSampleFormat = "f32" | "f32-planar" | "s16" | "s16-planar" | "s32" | "s32-planar" | "u8" | "u8-planar";
type AutoKeyword = "auto";
type AutoplayPolicy = "allowed" | "allowed-muted" | "disallowed";
type AutoplayPolicyMediaType = "audiocontext" | "mediaelement";
type AvcBitstreamFormat = "annexb" | "avc";
type Base64URLDecodePadding = "ignore" | "reject" | "require";
type BinaryType = "arraybuffer" | "blob";
type BiquadFilterType = "allpass" | "bandpass" | "highpass" | "highshelf" | "lowpass" | "lowshelf" | "notch" | "peaking";
type BitrateMode = "constant" | "variable";
type CSSBoxType = "border" | "content" | "margin" | "padding";
type CSSStyleSheetParsingMode = "agent" | "author" | "user";
type CacheStorageNamespace = "chrome" | "content";
type CallbackDebuggerNotificationPhase = "post" | "pre";
type CanvasContextProperties = "both" | "fill" | "none" | "stroke";
type CanvasDirection = "inherit" | "ltr" | "rtl";
type CanvasFontKerning = "auto" | "none" | "normal";
type CanvasFontStretch = "condensed" | "expanded" | "extra-condensed" | "extra-expanded" | "normal" | "semi-condensed" | "semi-expanded" | "ultra-condensed" | "ultra-expanded";
type CanvasFontVariantCaps = "all-petite-caps" | "all-small-caps" | "normal" | "petite-caps" | "small-caps" | "titling-caps" | "unicase";
type CanvasLineCap = "butt" | "round" | "square";
type CanvasLineJoin = "bevel" | "miter" | "round";
type CanvasTextAlign = "center" | "end" | "left" | "right" | "start";
type CanvasTextBaseline = "alphabetic" | "bottom" | "hanging" | "ideographic" | "middle" | "top";
type CanvasTextRendering = "auto" | "geometricPrecision" | "optimizeLegibility" | "optimizeSpeed";
type CanvasWindingRule = "evenodd" | "nonzero";
type CaretChangedReason = "dragcaret" | "longpressonemptycontent" | "presscaret" | "releasecaret" | "scroll" | "taponcaret" | "updateposition" | "visibilitychange";
type ChannelCountMode = "clamped-max" | "explicit" | "max";
type ChannelInterpretation = "discrete" | "speakers";
type CheckerboardReason = "recent" | "severe";
type CodecState = "closed" | "configured" | "unconfigured";
type ColorGamut = "p3" | "rec2020" | "srgb";
type ColorSpaceConversion = "default" | "none";
type CompositeOperation = "accumulate" | "add" | "replace";
type CompressionFormat = "deflate" | "deflate-raw" | "gzip" | "zstd";
type ConnectionType = "bluetooth" | "cellular" | "ethernet" | "none" | "other" | "unknown" | "wifi";
type ConsoleLevel = "error" | "log" | "warning";
type ConsoleLogLevel = "All" | "Clear" | "Debug" | "Dir" | "Dirxml" | "Error" | "Group" | "GroupEnd" | "Info" | "Log" | "Off" | "Profile" | "ProfileEnd" | "Time" | "TimeEnd" | "TimeLog" | "Trace" | "Warn";
type ContentScriptExecutionWorld = "ISOLATED" | "MAIN" | "USER_SCRIPT";
type ContentScriptRunAt = "document_end" | "document_idle" | "document_start";
type CookieSameSite = "lax" | "none" | "strict";
type CredentialMediationRequirement = "conditional" | "optional" | "required" | "silent";
type CredentialProtectionPolicy = "userVerificationOptional" | "userVerificationOptionalWithCredentialIDList" | "userVerificationRequired";
type DebuggerNotificationType = "cancelAnimationFrame" | "clearInterval" | "clearTimeout" | "domEvent" | "requestAnimationFrame" | "requestAnimationFrameCallback" | "setInterval" | "setIntervalCallback" | "setTimeout" | "setTimeoutCallback";
type DecoderDoctorReportType = "mediacannotinitializepulseaudio" | "mediacannotplaynodecoders" | "mediadecodeerror" | "mediadecodewarning" | "medianodecoders" | "mediaplatformdecodernotfound" | "mediaunsupportedlibavcodec" | "mediawidevinenowmf" | "mediawmfneeded";
type DirectionSetting = "" | "lr" | "rl";
type DisplayMode = "browser" | "fullscreen" | "minimal-ui" | "standalone";
type DistanceModelType = "exponential" | "inverse" | "linear";
type EncodedAudioChunkType = "delta" | "key";
type EncodedVideoChunkType = "delta" | "key";
type EndingType = "native" | "transparent";
type EventCallbackDebuggerNotificationType = "closewatcher" | "global" | "node" | "websocket" | "worker" | "xhr";
type FetchState = "aborted" | "complete" | "errored" | "requesting" | "responding";
type FileSystemHandleKind = "directory" | "file";
type FileType = "directory" | "other" | "regular";
type FillMode = "auto" | "backwards" | "both" | "forwards" | "none";
type FlexItemClampState = "clamped_to_max" | "clamped_to_min" | "unclamped";
type FlexLineGrowthState = "growing" | "shrinking";
type FlexPhysicalDirection = "horizontal-lr" | "horizontal-rl" | "vertical-bt" | "vertical-tb";
type FontFaceLoadStatus = "error" | "loaded" | "loading" | "unloaded";
type FontFaceSetLoadStatus = "loaded" | "loading";
type ForcedColorsOverride = "active" | "none";
type GPUAddressMode = "clamp-to-edge" | "mirror-repeat" | "repeat";
type GPUAutoLayoutMode = "auto";
type GPUBlendFactor = "constant" | "dst" | "dst-alpha" | "one" | "one-minus-constant" | "one-minus-dst" | "one-minus-dst-alpha" | "one-minus-src" | "one-minus-src-alpha" | "src" | "src-alpha" | "src-alpha-saturated" | "zero";
type GPUBlendOperation = "add" | "max" | "min" | "reverse-subtract" | "subtract";
type GPUBufferBindingType = "read-only-storage" | "storage" | "uniform";
type GPUBufferMapState = "mapped" | "pending" | "unmapped";
type GPUCanvasAlphaMode = "opaque" | "premultiplied";
type GPUCompareFunction = "always" | "equal" | "greater" | "greater-equal" | "less" | "less-equal" | "never" | "not-equal";
type GPUCompilationMessageType = "error" | "info" | "warning";
type GPUCullMode = "back" | "front" | "none";
type GPUErrorFilter = "internal" | "out-of-memory" | "validation";
type GPUFeatureName = "bgra8unorm-storage" | "clip-distances" | "core-features-and-limits" | "depth-clip-control" | "depth32float-stencil8" | "dual-source-blending" | "float32-blendable" | "float32-filterable" | "indirect-first-instance" | "rg11b10ufloat-renderable" | "shader-f16" | "subgroups" | "texture-compression-astc" | "texture-compression-astc-sliced-3d" | "texture-compression-bc" | "texture-compression-bc-sliced-3d" | "texture-compression-etc2" | "timestamp-query";
type GPUFilterMode = "linear" | "nearest";
type GPUFrontFace = "ccw" | "cw";
type GPUIndexFormat = "uint16" | "uint32";
type GPULoadOp = "clear" | "load";
type GPUMipmapFilterMode = "linear" | "nearest";
type GPUPipelineErrorReason = "internal" | "validation";
type GPUPowerPreference = "high-performance" | "low-power";
type GPUPrimitiveTopology = "line-list" | "line-strip" | "point-list" | "triangle-list" | "triangle-strip";
type GPUQueryType = "occlusion" | "timestamp";
type GPUSamplerBindingType = "comparison" | "filtering" | "non-filtering";
type GPUStencilOperation = "decrement-clamp" | "decrement-wrap" | "increment-clamp" | "increment-wrap" | "invert" | "keep" | "replace" | "zero";
type GPUStorageTextureAccess = "read-only" | "read-write" | "write-only";
type GPUStoreOp = "discard" | "store";
type GPUTextureAspect = "all" | "depth-only" | "stencil-only";
type GPUTextureDimension = "1d" | "2d" | "3d";
type GPUTextureFormat = "astc-10x10-unorm" | "astc-10x10-unorm-srgb" | "astc-10x5-unorm" | "astc-10x5-unorm-srgb" | "astc-10x6-unorm" | "astc-10x6-unorm-srgb" | "astc-10x8-unorm" | "astc-10x8-unorm-srgb" | "astc-12x10-unorm" | "astc-12x10-unorm-srgb" | "astc-12x12-unorm" | "astc-12x12-unorm-srgb" | "astc-4x4-unorm" | "astc-4x4-unorm-srgb" | "astc-5x4-unorm" | "astc-5x4-unorm-srgb" | "astc-5x5-unorm" | "astc-5x5-unorm-srgb" | "astc-6x5-unorm" | "astc-6x5-unorm-srgb" | "astc-6x6-unorm" | "astc-6x6-unorm-srgb" | "astc-8x5-unorm" | "astc-8x5-unorm-srgb" | "astc-8x6-unorm" | "astc-8x6-unorm-srgb" | "astc-8x8-unorm" | "astc-8x8-unorm-srgb" | "bc1-rgba-unorm" | "bc1-rgba-unorm-srgb" | "bc2-rgba-unorm" | "bc2-rgba-unorm-srgb" | "bc3-rgba-unorm" | "bc3-rgba-unorm-srgb" | "bc4-r-snorm" | "bc4-r-unorm" | "bc5-rg-snorm" | "bc5-rg-unorm" | "bc6h-rgb-float" | "bc6h-rgb-ufloat" | "bc7-rgba-unorm" | "bc7-rgba-unorm-srgb" | "bgra8unorm" | "bgra8unorm-srgb" | "depth16unorm" | "depth24plus" | "depth24plus-stencil8" | "depth32float" | "depth32float-stencil8" | "eac-r11snorm" | "eac-r11unorm" | "eac-rg11snorm" | "eac-rg11unorm" | "etc2-rgb8a1unorm" | "etc2-rgb8a1unorm-srgb" | "etc2-rgb8unorm" | "etc2-rgb8unorm-srgb" | "etc2-rgba8unorm" | "etc2-rgba8unorm-srgb" | "r16float" | "r16sint" | "r16uint" | "r32float" | "r32sint" | "r32uint" | "r8sint" | "r8snorm" | "r8uint" | "r8unorm" | "rg11b10ufloat" | "rg16float" | "rg16sint" | "rg16uint" | "rg32float" | "rg32sint" | "rg32uint" | "rg8sint" | "rg8snorm" | "rg8uint" | "rg8unorm" | "rgb10a2uint" | "rgb10a2unorm" | "rgb9e5ufloat" | "rgba16float" | "rgba16sint" | "rgba16uint" | "rgba32float" | "rgba32sint" | "rgba32uint" | "rgba8sint" | "rgba8snorm" | "rgba8uint" | "rgba8unorm" | "rgba8unorm-srgb" | "stencil8";
type GPUTextureSampleType = "depth" | "float" | "sint" | "uint" | "unfilterable-float";
type GPUTextureViewDimension = "1d" | "2d" | "2d-array" | "3d" | "cube" | "cube-array";
type GPUVertexFormat = "float16" | "float16x2" | "float16x4" | "float32" | "float32x2" | "float32x3" | "float32x4" | "sint16" | "sint16x2" | "sint16x4" | "sint32" | "sint32x2" | "sint32x3" | "sint32x4" | "sint8" | "sint8x2" | "sint8x4" | "snorm16" | "snorm16x2" | "snorm16x4" | "snorm8" | "snorm8x2" | "snorm8x4" | "uint16" | "uint16x2" | "uint16x4" | "uint32" | "uint32x2" | "uint32x3" | "uint32x4" | "uint8" | "uint8x2" | "uint8x4" | "unorm10-10-10-2" | "unorm16" | "unorm16x2" | "unorm16x4" | "unorm8" | "unorm8x2" | "unorm8x4" | "unorm8x4-bgra";
type GPUVertexStepMode = "instance" | "vertex";
type GamepadHand = "" | "left" | "right";
type GamepadHapticActuatorType = "vibration";
type GamepadLightIndicatorType = "on-off" | "rgb";
type GamepadMappingType = "" | "standard" | "xr-standard";
type GetUserMediaRequestType = "getusermedia" | "recording-device-stopped" | "selectaudiooutput";
type GridDeclaration = "explicit" | "implicit";
type GridTrackState = "removed" | "repeat" | "static";
type HDCPVersion = "1.0" | "1.1" | "1.2" | "1.3" | "1.4" | "2.0" | "2.1" | "2.2" | "2.3";
type HardwareAcceleration = "no-preference" | "prefer-hardware" | "prefer-software";
type HashAlgorithm = "sha256" | "sha384" | "sha512";
type HdrMetadataType = "smpteSt2086" | "smpteSt2094-10" | "smpteSt2094-40";
type HeadersGuardEnum = "immutable" | "none" | "request" | "request-no-cors" | "response";
type HighlightType = "grammar-error" | "highlight" | "spelling-error";
type IDBCursorDirection = "next" | "nextunique" | "prev" | "prevunique";
type IDBRequestReadyState = "done" | "pending";
type IDBTransactionDurability = "default" | "relaxed" | "strict";
type IDBTransactionMode = "cleanup" | "readonly" | "readwrite" | "readwriteflush" | "versionchange";
type IdentityCredentialRequestOptionsMode = "active" | "passive";
type IdentityLoginTargetType = "popup" | "redirect";
type ImageOrientation = "flipY" | "from-image" | "none";
type ImportESModuleTargetGlobal = "contextual" | "current" | "devtools" | "shared";
type InspectorPropertyType = "color" | "gradient" | "timing-function";
type IterationCompositeOperation = "accumulate" | "replace";
type JSRFPTarget = "CSSPrefersColorScheme" | "HttpUserAgent" | "JSLocalePrompt" | "RoundWindowSize" | "SiteSpecificZoom";
type L10nFileSourceHasFileStatus = "missing" | "present" | "unknown";
type LatencyMode = "quality" | "realtime";
type LineAlignSetting = "center" | "end" | "start";
type LockMode = "exclusive" | "shared";
type LoginStatus = "logged-in" | "logged-out";
type MIDIPortConnectionState = "closed" | "open" | "pending";
type MIDIPortDeviceState = "connected" | "disconnected";
type MIDIPortType = "input" | "output";
type MLSObjectType = "application-message-ciphertext" | "application-message-plaintext" | "client-identifier" | "commit-output" | "commit-processed" | "credential-basic" | "exporter-context" | "exporter-label" | "exporter-output" | "group-epoch" | "group-identifier" | "group-info" | "key-package" | "proposal" | "welcome";
type MediaControlKey = "focus" | "nexttrack" | "pause" | "play" | "playpause" | "previoustrack" | "seekbackward" | "seekforward" | "seekto" | "skipad" | "stop";
type MediaDecodingType = "file" | "media-source";
type MediaDeviceKind = "audioinput" | "audiooutput" | "videoinput";
type MediaEncodingType = "record" | "transmission";
type MediaKeyMessageType = "individualization-request" | "license-release" | "license-renewal" | "license-request";
type MediaKeySessionType = "persistent-license" | "temporary";
type MediaKeyStatus = "expired" | "internal-error" | "output-downscaled" | "output-restricted" | "released" | "status-pending" | "usable";
type MediaKeysRequirement = "not-allowed" | "optional" | "required";
type MediaSessionAction = "nexttrack" | "pause" | "play" | "previoustrack" | "seekbackward" | "seekforward" | "seekto" | "skipad" | "stop";
type MediaSessionPlaybackState = "none" | "paused" | "playing";
type MediaSourceEndOfStreamError = "decode" | "network";
type MediaSourceReadyState = "closed" | "ended" | "open";
type MediaStreamTrackState = "ended" | "live";
type MozContentPolicyType = "beacon" | "csp_report" | "font" | "image" | "imageset" | "json" | "main_frame" | "media" | "object" | "other" | "ping" | "script" | "speculative" | "stylesheet" | "sub_frame" | "web_manifest" | "websocket" | "xml_dtd" | "xmlhttprequest" | "xslt";
type MozUrlClassificationFlags = "any_basic_tracking" | "any_social_tracking" | "any_strict_tracking" | "consentmanager" | "cryptomining" | "cryptomining_content" | "emailtracking" | "emailtracking_content" | "fingerprinting" | "fingerprinting_content" | "socialtracking" | "socialtracking_facebook" | "socialtracking_linkedin" | "socialtracking_twitter" | "tracking" | "tracking_ad" | "tracking_analytics" | "tracking_content" | "tracking_social";
type NavigationFocusReset = "after-transition" | "manual";
type NavigationHistoryBehavior = "auto" | "push" | "replace";
type NavigationScrollBehavior = "after-transition" | "manual";
type NavigationTimingType = "back_forward" | "navigate" | "prerender" | "reload";
type NavigationType = "push" | "reload" | "replace" | "traverse";
type NotificationDirection = "auto" | "ltr" | "rtl";
type NotificationPermission = "default" | "denied" | "granted";
type OffscreenRenderingContextId = "2d" | "bitmaprenderer" | "webgl" | "webgl2" | "webgpu";
type OpusBitstreamFormat = "ogg" | "opus";
type OrientationLockType = "any" | "landscape" | "landscape-primary" | "landscape-secondary" | "natural" | "portrait" | "portrait-primary" | "portrait-secondary";
type OrientationType = "landscape-primary" | "landscape-secondary" | "portrait-primary" | "portrait-secondary";
type OscillatorType = "custom" | "sawtooth" | "sine" | "square" | "triangle";
type OverSampleType = "2x" | "4x" | "none";
type OverridableErrorCategory = "domain-mismatch" | "expired-or-not-yet-valid" | "trust-error" | "unset";
type PCError = "InvalidAccessError" | "InvalidCharacterError" | "InvalidModificationError" | "InvalidStateError" | "NotReadableError" | "NotSupportedError" | "OperationError" | "RangeError" | "SyntaxError" | "TypeError" | "UnknownError";
type PCObserverStateType = "ConnectionState" | "IceConnectionState" | "IceGatheringState" | "None" | "SignalingState";
type PanningModelType = "HRTF" | "equalpower";
type PaymentComplete = "fail" | "success" | "unknown";
type PaymentShippingType = "delivery" | "pickup" | "shipping";
type PermissionName = "camera" | "geolocation" | "microphone" | "midi" | "notifications" | "persistent-storage" | "push" | "screen-wake-lock" | "storage-access";
type PermissionState = "denied" | "granted" | "prompt";
type PermitUnloadAction = "dontUnload" | "prompt" | "unload";
type PlacesEventType = "bookmark-added" | "bookmark-guid-changed" | "bookmark-keyword-changed" | "bookmark-moved" | "bookmark-removed" | "bookmark-tags-changed" | "bookmark-time-changed" | "bookmark-title-changed" | "bookmark-url-changed" | "favicon-changed" | "history-cleared" | "none" | "page-removed" | "page-title-changed" | "page-visited" | "pages-rank-changed" | "purge-caches";
type PlaybackDirection = "alternate" | "alternate-reverse" | "normal" | "reverse";
type PopupBlockerState = "openAbused" | "openAllowed" | "openBlocked" | "openControlled" | "openOverridden";
type PositionAlignSetting = "auto" | "center" | "line-left" | "line-right";
type PredefinedColorSpace = "display-p3" | "srgb";
type PrefersColorSchemeOverride = "dark" | "light" | "none";
type PremultiplyAlpha = "default" | "none" | "premultiply";
type PresentationStyle = "attachment" | "inline" | "unspecified";
type PrivateAttributionImpressionType = "click" | "view";
type PromiseDebuggingState = "fulfilled" | "pending" | "rejected";
type PushEncryptionKeyName = "auth" | "p256dh";
type RTCBundlePolicy = "balanced" | "max-bundle" | "max-compat";
type RTCCodecType = "decode" | "encode";
type RTCDataChannelState = "closed" | "closing" | "connecting" | "open";
type RTCDataChannelType = "arraybuffer" | "blob";
type RTCDegradationPreference = "balanced" | "maintain-framerate" | "maintain-resolution";
type RTCDtlsTransportState = "closed" | "connected" | "connecting" | "failed" | "new";
type RTCEncodedVideoFrameType = "delta" | "empty" | "key";
type RTCIceCandidateType = "host" | "prflx" | "relay" | "srflx";
type RTCIceComponent = "rtcp" | "rtp";
type RTCIceConnectionState = "checking" | "closed" | "completed" | "connected" | "disconnected" | "failed" | "new";
type RTCIceCredentialType = "password";
type RTCIceGathererState = "complete" | "gathering" | "new";
type RTCIceGatheringState = "complete" | "gathering" | "new";
type RTCIceProtocol = "tcp" | "udp";
type RTCIceTcpCandidateType = "active" | "passive" | "so";
type RTCIceTransportPolicy = "all" | "relay";
type RTCIceTransportState = "checking" | "closed" | "completed" | "connected" | "disconnected" | "failed" | "new";
type RTCLifecycleEvent = "connectionstatechange" | "iceconnectionstatechange" | "icegatheringstatechange" | "initialized";
type RTCPeerConnectionState = "closed" | "connected" | "connecting" | "disconnected" | "failed" | "new";
type RTCPriorityType = "high" | "low" | "medium" | "very-low";
type RTCRtpTransceiverDirection = "inactive" | "recvonly" | "sendonly" | "sendrecv" | "stopped";
type RTCSctpTransportState = "closed" | "connected" | "connecting";
type RTCSdpType = "answer" | "offer" | "pranswer" | "rollback";
type RTCSignalingState = "closed" | "have-local-offer" | "have-local-pranswer" | "have-remote-offer" | "have-remote-pranswer" | "stable";
type RTCStatsIceCandidatePairState = "cancelled" | "failed" | "frozen" | "inprogress" | "succeeded" | "waiting";
type RTCStatsType = "candidate-pair" | "codec" | "csrc" | "data-channel" | "inbound-rtp" | "local-candidate" | "media-source" | "outbound-rtp" | "peer-connection" | "remote-candidate" | "remote-inbound-rtp" | "remote-outbound-rtp" | "session" | "track" | "transport";
type ReadableStreamReaderMode = "byob";
type RecordingState = "inactive" | "paused" | "recording";
type ReferrerPolicy = "" | "no-referrer" | "no-referrer-when-downgrade" | "origin" | "origin-when-cross-origin" | "same-origin" | "strict-origin" | "strict-origin-when-cross-origin" | "unsafe-url";
type RenderBlockingStatusType = "blocking" | "non-blocking";
type RequestCache = "default" | "force-cache" | "no-cache" | "no-store" | "only-if-cached" | "reload";
type RequestCredentials = "include" | "omit" | "same-origin";
type RequestDestination = "" | "audio" | "audioworklet" | "document" | "embed" | "font" | "frame" | "iframe" | "image" | "json" | "manifest" | "object" | "paintworklet" | "report" | "script" | "sharedworker" | "style" | "track" | "video" | "worker" | "xslt";
type RequestMode = "cors" | "navigate" | "no-cors" | "same-origin";
type RequestPriority = "auto" | "high" | "low";
type RequestRedirect = "error" | "follow" | "manual";
type ResizeObserverBoxOptions = "border-box" | "content-box" | "device-pixel-content-box";
type ResourceCacheTarget = "chrome" | "content";
type ResourceCacheType = "image" | "script" | "stylesheet";
type ResponseType = "basic" | "cors" | "default" | "error" | "opaque" | "opaqueredirect";
type SanitizerPresets = "default";
type ScreenColorGamut = "p3" | "rec2020" | "srgb";
type ScrollBehavior = "auto" | "instant" | "smooth";
type ScrollLogicalPosition = "center" | "end" | "nearest" | "start";
type ScrollRestoration = "auto" | "manual";
type ScrollSetting = "" | "up";
type SecurityPolicyViolationEventDisposition = "enforce" | "report";
type SelectionMode = "end" | "preserve" | "select" | "start";
type SelectorWarningKind = "UnconstrainedHas";
type ServiceWorkerState = "activated" | "activating" | "installed" | "installing" | "parsed" | "redundant";
type ServiceWorkerUpdateViaCache = "all" | "imports" | "none";
type ShadowRootMode = "closed" | "open";
type SlotAssignmentMode = "manual" | "named";
type SocketReadyState = "closed" | "closing" | "halfclosed" | "open" | "opening";
type SourceBufferAppendMode = "segments" | "sequence";
type SpeechRecognitionErrorCode = "aborted" | "audio-capture" | "bad-grammar" | "language-not-supported" | "network" | "no-speech" | "not-allowed" | "service-not-allowed";
type SpeechSynthesisErrorCode = "audio-busy" | "audio-hardware" | "canceled" | "interrupted" | "invalid-argument" | "language-unavailable" | "network" | "synthesis-failed" | "synthesis-unavailable" | "text-too-long" | "voice-unavailable";
type StreamFilterStatus = "closed" | "disconnected" | "failed" | "finishedtransferringdata" | "suspended" | "transferringdata" | "uninitialized";
type StringType = "inline" | "literal" | "other" | "stringbuffer";
type SupportedType = "application/xhtml+xml" | "application/xml" | "image/svg+xml" | "text/html" | "text/xml";
type TCPReadyState = "closed" | "closing" | "connecting" | "open";
type TCPSocketBinaryType = "arraybuffer" | "string";
type TaskPriority = "background" | "user-blocking" | "user-visible";
type TextTrackKind = "captions" | "chapters" | "descriptions" | "metadata" | "subtitles";
type TextTrackMode = "disabled" | "hidden" | "showing";
type TouchEventsOverride = "disabled" | "enabled" | "none";
type TransferFunction = "hlg" | "pq" | "srgb";
type UniFFIScaffoldingCallCode = "error" | "internal-error" | "success";
type VRDisplayEventReason = "mounted" | "navigation" | "requested" | "unmounted";
type VREye = "left" | "right";
type VideoColorPrimaries = "bt2020" | "bt470bg" | "bt709" | "smpte170m" | "smpte432";
type VideoEncoderBitrateMode = "constant" | "quantizer" | "variable";
type VideoMatrixCoefficients = "bt2020-ncl" | "bt470bg" | "bt709" | "rgb" | "smpte170m";
type VideoPixelFormat = "BGRA" | "BGRX" | "I420" | "I420A" | "I420AP10" | "I420AP12" | "I420P10" | "I420P12" | "I422" | "I422A" | "I422AP10" | "I422AP12" | "I422P10" | "I422P12" | "I444" | "I444A" | "I444AP10" | "I444AP12" | "I444P10" | "I444P12" | "NV12" | "RGBA" | "RGBX";
type VideoTransferCharacteristics = "bt709" | "hlg" | "iec61966-2-1" | "linear" | "pq" | "smpte170m";
type VisibilityState = "hidden" | "visible";
type WakeLockType = "screen";
type WebGLPowerPreference = "default" | "high-performance" | "low-power";
type WebIDLProcType = "browser" | "extension" | "file" | "forkServer" | "gmpPlugin" | "gpu" | "inference" | "ipdlUnitTest" | "preallocated" | "privilegedabout" | "privilegedmozilla" | "rdd" | "socket" | "unknown" | "utility" | "vr" | "web" | "webIsolated" | "webServiceWorker" | "withCoopCoep";
type WebIDLUtilityActorName = "audioDecoder_AppleMedia" | "audioDecoder_Generic" | "audioDecoder_WMF" | "jSOracle" | "mfMediaEngineCDM" | "unknown" | "windowsFileDialog" | "windowsUtils";
type WebTransportCongestionControl = "default" | "low-latency" | "throughput";
type WebTransportErrorSource = "session" | "stream";
type WebTransportReliabilityMode = "pending" | "reliable-only" | "supports-unreliable";
type WireframeRectType = "background" | "image" | "text" | "unknown";
type WorkerType = "classic" | "module";
type WriteCommandType = "seek" | "truncate" | "write";
type WriteMode = "append" | "appendOrCreate" | "create" | "overwrite";
type XMLHttpRequestResponseType = "" | "arraybuffer" | "blob" | "document" | "json" | "text";
type XREye = "left" | "none" | "right";
type XRHandedness = "left" | "none" | "right";
type XRReferenceSpaceType = "bounded-floor" | "local" | "local-floor" | "unbounded" | "viewer";
type XRSessionMode = "immersive-ar" | "immersive-vr" | "inline";
type XRTargetRayMode = "gaze" | "screen" | "tracked-pointer";
type XRVisibilityState = "hidden" | "visible" | "visible-blurred";
type mozPacketDumpType = "rtcp" | "rtp" | "srtcp" | "srtp";

/////////////////////////////
/////////////////////////////

interface AudioParam {
    setValueCurveAtTime(values: Iterable<number>, startTime: number, duration: number): AudioParam;
}

interface AudioParamMap extends ReadonlyMap<string, AudioParam> {
}

interface AudioTrackList {
    [Symbol.iterator](): IterableIterator<AudioTrack>;
}

interface BaseAudioContext {
    createIIRFilter(feedforward: Iterable<number>, feedback: Iterable<number>): IIRFilterNode;
    createPeriodicWave(real: Iterable<number>, imag: Iterable<number>, constraints?: PeriodicWaveConstraints): PeriodicWave;
}

interface CSSKeyframesRule {
    [Symbol.iterator](): IterableIterator<CSSKeyframeRule>;
}

interface CSSRuleList {
    [Symbol.iterator](): IterableIterator<CSSRule>;
}

interface CSSStyleDeclaration {
    [Symbol.iterator](): IterableIterator<string>;
}

interface Cache {
    addAll(requests: Iterable<RequestInfo>): Promise<void>;
}

interface CanvasPathDrawingStyles {
    setLineDash(segments: Iterable<number>): void;
}

interface CanvasPathMethods {
    roundRect(x: number, y: number, w: number, h: number, radii?: number | DOMPointInit | Iterable<number | DOMPointInit>): void;
}

interface CookieStoreManager {
    subscribe(subscriptions: Iterable<CookieStoreGetOptions>): Promise<void>;
    unsubscribe(subscriptions: Iterable<CookieStoreGetOptions>): Promise<void>;
}

interface CustomStateSet extends Set<string> {
}

interface DOMLocalization {
    translateElements(aElements: Iterable<Element>): Promise<void>;
}

interface DOMParser {
    parseFromBuffer(buf: Iterable<number>, type: SupportedType): Document;
}

interface DOMRectList {
    [Symbol.iterator](): IterableIterator<DOMRect>;
}

interface DOMStringList {
    [Symbol.iterator](): IterableIterator<string>;
}

interface DOMTokenList {
    [Symbol.iterator](): IterableIterator<string | null>;
    entries(): IterableIterator<[number, string | null]>;
    keys(): IterableIterator<number>;
    values(): IterableIterator<string | null>;
}

interface DataTransferItemList {
    [Symbol.iterator](): IterableIterator<DataTransferItem>;
}

interface Document {
    createTouchList(touches: Iterable<Touch>): TouchList;
}

interface EventCounts extends ReadonlyMap<string, number> {
}

interface FileList {
    [Symbol.iterator](): IterableIterator<File>;
}

interface FormData {
    [Symbol.iterator](): IterableIterator<[string, FormDataEntryValue]>;
    entries(): IterableIterator<[string, FormDataEntryValue]>;
    keys(): IterableIterator<string>;
    values(): IterableIterator<FormDataEntryValue>;
}

interface GPUBindingCommandsMixin {
    setBindGroup(index: GPUIndex32, bindGroup: GPUBindGroup | null, dynamicOffsets?: Iterable<GPUBufferDynamicOffset>): void;
}

interface GPUCommandEncoder {
    copyBufferToTexture(source: GPUTexelCopyBufferInfo, destination: GPUTexelCopyTextureInfo, copySize: Iterable<GPUIntegerCoordinate>): void;
    copyTextureToBuffer(source: GPUTexelCopyTextureInfo, destination: GPUTexelCopyBufferInfo, copySize: Iterable<GPUIntegerCoordinate>): void;
    copyTextureToTexture(source: GPUTexelCopyTextureInfo, destination: GPUTexelCopyTextureInfo, copySize: Iterable<GPUIntegerCoordinate>): void;
}

interface GPUQueue {
    copyExternalImageToTexture(source: GPUCopyExternalImageSourceInfo, destination: GPUCopyExternalImageDestInfo, copySize: Iterable<GPUIntegerCoordinate>): void;
    submit(buffers: Iterable<GPUCommandBuffer>): void;
    writeTexture(destination: GPUTexelCopyTextureInfo, data: AllowSharedBufferSource, dataLayout: GPUTexelCopyBufferLayout, size: Iterable<GPUIntegerCoordinate>): void;
}

interface GPURenderPassEncoder {
    executeBundles(bundles: Iterable<GPURenderBundle>): void;
    setBlendConstant(color: Iterable<number>): void;
}

interface GPUSupportedFeatures extends ReadonlySet<string> {
}

interface GleanCustomDistribution {
    accumulateSamples(aSamples: Iterable<number>): void;
}

interface GleanStringList {
    set(aValue: Iterable<string>): void;
}

interface GleanTimingDistribution {
    accumulateSamples(aSamples: Iterable<number>): void;
}

interface GridLines {
    [Symbol.iterator](): IterableIterator<GridLine>;
}

interface GridTracks {
    [Symbol.iterator](): IterableIterator<GridTrack>;
}

interface HTMLAllCollection {
    [Symbol.iterator](): IterableIterator<Element>;
}

interface HTMLCollectionBase {
    [Symbol.iterator](): IterableIterator<Element>;
}

interface HTMLFormElement {
    [Symbol.iterator](): IterableIterator<Element>;
}

interface HTMLInputElement {
    mozSetDndFilesAndDirectories(list: Iterable<File | Directory>): void;
    mozSetFileArray(files: Iterable<File>): void;
    mozSetFileNameArray(fileNames: Iterable<string>): void;
}

interface HTMLSelectElement {
    [Symbol.iterator](): IterableIterator<Element>;
}

interface Headers {
    [Symbol.iterator](): IterableIterator<[string, string]>;
    entries(): IterableIterator<[string, string]>;
    keys(): IterableIterator<string>;
    values(): IterableIterator<string>;
}

interface HeapSnapshot {
    computeShortestPaths(start: NodeId, targets: Iterable<NodeId>, maxNumPaths: number): any;
}

interface Highlight extends Set<AbstractRange> {
}

interface HighlightRegistry extends Map<string, Highlight> {
}

interface IDBDatabase {
    transaction(storeNames: string | Iterable<string>, mode?: IDBTransactionMode, options?: IDBTransactionOptions): IDBTransaction;
}

interface IDBObjectStore {
    createIndex(name: string, keyPath: string | Iterable<string>, optionalParameters?: IDBIndexParameters): IDBIndex;
}

interface ImageTrackList {
    [Symbol.iterator](): IterableIterator<ImageTrack>;
}

interface IntlUtils {
    getDisplayNames(locales: Iterable<string>, options?: DisplayNameOptions): DisplayNameResult;
}

interface L10nRegistry {
    generateBundles(aLocales: Iterable<string>, aResourceIds: Iterable<L10nResourceId>): FluentBundleAsyncIterator;
    generateBundlesSync(aLocales: Iterable<string>, aResourceIds: Iterable<L10nResourceId>): FluentBundleIterator;
    registerSources(aSources: Iterable<L10nFileSource>): void;
    removeSources(aSources: Iterable<string>): void;
    updateSources(aSources: Iterable<L10nFileSource>): void;
}

interface Localization {
    addResourceIds(aResourceIds: Iterable<L10nResourceId>): void;
    formatMessages(aKeys: Iterable<L10nKey>): Promise<(L10nMessage | null)[]>;
    formatMessagesSync(aKeys: Iterable<L10nKey>): (L10nMessage | null)[];
    formatValues(aKeys: Iterable<L10nKey>): Promise<(string | null)[]>;
    formatValuesSync(aKeys: Iterable<L10nKey>): (string | null)[];
    removeResourceIds(aResourceIds: Iterable<L10nResourceId>): number;
}

interface MIDIInputMap extends ReadonlyMap<string, MIDIInput> {
}

interface MIDIOutput {
    send(data: Iterable<number>, timestamp?: DOMHighResTimeStamp): void;
}

interface MIDIOutputMap extends ReadonlyMap<string, MIDIOutput> {
}

interface MediaKeyStatusMap {
    [Symbol.iterator](): IterableIterator<[ArrayBuffer, MediaKeyStatus]>;
    entries(): IterableIterator<[ArrayBuffer, MediaKeyStatus]>;
    keys(): IterableIterator<ArrayBuffer>;
    values(): IterableIterator<MediaKeyStatus>;
}

interface MediaList {
    [Symbol.iterator](): IterableIterator<string>;
}

interface MessageEvent {
    initMessageEvent(type: string, bubbles?: boolean, cancelable?: boolean, data?: any, origin?: string, lastEventId?: string, source?: MessageEventSource | null, ports?: Iterable<MessagePort>): void;
}

interface MessagePort {
    postMessage(message: any, transferable: Iterable<any>): void;
}

interface MimeTypeArray {
    [Symbol.iterator](): IterableIterator<MimeType>;
}

interface MozDocumentObserver {
    observe(matchers: Iterable<MozDocumentMatcher>): void;
}

interface MozSharedMap {
    [Symbol.iterator](): IterableIterator<[string, StructuredClonable]>;
    entries(): IterableIterator<[string, StructuredClonable]>;
    keys(): IterableIterator<string>;
    values(): IterableIterator<StructuredClonable>;
}

interface MozStorageAsyncStatementParams {
    [Symbol.iterator](): IterableIterator<any>;
}

interface MozStorageStatementParams {
    [Symbol.iterator](): IterableIterator<any>;
}

interface NamedNodeMap {
    [Symbol.iterator](): IterableIterator<Attr>;
}

interface Navigator {
    requestMediaKeySystemAccess(keySystem: string, supportedConfigurations: Iterable<MediaKeySystemConfiguration>): Promise<MediaKeySystemAccess>;
    vibrate(pattern: Iterable<number>): boolean;
}

interface NodeList {
    [Symbol.iterator](): IterableIterator<Node | null>;
    entries(): IterableIterator<[number, Node | null]>;
    keys(): IterableIterator<number>;
    values(): IterableIterator<Node | null>;
}

interface PaintRequestList {
    [Symbol.iterator](): IterableIterator<PaintRequest>;
}

interface PeerConnectionObserver {
    fireTrackEvent(receiver: RTCRtpReceiver, streams: Iterable<MediaStream>): void;
}

interface PlacesEventCounts extends ReadonlyMap<string, number> {
}

interface Plugin {
    [Symbol.iterator](): IterableIterator<MimeType>;
}

interface PluginArray {
    [Symbol.iterator](): IterableIterator<Plugin>;
}

interface RTCRtpTransceiver {
    setCodecPreferences(codecs: Iterable<RTCRtpCodec>): void;
}

interface RTCStatsReport extends ReadonlyMap<string, any> {
}

interface SVGLengthList {
    [Symbol.iterator](): IterableIterator<SVGLength>;
}

interface SVGNumberList {
    [Symbol.iterator](): IterableIterator<SVGNumber>;
}

interface SVGPathData {
    setPathData(pathData: Iterable<SVGPathSegmentInit>): void;
}

interface SVGPointList {
    [Symbol.iterator](): IterableIterator<SVGPoint>;
}

interface SVGStringList {
    [Symbol.iterator](): IterableIterator<string>;
}

interface SVGTransformList {
    [Symbol.iterator](): IterableIterator<SVGTransform>;
}

interface Screen {
    mozLockOrientation(orientation: Iterable<string>): boolean;
}

interface ServiceWorker {
    postMessage(message: any, transferable: Iterable<any>): void;
}

interface SourceBufferList {
    [Symbol.iterator](): IterableIterator<SourceBuffer>;
}

interface SpeechGrammarList {
    [Symbol.iterator](): IterableIterator<SpeechGrammar>;
}

interface SpeechRecognitionResult {
    [Symbol.iterator](): IterableIterator<SpeechRecognitionAlternative>;
}

interface SpeechRecognitionResultList {
    [Symbol.iterator](): IterableIterator<SpeechRecognitionResult>;
}

interface StyleSheetList {
    [Symbol.iterator](): IterableIterator<CSSStyleSheet>;
}

interface SubtleCrypto {
    deriveKey(algorithm: AlgorithmIdentifier, baseKey: CryptoKey, derivedKeyType: AlgorithmIdentifier, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<any>;
    generateKey(algorithm: AlgorithmIdentifier, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<any>;
    importKey(format: KeyFormat, keyData: any, algorithm: AlgorithmIdentifier, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<any>;
    unwrapKey(format: KeyFormat, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier, unwrappedKeyAlgorithm: AlgorithmIdentifier, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<any>;
}

interface TestInterfaceIterableDouble {
    [Symbol.iterator](): IterableIterator<[string, string]>;
    entries(): IterableIterator<[string, string]>;
    keys(): IterableIterator<string>;
    values(): IterableIterator<string>;
}

interface TestInterfaceIterableDoubleUnion {
    [Symbol.iterator](): IterableIterator<[string, string | number]>;
    entries(): IterableIterator<[string, string | number]>;
    keys(): IterableIterator<string>;
    values(): IterableIterator<string | number>;
}

interface TestInterfaceIterableSingle {
    [Symbol.iterator](): IterableIterator<number>;
    entries(): IterableIterator<[number, number]>;
    keys(): IterableIterator<number>;
    values(): IterableIterator<number>;
}

interface TestInterfaceJS {
    anySequenceLength(seq: Iterable<any>): number;
    objectSequenceLength(seq: Iterable<any>): number;
    testSequenceOverload(arg: Iterable<string>): void;
    testSequenceUnion(arg: Iterable<string> | string): void;
}

interface TestInterfaceMaplike extends Map<string, number> {
}

interface TestInterfaceMaplikeJSObject extends ReadonlyMap<string, any> {
}

interface TestInterfaceMaplikeObject extends ReadonlyMap<string, TestInterfaceMaplike> {
}

interface TestInterfaceSetlike extends Set<string> {
}

interface TestInterfaceSetlikeNode extends Set<Node> {
}

interface TestReflectedHTMLAttribute {
    setReflectedHTMLAttributeValue(seq: Iterable<Element>): void;
}

interface TextTrackCueList {
    [Symbol.iterator](): IterableIterator<VTTCue>;
}

interface TextTrackList {
    [Symbol.iterator](): IterableIterator<TextTrack>;
}

interface TouchList {
    [Symbol.iterator](): IterableIterator<Touch>;
}

interface TreeColumns {
    [Symbol.iterator](): IterableIterator<TreeColumn>;
}

interface URLSearchParams {
    [Symbol.iterator](): IterableIterator<[string, string]>;
    entries(): IterableIterator<[string, string]>;
    keys(): IterableIterator<string>;
    values(): IterableIterator<string>;
}

interface VRDisplay {
    requestPresent(layers: Iterable<VRLayer>): Promise<void>;
}

interface VideoTrackList {
    [Symbol.iterator](): IterableIterator<VideoTrack>;
}

interface WEBGL_draw_buffers {
    drawBuffersWEBGL(buffers: Iterable<GLenum>): void;
}

interface WGSLLanguageFeatures extends ReadonlySet<string> {
}

interface WebGL2RenderingContextBase {
    clearBufferfv(buffer: GLenum, drawbuffer: GLint, values: Iterable<GLfloat>, srcOffset?: GLuint): void;
    clearBufferiv(buffer: GLenum, drawbuffer: GLint, values: Iterable<GLint>, srcOffset?: GLuint): void;
    clearBufferuiv(buffer: GLenum, drawbuffer: GLint, values: Iterable<GLuint>, srcOffset?: GLuint): void;
    drawBuffers(buffers: Iterable<GLenum>): void;
    getActiveUniforms(program: WebGLProgram, uniformIndices: Iterable<GLuint>, pname: GLenum): any;
    getUniformIndices(program: WebGLProgram, uniformNames: Iterable<string>): GLuint[] | null;
    invalidateFramebuffer(target: GLenum, attachments: Iterable<GLenum>): void;
    invalidateSubFramebuffer(target: GLenum, attachments: Iterable<GLenum>, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
    transformFeedbackVaryings(program: WebGLProgram, varyings: Iterable<string>, bufferMode: GLenum): void;
    uniform1fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform1iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform1uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform2fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform2iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform2uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform3fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform3iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform3uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform4fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform4iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniform4uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix2x3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix2x4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix3x2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix3x4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix4x2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: GLuint, srcLength?: GLuint): void;
    uniformMatrix4x3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: GLuint, srcLength?: GLuint): void;
    vertexAttribI4iv(index: GLuint, values: Iterable<GLint>): void;
    vertexAttribI4uiv(index: GLuint, values: Iterable<GLuint>): void;
}

interface WebGLRenderingContext {
    uniform1fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>): void;
    uniform1iv(location: WebGLUniformLocation | null, data: Iterable<GLint>): void;
    uniform2fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>): void;
    uniform2iv(location: WebGLUniformLocation | null, data: Iterable<GLint>): void;
    uniform3fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>): void;
    uniform3iv(location: WebGLUniformLocation | null, data: Iterable<GLint>): void;
    uniform4fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>): void;
    uniform4iv(location: WebGLUniformLocation | null, data: Iterable<GLint>): void;
    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>): void;
    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>): void;
    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>): void;
}

interface WebGLRenderingContextBase {
    vertexAttrib1fv(indx: GLuint, values: Iterable<GLfloat>): void;
    vertexAttrib2fv(indx: GLuint, values: Iterable<GLfloat>): void;
    vertexAttrib3fv(indx: GLuint, values: Iterable<GLfloat>): void;
    vertexAttrib4fv(indx: GLuint, values: Iterable<GLfloat>): void;
}

interface Window {
    postMessage(message: any, targetOrigin: string, transfer?: Iterable<any>): void;
    setScrollMarks(marks: Iterable<number>, onHorizontalScrollbar?: boolean): void;
}

interface Worker {
    postMessage(message: any, transfer: Iterable<any>): void;
}

interface XRInputSourceArray {
    [Symbol.iterator](): IterableIterator<XRInputSource>;
    entries(): IterableIterator<[number, XRInputSource]>;
    keys(): IterableIterator<number>;
    values(): IterableIterator<XRInputSource>;
}

interface XSLTProcessor {
    setParameter(namespaceURI: string | null, localName: string, value: Iterable<Node>): void;
}

/////////////////////////////
/////////////////////////////

interface FileSystemDirectoryHandle {
    [Symbol.asyncIterator](): AsyncIterableIterator<[string, FileSystemHandle]>;
    entries(): AsyncIterableIterator<[string, FileSystemHandle]>;
    keys(): AsyncIterableIterator<string>;
    values(): AsyncIterableIterator<FileSystemHandle>;
}

interface ReadableStream {
    [Symbol.asyncIterator](options?: ReadableStreamIteratorOptions): AsyncIterableIterator<any>;
    values(options?: ReadableStreamIteratorOptions): AsyncIterableIterator<any>;
}

interface TestInterfaceAsyncIterableDouble {
    [Symbol.asyncIterator](): AsyncIterableIterator<[string, string]>;
    entries(): AsyncIterableIterator<[string, string]>;
    keys(): AsyncIterableIterator<string>;
    values(): AsyncIterableIterator<string>;
}

interface TestInterfaceAsyncIterableDoubleUnion {
    [Symbol.asyncIterator](): AsyncIterableIterator<[string, string | number]>;
    entries(): AsyncIterableIterator<[string, string | number]>;
    keys(): AsyncIterableIterator<string>;
    values(): AsyncIterableIterator<string | number>;
}

interface TestInterfaceAsyncIterableSingle {
    [Symbol.asyncIterator](): AsyncIterableIterator<number>;
    values(): AsyncIterableIterator<number>;
}

interface TestInterfaceAsyncIterableSingleWithArgs {
    [Symbol.asyncIterator](options?: TestInterfaceAsyncIteratorOptions): AsyncIterableIterator<number>;
    values(options?: TestInterfaceAsyncIteratorOptions): AsyncIterableIterator<number>;
}

// @ts-nocheck
/**
 * NOTE: Do not modify this file by hand.
 * Content was generated from source glean .yaml files.
 * If you're updating some of the sources, see README for instructions.
 */

interface GleanImpl {

  a11y: {
    alwaysUnderlineLinks: GleanBoolean;
    useSystemColors: GleanBoolean;
    hcmBackground: GleanQuantity;
    hcmForeground: GleanQuantity;
    backplate: GleanBoolean;
    instantiators: GleanString;
    invertColors: GleanBoolean;
    theme: Record<string, GleanBoolean>;
    consumers: GleanCustomDistribution;
    treeUpdateTiming: GleanTimingDistribution;
  }

  fullscreen: {
    change: GleanTimingDistribution;
  }

  securityUiProtectionspopup: {
    openProtectionsPopup: GleanEvent;
    closeProtectionsPopup: GleanEvent;
    openProtectionspopupCfr: GleanEvent;
    clickEtpToggleOn: GleanEvent;
    clickEtpToggleOff: GleanEvent;
    clickSocial: GleanEvent;
    clickCookies: GleanEvent;
    clickTrackers: GleanEvent;
    clickFingerprinters: GleanEvent;
    clickCryptominers: GleanEvent;
    clickSubviewSettings: GleanEvent;
    clickSettings: GleanEvent;
    clickFullReport: GleanEvent;
    clickMilestoneMessage: GleanEvent;
    clickCookiebToggleOn: GleanEvent;
    clickCookiebToggleOff: GleanEvent;
    clickProtectionspopupCfr: GleanEvent;
    clickSmartblockembedsToggle: GleanEvent;
    smartblockembedsShown: GleanCounter;
  }

  browserEngagement: {
    bookmarksToolbarBookmarkAdded: GleanCounter;
    bookmarksToolbarBookmarkOpened: GleanCounter;
    totalTopVisits: Record<string, GleanCounter>;
    sessionrestoreInterstitial: Record<string, GleanCounter>;
    tabUnloadCount: GleanCounter;
    tabReloadCount: GleanCounter;
    tabExplicitUnload: GleanEvent;
    tabUnloadToReload: GleanTimingDistribution;
    activeTicks: GleanCounter;
    uriCount: GleanCounter;
    uriCountNormalMode: GleanCounter;
    profileCount: GleanQuantity;
    maxConcurrentTabCount: GleanQuantity;
    maxConcurrentVerticalTabCount: GleanQuantity;
    maxConcurrentWindowCount: GleanQuantity;
    maxConcurrentTabPinnedCount: GleanQuantity;
    maxConcurrentVerticalTabPinnedCount: GleanQuantity;
    tabOpenEventCount: GleanCounter;
    verticalTabOpenEventCount: GleanCounter;
    windowOpenEventCount: GleanCounter;
    tabPinnedEventCount: GleanCounter;
    verticalTabPinnedEventCount: GleanCounter;
    unfilteredUriCount: GleanCounter;
    uniqueDomainsCount: GleanQuantity;
    tabCount: GleanCustomDistribution;
    loadedTabCount: GleanCustomDistribution;
    sessionTimeIncludingSuspend: GleanQuantity;
    sessionTimeExcludingSuspend: GleanQuantity;
  }

  networking: {
    captivePortalBannerDisplayed: GleanCounter;
    captivePortalBannerDisplayTime: Record<string, GleanCounter>;
    speculativeConnectOutcome: Record<string, GleanCounter>;
    cookieTimestampFixedCount: Record<string, GleanCounter>;
    cookieCreationFixupDiff: GleanCustomDistribution;
    cookieAccessFixupDiff: GleanCustomDistribution;
    cookieCountTotal: GleanCustomDistribution;
    cookieCountPartitioned: GleanCustomDistribution;
    cookieCountUnpartitioned: GleanCustomDistribution;
    cookieCountPartByKey: GleanCustomDistribution;
    cookieCountUnpartByKey: GleanCustomDistribution;
    cookieCountInvalidFirstPartyPartitionedInDb: GleanCounter;
    setInvalidFirstPartyPartitionedCookie: GleanCounter;
    cookiePurgeMax: GleanCustomDistribution;
    cookiePurgeEntryMax: GleanCustomDistribution;
    cookieChipsPartitionLimitOverflow: GleanCustomDistribution;
    sqliteCookiesBlockMainThread: GleanTimingDistribution;
    sqliteCookiesTimeToBlockMainThread: GleanTimingDistribution;
    setCookie: GleanCounter;
    setCookieForeign: GleanRate;
    setCookiePartitioned: GleanRate;
    setCookieForeignPartitioned: GleanRate;
    dnsLookupTime: GleanTimingDistribution;
    trrFetchDuration: Record<string, GleanTimingDistribution>;
    trrDnsStart: Record<string, GleanTimingDistribution>;
    trrDnsEnd: Record<string, GleanTimingDistribution>;
    trrTcpConnection: Record<string, GleanTimingDistribution>;
    trrTlsHandshake: Record<string, GleanTimingDistribution>;
    trrOpenToFirstSent: Record<string, GleanTimingDistribution>;
    trrFirstSentToLastReceived: Record<string, GleanTimingDistribution>;
    trrOpenToFirstReceived: Record<string, GleanTimingDistribution>;
    trrCompleteLoad: Record<string, GleanTimingDistribution>;
    trrResponseSize: Record<string, GleanMemoryDistribution>;
    trrRequestSize: Record<string, GleanMemoryDistribution>;
    dnsRenewalTime: GleanTimingDistribution;
    dnsRenewalTimeForTtl: GleanTimingDistribution;
    dnsFailedLookupTime: GleanTimingDistribution;
    dnsNativeHttpsCallTime: GleanTimingDistribution;
    dnsNativeCount: Record<string, GleanCounter>;
    fetchKeepaliveDiscardCount: Record<string, GleanCounter>;
    fetchKeepaliveRequestCount: Record<string, GleanCounter>;
    httpContentOnstartDelay: GleanTimingDistribution;
    httpContentOnstopDelay: GleanTimingDistribution;
    httpContentOndatafinishedDelay: GleanTimingDistribution;
    httpContentOndatafinishedDelay2: GleanTimingDistribution;
    httpContentOndatafinishedToOnstopDelay: GleanTimingDistribution;
    httpContentHtml5parserOndatafinishedToOnstopDelay: GleanTimingDistribution;
    httpContentCssloaderOndatafinishedToOnstopDelay: GleanTimingDistribution;
    httpIpAddrAnyCount: Record<string, GleanCounter>;
    httpIpAddrAnyHostnames: Record<string, GleanCounter>;
    httpOnstartSuspendTotalTime: GleanTimingDistribution;
    http1DownloadThroughput: GleanCustomDistribution;
    http1DownloadThroughput1050: GleanCustomDistribution;
    http1DownloadThroughput50100: GleanCustomDistribution;
    http1DownloadThroughput100: GleanCustomDistribution;
    http2DownloadThroughput: GleanCustomDistribution;
    http2DownloadThroughput1050: GleanCustomDistribution;
    http2DownloadThroughput50100: GleanCustomDistribution;
    http2DownloadThroughput100: GleanCustomDistribution;
    http3DownloadThroughput: GleanCustomDistribution;
    http3DownloadThroughput1050: GleanCustomDistribution;
    http3DownloadThroughput50100: GleanCustomDistribution;
    http3DownloadThroughput100: GleanCustomDistribution;
    http1UploadThroughput: GleanCustomDistribution;
    http2UploadThroughput: GleanCustomDistribution;
    http3UploadThroughput: GleanCustomDistribution;
    http1UploadThroughput1050: GleanCustomDistribution;
    http1UploadThroughput50100: GleanCustomDistribution;
    http1UploadThroughput100: GleanCustomDistribution;
    http2UploadThroughput1050: GleanCustomDistribution;
    http2UploadThroughput50100: GleanCustomDistribution;
    http2UploadThroughput100: GleanCustomDistribution;
    http3UploadThroughput1050: GleanCustomDistribution;
    http3UploadThroughput50100: GleanCustomDistribution;
    http3UploadThroughput100: GleanCustomDistribution;
    http3EcnCeEct0RatioSent: GleanCustomDistribution;
    http3EcnCeEct0RatioReceived: GleanCustomDistribution;
    http3EcnPathCapability: Record<string, GleanCounter>;
    http3LossRatio: GleanCustomDistribution;
    http3ConnectionCloseReason: Record<string, GleanCounter>;
    http3QuicFrameCount: Record<string, GleanCounter>;
    cacheMetadataFirstReadTime: GleanTimingDistribution;
    cacheMetadataSecondReadTime: GleanTimingDistribution;
    cacheMetadataSize: GleanMemoryDistribution;
    residualCacheFolderCount: GleanCounter;
    residualCacheFolderRemoval: Record<string, GleanCounter>;
    cachePurgeDueToMemoryLimit: Record<string, GleanCounter>;
    trrRequestCount: Record<string, GleanCounter>;
    trrRequestCountPerConn: Record<string, GleanCounter>;
    httpRedirectToSchemeTopLevel: Record<string, GleanCounter>;
    httpRedirectToSchemeSubresource: Record<string, GleanCounter>;
    httpResponseVersion: Record<string, GleanCounter>;
    httpResponseStatusCode: Record<string, GleanCounter>;
    httpsRrPresented: Record<string, GleanCounter>;
    httpChannelOnstartSuccessHttpsRr: Record<string, GleanCounter>;
    httpChannelDisposition: Record<string, GleanCounter>;
    httpChannelDispositionEnabledUpgrade: Record<string, GleanCounter>;
    httpChannelDispositionEnabledNoReason: Record<string, GleanCounter>;
    httpChannelDispositionEnabledWont: Record<string, GleanCounter>;
    httpChannelDispositionDisabledUpgrade: Record<string, GleanCounter>;
    httpChannelDispositionDisabledNoReason: Record<string, GleanCounter>;
    httpChannelDispositionDisabledWont: Record<string, GleanCounter>;
    httpChannelOnstartStatus: Record<string, GleanCounter>;
    httpChannelPageOpenToFirstSent: GleanTimingDistribution;
    httpChannelSubOpenToFirstSent: GleanTimingDistribution;
    httpChannelPageOpenToFirstSentHttpsRr: GleanTimingDistribution;
    httpToHttpsUpgradeReason: Record<string, GleanCounter>;
    httpsHttpOrLocal: Record<string, GleanCounter>;
    localNetworkAccess: Record<string, GleanCounter>;
    localNetworkAccessPort: GleanCustomDistribution;
    httpChannelSubOpenToFirstSentHttpsRr: GleanTimingDistribution;
    transactionWaitTimeHttpsRr: GleanTimingDistribution;
    proxyInfoType: Record<string, GleanCounter>;
    transactionWaitTime: GleanTimingDistribution;
    osSocketLimitReached: GleanCounter;
    http3UdpDatagramSegmentSizeSent: GleanMemoryDistribution;
    http3UdpDatagramSegmentSizeReceived: GleanMemoryDistribution;
    http3UdpDatagramSizeReceived: GleanMemoryDistribution;
    http3UdpDatagramSegmentsReceived: GleanCustomDistribution;
    prconnectBlockingTimeNormal: GleanTimingDistribution;
    prconnectBlockingTimeShutdown: GleanTimingDistribution;
    prconnectBlockingTimeConnectivityChange: GleanTimingDistribution;
    prconnectBlockingTimeLinkChange: GleanTimingDistribution;
    prconnectBlockingTimeOffline: GleanTimingDistribution;
    prconnectFailBlockingTimeNormal: GleanTimingDistribution;
    prconnectFailBlockingTimeShutdown: GleanTimingDistribution;
    prconnectFailBlockingTimeConnectivityChange: GleanTimingDistribution;
    prconnectFailBlockingTimeLinkChange: GleanTimingDistribution;
    prconnectFailBlockingTimeOffline: GleanTimingDistribution;
    prconnectcontinueBlockingTimeNormal: GleanTimingDistribution;
    prconnectcontinueBlockingTimeShutdown: GleanTimingDistribution;
    prconnectcontinueBlockingTimeConnectivityChange: GleanTimingDistribution;
    prconnectcontinueBlockingTimeLinkChange: GleanTimingDistribution;
    prconnectcontinueBlockingTimeOffline: GleanTimingDistribution;
    prcloseTcpBlockingTimeNormal: GleanTimingDistribution;
    prcloseTcpBlockingTimeShutdown: GleanTimingDistribution;
    prcloseTcpBlockingTimeConnectivityChange: GleanTimingDistribution;
    prcloseTcpBlockingTimeLinkChange: GleanTimingDistribution;
    prcloseTcpBlockingTimeOffline: GleanTimingDistribution;
    prcloseUdpBlockingTimeNormal: GleanTimingDistribution;
    prcloseUdpBlockingTimeShutdown: GleanTimingDistribution;
    prcloseUdpBlockingTimeConnectivityChange: GleanTimingDistribution;
    prcloseUdpBlockingTimeLinkChange: GleanTimingDistribution;
    prcloseUdpBlockingTimeOffline: GleanTimingDistribution;
    http3Enabled: GleanBoolean;
    httpsRrPrefsUsage: GleanQuantity;
    trrConnectionCycleCount: Record<string, GleanCounter>;
    dataTransferredV3Kb: Record<string, GleanCounter>;
    httpsRecordState: Record<string, GleanCounter>;
    nssInitialization: GleanQuantity;
    loadingCertsTask: GleanQuantity;
    dohHeuristicsAttempts: GleanCounter;
    dohHeuristicsPassCount: GleanCounter;
    dohHeuristicsResult: GleanQuantity;
    dohHeuristicEverTripped: Record<string, GleanBoolean>;
  }

  browserTimings: {
    tabClick: GleanTimingDistribution;
    newWindow: GleanTimingDistribution;
    pageLoad: GleanTimingDistribution;
    pageReloadNormal: GleanTimingDistribution;
    pageReloadSkipCache: GleanTimingDistribution;
    lastShutdown: GleanQuantity;
  }

  messagingSystem: {
    eventContextParseError: GleanCounter;
    eventReason: GleanString;
    eventPage: GleanString;
    eventSource: GleanString;
    eventContext: GleanText;
    eventScreenFamily: GleanText;
    eventScreenId: GleanText;
    eventScreenInitials: GleanText;
    eventScreenIndex: GleanQuantity;
    messageId: GleanText;
    event: GleanString;
    pingType: GleanString;
    source: GleanString;
    clientId: GleanUuid;
    locale: GleanString;
    browserSessionId: GleanUuid;
    impressionId: GleanUuid;
    bucketId: GleanString;
    addonVersion: GleanString;
    unknownKeyCount: GleanCounter;
    unknownKeys: Record<string, GleanCounter>;
    gleanPingForPingFailures: GleanCounter;
    invalidNestedData: Record<string, GleanCounter>;
    messageRequestTime: GleanTimingDistribution;
  }

  messagingSystemAttribution: {
    source: GleanString;
    medium: GleanString;
    campaign: GleanString;
    content: GleanString;
    experiment: GleanString;
    variation: GleanString;
    ua: GleanString;
    dltoken: GleanString;
    msstoresignedin: GleanString;
    dlsource: GleanString;
    unknownKeys: Record<string, GleanCounter>;
  }

  gleanAttribution: {
    ext: GleanObject;
  }

  gleanDistribution: {
    ext: GleanObject;
  }

  browserBackup: {
    enabled: GleanBoolean;
    schedulerEnabled: GleanBoolean;
    pswdEncrypted: GleanBoolean;
    locationOnDevice: GleanQuantity;
    profDDiskSpace: GleanQuantity;
    totalBackupSize: GleanMemoryDistribution;
    compressedArchiveSize: GleanMemoryDistribution;
    totalBackupTime: GleanTimingDistribution;
    placesSize: GleanQuantity;
    placesTime: GleanTimingDistribution;
    faviconsSize: GleanQuantity;
    faviconsTime: GleanTimingDistribution;
    credentialsDataSize: GleanQuantity;
    securityDataSize: GleanQuantity;
    preferencesSize: GleanQuantity;
    miscDataSize: GleanQuantity;
    cookiesSize: GleanQuantity;
    formHistorySize: GleanQuantity;
    sessionStoreBackupsDirectorySize: GleanQuantity;
    sessionStoreSize: GleanQuantity;
    extensionsJsonSize: GleanQuantity;
    extensionStorePermissionsDataSize: GleanQuantity;
    storageSyncSize: GleanQuantity;
    browserExtensionDataSize: GleanQuantity;
    extensionsXpiDirectorySize: GleanQuantity;
    extensionsStorageSize: GleanQuantity;
    toggleOn: GleanEvent;
    toggleOff: GleanEvent;
    created: GleanEvent;
    changeLocation: GleanEvent;
    passwordChanged: GleanEvent;
    passwordAdded: GleanEvent;
    passwordRemoved: GleanEvent;
    error: GleanEvent;
  }

  downloads: {
    panelShown: GleanCounter;
    addedFileExtension: GleanEvent;
    fileOpened: GleanCounter;
    userActionOnBlockedDownload: Record<string, GleanCustomDistribution>;
  }

  glamExperiment: {
    panelShown: GleanCounter;
    activeTicks: GleanCounter;
    protectTime: GleanTimingDistribution;
    largestContentfulPaint: GleanTimingDistribution;
    httpContentHtml5parserOndatafinishedToOnstopDelay: GleanTimingDistribution;
    osSocketLimitReached: GleanCounter;
    subCompleteLoadNet: GleanTimingDistribution;
    used: GleanCounter;
    cpuTimeBogusValues: GleanCounter;
    totalCpuTimeMs: GleanCounter;
  }

  firefoxviewNext: {
    recentlyClosedTabs: GleanEvent;
    dismissClosedTabTabs: GleanEvent;
    cardCollapsedCardContainer: GleanEvent;
    cardExpandedCardContainer: GleanEvent;
    changePageNavigation: GleanEvent;
    contextMenuTabs: GleanEvent;
    closeOpenTabTabs: GleanEvent;
    browserContextMenuTabs: GleanEvent;
    enteredFirefoxview: GleanEvent;
    fxaContinueSync: GleanEvent;
    fxaMobileSync: GleanEvent;
    syncedTabsTabs: GleanEvent;
    historyVisits: GleanEvent;
    sortHistoryTabs: GleanEvent;
    showAllHistoryTabs: GleanEvent;
    openTabTabs: GleanEvent;
    tabSelectedToolbarbutton: GleanEvent;
    searchInitiatedSearch: GleanEvent;
    searchShowAllShowallbutton: GleanEvent;
  }

  firefoxview: {
    cumulativeSearches: Record<string, GleanCustomDistribution>;
  }

  genaiChatbot: {
    enabled: GleanBoolean;
    provider: GleanString;
    shortcuts: GleanBoolean;
    shortcutsCustom: GleanBoolean;
    sidebar: GleanBoolean;
    contextmenuPromptClick: GleanEvent;
    contextmenuRemove: GleanEvent;
    experimentCheckboxClick: GleanEvent;
    keyboardShortcut: GleanEvent;
    onboardingClose: GleanEvent;
    onboardingContinue: GleanEvent;
    onboardingFinish: GleanEvent;
    onboardingLearnMore: GleanEvent;
    onboardingProviderChoiceDisplayed: GleanEvent;
    onboardingProviderLearn: GleanEvent;
    onboardingProviderSelection: GleanEvent;
    onboardingProviderTerms: GleanEvent;
    onboardingTextHighlightDisplayed: GleanEvent;
    providerChange: GleanEvent;
    shortcutsCheckboxClick: GleanEvent;
    shortcutsDisplayed: GleanEvent;
    shortcutsExpanded: GleanEvent;
    shortcutsHideClick: GleanEvent;
    shortcutsPromptClick: GleanEvent;
    sidebarCloseClick: GleanEvent;
    sidebarMoreMenuClick: GleanEvent;
    sidebarMoreMenuDisplay: GleanEvent;
    sidebarProviderMenuClick: GleanEvent;
    sidebarToggle: GleanEvent;
  }

  genaiLinkpreview: {
    enabled: GleanBoolean;
    cardAiConsent: GleanEvent;
    cardClose: GleanEvent;
    cardLink: GleanEvent;
    fetch: GleanEvent;
    generate: GleanEvent;
    keyPointsToggle: GleanEvent;
    labsCheckbox: GleanEvent;
    start: GleanEvent;
  }

  browserLaunchedToHandle: {
    systemNotification: GleanEvent;
  }

  backgroundUpdate: {
    reasonsToNotUpdate: GleanStringList;
    timeLastUpdateScheduled: GleanDatetime;
    automaticRestartAttempted: GleanBoolean;
    automaticRestartSuccess: GleanBoolean;
    clientId: GleanUuid;
    exitCodeException: GleanBoolean;
    exitCodeSuccess: GleanBoolean;
    finalState: GleanString;
    reasons: GleanStringList;
    states: GleanStringList;
    targetingEnvCurrentDate: GleanDatetime;
    targetingEnvFirefoxVersion: GleanQuantity;
    targetingEnvProfileAge: GleanDatetime;
    targetingException: GleanBoolean;
    targetingExists: GleanBoolean;
    targetingVersion: GleanQuantity;
  }

  startMenu: {
    manuallyUnpinnedSinceLastLaunch: GleanEvent;
  }

  sslkeylogging: {
    enabled: GleanBoolean;
  }

  launchOnLogin: {
    lastProfileDisableStartup: GleanEvent;
  }

  upgradeDialog: {
    triggerReason: GleanEvent;
  }

  browserStartup: {
    abouthomeCacheResult: GleanQuantity;
    abouthomeCacheShutdownwrite: GleanBoolean;
    kioskMode: GleanBoolean;
  }

  datasanitization: {
    privacySanitizeSanitizeOnShutdown: GleanBoolean;
    privacyClearOnShutdownCookies: GleanBoolean;
    privacyClearOnShutdownHistory: GleanBoolean;
    privacyClearOnShutdownFormdata: GleanBoolean;
    privacyClearOnShutdownDownloads: GleanBoolean;
    privacyClearOnShutdownCache: GleanBoolean;
    privacyClearOnShutdownSessions: GleanBoolean;
    privacyClearOnShutdownOfflineApps: GleanBoolean;
    privacyClearOnShutdownSiteSettings: GleanBoolean;
    privacyClearOnShutdownOpenWindows: GleanBoolean;
    sessionPermissionExceptions: GleanQuantity;
  }

  startup: {
    isCold: GleanBoolean;
    secondsSinceLastOsRestart: GleanQuantity;
    profileSelectionReason: GleanString;
    profileDatabaseVersion: GleanString;
    profileCount: GleanQuantity;
  }

  osEnvironment: {
    launchMethod: GleanString;
    launchedToHandle: Record<string, GleanCounter>;
    invokedToHandle: Record<string, GleanCounter>;
    isDefaultHandler: Record<string, GleanBoolean>;
    isKeptInDock: GleanBoolean;
    isTaskbarPinned: GleanBoolean;
    isTaskbarPinnedPrivate: GleanBoolean;
    allowedAppSources: GleanString;
    isAdminWithoutUac: GleanBoolean;
  }

  security: {
    httpsOnlyModeEnabled: GleanQuantity;
    httpsOnlyModeEnabledPbm: GleanQuantity;
    globalPrivacyControlEnabled: GleanQuantity;
    fissionPrincipals: GleanEvent;
    shadowedHtmlDocumentPropertyAccess: GleanEvent;
    unexpectedLoad: GleanEvent;
    evalUsageSystemContext: GleanEvent;
    cspViolationInternalPage: GleanEvent;
    evalUsageParentProcess: GleanEvent;
    javascriptLoadParentProcess: GleanEvent;
    httpsOnlyModeUpgradeTime: Record<string, GleanTimingDistribution>;
    referrerPolicyCount: GleanCustomDistribution;
    prefUsageContentProcess: GleanEvent;
    clientAuthCertUsage: Record<string, GleanCounter>;
    addonSignatureVerificationStatus: GleanCustomDistribution;
    contentSignatureVerificationStatus: GleanCustomDistribution;
    ntlmModuleUsed: GleanCustomDistribution;
  }

  primaryPassword: {
    enabled: GleanBoolean;
  }

  browser: {
    isUserDefault: Record<string, GleanCounter>;
    isUserDefaultError: Record<string, GleanCounter>;
    setDefaultDialogPromptRawcount: GleanCustomDistribution;
    setDefaultAlwaysCheck: Record<string, GleanCounter>;
    setDefaultResult: GleanCustomDistribution;
    setDefaultError: Record<string, GleanCounter>;
    setDefaultPdfHandlerUserChoiceResult: Record<string, GleanCounter>;
    setDefaultUserChoiceResult: Record<string, GleanCounter>;
    attributionErrors: Record<string, GleanCounter>;
    defaultAtLaunch: GleanBoolean;
  }

  browserMigration: {
    matchedExtensions: GleanStringList;
    unmatchedExtensions: GleanStringList;
    openedWizard: GleanEvent;
    noBrowsersFoundWizard: GleanEvent;
    browserSelectedWizard: GleanEvent;
    profileSelectedWizard: GleanEvent;
    resourcesSelectedWizard: GleanEvent;
    linuxPermsWizard: GleanEvent;
    safariPermsWizard: GleanEvent;
    safariPasswordFileWizard: GleanEvent;
    chromePasswordFileWizard: GleanEvent;
    migrationStartedWizard: GleanEvent;
    migrationFinishedWizard: GleanEvent;
    entryPointCategorical: Record<string, GleanCounter>;
    sourceBrowser: GleanCustomDistribution;
    errors: Record<string, GleanCustomDistribution>;
    usage: Record<string, GleanCustomDistribution>;
    bookmarksQuantity: Record<string, GleanCustomDistribution>;
    historyQuantity: Record<string, GleanCustomDistribution>;
    loginsQuantity: Record<string, GleanCustomDistribution>;
    cardsQuantity: Record<string, GleanCustomDistribution>;
    extensionsQuantity: Record<string, GleanCustomDistribution>;
  }

  migration: {
    uninstallerProfileRefresh: GleanBoolean;
    discoveredMigrators: Record<string, GleanCounter>;
    timeToProduceMigratorList: GleanTimespan;
  }

  newtab: {
    locale: GleanString;
    newtabCategory: GleanString;
    homepageCategory: GleanString;
    opened: GleanEvent;
    closed: GleanEvent;
    blockedSponsors: GleanStringList;
    sovAllocation: GleanStringList;
    tooltipClick: GleanEvent;
    topicSelectionOpen: GleanEvent;
    topicSelectionDismiss: GleanEvent;
    topicSelectionTopicsSaved: GleanEvent;
    selectedTopics: GleanStringList;
    wallpaperClick: GleanEvent;
    wallpaperHighlightCtaClick: GleanEvent;
    wallpaperHighlightDismissed: GleanEvent;
    wallpaperCategoryClick: GleanEvent;
    weatherChangeDisplay: GleanEvent;
    weatherEnabled: GleanBoolean;
    weatherOpenProviderUrl: GleanEvent;
    weatherImpression: GleanEvent;
    weatherLoadError: GleanEvent;
    weatherLocationSelected: GleanEvent;
    fakespotDismiss: GleanEvent;
    fakespotAboutClick: GleanEvent;
    fakespotClick: GleanEvent;
    fakespotProductImpression: GleanEvent;
    fakespotCtaClick: GleanEvent;
    fakespotCategory: GleanEvent;
    sectionsImpression: GleanEvent;
    sectionsFollowSection: GleanEvent;
    sectionsUnfollowSection: GleanEvent;
    sectionsBlockSection: GleanEvent;
    sectionsUnblockSection: GleanEvent;
    inlineSelectionImpression: GleanEvent;
    inlineSelectionClick: GleanEvent;
    abouthomeCacheConstruction: GleanTimingDistribution;
    reportContentOpen: GleanEvent;
    reportContentSubmit: GleanEvent;
    metricRegistered: Record<string, GleanBoolean>;
    pingRegistered: Record<string, GleanBoolean>;
    activityStreamCtorSuccess: GleanBoolean;
    addonReadySuccess: GleanBoolean;
  }

  newtabSearch: {
    enabled: GleanBoolean;
    issued: GleanEvent;
  }

  newtabHandoffPreference: {
    enabled: GleanBoolean;
  }

  topsites: {
    enabled: GleanBoolean;
    sponsoredEnabled: GleanBoolean;
    impression: GleanEvent;
    click: GleanEvent;
    showPrivacyClick: GleanEvent;
    dismiss: GleanEvent;
    prefChanged: GleanEvent;
    rows: GleanQuantity;
    sponsoredTilesConfigured: GleanQuantity;
    sponsoredTilesReceived: GleanText;
  }

  pocket: {
    isSignedIn: GleanBoolean;
    enabled: GleanBoolean;
    sponsoredStoriesEnabled: GleanBoolean;
    impression: GleanEvent;
    click: GleanEvent;
    dismiss: GleanEvent;
    save: GleanEvent;
    topicClick: GleanEvent;
    shim: GleanText;
    fetchTimestamp: GleanDatetime;
    newtabCreationTimestamp: GleanDatetime;
    thumbVotingInteraction: GleanEvent;
  }

  newtabContent: {
    experimentName: GleanString;
    experimentBranch: GleanString;
    inferredInterests: GleanString;
    coarseOs: GleanString;
    utcOffset: GleanQuantity;
    country: GleanString;
    surfaceId: GleanString;
    followedSections: GleanStringList;
    impression: GleanEvent;
    click: GleanEvent;
    dismiss: GleanEvent;
    thumbVotingInteraction: GleanEvent;
    sectionsImpression: GleanEvent;
    sectionsFollowSection: GleanEvent;
    sectionsUnfollowSection: GleanEvent;
    sectionsBlockSection: GleanEvent;
    sectionsUnblockSection: GleanEvent;
  }

  topSites: {
    pingType: GleanString;
    position: GleanQuantity;
    source: GleanString;
    tileId: GleanString;
    reportingUrl: GleanUrl;
    advertiser: GleanString;
    contextId: GleanUuid;
  }

  activityStream: {
    endSession: GleanEvent;
    eventArchiveFromPocket: GleanEvent;
    eventBlock: GleanEvent;
    eventBookmarkAdd: GleanEvent;
    eventBookmarkDelete: GleanEvent;
    eventClick: GleanEvent;
    eventClickPrivacyInfo: GleanEvent;
    eventCloseNewtabPrefs: GleanEvent;
    eventShowPersonalize: GleanEvent;
    eventHidePersonalize: GleanEvent;
    eventDelete: GleanEvent;
    eventDeleteFromPocket: GleanEvent;
    eventDeleteConfirm: GleanEvent;
    eventDialogCancel: GleanEvent;
    eventDialogOpen: GleanEvent;
    eventDrag: GleanEvent;
    eventDrop: GleanEvent;
    eventImpression: GleanEvent;
    eventMigrationCancel: GleanEvent;
    eventMigrationStart: GleanEvent;
    eventOpenNewtabPrefs: GleanEvent;
    eventOpenNewWindow: GleanEvent;
    eventOpenPrivateWindow: GleanEvent;
    eventPin: GleanEvent;
    eventPocketThumbsDown: GleanEvent;
    eventPocketThumbsUp: GleanEvent;
    eventFakespotClick: GleanEvent;
    eventFakespotCategory: GleanEvent;
    eventPrefChanged: GleanEvent;
    eventPreviewRequest: GleanEvent;
    eventSaveToPocket: GleanEvent;
    eventSearch: GleanEvent;
    eventSearchEditAdd: GleanEvent;
    eventSearchEditClose: GleanEvent;
    eventSearchEditDelete: GleanEvent;
    eventSearchHandoff: GleanEvent;
    eventShowPrivacyInfo: GleanEvent;
    eventSkippedSignin: GleanEvent;
    eventSubmitEmail: GleanEvent;
    eventDisclaimerAcked: GleanEvent;
    eventMenuAddSearch: GleanEvent;
    eventMenuAddTopsite: GleanEvent;
    eventMenuCollapse: GleanEvent;
    eventMenuExpand: GleanEvent;
    eventMenuManage: GleanEvent;
    eventMenuMoveDown: GleanEvent;
    eventMenuMoveUp: GleanEvent;
    eventMenuPrivacyNotice: GleanEvent;
    eventMenuRemove: GleanEvent;
    eventTopSitesEdit: GleanEvent;
    eventTopSitesEditClose: GleanEvent;
    eventTopsiteSponsorInfo: GleanEvent;
    eventUnpin: GleanEvent;
  }

  deletionRequest: {
    impressionId: GleanString;
    contextId: GleanString;
    syncDeviceId: GleanString;
  }

  contextualServicesTopsites: {
    impression: Record<string, GleanCounter>;
    click: Record<string, GleanCounter>;
  }

  library: {
    link: Record<string, GleanCounter>;
    opened: Record<string, GleanCounter>;
    search: Record<string, GleanCounter>;
    historySearchTime: GleanTimingDistribution;
    cumulativeHistorySearches: GleanCustomDistribution;
    cumulativeBookmarkSearches: GleanCustomDistribution;
  }

  historySidebar: {
    filterType: Record<string, GleanCounter>;
    cumulativeSearches: GleanCustomDistribution;
    cumulativeFilterCount: GleanCustomDistribution;
    lastvisitedTreeQueryTime: GleanTimingDistribution;
  }

  bookmarksSidebar: {
    cumulativeSearches: GleanCustomDistribution;
  }

  bookmarksToolbar: {
    init: GleanTimingDistribution;
  }

  pocketButton: {
    impressionId: GleanUuid;
    pocketLoggedInStatus: GleanBoolean;
    profileCreationDate: GleanQuantity;
    eventAction: GleanString;
    eventSource: GleanString;
    eventPosition: GleanQuantity;
    model: GleanString;
  }

  privacyUiFppClick: {
    checkbox: GleanEvent;
    menu: GleanEvent;
  }

  networkProxySettings: {
    proxyTypePreference: GleanEvent;
  }

  securityDohSettings: {
    modeChangedButton: GleanEvent;
    providerChoiceValue: GleanEvent;
  }

  intlUiBrowserLanguage: {
    manageMain: GleanEvent;
    searchDialog: GleanEvent;
    searchMain: GleanEvent;
    addDialog: GleanEvent;
    removeDialog: GleanEvent;
    reorderDialog: GleanEvent;
    reorderMain: GleanEvent;
    applyMain: GleanEvent;
    acceptDialog: GleanEvent;
    cancelDialog: GleanEvent;
    setFallbackDialog: GleanEvent;
  }

  aboutpreferences: {
    showInitial: GleanEvent;
    showClick: GleanEvent;
    showHash: GleanEvent;
  }

  privateBrowsingResetPbm: {
    confirmPanel: GleanEvent;
    resetAction: GleanEvent;
  }

  aboutprivatebrowsing: {
    clickInfoLink: GleanEvent;
    clickPromoLink: GleanEvent;
    clickDismissButton: GleanEvent;
  }

  profilesDefault: {
    updated: GleanEvent;
  }

  profilesDelete: {
    cancel: GleanEvent;
    confirm: GleanEvent;
    displayed: GleanEvent;
  }

  profilesExisting: {
    alert: GleanEvent;
    avatar: GleanEvent;
    closed: GleanEvent;
    deleted: GleanEvent;
    displayed: GleanEvent;
    learnMore: GleanEvent;
    name: GleanEvent;
    theme: GleanEvent;
  }

  profilesNew: {
    alert: GleanEvent;
    avatar: GleanEvent;
    closed: GleanEvent;
    deleted: GleanEvent;
    displayed: GleanEvent;
    learnMore: GleanEvent;
    name: GleanEvent;
    theme: GleanEvent;
  }

  profilesSelectorWindow: {
    launch: GleanEvent;
    showAtStartup: GleanEvent;
  }

  securityUiProtections: {
    showProtectionReport: GleanEvent;
    showVpnBanner: GleanEvent;
    closeProtectionReport: GleanEvent;
    clickLwOpenButton: GleanEvent;
    clickLwSyncLink: GleanEvent;
    clickLwAboutLink: GleanEvent;
    clickMtrAboutLink: GleanEvent;
    clickMtrReportLink: GleanEvent;
    clickMtrSignupButton: GleanEvent;
    clickTrackersAboutLink: GleanEvent;
    clickMobileAppLink: GleanEvent;
    clickSettingsLink: GleanEvent;
    clickVpnBannerLink: GleanEvent;
    clickVpnBannerClose: GleanEvent;
    clickVpnCardLink: GleanEvent;
    clickVpnAppLinkAndroid: GleanEvent;
    clickVpnAppLinkIos: GleanEvent;
  }

  protocolhandlerMailto: {
    promptClicked: Record<string, GleanCounter>;
    handlerPromptShown: Record<string, GleanCounter>;
    visit: GleanEvent;
  }

  screenshots: {
    downloadOverlayDownload: GleanEvent;
    downloadPreviewDownload: GleanEvent;
    copyOverlayCopy: GleanEvent;
    copyPreviewCopy: GleanEvent;
    selectedElement: GleanEvent;
    selectedRegionSelection: GleanEvent;
    selectedVisible: GleanEvent;
    selectedFullPage: GleanEvent;
    startedToolbarButton: GleanEvent;
    startedShortcut: GleanEvent;
    startedContextMenu: GleanEvent;
    startedQuickActions: GleanEvent;
    startedPreviewRetry: GleanEvent;
    startedOverlayRetry: GleanEvent;
    canceledToolbarButton: GleanEvent;
    canceledShortcut: GleanEvent;
    canceledContextMenu: GleanEvent;
    canceledQuickActions: GleanEvent;
    canceledPreviewCancel: GleanEvent;
    canceledOverlayCancel: GleanEvent;
    canceledEscape: GleanEvent;
    canceledNavigation: GleanEvent;
    failedScreenshotTooLarge: GleanEvent;
  }

  newtabSearchAd: {
    impression: GleanEvent;
    click: GleanEvent;
  }

  sap: {
    counts: GleanEvent;
    deprecatedCounts: Record<string, GleanCounter>;
    searchFormCounts: GleanEvent;
  }

  serp: {
    impression: GleanEvent;
    engagement: GleanEvent;
    adImpression: GleanEvent;
    abandonment: GleanEvent;
    categorizationDuration: GleanTimingDistribution;
    categorization: GleanEvent;
    adsBlockedCount: Record<string, GleanCounter>;
    experimentInfo: GleanObject;
    categorizationNoMapFound: GleanCounter;
  }

  searchWith: {
    reportingUrl: GleanUrl;
    contextId: GleanUuid;
  }

  browserEngagementNavigation: {
    urlbar: Record<string, GleanCounter>;
    urlbarHandoff: Record<string, GleanCounter>;
    urlbarPersisted: Record<string, GleanCounter>;
    urlbarSearchmode: Record<string, GleanCounter>;
    searchbar: Record<string, GleanCounter>;
    aboutHome: Record<string, GleanCounter>;
    aboutNewtab: Record<string, GleanCounter>;
    contextmenu: Record<string, GleanCounter>;
    webextension: Record<string, GleanCounter>;
  }

  browserSearchContent: {
    urlbar: Record<string, GleanCounter>;
    urlbarHandoff: Record<string, GleanCounter>;
    urlbarPersisted: Record<string, GleanCounter>;
    urlbarSearchmode: Record<string, GleanCounter>;
    searchbar: Record<string, GleanCounter>;
    aboutHome: Record<string, GleanCounter>;
    aboutNewtab: Record<string, GleanCounter>;
    contextmenu: Record<string, GleanCounter>;
    webextension: Record<string, GleanCounter>;
    system: Record<string, GleanCounter>;
    tabhistory: Record<string, GleanCounter>;
    reload: Record<string, GleanCounter>;
    unknown: Record<string, GleanCounter>;
  }

  browserSearchWithads: {
    urlbar: Record<string, GleanCounter>;
    urlbarHandoff: Record<string, GleanCounter>;
    urlbarPersisted: Record<string, GleanCounter>;
    urlbarSearchmode: Record<string, GleanCounter>;
    searchbar: Record<string, GleanCounter>;
    aboutHome: Record<string, GleanCounter>;
    aboutNewtab: Record<string, GleanCounter>;
    contextmenu: Record<string, GleanCounter>;
    webextension: Record<string, GleanCounter>;
    system: Record<string, GleanCounter>;
    tabhistory: Record<string, GleanCounter>;
    reload: Record<string, GleanCounter>;
    unknown: Record<string, GleanCounter>;
  }

  browserSearchAdclicks: {
    urlbar: Record<string, GleanCounter>;
    urlbarHandoff: Record<string, GleanCounter>;
    urlbarPersisted: Record<string, GleanCounter>;
    urlbarSearchmode: Record<string, GleanCounter>;
    searchbar: Record<string, GleanCounter>;
    aboutHome: Record<string, GleanCounter>;
    aboutNewtab: Record<string, GleanCounter>;
    contextmenu: Record<string, GleanCounter>;
    webextension: Record<string, GleanCounter>;
    system: Record<string, GleanCounter>;
    tabhistory: Record<string, GleanCounter>;
    reload: Record<string, GleanCounter>;
    unknown: Record<string, GleanCounter>;
  }

  urlbarSearchmode: {
    bookmarkmenu: Record<string, GleanCounter>;
    handoff: Record<string, GleanCounter>;
    keywordoffer: Record<string, GleanCounter>;
    oneoff: Record<string, GleanCounter>;
    searchbutton: Record<string, GleanCounter>;
    shortcut: Record<string, GleanCounter>;
    tabmenu: Record<string, GleanCounter>;
    tabtosearch: Record<string, GleanCounter>;
    tabtosearchOnboard: Record<string, GleanCounter>;
    topsitesNewtab: Record<string, GleanCounter>;
    topsitesUrlbar: Record<string, GleanCounter>;
    touchbar: Record<string, GleanCounter>;
    typed: Record<string, GleanCounter>;
    historymenu: Record<string, GleanCounter>;
    other: Record<string, GleanCounter>;
  }

  searchbar: {
    selectedResultMethod: Record<string, GleanCounter>;
  }

  sessionRestore: {
    backupCanBeLoadedSessionFile: GleanEvent;
    shutdownSuccessSessionStartup: GleanEvent;
    startupInitSession: GleanTimingDistribution;
    startupOnloadInitialWindow: GleanTimingDistribution;
    collectAllWindowsData: GleanTimingDistribution;
    collectData: GleanTimingDistribution;
    collectSessionHistory: GleanTimingDistribution;
    readFile: GleanTimingDistribution;
    writeFile: GleanTimingDistribution;
    fileSizeBytes: GleanMemoryDistribution;
    corruptFile: Record<string, GleanCounter>;
    allFilesCorrupt: Record<string, GleanCounter>;
    restoreWindow: GleanTimingDistribution;
    autoRestoreDurationUntilEagerTabsRestored: GleanTimingDistribution;
    manualRestoreDurationUntilEagerTabsRestored: GleanTimingDistribution;
    numberOfTabsRestored: GleanCustomDistribution;
    numberOfWindowsRestored: GleanCustomDistribution;
    numberOfEagerTabsRestored: GleanCustomDistribution;
    shutdownOk: Record<string, GleanCounter>;
  }

  sidebar: {
    expand: GleanEvent;
    resize: GleanEvent;
    displaySettings: GleanString;
    positionSettings: GleanString;
    tabsLayout: GleanString;
    width: GleanQuantity;
    search: Record<string, GleanCounter>;
    link: Record<string, GleanCounter>;
    chatbotIconClick: GleanEvent;
    historyIconClick: GleanEvent;
    syncedTabsIconClick: GleanEvent;
    bookmarksIconClick: GleanEvent;
    addonIconClick: GleanEvent;
    keyboardShortcut: GleanEvent;
  }

  history: {
    sidebarToggle: GleanEvent;
  }

  syncedTabs: {
    sidebarToggle: GleanEvent;
    clickFxaAvatarMenu: GleanEvent;
    clickFxaAppMenu: GleanEvent;
    clickSyncedTabsSidebar: GleanEvent;
  }

  bookmarks: {
    sidebarToggle: GleanEvent;
  }

  extension: {
    sidebarToggle: GleanEvent;
  }

  sidebarCustomize: {
    panelToggle: GleanEvent;
    iconClick: GleanEvent;
    chatbotEnabled: GleanEvent;
    syncedTabsEnabled: GleanEvent;
    historyEnabled: GleanEvent;
    bookmarksEnabled: GleanEvent;
    extensionsClicked: GleanEvent;
    sidebarDisplay: GleanEvent;
    sidebarPosition: GleanEvent;
    tabsLayout: GleanEvent;
    tabsDisplay: GleanEvent;
    firefoxSettingsClicked: GleanEvent;
    expandOnHoverEnabled: GleanEvent;
  }

  contextualManager: {
    sidebarToggle: GleanEvent;
    passwordsEnabled: GleanEvent;
    toolbarAction: GleanEvent;
    recordsUpdate: GleanEvent;
    recordsInteraction: GleanEvent;
    notificationShown: GleanEvent;
    notificationInteraction: GleanEvent;
  }

  browserUiInteraction: {
    allTabsPanelDragstartTabEventCount: GleanCounter;
    allTabsPanelEntrypoint: Record<string, GleanCounter>;
    textrecognitionError: GleanCounter;
    menuBar: Record<string, GleanCounter>;
    tabsBar: Record<string, GleanCounter>;
    verticalTabsContainer: Record<string, GleanCounter>;
    navBar: Record<string, GleanCounter>;
    bookmarksBar: Record<string, GleanCounter>;
    appMenu: Record<string, GleanCounter>;
    tabsContext: Record<string, GleanCounter>;
    tabsContextEntrypoint: Record<string, GleanCounter>;
    contentContext: Record<string, GleanCounter>;
    overflowMenu: Record<string, GleanCounter>;
    unifiedExtensionsArea: Record<string, GleanCounter>;
    pinnedOverflowMenu: Record<string, GleanCounter>;
    pageactionUrlbar: Record<string, GleanCounter>;
    pageactionPanel: Record<string, GleanCounter>;
    preferencesPaneHome: Record<string, GleanCounter>;
    preferencesPaneGeneral: Record<string, GleanCounter>;
    preferencesPanePrivacy: Record<string, GleanCounter>;
    preferencesPaneSearch: Record<string, GleanCounter>;
    preferencesPaneSearchResults: Record<string, GleanCounter>;
    preferencesPaneSync: Record<string, GleanCounter>;
    preferencesPaneContainers: Record<string, GleanCounter>;
    preferencesPaneExperimental: Record<string, GleanCounter>;
    preferencesPaneMoreFromMozilla: Record<string, GleanCounter>;
    preferencesPaneUnknown: Record<string, GleanCounter>;
    keyboard: Record<string, GleanCounter>;
  }

  tabgroup: {
    createGroup: GleanEvent;
    reopen: GleanEvent;
    addTab: GleanEvent;
    activeGroups: Record<string, GleanQuantity>;
    tabsPerActiveGroup: Record<string, GleanQuantity>;
    savedGroups: GleanQuantity;
    tabsPerSavedGroup: Record<string, GleanQuantity>;
    tabCountInGroups: Record<string, GleanQuantity>;
    save: GleanEvent;
    delete: GleanEvent;
    ungroup: GleanEvent;
    tabInteractions: Record<string, GleanCounter>;
    groupInteractions: Record<string, GleanCounter>;
    smartTabOptin: GleanEvent;
    smartTabTopic: GleanEvent;
    smartTabSuggest: GleanEvent;
    smartTab: GleanEvent;
    smartTabEnabled: GleanBoolean;
  }

  browserTabswitch: {
    update: GleanTimingDistribution;
    total: GleanTimingDistribution;
    spinnerVisible: GleanTimingDistribution;
    spinnerVisibleTrigger: Record<string, GleanCounter>;
  }

  browserTabclose: {
    timeAnim: GleanTimingDistribution;
    timeNoAnim: GleanTimingDistribution;
    permitUnloadTime: GleanTimingDistribution;
  }

  textRecognition: {
    apiPerformance: GleanTimingDistribution;
    interactionTiming: GleanTimingDistribution;
    textLength: GleanCustomDistribution;
  }

  urlbar: {
    abandonment: GleanEvent;
    disable: GleanEvent;
    engagement: GleanEvent;
    fakespotEngagement: GleanEvent;
    exposure: GleanEvent;
    keywordExposure: GleanEvent;
    quickSuggestContextualOptIn: GleanEvent;
    prefMaxResults: GleanQuantity;
    prefSuggestDataCollection: GleanBoolean;
    prefSuggestNonsponsored: GleanBoolean;
    prefSuggestSponsored: GleanBoolean;
    prefSuggestTopsites: GleanBoolean;
    autofillDeletion: GleanCounter;
    autocompleteFirstResultTime: GleanTimingDistribution;
    autocompleteSixthResultTime: GleanTimingDistribution;
  }

  quickSuggest: {
    pingType: GleanString;
    position: GleanQuantity;
    suggestedIndex: GleanString;
    suggestedIndexRelativeToGroup: GleanBoolean;
    source: GleanString;
    matchType: GleanString;
    blockId: GleanString;
    improveSuggestExperience: GleanBoolean;
    advertiser: GleanString;
    requestId: GleanString;
    isClicked: GleanBoolean;
    reportingUrl: GleanUrl;
    contextId: GleanUuid;
    iabCategory: GleanString;
  }

  suggest: {
    ingestTime: Record<string, GleanTimingDistribution>;
    ingestDownloadTime: Record<string, GleanTimingDistribution>;
    queryTime: Record<string, GleanTimingDistribution>;
  }

  suggestRelevance: {
    status: Record<string, GleanCounter>;
    outcome: Record<string, GleanCounter>;
  }

  urlbarTrending: {
    block: GleanCounter;
  }

  urlbarPersistedsearchterms: {
    revertByPopupCount: GleanCounter;
    viewCount: GleanCounter;
  }

  urlbarZeroprefix: {
    abandonment: GleanCounter;
    engagement: GleanCounter;
    exposure: GleanCounter;
  }

  urlbarQuickaction: {
    picked: Record<string, GleanCounter>;
  }

  urlbarUnifiedsearchbutton: {
    opened: GleanCounter;
    picked: Record<string, GleanCounter>;
  }

  addonsSearchDetection: {
    etldChangeWebrequest: GleanEvent;
    etldChangeOther: GleanEvent;
  }

  installationFirstSeen: {
    failureReason: GleanString;
    installerType: GleanString;
    version: GleanString;
    adminUser: GleanBoolean;
    installExisted: GleanBoolean;
    profdirExisted: GleanBoolean;
    otherInst: GleanBoolean;
    otherMsixInst: GleanBoolean;
    silent: GleanBoolean;
    fromMsi: GleanBoolean;
    defaultPath: GleanBoolean;
  }

  performanceInteraction: {
    tabSwitchComposite: GleanTimingDistribution;
    keypressPresentLatency: GleanTimingDistribution;
    mouseupClickPresentLatency: GleanTimingDistribution;
  }

  browserUsage: {
    interaction: GleanEvent;
  }

  browserUi: {
    toolbarWidgets: GleanObject;
    mirrorForToolbarWidgets: Record<string, GleanBoolean>;
    customizedWidgets: Record<string, GleanCounter>;
  }

  homepage: {
    preferenceIgnore: GleanEvent;
  }

  installation: {
    firstSeenFull: GleanEvent;
    firstSeenStub: GleanEvent;
    firstSeenMsix: GleanEvent;
  }

  partnerLink: {
    clickNewtab: GleanEvent;
    clickUrlbar: GleanEvent;
    attributionSuccess: GleanEvent;
    attributionFailure: GleanEvent;
    attributionAbort: GleanEvent;
  }

  timestamps: {
    aboutHomeTopsitesFirstPaint: GleanQuantity;
    firstPaint: GleanQuantity;
    firstPaintTwo: GleanQuantity;
  }

  browserSanitizer: {
    total: GleanTimingDistribution;
    cache: GleanTimingDistribution;
    cookies: GleanTimingDistribution;
    history: GleanTimingDistribution;
    formdata: GleanTimingDistribution;
    downloads: GleanTimingDistribution;
    sessions: GleanTimingDistribution;
    sitesettings: GleanTimingDistribution;
    openwindows: GleanTimingDistribution;
  }

  browserContentCrash: {
    dumpUnavailable: GleanCounter;
    notSubmitted: GleanCounter;
  }

  linkIconSizesAttr: {
    usage: GleanCustomDistribution;
    dimension: GleanCustomDistribution;
  }

  contextualServices: {
    contextId: GleanUuid;
  }

  devtoolsAccessibility: {
    nodeInspectedCount: GleanCounter;
    selectAccessibleForNode: Record<string, GleanCounter>;
    accessibleContextMenuOpened: GleanCounter;
    accessibleContextMenuItemActivated: Record<string, GleanCounter>;
    auditActivated: Record<string, GleanCounter>;
    simulationActivated: Record<string, GleanCounter>;
    openedCount: GleanCounter;
    pickerUsedCount: GleanCounter;
  }

  devtools: {
    currentTheme: Record<string, GleanCounter>;
    coldToolboxOpenDelay: Record<string, GleanTimingDistribution>;
    warmToolboxOpenDelay: Record<string, GleanTimingDistribution>;
    toolboxPageReloadDelay: Record<string, GleanTimingDistribution>;
    toolboxHost: GleanCustomDistribution;
    toolboxOpenedCount: GleanCounter;
    optionsOpenedCount: GleanCounter;
    webconsoleOpenedCount: GleanCounter;
    browserconsoleOpenedCount: GleanCounter;
    inspectorOpenedCount: GleanCounter;
    ruleviewOpenedCount: GleanCounter;
    computedviewOpenedCount: GleanCounter;
    layoutviewOpenedCount: GleanCounter;
    fontinspectorOpenedCount: GleanCounter;
    animationinspectorOpenedCount: GleanCounter;
    jsdebuggerOpenedCount: GleanCounter;
    jsbrowserdebuggerOpenedCount: GleanCounter;
    styleeditorOpenedCount: GleanCounter;
    jsprofilerOpenedCount: GleanCounter;
    memoryOpenedCount: GleanCounter;
    netmonitorOpenedCount: GleanCounter;
    storageOpenedCount: GleanCounter;
    domOpenedCount: GleanCounter;
    responsiveOpenedCount: GleanCounter;
    eyedropperOpenedCount: GleanCounter;
    menuEyedropperOpenedCount: GleanCounter;
    pickerEyedropperOpenedCount: GleanCounter;
    aboutdebuggingOpenedCount: GleanCounter;
    compatibilityviewOpenedCount: GleanCounter;
    customOpenedCount: GleanCounter;
    accessibilityTimeActive: GleanTimingDistribution;
    accessibilityPickerTimeActive: GleanTimingDistribution;
    accessibilityServiceTimeActive: GleanTimingDistribution;
    flexboxHighlighterTimeActive: GleanTimingDistribution;
    gridHighlighterTimeActive: GleanTimingDistribution;
    toolboxTimeActive: GleanTimingDistribution;
    optionsTimeActive: GleanTimingDistribution;
    webconsoleTimeActive: GleanTimingDistribution;
    browserconsoleTimeActive: GleanTimingDistribution;
    inspectorTimeActive: GleanTimingDistribution;
    ruleviewTimeActive: GleanTimingDistribution;
    changesviewTimeActive: GleanTimingDistribution;
    computedviewTimeActive: GleanTimingDistribution;
    layoutviewTimeActive: GleanTimingDistribution;
    fontinspectorTimeActive: GleanTimingDistribution;
    animationinspectorTimeActive: GleanTimingDistribution;
    jsdebuggerTimeActive: GleanTimingDistribution;
    jsbrowserdebuggerTimeActive: GleanTimingDistribution;
    styleeditorTimeActive: GleanTimingDistribution;
    jsprofilerTimeActive: GleanTimingDistribution;
    memoryTimeActive: GleanTimingDistribution;
    netmonitorTimeActive: GleanTimingDistribution;
    storageTimeActive: GleanTimingDistribution;
    domTimeActive: GleanTimingDistribution;
    responsiveTimeActive: GleanTimingDistribution;
    aboutdebuggingTimeActive: GleanTimingDistribution;
    compatibilityviewTimeActive: GleanTimingDistribution;
    customTimeActive: GleanTimingDistribution;
    entryPoint: Record<string, GleanCounter>;
    saveHeapSnapshot: GleanTimingDistribution;
    readHeapSnapshot: GleanTimingDistribution;
    heapSnapshotNodeCount: GleanCustomDistribution;
    heapSnapshotEdgeCount: GleanCustomDistribution;
  }

  devtoolsTool: {
    registered: Record<string, GleanBoolean>;
  }

  devtoolsToolbox: {
    tabsReordered: Record<string, GleanCounter>;
  }

  devtoolsInspector: {
    threePaneEnabled: Record<string, GleanCounter>;
    nodeSelectionCount: GleanCounter;
    newRootToReloadDelay: GleanTimingDistribution;
    numberOfCssGridsInAPage: GleanCustomDistribution;
    fonteditorFontTypeDisplayed: Record<string, GleanCounter>;
  }

  devtoolsLayoutFlexboxhighlighter: {
    opened: GleanCounter;
  }

  devtoolsMarkupFlexboxhighlighter: {
    opened: GleanCounter;
  }

  devtoolsRulesFlexboxhighlighter: {
    opened: GleanCounter;
  }

  devtoolsMarkupGridinspector: {
    opened: GleanCounter;
  }

  devtoolsRulesGridinspector: {
    opened: GleanCounter;
  }

  devtoolsGridGridinspector: {
    opened: GleanCounter;
  }

  devtoolsShadowdom: {
    shadowRootDisplayed: GleanBoolean;
    shadowRootExpanded: GleanBoolean;
    revealLinkClicked: GleanBoolean;
  }

  devtoolsTooltip: {
    shown: Record<string, GleanCounter>;
  }

  devtoolsMarkupScrollableBadge: {
    clicked: GleanCounter;
  }

  devtoolsResponsive: {
    openTrigger: Record<string, GleanCounter>;
    toolboxOpenedFirst: GleanCounter;
  }

  devtoolsMain: {
    activateResponsiveDesign: GleanEvent;
    activateSplitConsole: GleanEvent;
    addBreakpointDebugger: GleanEvent;
    blackboxDebugger: GleanEvent;
    closeTools: GleanEvent;
    closeAdbgAboutdebugging: GleanEvent;
    connectionAttemptAboutdebugging: GleanEvent;
    continueDebugger: GleanEvent;
    deactivateResponsiveDesign: GleanEvent;
    deactivateSplitConsole: GleanEvent;
    deviceAddedAboutdebugging: GleanEvent;
    deviceRemovedAboutdebugging: GleanEvent;
    editHtmlInspector: GleanEvent;
    editResendNetmonitor: GleanEvent;
    editRuleRuleview: GleanEvent;
    enterAccessibility: GleanEvent;
    enterApplication: GleanEvent;
    enterDom: GleanEvent;
    enterInspector: GleanEvent;
    enterJsdebugger: GleanEvent;
    enterMemory: GleanEvent;
    enterNetmonitor: GleanEvent;
    enterOptions: GleanEvent;
    enterPerformance: GleanEvent;
    enterStorage: GleanEvent;
    enterStyleeditor: GleanEvent;
    enterWebconsole: GleanEvent;
    enterWhatsnew: GleanEvent;
    enterOther: GleanEvent;
    enterFakeTool4242: GleanEvent;
    enterTestBlankPanel: GleanEvent;
    enterTestTool: GleanEvent;
    enterTesttool1: GleanEvent;
    enterTestTool1072208: GleanEvent;
    enterTesttool2: GleanEvent;
    executeJsWebconsole: GleanEvent;
    reverseSearchWebconsole: GleanEvent;
    exitAccessibility: GleanEvent;
    exitApplication: GleanEvent;
    exitDom: GleanEvent;
    exitInspector: GleanEvent;
    exitJsdebugger: GleanEvent;
    exitMemory: GleanEvent;
    exitNetmonitor: GleanEvent;
    exitOptions: GleanEvent;
    exitPerformance: GleanEvent;
    exitStorage: GleanEvent;
    exitStyleeditor: GleanEvent;
    exitWebconsole: GleanEvent;
    exitWhatsnew: GleanEvent;
    exitOther: GleanEvent;
    exitFakeTool4242: GleanEvent;
    exitTestBlankPanel: GleanEvent;
    exitTestTool: GleanEvent;
    exitTesttool1: GleanEvent;
    exitTestTool1072208: GleanEvent;
    exitTesttool2: GleanEvent;
    filtersChangedNetmonitor: GleanEvent;
    filtersChangedWebconsole: GleanEvent;
    inspectAboutdebugging: GleanEvent;
    jumpToDefinitionWebconsole: GleanEvent;
    jumpToSourceWebconsole: GleanEvent;
    objectExpandedWebconsole: GleanEvent;
    openTools: GleanEvent;
    openAdbgAboutdebugging: GleanEvent;
    pauseOnExceptionsDebugger: GleanEvent;
    pauseDebugger: GleanEvent;
    persistChangedNetmonitor: GleanEvent;
    persistChangedWebconsole: GleanEvent;
    prettyPrintDebugger: GleanEvent;
    removeBreakpointDebugger: GleanEvent;
    runtimeAddedAboutdebugging: GleanEvent;
    runtimeConnectedAboutdebugging: GleanEvent;
    runtimeDisconnectedAboutdebugging: GleanEvent;
    runtimeRemovedAboutdebugging: GleanEvent;
    selectPageAboutdebugging: GleanEvent;
    selectPageApplication: GleanEvent;
    showProfilerAboutdebugging: GleanEvent;
    selectWsFrameNetmonitor: GleanEvent;
    sidepanelChangedInspector: GleanEvent;
    sidepanelChangedNetmonitor: GleanEvent;
    startWorkerApplication: GleanEvent;
    throttleChangedNetmonitor: GleanEvent;
    toolTimerAnimationinspector: GleanEvent;
    toolTimerCompatibilityview: GleanEvent;
    toolTimerComputedview: GleanEvent;
    toolTimerChangesview: GleanEvent;
    toolTimerFontinspector: GleanEvent;
    toolTimerLayoutview: GleanEvent;
    toolTimerRuleview: GleanEvent;
    unregisterWorkerApplication: GleanEvent;
    updateConnPromptAboutdebugging: GleanEvent;
  }

  devtoolsChangesview: {
    openedCount: GleanCounter;
  }

  performancePage: {
    totalContentPageLoad: GleanTimingDistribution;
    nonBlankPaint: GleanTimingDistribution;
  }

  bfcache: {
    combo: Record<string, GleanCounter>;
    pageRestored: Record<string, GleanCounter>;
  }

  useCounter: {
    contentDocumentsDestroyed: GleanCounter;
    topLevelContentDocumentsDestroyed: GleanCounter;
    dedicatedWorkersDestroyed: GleanCounter;
    sharedWorkersDestroyed: GleanCounter;
    serviceWorkersDestroyed: GleanCounter;
  }

  useCounterPage: {
    svgsvgelementGetelementbyid: GleanCounter;
    svgsvgelementCurrentscaleGetter: GleanCounter;
    svgsvgelementCurrentscaleSetter: GleanCounter;
    pushmanagerSubscribe: GleanCounter;
    pushsubscriptionUnsubscribe: GleanCounter;
    windowSidebarGetter: GleanCounter;
    windowSidebarSetter: GleanCounter;
    datatransferAddelement: GleanCounter;
    datatransferMozitemcountGetter: GleanCounter;
    datatransferMozitemcountSetter: GleanCounter;
    datatransferMozcursorGetter: GleanCounter;
    datatransferMozcursorSetter: GleanCounter;
    datatransferMoztypesat: GleanCounter;
    datatransferMozcleardataat: GleanCounter;
    datatransferMozsetdataat: GleanCounter;
    datatransferMozgetdataat: GleanCounter;
    datatransferMozusercancelledGetter: GleanCounter;
    datatransferMozusercancelledSetter: GleanCounter;
    datatransferMozsourcenodeGetter: GleanCounter;
    datatransferMozsourcenodeSetter: GleanCounter;
    jsAsmjs: GleanCounter;
    jsWasm: GleanCounter;
    jsWasmLegacyExceptions: GleanCounter;
    jsIsHtmlddaFuse: GleanCounter;
    jsOptimizeGetIteratorFuse: GleanCounter;
    jsOptimizeArraySpeciesFuse: GleanCounter;
    jsOptimizePromiseLookupFuse: GleanCounter;
    jsThenable: GleanCounter;
    jsThenableProto: GleanCounter;
    jsThenableStandardProto: GleanCounter;
    jsThenableObjectProto: GleanCounter;
    jsLegacyLangSubtag: GleanCounter;
    jsIcStubTooLarge: GleanCounter;
    jsIcStubOom: GleanCounter;
    jsErrorstackGetter: GleanCounter;
    jsErrorstackGetterNoErrordata: GleanCounter;
    jsErrorstackSetter: GleanCounter;
    jsErrorstackSetterNonstring: GleanCounter;
    jsErrorstackSetterNoErrordata: GleanCounter;
    jsDateparse: GleanCounter;
    jsDateparseImplDef: GleanCounter;
    jsRegexpSymbolProtocolOnPrimitive: GleanCounter;
    jsLargeOomReported: GleanCounter;
    jsSmallOomReported: GleanCounter;
    jsLargeOomRecovered: GleanCounter;
    jsSmallOomRecovered: GleanCounter;
    consoleAssert: GleanCounter;
    consoleClear: GleanCounter;
    consoleCount: GleanCounter;
    consoleCountreset: GleanCounter;
    consoleDebug: GleanCounter;
    consoleError: GleanCounter;
    consoleInfo: GleanCounter;
    consoleLog: GleanCounter;
    consoleTable: GleanCounter;
    consoleTrace: GleanCounter;
    consoleWarn: GleanCounter;
    consoleDir: GleanCounter;
    consoleDirxml: GleanCounter;
    consoleGroup: GleanCounter;
    consoleGroupcollapsed: GleanCounter;
    consoleGroupend: GleanCounter;
    consoleTime: GleanCounter;
    consoleTimelog: GleanCounter;
    consoleTimeend: GleanCounter;
    consoleException: GleanCounter;
    consoleTimestamp: GleanCounter;
    consoleProfile: GleanCounter;
    consoleProfileend: GleanCounter;
    cookiestoreGet: GleanCounter;
    cookiestoreGetall: GleanCounter;
    cookiestoreSet: GleanCounter;
    cookiestoreDelete: GleanCounter;
    documentOpen: GleanCounter;
    htmldocumentNamedGetterHit: GleanCounter;
    filteredCrossOriginIframe: GleanCounter;
    customelementregistryDefine: GleanCounter;
    customizedBuiltin: GleanCounter;
    xslstylesheet: GleanCounter;
    xsltprocessorConstructor: GleanCounter;
    elementAttachshadow: GleanCounter;
    elementSetcapture: GleanCounter;
    elementReleasecapture: GleanCounter;
    elementSetpointercapture: GleanCounter;
    elementReleasepointercapture: GleanCounter;
    mediadevicesEnumeratedevices: GleanCounter;
    enumerateDevicesInsec: GleanCounter;
    enumerateDevicesUnfocused: GleanCounter;
    mediadevicesGetusermedia: GleanCounter;
    navigatorMozgetusermedia: GleanCounter;
    getUserMediaUnfocused: GleanCounter;
    getUserMediaInsec: GleanCounter;
    mediadevicesGetdisplaymedia: GleanCounter;
    mlsStatedelete: GleanCounter;
    mlsStatedeletegroup: GleanCounter;
    mlsGeneratesignaturekeypair: GleanCounter;
    mlsGeneratecredentialbasic: GleanCounter;
    mlsGeneratekeypackage: GleanCounter;
    mlsGroupcreate: GleanCounter;
    mlsGroupjoin: GleanCounter;
    mlsGroupadd: GleanCounter;
    mlsGroupproposeadd: GleanCounter;
    mlsGroupremove: GleanCounter;
    mlsGroupproposeremove: GleanCounter;
    mlsGroupclose: GleanCounter;
    mlsGroupmembers: GleanCounter;
    mlsReceive: GleanCounter;
    mlsSend: GleanCounter;
    mlsDeriveexporter: GleanCounter;
    documentMozsetimageelement: GleanCounter;
    ondommousescroll: GleanCounter;
    onmozmousepixelscroll: GleanCounter;
    percentageStrokeWidthInSvg: GleanCounter;
    percentageStrokeWidthInSvgtext: GleanCounter;
    htmldocumentCaretrangefrompoint: GleanCounter;
    htmldocumentExitpictureinpicture: GleanCounter;
    htmldocumentFeaturepolicy: GleanCounter;
    htmldocumentOnbeforecopy: GleanCounter;
    htmldocumentOnbeforecut: GleanCounter;
    htmldocumentOnbeforepaste: GleanCounter;
    htmldocumentOncancel: GleanCounter;
    htmldocumentOnfreeze: GleanCounter;
    htmldocumentOnmousewheel: GleanCounter;
    htmldocumentOnresume: GleanCounter;
    htmldocumentOnsearch: GleanCounter;
    htmldocumentOnwebkitfullscreenchange: GleanCounter;
    htmldocumentOnwebkitfullscreenerror: GleanCounter;
    htmldocumentPictureinpictureelement: GleanCounter;
    htmldocumentPictureinpictureenabled: GleanCounter;
    htmldocumentRegisterelement: GleanCounter;
    htmldocumentWasdiscarded: GleanCounter;
    htmldocumentWebkitcancelfullscreen: GleanCounter;
    htmldocumentWebkitcurrentfullscreenelement: GleanCounter;
    htmldocumentWebkitexitfullscreen: GleanCounter;
    htmldocumentWebkitfullscreenelement: GleanCounter;
    htmldocumentWebkitfullscreenenabled: GleanCounter;
    htmldocumentWebkithidden: GleanCounter;
    htmldocumentWebkitisfullscreen: GleanCounter;
    htmldocumentWebkitvisibilitystate: GleanCounter;
    htmldocumentXmlencoding: GleanCounter;
    htmldocumentXmlstandalone: GleanCounter;
    htmldocumentXmlversion: GleanCounter;
    locationAncestororigins: GleanCounter;
    windowAbsoluteorientationsensor: GleanCounter;
    windowAccelerometer: GleanCounter;
    windowBackgroundfetchmanager: GleanCounter;
    windowBackgroundfetchrecord: GleanCounter;
    windowBackgroundfetchregistration: GleanCounter;
    windowBeforeinstallpromptevent: GleanCounter;
    windowBluetooth: GleanCounter;
    windowBluetoothcharacteristicproperties: GleanCounter;
    windowBluetoothdevice: GleanCounter;
    windowBluetoothremotegattcharacteristic: GleanCounter;
    windowBluetoothremotegattdescriptor: GleanCounter;
    windowBluetoothremotegattserver: GleanCounter;
    windowBluetoothremotegattservice: GleanCounter;
    windowBluetoothuuid: GleanCounter;
    windowCanvascapturemediastreamtrack: GleanCounter;
    windowChrome: GleanCounter;
    windowClipboarditem: GleanCounter;
    windowCssimagevalue: GleanCounter;
    windowCsskeywordvalue: GleanCounter;
    windowCssmathclamp: GleanCounter;
    windowCssmathinvert: GleanCounter;
    windowCssmathmax: GleanCounter;
    windowCssmathmin: GleanCounter;
    windowCssmathnegate: GleanCounter;
    windowCssmathproduct: GleanCounter;
    windowCssmathsum: GleanCounter;
    windowCssmathvalue: GleanCounter;
    windowCssmatrixcomponent: GleanCounter;
    windowCssnumericarray: GleanCounter;
    windowCssnumericvalue: GleanCounter;
    windowCssperspective: GleanCounter;
    windowCsspositionvalue: GleanCounter;
    windowCsspropertyrule: GleanCounter;
    windowCssrotate: GleanCounter;
    windowCssscale: GleanCounter;
    windowCssskew: GleanCounter;
    windowCssskewx: GleanCounter;
    windowCssskewy: GleanCounter;
    windowCssstylevalue: GleanCounter;
    windowCsstransformcomponent: GleanCounter;
    windowCsstransformvalue: GleanCounter;
    windowCsstranslate: GleanCounter;
    windowCssunitvalue: GleanCounter;
    windowCssunparsedvalue: GleanCounter;
    windowCssvariablereferencevalue: GleanCounter;
    windowDefaultstatus: GleanCounter;
    windowDevicemotioneventacceleration: GleanCounter;
    windowDevicemotioneventrotationrate: GleanCounter;
    windowDomerror: GleanCounter;
    windowEncodedvideochunk: GleanCounter;
    windowEnterpictureinpictureevent: GleanCounter;
    windowExternal: GleanCounter;
    windowFederatedcredential: GleanCounter;
    windowGyroscope: GleanCounter;
    windowHtmlcontentelement: GleanCounter;
    windowHtmlshadowelement: GleanCounter;
    windowImagecapture: GleanCounter;
    windowInputdevicecapabilities: GleanCounter;
    windowInputdeviceinfo: GleanCounter;
    windowKeyboard: GleanCounter;
    windowKeyboardlayoutmap: GleanCounter;
    windowLinearaccelerationsensor: GleanCounter;
    windowMediasettingsrange: GleanCounter;
    windowMidiaccess: GleanCounter;
    windowMidiconnectionevent: GleanCounter;
    windowMidiinput: GleanCounter;
    windowMidiinputmap: GleanCounter;
    windowMidimessageevent: GleanCounter;
    windowMidioutput: GleanCounter;
    windowMidioutputmap: GleanCounter;
    windowMidiport: GleanCounter;
    windowNetworkinformation: GleanCounter;
    windowOffscreenbuffering: GleanCounter;
    windowOnbeforeinstallprompt: GleanCounter;
    windowOncancel: GleanCounter;
    windowOnmousewheel: GleanCounter;
    windowOnorientationchange: GleanCounter;
    windowOnsearch: GleanCounter;
    windowOnselectionchange: GleanCounter;
    windowOpendatabase: GleanCounter;
    windowOrientation: GleanCounter;
    windowOrientationsensor: GleanCounter;
    windowOverconstrainederror: GleanCounter;
    windowPasswordcredential: GleanCounter;
    windowPaymentaddress: GleanCounter;
    windowPaymentinstruments: GleanCounter;
    windowPaymentmanager: GleanCounter;
    windowPaymentmethodchangeevent: GleanCounter;
    windowPaymentrequest: GleanCounter;
    windowPaymentrequestupdateevent: GleanCounter;
    windowPaymentresponse: GleanCounter;
    windowPerformancelongtasktiming: GleanCounter;
    windowPhotocapabilities: GleanCounter;
    windowPictureinpictureevent: GleanCounter;
    windowPictureinpicturewindow: GleanCounter;
    windowPresentation: GleanCounter;
    windowPresentationavailability: GleanCounter;
    windowPresentationconnection: GleanCounter;
    windowPresentationconnectionavailableevent: GleanCounter;
    windowPresentationconnectioncloseevent: GleanCounter;
    windowPresentationconnectionlist: GleanCounter;
    windowPresentationreceiver: GleanCounter;
    windowPresentationrequest: GleanCounter;
    windowRelativeorientationsensor: GleanCounter;
    windowRemoteplayback: GleanCounter;
    windowReport: GleanCounter;
    windowReportbody: GleanCounter;
    windowReportingobserver: GleanCounter;
    windowRtcerror: GleanCounter;
    windowRtcerrorevent: GleanCounter;
    windowRtcicetransport: GleanCounter;
    windowRtcpeerconnectioniceerrorevent: GleanCounter;
    windowSensor: GleanCounter;
    windowSensorerrorevent: GleanCounter;
    windowSpeechrecognitionalternative: GleanCounter;
    windowSpeechrecognitionresult: GleanCounter;
    windowSpeechrecognitionresultlist: GleanCounter;
    windowStylemedia: GleanCounter;
    windowStylepropertymap: GleanCounter;
    windowStylepropertymapreadonly: GleanCounter;
    windowSvgdiscardelement: GleanCounter;
    windowSyncmanager: GleanCounter;
    windowTaskattributiontiming: GleanCounter;
    windowTextevent: GleanCounter;
    windowTouch: GleanCounter;
    windowTouchevent: GleanCounter;
    windowTouchlist: GleanCounter;
    windowUsb: GleanCounter;
    windowUsbalternateinterface: GleanCounter;
    windowUsbconfiguration: GleanCounter;
    windowUsbconnectionevent: GleanCounter;
    windowUsbdevice: GleanCounter;
    windowUsbendpoint: GleanCounter;
    windowUsbinterface: GleanCounter;
    windowUsbintransferresult: GleanCounter;
    windowUsbisochronousintransferpacket: GleanCounter;
    windowUsbisochronousintransferresult: GleanCounter;
    windowUsbisochronousouttransferpacket: GleanCounter;
    windowUsbisochronousouttransferresult: GleanCounter;
    windowUsbouttransferresult: GleanCounter;
    windowUseractivation: GleanCounter;
    windowVideocolorspace: GleanCounter;
    windowVideodecoder: GleanCounter;
    windowVideoencoder: GleanCounter;
    windowVideoframe: GleanCounter;
    windowWakelock: GleanCounter;
    windowWakelocksentinel: GleanCounter;
    windowWebkitcancelanimationframe: GleanCounter;
    windowWebkitmediastream: GleanCounter;
    windowWebkitmutationobserver: GleanCounter;
    windowWebkitrequestanimationframe: GleanCounter;
    windowWebkitrequestfilesystem: GleanCounter;
    windowWebkitresolvelocalfilesystemurl: GleanCounter;
    windowWebkitrtcpeerconnection: GleanCounter;
    windowWebkitspeechgrammar: GleanCounter;
    windowWebkitspeechgrammarlist: GleanCounter;
    windowWebkitspeechrecognition: GleanCounter;
    windowWebkitspeechrecognitionerror: GleanCounter;
    windowWebkitspeechrecognitionevent: GleanCounter;
    windowWebkitstorageinfo: GleanCounter;
    documentExecCommandContentReadOnly: GleanCounter;
    domparserParsefromstring: GleanCounter;
    rangeCreatecontextualfragment: GleanCounter;
    documentQueryCommandStateOrValueContentReadOnly: GleanCounter;
    documentQueryCommandStateOrValueInsertBrOnReturn: GleanCounter;
    documentQueryCommandSupportedOrEnabledContentReadOnly: GleanCounter;
    documentQueryCommandSupportedOrEnabledInsertBrOnReturn: GleanCounter;
    animationCommitstyles: GleanCounter;
    commitStylesNonFillingFinalValue: GleanCounter;
    feBlend: GleanCounter;
    feColorMatrix: GleanCounter;
    feComponentTransfer: GleanCounter;
    feComposite: GleanCounter;
    feConvolveMatrix: GleanCounter;
    feDiffuseLighting: GleanCounter;
    feDisplacementMap: GleanCounter;
    feFlood: GleanCounter;
    feGaussianBlur: GleanCounter;
    feImage: GleanCounter;
    feMerge: GleanCounter;
    feMorphology: GleanCounter;
    feOffset: GleanCounter;
    feSpecularLighting: GleanCounter;
    feTile: GleanCounter;
    feTurbulence: GleanCounter;
    wrFilterFallback: GleanCounter;
    sanitizerConstructor: GleanCounter;
    sanitizerSanitize: GleanCounter;
    elementSethtml: GleanCounter;
    windowOpenEmptyUrl: GleanCounter;
    privateBrowsingIdbfactoryOpen: GleanCounter;
    privateBrowsingIdbfactoryDeleteDatabase: GleanCounter;
    privateBrowsingCachesMatch: GleanCounter;
    privateBrowsingCachesHas: GleanCounter;
    privateBrowsingCachesOpen: GleanCounter;
    privateBrowsingCachesDelete: GleanCounter;
    privateBrowsingCachesKeys: GleanCounter;
    privateBrowsingNavigatorServiceWorker: GleanCounter;
    youTubeFlashEmbed: GleanCounter;
    schedulerPosttask: GleanCounter;
    htmldialogelementShow: GleanCounter;
    mixedContentUpgradedImageSuccess: GleanCounter;
    mixedContentUpgradedImageFailure: GleanCounter;
    mixedContentUpgradedVideoSuccess: GleanCounter;
    mixedContentUpgradedVideoFailure: GleanCounter;
    mixedContentUpgradedAudioSuccess: GleanCounter;
    mixedContentUpgradedAudioFailure: GleanCounter;
    mixedContentNotUpgradedImageSuccess: GleanCounter;
    mixedContentNotUpgradedImageFailure: GleanCounter;
    mixedContentNotUpgradedVideoSuccess: GleanCounter;
    mixedContentNotUpgradedVideoFailure: GleanCounter;
    mixedContentNotUpgradedAudioSuccess: GleanCounter;
    mixedContentNotUpgradedAudioFailure: GleanCounter;
    componentsShimResolved: GleanCounter;
    sectioningH1WithNoFontSizeOrMargins: GleanCounter;
    textDirectivePages: GleanCounter;
    invalidTextDirectives: GleanCounter;
    textDirectiveNotCreated: GleanCounter;
    mathMlused: GleanCounter;
  }

  useCounterDoc: {
    svgsvgelementGetelementbyid: GleanCounter;
    svgsvgelementCurrentscaleGetter: GleanCounter;
    svgsvgelementCurrentscaleSetter: GleanCounter;
    pushmanagerSubscribe: GleanCounter;
    pushsubscriptionUnsubscribe: GleanCounter;
    windowSidebarGetter: GleanCounter;
    windowSidebarSetter: GleanCounter;
    datatransferAddelement: GleanCounter;
    datatransferMozitemcountGetter: GleanCounter;
    datatransferMozitemcountSetter: GleanCounter;
    datatransferMozcursorGetter: GleanCounter;
    datatransferMozcursorSetter: GleanCounter;
    datatransferMoztypesat: GleanCounter;
    datatransferMozcleardataat: GleanCounter;
    datatransferMozsetdataat: GleanCounter;
    datatransferMozgetdataat: GleanCounter;
    datatransferMozusercancelledGetter: GleanCounter;
    datatransferMozusercancelledSetter: GleanCounter;
    datatransferMozsourcenodeGetter: GleanCounter;
    datatransferMozsourcenodeSetter: GleanCounter;
    jsAsmjs: GleanCounter;
    jsWasm: GleanCounter;
    jsWasmLegacyExceptions: GleanCounter;
    jsIsHtmlddaFuse: GleanCounter;
    jsOptimizeGetIteratorFuse: GleanCounter;
    jsOptimizeArraySpeciesFuse: GleanCounter;
    jsOptimizePromiseLookupFuse: GleanCounter;
    jsThenable: GleanCounter;
    jsThenableProto: GleanCounter;
    jsThenableStandardProto: GleanCounter;
    jsThenableObjectProto: GleanCounter;
    jsLegacyLangSubtag: GleanCounter;
    jsIcStubTooLarge: GleanCounter;
    jsIcStubOom: GleanCounter;
    jsErrorstackGetter: GleanCounter;
    jsErrorstackGetterNoErrordata: GleanCounter;
    jsErrorstackSetter: GleanCounter;
    jsErrorstackSetterNonstring: GleanCounter;
    jsErrorstackSetterNoErrordata: GleanCounter;
    jsDateparse: GleanCounter;
    jsDateparseImplDef: GleanCounter;
    jsRegexpSymbolProtocolOnPrimitive: GleanCounter;
    jsLargeOomReported: GleanCounter;
    jsSmallOomReported: GleanCounter;
    jsLargeOomRecovered: GleanCounter;
    jsSmallOomRecovered: GleanCounter;
    consoleAssert: GleanCounter;
    consoleClear: GleanCounter;
    consoleCount: GleanCounter;
    consoleCountreset: GleanCounter;
    consoleDebug: GleanCounter;
    consoleError: GleanCounter;
    consoleInfo: GleanCounter;
    consoleLog: GleanCounter;
    consoleTable: GleanCounter;
    consoleTrace: GleanCounter;
    consoleWarn: GleanCounter;
    consoleDir: GleanCounter;
    consoleDirxml: GleanCounter;
    consoleGroup: GleanCounter;
    consoleGroupcollapsed: GleanCounter;
    consoleGroupend: GleanCounter;
    consoleTime: GleanCounter;
    consoleTimelog: GleanCounter;
    consoleTimeend: GleanCounter;
    consoleException: GleanCounter;
    consoleTimestamp: GleanCounter;
    consoleProfile: GleanCounter;
    consoleProfileend: GleanCounter;
    cookiestoreGet: GleanCounter;
    cookiestoreGetall: GleanCounter;
    cookiestoreSet: GleanCounter;
    cookiestoreDelete: GleanCounter;
    documentOpen: GleanCounter;
    htmldocumentNamedGetterHit: GleanCounter;
    filteredCrossOriginIframe: GleanCounter;
    customelementregistryDefine: GleanCounter;
    customizedBuiltin: GleanCounter;
    xslstylesheet: GleanCounter;
    xsltprocessorConstructor: GleanCounter;
    elementAttachshadow: GleanCounter;
    elementSetcapture: GleanCounter;
    elementReleasecapture: GleanCounter;
    elementSetpointercapture: GleanCounter;
    elementReleasepointercapture: GleanCounter;
    mediadevicesEnumeratedevices: GleanCounter;
    enumerateDevicesInsec: GleanCounter;
    enumerateDevicesUnfocused: GleanCounter;
    mediadevicesGetusermedia: GleanCounter;
    navigatorMozgetusermedia: GleanCounter;
    getUserMediaUnfocused: GleanCounter;
    getUserMediaInsec: GleanCounter;
    mediadevicesGetdisplaymedia: GleanCounter;
    mlsStatedelete: GleanCounter;
    mlsStatedeletegroup: GleanCounter;
    mlsGeneratesignaturekeypair: GleanCounter;
    mlsGeneratecredentialbasic: GleanCounter;
    mlsGeneratekeypackage: GleanCounter;
    mlsGroupcreate: GleanCounter;
    mlsGroupjoin: GleanCounter;
    mlsGroupadd: GleanCounter;
    mlsGroupproposeadd: GleanCounter;
    mlsGroupremove: GleanCounter;
    mlsGroupproposeremove: GleanCounter;
    mlsGroupclose: GleanCounter;
    mlsGroupmembers: GleanCounter;
    mlsReceive: GleanCounter;
    mlsSend: GleanCounter;
    mlsDeriveexporter: GleanCounter;
    documentMozsetimageelement: GleanCounter;
    ondommousescroll: GleanCounter;
    onmozmousepixelscroll: GleanCounter;
    percentageStrokeWidthInSvg: GleanCounter;
    percentageStrokeWidthInSvgtext: GleanCounter;
    htmldocumentCaretrangefrompoint: GleanCounter;
    htmldocumentExitpictureinpicture: GleanCounter;
    htmldocumentFeaturepolicy: GleanCounter;
    htmldocumentOnbeforecopy: GleanCounter;
    htmldocumentOnbeforecut: GleanCounter;
    htmldocumentOnbeforepaste: GleanCounter;
    htmldocumentOncancel: GleanCounter;
    htmldocumentOnfreeze: GleanCounter;
    htmldocumentOnmousewheel: GleanCounter;
    htmldocumentOnresume: GleanCounter;
    htmldocumentOnsearch: GleanCounter;
    htmldocumentOnwebkitfullscreenchange: GleanCounter;
    htmldocumentOnwebkitfullscreenerror: GleanCounter;
    htmldocumentPictureinpictureelement: GleanCounter;
    htmldocumentPictureinpictureenabled: GleanCounter;
    htmldocumentRegisterelement: GleanCounter;
    htmldocumentWasdiscarded: GleanCounter;
    htmldocumentWebkitcancelfullscreen: GleanCounter;
    htmldocumentWebkitcurrentfullscreenelement: GleanCounter;
    htmldocumentWebkitexitfullscreen: GleanCounter;
    htmldocumentWebkitfullscreenelement: GleanCounter;
    htmldocumentWebkitfullscreenenabled: GleanCounter;
    htmldocumentWebkithidden: GleanCounter;
    htmldocumentWebkitisfullscreen: GleanCounter;
    htmldocumentWebkitvisibilitystate: GleanCounter;
    htmldocumentXmlencoding: GleanCounter;
    htmldocumentXmlstandalone: GleanCounter;
    htmldocumentXmlversion: GleanCounter;
    locationAncestororigins: GleanCounter;
    windowAbsoluteorientationsensor: GleanCounter;
    windowAccelerometer: GleanCounter;
    windowBackgroundfetchmanager: GleanCounter;
    windowBackgroundfetchrecord: GleanCounter;
    windowBackgroundfetchregistration: GleanCounter;
    windowBeforeinstallpromptevent: GleanCounter;
    windowBluetooth: GleanCounter;
    windowBluetoothcharacteristicproperties: GleanCounter;
    windowBluetoothdevice: GleanCounter;
    windowBluetoothremotegattcharacteristic: GleanCounter;
    windowBluetoothremotegattdescriptor: GleanCounter;
    windowBluetoothremotegattserver: GleanCounter;
    windowBluetoothremotegattservice: GleanCounter;
    windowBluetoothuuid: GleanCounter;
    windowCanvascapturemediastreamtrack: GleanCounter;
    windowChrome: GleanCounter;
    windowClipboarditem: GleanCounter;
    windowCssimagevalue: GleanCounter;
    windowCsskeywordvalue: GleanCounter;
    windowCssmathclamp: GleanCounter;
    windowCssmathinvert: GleanCounter;
    windowCssmathmax: GleanCounter;
    windowCssmathmin: GleanCounter;
    windowCssmathnegate: GleanCounter;
    windowCssmathproduct: GleanCounter;
    windowCssmathsum: GleanCounter;
    windowCssmathvalue: GleanCounter;
    windowCssmatrixcomponent: GleanCounter;
    windowCssnumericarray: GleanCounter;
    windowCssnumericvalue: GleanCounter;
    windowCssperspective: GleanCounter;
    windowCsspositionvalue: GleanCounter;
    windowCsspropertyrule: GleanCounter;
    windowCssrotate: GleanCounter;
    windowCssscale: GleanCounter;
    windowCssskew: GleanCounter;
    windowCssskewx: GleanCounter;
    windowCssskewy: GleanCounter;
    windowCssstylevalue: GleanCounter;
    windowCsstransformcomponent: GleanCounter;
    windowCsstransformvalue: GleanCounter;
    windowCsstranslate: GleanCounter;
    windowCssunitvalue: GleanCounter;
    windowCssunparsedvalue: GleanCounter;
    windowCssvariablereferencevalue: GleanCounter;
    windowDefaultstatus: GleanCounter;
    windowDevicemotioneventacceleration: GleanCounter;
    windowDevicemotioneventrotationrate: GleanCounter;
    windowDomerror: GleanCounter;
    windowEncodedvideochunk: GleanCounter;
    windowEnterpictureinpictureevent: GleanCounter;
    windowExternal: GleanCounter;
    windowFederatedcredential: GleanCounter;
    windowGyroscope: GleanCounter;
    windowHtmlcontentelement: GleanCounter;
    windowHtmlshadowelement: GleanCounter;
    windowImagecapture: GleanCounter;
    windowInputdevicecapabilities: GleanCounter;
    windowInputdeviceinfo: GleanCounter;
    windowKeyboard: GleanCounter;
    windowKeyboardlayoutmap: GleanCounter;
    windowLinearaccelerationsensor: GleanCounter;
    windowMediasettingsrange: GleanCounter;
    windowMidiaccess: GleanCounter;
    windowMidiconnectionevent: GleanCounter;
    windowMidiinput: GleanCounter;
    windowMidiinputmap: GleanCounter;
    windowMidimessageevent: GleanCounter;
    windowMidioutput: GleanCounter;
    windowMidioutputmap: GleanCounter;
    windowMidiport: GleanCounter;
    windowNetworkinformation: GleanCounter;
    windowOffscreenbuffering: GleanCounter;
    windowOnbeforeinstallprompt: GleanCounter;
    windowOncancel: GleanCounter;
    windowOnmousewheel: GleanCounter;
    windowOnorientationchange: GleanCounter;
    windowOnsearch: GleanCounter;
    windowOnselectionchange: GleanCounter;
    windowOpendatabase: GleanCounter;
    windowOrientation: GleanCounter;
    windowOrientationsensor: GleanCounter;
    windowOverconstrainederror: GleanCounter;
    windowPasswordcredential: GleanCounter;
    windowPaymentaddress: GleanCounter;
    windowPaymentinstruments: GleanCounter;
    windowPaymentmanager: GleanCounter;
    windowPaymentmethodchangeevent: GleanCounter;
    windowPaymentrequest: GleanCounter;
    windowPaymentrequestupdateevent: GleanCounter;
    windowPaymentresponse: GleanCounter;
    windowPerformancelongtasktiming: GleanCounter;
    windowPhotocapabilities: GleanCounter;
    windowPictureinpictureevent: GleanCounter;
    windowPictureinpicturewindow: GleanCounter;
    windowPresentation: GleanCounter;
    windowPresentationavailability: GleanCounter;
    windowPresentationconnection: GleanCounter;
    windowPresentationconnectionavailableevent: GleanCounter;
    windowPresentationconnectioncloseevent: GleanCounter;
    windowPresentationconnectionlist: GleanCounter;
    windowPresentationreceiver: GleanCounter;
    windowPresentationrequest: GleanCounter;
    windowRelativeorientationsensor: GleanCounter;
    windowRemoteplayback: GleanCounter;
    windowReport: GleanCounter;
    windowReportbody: GleanCounter;
    windowReportingobserver: GleanCounter;
    windowRtcerror: GleanCounter;
    windowRtcerrorevent: GleanCounter;
    windowRtcicetransport: GleanCounter;
    windowRtcpeerconnectioniceerrorevent: GleanCounter;
    windowSensor: GleanCounter;
    windowSensorerrorevent: GleanCounter;
    windowSpeechrecognitionalternative: GleanCounter;
    windowSpeechrecognitionresult: GleanCounter;
    windowSpeechrecognitionresultlist: GleanCounter;
    windowStylemedia: GleanCounter;
    windowStylepropertymap: GleanCounter;
    windowStylepropertymapreadonly: GleanCounter;
    windowSvgdiscardelement: GleanCounter;
    windowSyncmanager: GleanCounter;
    windowTaskattributiontiming: GleanCounter;
    windowTextevent: GleanCounter;
    windowTouch: GleanCounter;
    windowTouchevent: GleanCounter;
    windowTouchlist: GleanCounter;
    windowUsb: GleanCounter;
    windowUsbalternateinterface: GleanCounter;
    windowUsbconfiguration: GleanCounter;
    windowUsbconnectionevent: GleanCounter;
    windowUsbdevice: GleanCounter;
    windowUsbendpoint: GleanCounter;
    windowUsbinterface: GleanCounter;
    windowUsbintransferresult: GleanCounter;
    windowUsbisochronousintransferpacket: GleanCounter;
    windowUsbisochronousintransferresult: GleanCounter;
    windowUsbisochronousouttransferpacket: GleanCounter;
    windowUsbisochronousouttransferresult: GleanCounter;
    windowUsbouttransferresult: GleanCounter;
    windowUseractivation: GleanCounter;
    windowVideocolorspace: GleanCounter;
    windowVideodecoder: GleanCounter;
    windowVideoencoder: GleanCounter;
    windowVideoframe: GleanCounter;
    windowWakelock: GleanCounter;
    windowWakelocksentinel: GleanCounter;
    windowWebkitcancelanimationframe: GleanCounter;
    windowWebkitmediastream: GleanCounter;
    windowWebkitmutationobserver: GleanCounter;
    windowWebkitrequestanimationframe: GleanCounter;
    windowWebkitrequestfilesystem: GleanCounter;
    windowWebkitresolvelocalfilesystemurl: GleanCounter;
    windowWebkitrtcpeerconnection: GleanCounter;
    windowWebkitspeechgrammar: GleanCounter;
    windowWebkitspeechgrammarlist: GleanCounter;
    windowWebkitspeechrecognition: GleanCounter;
    windowWebkitspeechrecognitionerror: GleanCounter;
    windowWebkitspeechrecognitionevent: GleanCounter;
    windowWebkitstorageinfo: GleanCounter;
    documentExecCommandContentReadOnly: GleanCounter;
    domparserParsefromstring: GleanCounter;
    rangeCreatecontextualfragment: GleanCounter;
    documentQueryCommandStateOrValueContentReadOnly: GleanCounter;
    documentQueryCommandStateOrValueInsertBrOnReturn: GleanCounter;
    documentQueryCommandSupportedOrEnabledContentReadOnly: GleanCounter;
    documentQueryCommandSupportedOrEnabledInsertBrOnReturn: GleanCounter;
    animationCommitstyles: GleanCounter;
    commitStylesNonFillingFinalValue: GleanCounter;
    feBlend: GleanCounter;
    feColorMatrix: GleanCounter;
    feComponentTransfer: GleanCounter;
    feComposite: GleanCounter;
    feConvolveMatrix: GleanCounter;
    feDiffuseLighting: GleanCounter;
    feDisplacementMap: GleanCounter;
    feFlood: GleanCounter;
    feGaussianBlur: GleanCounter;
    feImage: GleanCounter;
    feMerge: GleanCounter;
    feMorphology: GleanCounter;
    feOffset: GleanCounter;
    feSpecularLighting: GleanCounter;
    feTile: GleanCounter;
    feTurbulence: GleanCounter;
    wrFilterFallback: GleanCounter;
    sanitizerConstructor: GleanCounter;
    sanitizerSanitize: GleanCounter;
    elementSethtml: GleanCounter;
    windowOpenEmptyUrl: GleanCounter;
    privateBrowsingIdbfactoryOpen: GleanCounter;
    privateBrowsingIdbfactoryDeleteDatabase: GleanCounter;
    privateBrowsingCachesMatch: GleanCounter;
    privateBrowsingCachesHas: GleanCounter;
    privateBrowsingCachesOpen: GleanCounter;
    privateBrowsingCachesDelete: GleanCounter;
    privateBrowsingCachesKeys: GleanCounter;
    privateBrowsingNavigatorServiceWorker: GleanCounter;
    youTubeFlashEmbed: GleanCounter;
    schedulerPosttask: GleanCounter;
    htmldialogelementShow: GleanCounter;
    mixedContentUpgradedImageSuccess: GleanCounter;
    mixedContentUpgradedImageFailure: GleanCounter;
    mixedContentUpgradedVideoSuccess: GleanCounter;
    mixedContentUpgradedVideoFailure: GleanCounter;
    mixedContentUpgradedAudioSuccess: GleanCounter;
    mixedContentUpgradedAudioFailure: GleanCounter;
    mixedContentNotUpgradedImageSuccess: GleanCounter;
    mixedContentNotUpgradedImageFailure: GleanCounter;
    mixedContentNotUpgradedVideoSuccess: GleanCounter;
    mixedContentNotUpgradedVideoFailure: GleanCounter;
    mixedContentNotUpgradedAudioSuccess: GleanCounter;
    mixedContentNotUpgradedAudioFailure: GleanCounter;
    componentsShimResolved: GleanCounter;
    sectioningH1WithNoFontSizeOrMargins: GleanCounter;
    textDirectivePages: GleanCounter;
    invalidTextDirectives: GleanCounter;
    textDirectiveNotCreated: GleanCounter;
    mathMlused: GleanCounter;
  }

  useCounterWorkerDedicated: {
    pushmanagerSubscribe: GleanCounter;
    pushsubscriptionUnsubscribe: GleanCounter;
    consoleAssert: GleanCounter;
    consoleClear: GleanCounter;
    consoleCount: GleanCounter;
    consoleCountreset: GleanCounter;
    consoleDebug: GleanCounter;
    consoleError: GleanCounter;
    consoleInfo: GleanCounter;
    consoleLog: GleanCounter;
    consoleTable: GleanCounter;
    consoleTrace: GleanCounter;
    consoleWarn: GleanCounter;
    consoleDir: GleanCounter;
    consoleDirxml: GleanCounter;
    consoleGroup: GleanCounter;
    consoleGroupcollapsed: GleanCounter;
    consoleGroupend: GleanCounter;
    consoleTime: GleanCounter;
    consoleTimelog: GleanCounter;
    consoleTimeend: GleanCounter;
    consoleException: GleanCounter;
    consoleTimestamp: GleanCounter;
    consoleProfile: GleanCounter;
    consoleProfileend: GleanCounter;
    cookiestoreGet: GleanCounter;
    cookiestoreGetall: GleanCounter;
    cookiestoreSet: GleanCounter;
    cookiestoreDelete: GleanCounter;
    mlsStatedelete: GleanCounter;
    mlsStatedeletegroup: GleanCounter;
    mlsGeneratesignaturekeypair: GleanCounter;
    mlsGeneratecredentialbasic: GleanCounter;
    mlsGeneratekeypackage: GleanCounter;
    mlsGroupcreate: GleanCounter;
    mlsGroupjoin: GleanCounter;
    mlsGroupadd: GleanCounter;
    mlsGroupproposeadd: GleanCounter;
    mlsGroupremove: GleanCounter;
    mlsGroupproposeremove: GleanCounter;
    mlsGroupclose: GleanCounter;
    mlsGroupmembers: GleanCounter;
    mlsReceive: GleanCounter;
    mlsSend: GleanCounter;
    mlsDeriveexporter: GleanCounter;
    privateBrowsingIdbfactoryOpen: GleanCounter;
    privateBrowsingIdbfactoryDeleteDatabase: GleanCounter;
    privateBrowsingCachesMatch: GleanCounter;
    privateBrowsingCachesHas: GleanCounter;
    privateBrowsingCachesOpen: GleanCounter;
    privateBrowsingCachesDelete: GleanCounter;
    privateBrowsingCachesKeys: GleanCounter;
    schedulerPosttask: GleanCounter;
  }

  useCounterWorkerShared: {
    pushmanagerSubscribe: GleanCounter;
    pushsubscriptionUnsubscribe: GleanCounter;
    consoleAssert: GleanCounter;
    consoleClear: GleanCounter;
    consoleCount: GleanCounter;
    consoleCountreset: GleanCounter;
    consoleDebug: GleanCounter;
    consoleError: GleanCounter;
    consoleInfo: GleanCounter;
    consoleLog: GleanCounter;
    consoleTable: GleanCounter;
    consoleTrace: GleanCounter;
    consoleWarn: GleanCounter;
    consoleDir: GleanCounter;
    consoleDirxml: GleanCounter;
    consoleGroup: GleanCounter;
    consoleGroupcollapsed: GleanCounter;
    consoleGroupend: GleanCounter;
    consoleTime: GleanCounter;
    consoleTimelog: GleanCounter;
    consoleTimeend: GleanCounter;
    consoleException: GleanCounter;
    consoleTimestamp: GleanCounter;
    consoleProfile: GleanCounter;
    consoleProfileend: GleanCounter;
    cookiestoreGet: GleanCounter;
    cookiestoreGetall: GleanCounter;
    cookiestoreSet: GleanCounter;
    cookiestoreDelete: GleanCounter;
    mlsStatedelete: GleanCounter;
    mlsStatedeletegroup: GleanCounter;
    mlsGeneratesignaturekeypair: GleanCounter;
    mlsGeneratecredentialbasic: GleanCounter;
    mlsGeneratekeypackage: GleanCounter;
    mlsGroupcreate: GleanCounter;
    mlsGroupjoin: GleanCounter;
    mlsGroupadd: GleanCounter;
    mlsGroupproposeadd: GleanCounter;
    mlsGroupremove: GleanCounter;
    mlsGroupproposeremove: GleanCounter;
    mlsGroupclose: GleanCounter;
    mlsGroupmembers: GleanCounter;
    mlsReceive: GleanCounter;
    mlsSend: GleanCounter;
    mlsDeriveexporter: GleanCounter;
    privateBrowsingIdbfactoryOpen: GleanCounter;
    privateBrowsingIdbfactoryDeleteDatabase: GleanCounter;
    privateBrowsingCachesMatch: GleanCounter;
    privateBrowsingCachesHas: GleanCounter;
    privateBrowsingCachesOpen: GleanCounter;
    privateBrowsingCachesDelete: GleanCounter;
    privateBrowsingCachesKeys: GleanCounter;
    schedulerPosttask: GleanCounter;
  }

  useCounterWorkerService: {
    pushmanagerSubscribe: GleanCounter;
    pushsubscriptionUnsubscribe: GleanCounter;
    consoleAssert: GleanCounter;
    consoleClear: GleanCounter;
    consoleCount: GleanCounter;
    consoleCountreset: GleanCounter;
    consoleDebug: GleanCounter;
    consoleError: GleanCounter;
    consoleInfo: GleanCounter;
    consoleLog: GleanCounter;
    consoleTable: GleanCounter;
    consoleTrace: GleanCounter;
    consoleWarn: GleanCounter;
    consoleDir: GleanCounter;
    consoleDirxml: GleanCounter;
    consoleGroup: GleanCounter;
    consoleGroupcollapsed: GleanCounter;
    consoleGroupend: GleanCounter;
    consoleTime: GleanCounter;
    consoleTimelog: GleanCounter;
    consoleTimeend: GleanCounter;
    consoleException: GleanCounter;
    consoleTimestamp: GleanCounter;
    consoleProfile: GleanCounter;
    consoleProfileend: GleanCounter;
    cookiestoreGet: GleanCounter;
    cookiestoreGetall: GleanCounter;
    cookiestoreSet: GleanCounter;
    cookiestoreDelete: GleanCounter;
    mlsStatedelete: GleanCounter;
    mlsStatedeletegroup: GleanCounter;
    mlsGeneratesignaturekeypair: GleanCounter;
    mlsGeneratecredentialbasic: GleanCounter;
    mlsGeneratekeypackage: GleanCounter;
    mlsGroupcreate: GleanCounter;
    mlsGroupjoin: GleanCounter;
    mlsGroupadd: GleanCounter;
    mlsGroupproposeadd: GleanCounter;
    mlsGroupremove: GleanCounter;
    mlsGroupproposeremove: GleanCounter;
    mlsGroupclose: GleanCounter;
    mlsGroupmembers: GleanCounter;
    mlsReceive: GleanCounter;
    mlsSend: GleanCounter;
    mlsDeriveexporter: GleanCounter;
    privateBrowsingIdbfactoryOpen: GleanCounter;
    privateBrowsingIdbfactoryDeleteDatabase: GleanCounter;
    privateBrowsingCachesMatch: GleanCounter;
    privateBrowsingCachesHas: GleanCounter;
    privateBrowsingCachesOpen: GleanCounter;
    privateBrowsingCachesDelete: GleanCounter;
    privateBrowsingCachesKeys: GleanCounter;
    schedulerPosttask: GleanCounter;
  }

  useCounterDeprecatedOpsPage: {
    domsubtreeModified: GleanCounter;
    domnodeInserted: GleanCounter;
    domnodeRemoved: GleanCounter;
    domnodeRemovedFromDocument: GleanCounter;
    domnodeInsertedIntoDocument: GleanCounter;
    domattrModified: GleanCounter;
    domcharacterDataModified: GleanCounter;
    components: GleanCounter;
    nodeIteratorDetach: GleanCounter;
    lenientThis: GleanCounter;
    useOfCaptureEvents: GleanCounter;
    useOfReleaseEvents: GleanCounter;
    syncXmlhttpRequestDeprecated: GleanCounter;
    windowCcOntrollers: GleanCounter;
    importXulintoContent: GleanCounter;
    installTriggerDeprecated: GleanCounter;
    installTriggerInstallDeprecated: GleanCounter;
    navigatorGetUserMedia: GleanCounter;
    webrtcDeprecatedPrefix: GleanCounter;
    rtcpeerConnectionGetStreams: GleanCounter;
    appCache: GleanCounter;
    lenientSetter: GleanCounter;
    imageBitmapRenderingContextTransferImageBitmap: GleanCounter;
    windowContentUntrusted: GleanCounter;
    motionEvent: GleanCounter;
    orientationEvent: GleanCounter;
    proximityEvent: GleanCounter;
    ambientLightEvent: GleanCounter;
    idbopenDboptionsStorageType: GleanCounter;
    domquadBoundsAttr: GleanCounter;
    deprecatedTestingInterface: GleanCounter;
    deprecatedTestingMethod: GleanCounter;
    deprecatedTestingAttribute: GleanCounter;
    createImageBitmapCanvasRenderingContext2D: GleanCounter;
    drawWindowCanvasRenderingContext2D: GleanCounter;
    mozRequestFullScreenDeprecatedPrefix: GleanCounter;
    mozfullscreenchangeDeprecatedPrefix: GleanCounter;
    mozfullscreenerrorDeprecatedPrefix: GleanCounter;
    externalAddSearchProvider: GleanCounter;
    mouseEventMozPressure: GleanCounter;
    mozInputSource: GleanCounter;
    initMouseEvent: GleanCounter;
    initNsmouseEvent: GleanCounter;
    mathMlDeprecatedMathSpaceValue2: GleanCounter;
    mathMlDeprecatedMathVariant: GleanCounter;
    mathMlDeprecatedStixgeneralOperatorStretching: GleanCounter;
    formSubmissionUntrustedEvent: GleanCounter;
    elementSetCapture: GleanCounter;
    elementReleaseCapture: GleanCounter;
    documentReleaseCapture: GleanCounter;
    offscreenCanvasToBlob: GleanCounter;
    svgdeselectAll: GleanCounter;
    svgnearestViewportElement: GleanCounter;
    svgfarthestViewportElement: GleanCounter;
    idbobjectStoreCreateIndexLocale: GleanCounter;
    beforeScriptExecuteEvent: GleanCounter;
    afterScriptExecuteEvent: GleanCounter;
  }

  useCounterDeprecatedOpsDoc: {
    domsubtreeModified: GleanCounter;
    domnodeInserted: GleanCounter;
    domnodeRemoved: GleanCounter;
    domnodeRemovedFromDocument: GleanCounter;
    domnodeInsertedIntoDocument: GleanCounter;
    domattrModified: GleanCounter;
    domcharacterDataModified: GleanCounter;
    components: GleanCounter;
    nodeIteratorDetach: GleanCounter;
    lenientThis: GleanCounter;
    useOfCaptureEvents: GleanCounter;
    useOfReleaseEvents: GleanCounter;
    syncXmlhttpRequestDeprecated: GleanCounter;
    windowCcOntrollers: GleanCounter;
    importXulintoContent: GleanCounter;
    installTriggerDeprecated: GleanCounter;
    installTriggerInstallDeprecated: GleanCounter;
    navigatorGetUserMedia: GleanCounter;
    webrtcDeprecatedPrefix: GleanCounter;
    rtcpeerConnectionGetStreams: GleanCounter;
    appCache: GleanCounter;
    lenientSetter: GleanCounter;
    imageBitmapRenderingContextTransferImageBitmap: GleanCounter;
    windowContentUntrusted: GleanCounter;
    motionEvent: GleanCounter;
    orientationEvent: GleanCounter;
    proximityEvent: GleanCounter;
    ambientLightEvent: GleanCounter;
    idbopenDboptionsStorageType: GleanCounter;
    domquadBoundsAttr: GleanCounter;
    deprecatedTestingInterface: GleanCounter;
    deprecatedTestingMethod: GleanCounter;
    deprecatedTestingAttribute: GleanCounter;
    createImageBitmapCanvasRenderingContext2D: GleanCounter;
    drawWindowCanvasRenderingContext2D: GleanCounter;
    mozRequestFullScreenDeprecatedPrefix: GleanCounter;
    mozfullscreenchangeDeprecatedPrefix: GleanCounter;
    mozfullscreenerrorDeprecatedPrefix: GleanCounter;
    externalAddSearchProvider: GleanCounter;
    mouseEventMozPressure: GleanCounter;
    mozInputSource: GleanCounter;
    initMouseEvent: GleanCounter;
    initNsmouseEvent: GleanCounter;
    mathMlDeprecatedMathSpaceValue2: GleanCounter;
    mathMlDeprecatedMathVariant: GleanCounter;
    mathMlDeprecatedStixgeneralOperatorStretching: GleanCounter;
    formSubmissionUntrustedEvent: GleanCounter;
    elementSetCapture: GleanCounter;
    elementReleaseCapture: GleanCounter;
    documentReleaseCapture: GleanCounter;
    offscreenCanvasToBlob: GleanCounter;
    svgdeselectAll: GleanCounter;
    svgnearestViewportElement: GleanCounter;
    svgfarthestViewportElement: GleanCounter;
    idbobjectStoreCreateIndexLocale: GleanCounter;
    beforeScriptExecuteEvent: GleanCounter;
    afterScriptExecuteEvent: GleanCounter;
  }

  useCounterCssPage: {
    cssAlignContent: GleanCounter;
    cssAlignItems: GleanCounter;
    cssAlignSelf: GleanCounter;
    cssAspectRatio: GleanCounter;
    cssBackfaceVisibility: GleanCounter;
    cssBaselineSource: GleanCounter;
    cssBorderCollapse: GleanCounter;
    cssBorderImageRepeat: GleanCounter;
    cssBoxDecorationBreak: GleanCounter;
    cssBoxSizing: GleanCounter;
    cssBreakInside: GleanCounter;
    cssCaptionSide: GleanCounter;
    cssClear: GleanCounter;
    cssColorInterpolation: GleanCounter;
    cssColorInterpolationFilters: GleanCounter;
    cssColumnCount: GleanCounter;
    cssColumnFill: GleanCounter;
    cssColumnSpan: GleanCounter;
    cssContain: GleanCounter;
    cssContainerType: GleanCounter;
    cssContentVisibility: GleanCounter;
    cssDirection: GleanCounter;
    cssDisplay: GleanCounter;
    cssDominantBaseline: GleanCounter;
    cssEmptyCells: GleanCounter;
    cssFieldSizing: GleanCounter;
    cssFlexDirection: GleanCounter;
    cssFlexWrap: GleanCounter;
    cssFloat: GleanCounter;
    cssFontKerning: GleanCounter;
    cssFontLanguageOverride: GleanCounter;
    cssFontOpticalSizing: GleanCounter;
    cssFontSizeAdjust: GleanCounter;
    cssFontStretch: GleanCounter;
    cssFontStyle: GleanCounter;
    cssFontSynthesisStyle: GleanCounter;
    cssFontVariantCaps: GleanCounter;
    cssFontVariantEastAsian: GleanCounter;
    cssFontVariantEmoji: GleanCounter;
    cssFontVariantLigatures: GleanCounter;
    cssFontVariantNumeric: GleanCounter;
    cssFontVariantPosition: GleanCounter;
    cssFontWeight: GleanCounter;
    cssForcedColorAdjust: GleanCounter;
    cssGridAutoFlow: GleanCounter;
    cssHyphens: GleanCounter;
    cssImageOrientation: GleanCounter;
    cssImageRendering: GleanCounter;
    cssImeMode: GleanCounter;
    cssInitialLetter: GleanCounter;
    cssIsolation: GleanCounter;
    cssJustifyContent: GleanCounter;
    cssJustifyItems: GleanCounter;
    cssJustifySelf: GleanCounter;
    cssLineBreak: GleanCounter;
    cssListStylePosition: GleanCounter;
    cssMaskType: GleanCounter;
    cssMasonryAutoFlow: GleanCounter;
    cssMathDepth: GleanCounter;
    cssMathStyle: GleanCounter;
    cssMixBlendMode: GleanCounter;
    cssMozBoxAlign: GleanCounter;
    cssMozBoxCollapse: GleanCounter;
    cssMozBoxDirection: GleanCounter;
    cssMozBoxOrient: GleanCounter;
    cssMozBoxPack: GleanCounter;
    cssMozControlCharacterVisibility: GleanCounter;
    cssMozFloatEdge: GleanCounter;
    cssMozInert: GleanCounter;
    cssMozMathVariant: GleanCounter;
    cssMozMinFontSizeRatio: GleanCounter;
    cssMozOrient: GleanCounter;
    cssMozOsxFontSmoothing: GleanCounter;
    cssMozTextSizeAdjust: GleanCounter;
    cssMozTheme: GleanCounter;
    cssMozTopLayer: GleanCounter;
    cssMozUserFocus: GleanCounter;
    cssMozUserInput: GleanCounter;
    cssMozWindowDragging: GleanCounter;
    cssMozWindowShadow: GleanCounter;
    cssObjectFit: GleanCounter;
    cssOffsetRotate: GleanCounter;
    cssOutlineStyle: GleanCounter;
    cssOverflowAnchor: GleanCounter;
    cssOverflowWrap: GleanCounter;
    cssPageOrientation: GleanCounter;
    cssPaintOrder: GleanCounter;
    cssPointerEvents: GleanCounter;
    cssPosition: GleanCounter;
    cssPositionArea: GleanCounter;
    cssPositionTryOrder: GleanCounter;
    cssPositionVisibility: GleanCounter;
    cssPrintColorAdjust: GleanCounter;
    cssResize: GleanCounter;
    cssRubyAlign: GleanCounter;
    cssRubyPosition: GleanCounter;
    cssScrollBehavior: GleanCounter;
    cssScrollSnapAlign: GleanCounter;
    cssScrollSnapStop: GleanCounter;
    cssScrollSnapType: GleanCounter;
    cssScrollbarGutter: GleanCounter;
    cssScrollbarWidth: GleanCounter;
    cssShapeRendering: GleanCounter;
    cssStrokeLinecap: GleanCounter;
    cssStrokeLinejoin: GleanCounter;
    cssTableLayout: GleanCounter;
    cssTextAlign: GleanCounter;
    cssTextAlignLast: GleanCounter;
    cssTextAnchor: GleanCounter;
    cssTextCombineUpright: GleanCounter;
    cssTextDecorationLine: GleanCounter;
    cssTextDecorationSkipInk: GleanCounter;
    cssTextDecorationStyle: GleanCounter;
    cssTextEmphasisPosition: GleanCounter;
    cssTextJustify: GleanCounter;
    cssTextOrientation: GleanCounter;
    cssTextRendering: GleanCounter;
    cssTextTransform: GleanCounter;
    cssTextUnderlinePosition: GleanCounter;
    cssTextWrapMode: GleanCounter;
    cssTextWrapStyle: GleanCounter;
    cssTouchAction: GleanCounter;
    cssTransformBox: GleanCounter;
    cssTransformStyle: GleanCounter;
    cssUnicodeBidi: GleanCounter;
    cssUserSelect: GleanCounter;
    cssVectorEffect: GleanCounter;
    cssVisibility: GleanCounter;
    cssWebkitLineClamp: GleanCounter;
    cssWebkitTextSecurity: GleanCounter;
    cssWhiteSpaceCollapse: GleanCounter;
    cssWordBreak: GleanCounter;
    cssWritingMode: GleanCounter;
    cssXTextScale: GleanCounter;
    cssZIndex: GleanCounter;
    cssZoom: GleanCounter;
    cssAppearance: GleanCounter;
    cssMozDefaultAppearance: GleanCounter;
    cssMozForceBrokenImageIcon: GleanCounter;
    cssMozSubtreeHiddenOnlyVisually: GleanCounter;
    cssBreakAfter: GleanCounter;
    cssBreakBefore: GleanCounter;
    cssClipRule: GleanCounter;
    cssFillRule: GleanCounter;
    cssOverflowClipBoxBlock: GleanCounter;
    cssOverflowClipBoxInline: GleanCounter;
    cssFillOpacity: GleanCounter;
    cssStrokeOpacity: GleanCounter;
    cssFontSynthesisPosition: GleanCounter;
    cssFontSynthesisSmallCaps: GleanCounter;
    cssFontSynthesisWeight: GleanCounter;
    cssMozBoxOrdinalGroup: GleanCounter;
    cssOrder: GleanCounter;
    cssXSpan: GleanCounter;
    cssFlexGrow: GleanCounter;
    cssFlexShrink: GleanCounter;
    cssMozBoxFlex: GleanCounter;
    cssStrokeMiterlimit: GleanCounter;
    cssOverflowBlock: GleanCounter;
    cssOverflowInline: GleanCounter;
    cssOverflowX: GleanCounter;
    cssOverflowY: GleanCounter;
    cssOverscrollBehaviorBlock: GleanCounter;
    cssOverscrollBehaviorInline: GleanCounter;
    cssOverscrollBehaviorX: GleanCounter;
    cssOverscrollBehaviorY: GleanCounter;
    cssFloodOpacity: GleanCounter;
    cssMozWindowOpacity: GleanCounter;
    cssOpacity: GleanCounter;
    cssShapeImageThreshold: GleanCounter;
    cssStopOpacity: GleanCounter;
    cssBorderBlockEndStyle: GleanCounter;
    cssBorderBlockStartStyle: GleanCounter;
    cssBorderBottomStyle: GleanCounter;
    cssBorderInlineEndStyle: GleanCounter;
    cssBorderInlineStartStyle: GleanCounter;
    cssBorderLeftStyle: GleanCounter;
    cssBorderRightStyle: GleanCounter;
    cssBorderTopStyle: GleanCounter;
    cssColumnRuleStyle: GleanCounter;
    cssAccentColor: GleanCounter;
    cssAnchorName: GleanCounter;
    cssAnchorScope: GleanCounter;
    cssAnimationComposition: GleanCounter;
    cssAnimationDelay: GleanCounter;
    cssAnimationDirection: GleanCounter;
    cssAnimationDuration: GleanCounter;
    cssAnimationFillMode: GleanCounter;
    cssAnimationIterationCount: GleanCounter;
    cssAnimationName: GleanCounter;
    cssAnimationPlayState: GleanCounter;
    cssAnimationTimeline: GleanCounter;
    cssAnimationTimingFunction: GleanCounter;
    cssBackdropFilter: GleanCounter;
    cssBackgroundAttachment: GleanCounter;
    cssBackgroundBlendMode: GleanCounter;
    cssBackgroundClip: GleanCounter;
    cssBackgroundImage: GleanCounter;
    cssBackgroundOrigin: GleanCounter;
    cssBackgroundPositionX: GleanCounter;
    cssBackgroundPositionY: GleanCounter;
    cssBackgroundRepeat: GleanCounter;
    cssBackgroundSize: GleanCounter;
    cssBorderImageOutset: GleanCounter;
    cssBorderImageSlice: GleanCounter;
    cssBorderImageWidth: GleanCounter;
    cssBorderSpacing: GleanCounter;
    cssBoxShadow: GleanCounter;
    cssCaretColor: GleanCounter;
    cssClip: GleanCounter;
    cssClipPath: GleanCounter;
    cssColor: GleanCounter;
    cssColorScheme: GleanCounter;
    cssColumnWidth: GleanCounter;
    cssContainerName: GleanCounter;
    cssContent: GleanCounter;
    cssCounterIncrement: GleanCounter;
    cssCounterReset: GleanCounter;
    cssCounterSet: GleanCounter;
    cssCursor: GleanCounter;
    cssD: GleanCounter;
    cssFilter: GleanCounter;
    cssFlexBasis: GleanCounter;
    cssFontFamily: GleanCounter;
    cssFontFeatureSettings: GleanCounter;
    cssFontPalette: GleanCounter;
    cssFontSize: GleanCounter;
    cssFontVariantAlternates: GleanCounter;
    cssFontVariationSettings: GleanCounter;
    cssGridTemplateAreas: GleanCounter;
    cssHyphenateCharacter: GleanCounter;
    cssHyphenateLimitChars: GleanCounter;
    cssLetterSpacing: GleanCounter;
    cssLineHeight: GleanCounter;
    cssListStyleType: GleanCounter;
    cssMaskClip: GleanCounter;
    cssMaskComposite: GleanCounter;
    cssMaskImage: GleanCounter;
    cssMaskMode: GleanCounter;
    cssMaskOrigin: GleanCounter;
    cssMaskPositionX: GleanCounter;
    cssMaskPositionY: GleanCounter;
    cssMaskRepeat: GleanCounter;
    cssMaskSize: GleanCounter;
    cssMozContextProperties: GleanCounter;
    cssOffsetAnchor: GleanCounter;
    cssOffsetPath: GleanCounter;
    cssOffsetPosition: GleanCounter;
    cssPage: GleanCounter;
    cssPerspective: GleanCounter;
    cssPositionAnchor: GleanCounter;
    cssPositionTryFallbacks: GleanCounter;
    cssQuotes: GleanCounter;
    cssRotate: GleanCounter;
    cssScale: GleanCounter;
    cssScrollTimelineAxis: GleanCounter;
    cssScrollTimelineName: GleanCounter;
    cssScrollbarColor: GleanCounter;
    cssShapeOutside: GleanCounter;
    cssSize: GleanCounter;
    cssStrokeDasharray: GleanCounter;
    cssStrokeDashoffset: GleanCounter;
    cssStrokeWidth: GleanCounter;
    cssTabSize: GleanCounter;
    cssTextDecorationThickness: GleanCounter;
    cssTextEmphasisStyle: GleanCounter;
    cssTextIndent: GleanCounter;
    cssTextOverflow: GleanCounter;
    cssTextShadow: GleanCounter;
    cssTextUnderlineOffset: GleanCounter;
    cssTransformOrigin: GleanCounter;
    cssTransitionBehavior: GleanCounter;
    cssTransitionDelay: GleanCounter;
    cssTransitionDuration: GleanCounter;
    cssTransitionProperty: GleanCounter;
    cssTransitionTimingFunction: GleanCounter;
    cssTranslate: GleanCounter;
    cssVerticalAlign: GleanCounter;
    cssViewTimelineAxis: GleanCounter;
    cssViewTimelineInset: GleanCounter;
    cssViewTimelineName: GleanCounter;
    cssViewTransitionClass: GleanCounter;
    cssViewTransitionName: GleanCounter;
    cssWebkitTextStrokeWidth: GleanCounter;
    cssWillChange: GleanCounter;
    cssWordSpacing: GleanCounter;
    cssXLang: GleanCounter;
    cssObjectPosition: GleanCounter;
    cssPerspectiveOrigin: GleanCounter;
    cssFill: GleanCounter;
    cssStroke: GleanCounter;
    cssGridTemplateColumns: GleanCounter;
    cssGridTemplateRows: GleanCounter;
    cssBorderImageSource: GleanCounter;
    cssListStyleImage: GleanCounter;
    cssGridAutoColumns: GleanCounter;
    cssGridAutoRows: GleanCounter;
    cssMozWindowTransform: GleanCounter;
    cssTransform: GleanCounter;
    cssColumnGap: GleanCounter;
    cssRowGap: GleanCounter;
    cssMarkerEnd: GleanCounter;
    cssMarkerMid: GleanCounter;
    cssMarkerStart: GleanCounter;
    cssContainIntrinsicBlockSize: GleanCounter;
    cssContainIntrinsicHeight: GleanCounter;
    cssContainIntrinsicInlineSize: GleanCounter;
    cssContainIntrinsicWidth: GleanCounter;
    cssGridColumnEnd: GleanCounter;
    cssGridColumnStart: GleanCounter;
    cssGridRowEnd: GleanCounter;
    cssGridRowStart: GleanCounter;
    cssMaxBlockSize: GleanCounter;
    cssMaxHeight: GleanCounter;
    cssMaxInlineSize: GleanCounter;
    cssMaxWidth: GleanCounter;
    cssCx: GleanCounter;
    cssCy: GleanCounter;
    cssOffsetDistance: GleanCounter;
    cssX: GleanCounter;
    cssY: GleanCounter;
    cssBorderBottomLeftRadius: GleanCounter;
    cssBorderBottomRightRadius: GleanCounter;
    cssBorderEndEndRadius: GleanCounter;
    cssBorderEndStartRadius: GleanCounter;
    cssBorderStartEndRadius: GleanCounter;
    cssBorderStartStartRadius: GleanCounter;
    cssBorderTopLeftRadius: GleanCounter;
    cssBorderTopRightRadius: GleanCounter;
    cssBottom: GleanCounter;
    cssInsetBlockEnd: GleanCounter;
    cssInsetBlockStart: GleanCounter;
    cssInsetInlineEnd: GleanCounter;
    cssInsetInlineStart: GleanCounter;
    cssLeft: GleanCounter;
    cssRight: GleanCounter;
    cssTop: GleanCounter;
    cssMarginBlockEnd: GleanCounter;
    cssMarginBlockStart: GleanCounter;
    cssMarginBottom: GleanCounter;
    cssMarginInlineEnd: GleanCounter;
    cssMarginInlineStart: GleanCounter;
    cssMarginLeft: GleanCounter;
    cssMarginRight: GleanCounter;
    cssMarginTop: GleanCounter;
    cssBlockSize: GleanCounter;
    cssHeight: GleanCounter;
    cssInlineSize: GleanCounter;
    cssMinBlockSize: GleanCounter;
    cssMinHeight: GleanCounter;
    cssMinInlineSize: GleanCounter;
    cssMinWidth: GleanCounter;
    cssWidth: GleanCounter;
    cssBorderBlockEndWidth: GleanCounter;
    cssBorderBlockStartWidth: GleanCounter;
    cssBorderBottomWidth: GleanCounter;
    cssBorderInlineEndWidth: GleanCounter;
    cssBorderInlineStartWidth: GleanCounter;
    cssBorderLeftWidth: GleanCounter;
    cssBorderRightWidth: GleanCounter;
    cssBorderTopWidth: GleanCounter;
    cssColumnRuleWidth: GleanCounter;
    cssOutlineWidth: GleanCounter;
    cssPaddingBlockEnd: GleanCounter;
    cssPaddingBlockStart: GleanCounter;
    cssPaddingBottom: GleanCounter;
    cssPaddingInlineEnd: GleanCounter;
    cssPaddingInlineStart: GleanCounter;
    cssPaddingLeft: GleanCounter;
    cssPaddingRight: GleanCounter;
    cssPaddingTop: GleanCounter;
    cssR: GleanCounter;
    cssShapeMargin: GleanCounter;
    cssRx: GleanCounter;
    cssRy: GleanCounter;
    cssScrollPaddingBlockEnd: GleanCounter;
    cssScrollPaddingBlockStart: GleanCounter;
    cssScrollPaddingBottom: GleanCounter;
    cssScrollPaddingInlineEnd: GleanCounter;
    cssScrollPaddingInlineStart: GleanCounter;
    cssScrollPaddingLeft: GleanCounter;
    cssScrollPaddingRight: GleanCounter;
    cssScrollPaddingTop: GleanCounter;
    cssMozWindowInputRegionMargin: GleanCounter;
    cssOutlineOffset: GleanCounter;
    cssOverflowClipMargin: GleanCounter;
    cssScrollMarginBlockEnd: GleanCounter;
    cssScrollMarginBlockStart: GleanCounter;
    cssScrollMarginBottom: GleanCounter;
    cssScrollMarginInlineEnd: GleanCounter;
    cssScrollMarginInlineStart: GleanCounter;
    cssScrollMarginLeft: GleanCounter;
    cssScrollMarginRight: GleanCounter;
    cssScrollMarginTop: GleanCounter;
    cssBackgroundColor: GleanCounter;
    cssBorderBlockEndColor: GleanCounter;
    cssBorderBlockStartColor: GleanCounter;
    cssBorderBottomColor: GleanCounter;
    cssBorderInlineEndColor: GleanCounter;
    cssBorderInlineStartColor: GleanCounter;
    cssBorderLeftColor: GleanCounter;
    cssBorderRightColor: GleanCounter;
    cssBorderTopColor: GleanCounter;
    cssColumnRuleColor: GleanCounter;
    cssFloodColor: GleanCounter;
    cssLightingColor: GleanCounter;
    cssOutlineColor: GleanCounter;
    cssStopColor: GleanCounter;
    cssTextDecorationColor: GleanCounter;
    cssTextEmphasisColor: GleanCounter;
    cssWebkitTextFillColor: GleanCounter;
    cssWebkitTextStrokeColor: GleanCounter;
    cssBackground: GleanCounter;
    cssBackgroundPosition: GleanCounter;
    cssBorderColor: GleanCounter;
    cssBorderStyle: GleanCounter;
    cssBorderWidth: GleanCounter;
    cssBorderTop: GleanCounter;
    cssBorderRight: GleanCounter;
    cssBorderBottom: GleanCounter;
    cssBorderLeft: GleanCounter;
    cssBorderBlockStart: GleanCounter;
    cssBorderBlockEnd: GleanCounter;
    cssBorderInlineStart: GleanCounter;
    cssBorderInlineEnd: GleanCounter;
    cssBorder: GleanCounter;
    cssBorderRadius: GleanCounter;
    cssBorderImage: GleanCounter;
    cssBorderBlockWidth: GleanCounter;
    cssBorderBlockStyle: GleanCounter;
    cssBorderBlockColor: GleanCounter;
    cssBorderInlineWidth: GleanCounter;
    cssBorderInlineStyle: GleanCounter;
    cssBorderInlineColor: GleanCounter;
    cssBorderBlock: GleanCounter;
    cssBorderInline: GleanCounter;
    cssOverflow: GleanCounter;
    cssOverflowClipBox: GleanCounter;
    cssOverscrollBehavior: GleanCounter;
    cssContainer: GleanCounter;
    cssPageBreakBefore: GleanCounter;
    cssPageBreakAfter: GleanCounter;
    cssPageBreakInside: GleanCounter;
    cssOffset: GleanCounter;
    cssColumns: GleanCounter;
    cssColumnRule: GleanCounter;
    cssFont: GleanCounter;
    cssFontVariant: GleanCounter;
    cssFontSynthesis: GleanCounter;
    cssMarker: GleanCounter;
    cssTextEmphasis: GleanCounter;
    cssTextWrap: GleanCounter;
    cssWhiteSpace: GleanCounter;
    cssWebkitTextStroke: GleanCounter;
    cssListStyle: GleanCounter;
    cssMargin: GleanCounter;
    cssMarginBlock: GleanCounter;
    cssMarginInline: GleanCounter;
    cssScrollMargin: GleanCounter;
    cssScrollMarginBlock: GleanCounter;
    cssScrollMarginInline: GleanCounter;
    cssOutline: GleanCounter;
    cssPadding: GleanCounter;
    cssPaddingBlock: GleanCounter;
    cssPaddingInline: GleanCounter;
    cssScrollPadding: GleanCounter;
    cssScrollPaddingBlock: GleanCounter;
    cssScrollPaddingInline: GleanCounter;
    cssFlexFlow: GleanCounter;
    cssFlex: GleanCounter;
    cssGap: GleanCounter;
    cssGridRow: GleanCounter;
    cssGridColumn: GleanCounter;
    cssGridArea: GleanCounter;
    cssGridTemplate: GleanCounter;
    cssGrid: GleanCounter;
    cssPlaceContent: GleanCounter;
    cssPlaceSelf: GleanCounter;
    cssPlaceItems: GleanCounter;
    cssPositionTry: GleanCounter;
    cssInset: GleanCounter;
    cssInsetBlock: GleanCounter;
    cssInsetInline: GleanCounter;
    cssContainIntrinsicSize: GleanCounter;
    cssMask: GleanCounter;
    cssMaskPosition: GleanCounter;
    cssTextDecoration: GleanCounter;
    cssTransition: GleanCounter;
    cssAnimation: GleanCounter;
    cssScrollTimeline: GleanCounter;
    cssViewTimeline: GleanCounter;
    cssAll: GleanCounter;
    cssWebkitBackgroundClip: GleanCounter;
    cssWebkitBackgroundOrigin: GleanCounter;
    cssWebkitBackgroundSize: GleanCounter;
    cssMozBorderStartColor: GleanCounter;
    cssMozBorderStartStyle: GleanCounter;
    cssMozBorderStartWidth: GleanCounter;
    cssMozBorderEndColor: GleanCounter;
    cssMozBorderEndStyle: GleanCounter;
    cssMozBorderEndWidth: GleanCounter;
    cssWebkitBorderTopLeftRadius: GleanCounter;
    cssWebkitBorderTopRightRadius: GleanCounter;
    cssWebkitBorderBottomRightRadius: GleanCounter;
    cssWebkitBorderBottomLeftRadius: GleanCounter;
    cssMozTransform: GleanCounter;
    cssWebkitTransform: GleanCounter;
    cssMozPerspective: GleanCounter;
    cssWebkitPerspective: GleanCounter;
    cssMozPerspectiveOrigin: GleanCounter;
    cssWebkitPerspectiveOrigin: GleanCounter;
    cssMozBackfaceVisibility: GleanCounter;
    cssWebkitBackfaceVisibility: GleanCounter;
    cssMozTransformStyle: GleanCounter;
    cssWebkitTransformStyle: GleanCounter;
    cssMozTransformOrigin: GleanCounter;
    cssWebkitTransformOrigin: GleanCounter;
    cssMozAppearance: GleanCounter;
    cssWebkitAppearance: GleanCounter;
    cssWebkitBoxShadow: GleanCounter;
    cssWebkitFilter: GleanCounter;
    cssMozFontFeatureSettings: GleanCounter;
    cssWebkitFontFeatureSettings: GleanCounter;
    cssMozFontLanguageOverride: GleanCounter;
    cssWebkitFontSmoothing: GleanCounter;
    cssColorAdjust: GleanCounter;
    cssMozHyphens: GleanCounter;
    cssWebkitTextSizeAdjust: GleanCounter;
    cssWordWrap: GleanCounter;
    cssMozTabSize: GleanCounter;
    cssMozMarginStart: GleanCounter;
    cssMozMarginEnd: GleanCounter;
    cssMozPaddingStart: GleanCounter;
    cssMozPaddingEnd: GleanCounter;
    cssWebkitFlexDirection: GleanCounter;
    cssWebkitFlexWrap: GleanCounter;
    cssWebkitJustifyContent: GleanCounter;
    cssWebkitAlignContent: GleanCounter;
    cssWebkitAlignItems: GleanCounter;
    cssWebkitFlexGrow: GleanCounter;
    cssWebkitFlexShrink: GleanCounter;
    cssWebkitAlignSelf: GleanCounter;
    cssWebkitOrder: GleanCounter;
    cssWebkitFlexBasis: GleanCounter;
    cssMozBoxSizing: GleanCounter;
    cssWebkitBoxSizing: GleanCounter;
    cssGridColumnGap: GleanCounter;
    cssGridRowGap: GleanCounter;
    cssWebkitClipPath: GleanCounter;
    cssWebkitMaskRepeat: GleanCounter;
    cssWebkitMaskPositionX: GleanCounter;
    cssWebkitMaskPositionY: GleanCounter;
    cssWebkitMaskClip: GleanCounter;
    cssWebkitMaskOrigin: GleanCounter;
    cssWebkitMaskSize: GleanCounter;
    cssWebkitMaskComposite: GleanCounter;
    cssWebkitMaskImage: GleanCounter;
    cssMozUserSelect: GleanCounter;
    cssWebkitUserSelect: GleanCounter;
    cssMozTransitionDuration: GleanCounter;
    cssWebkitTransitionDuration: GleanCounter;
    cssMozTransitionTimingFunction: GleanCounter;
    cssWebkitTransitionTimingFunction: GleanCounter;
    cssMozTransitionProperty: GleanCounter;
    cssWebkitTransitionProperty: GleanCounter;
    cssMozTransitionDelay: GleanCounter;
    cssWebkitTransitionDelay: GleanCounter;
    cssMozAnimationName: GleanCounter;
    cssWebkitAnimationName: GleanCounter;
    cssMozAnimationDuration: GleanCounter;
    cssWebkitAnimationDuration: GleanCounter;
    cssMozAnimationTimingFunction: GleanCounter;
    cssWebkitAnimationTimingFunction: GleanCounter;
    cssMozAnimationIterationCount: GleanCounter;
    cssWebkitAnimationIterationCount: GleanCounter;
    cssMozAnimationDirection: GleanCounter;
    cssWebkitAnimationDirection: GleanCounter;
    cssMozAnimationPlayState: GleanCounter;
    cssWebkitAnimationPlayState: GleanCounter;
    cssMozAnimationFillMode: GleanCounter;
    cssWebkitAnimationFillMode: GleanCounter;
    cssMozAnimationDelay: GleanCounter;
    cssWebkitAnimationDelay: GleanCounter;
    cssWebkitBoxAlign: GleanCounter;
    cssWebkitBoxDirection: GleanCounter;
    cssWebkitBoxFlex: GleanCounter;
    cssWebkitBoxOrient: GleanCounter;
    cssWebkitBoxPack: GleanCounter;
    cssWebkitBoxOrdinalGroup: GleanCounter;
    cssMozBorderStart: GleanCounter;
    cssMozBorderEnd: GleanCounter;
    cssWebkitBorderRadius: GleanCounter;
    cssMozBorderImage: GleanCounter;
    cssWebkitBorderImage: GleanCounter;
    cssWebkitFlexFlow: GleanCounter;
    cssWebkitFlex: GleanCounter;
    cssGridGap: GleanCounter;
    cssWebkitMask: GleanCounter;
    cssWebkitMaskPosition: GleanCounter;
    cssMozTransition: GleanCounter;
    cssWebkitTransition: GleanCounter;
    cssMozAnimation: GleanCounter;
    cssWebkitAnimation: GleanCounter;
    webkitTapHighlightColor: GleanCounter;
    speak: GleanCounter;
    textSizeAdjust: GleanCounter;
    webkitUserDrag: GleanCounter;
    orphans: GleanCounter;
    widows: GleanCounter;
    webkitUserModify: GleanCounter;
    webkitMarginBefore: GleanCounter;
    webkitMarginAfter: GleanCounter;
    webkitMarginStart: GleanCounter;
    webkitColumnBreakInside: GleanCounter;
    webkitPaddingStart: GleanCounter;
    webkitMarginEnd: GleanCounter;
    webkitBoxReflect: GleanCounter;
    webkitPrintColorAdjust: GleanCounter;
    webkitMaskBoxImage: GleanCounter;
    webkitLineBreak: GleanCounter;
    alignmentBaseline: GleanCounter;
    webkitWritingMode: GleanCounter;
    baselineShift: GleanCounter;
    webkitHyphenateCharacter: GleanCounter;
    webkitHighlight: GleanCounter;
    backgroundRepeatX: GleanCounter;
    webkitPaddingEnd: GleanCounter;
    backgroundRepeatY: GleanCounter;
    webkitTextEmphasisColor: GleanCounter;
    webkitMarginTopCollapse: GleanCounter;
    webkitRtlOrdering: GleanCounter;
    webkitPaddingBefore: GleanCounter;
    webkitTextDecorationsInEffect: GleanCounter;
    webkitBorderVerticalSpacing: GleanCounter;
    webkitLocale: GleanCounter;
    webkitPaddingAfter: GleanCounter;
    webkitBorderHorizontalSpacing: GleanCounter;
    colorRendering: GleanCounter;
    webkitColumnBreakBefore: GleanCounter;
    webkitTransformOriginX: GleanCounter;
    webkitTransformOriginY: GleanCounter;
    webkitTextEmphasisPosition: GleanCounter;
    bufferedRendering: GleanCounter;
    webkitTextOrientation: GleanCounter;
    webkitTextCombine: GleanCounter;
    webkitTextEmphasisStyle: GleanCounter;
    webkitTextEmphasis: GleanCounter;
    webkitMaskBoxImageWidth: GleanCounter;
    webkitMaskBoxImageSource: GleanCounter;
    webkitMaskBoxImageOutset: GleanCounter;
    webkitMaskBoxImageSlice: GleanCounter;
    webkitMaskBoxImageRepeat: GleanCounter;
    webkitMarginAfterCollapse: GleanCounter;
    webkitBorderBeforeColor: GleanCounter;
    webkitBorderBeforeWidth: GleanCounter;
    webkitPerspectiveOriginX: GleanCounter;
    webkitPerspectiveOriginY: GleanCounter;
    webkitMarginBeforeCollapse: GleanCounter;
    webkitBorderBeforeStyle: GleanCounter;
    webkitMarginBottomCollapse: GleanCounter;
    webkitRubyPosition: GleanCounter;
    webkitColumnBreakAfter: GleanCounter;
    webkitMarginCollapse: GleanCounter;
    webkitBorderBefore: GleanCounter;
    webkitBorderEnd: GleanCounter;
    webkitBorderAfter: GleanCounter;
    webkitBorderStart: GleanCounter;
    webkitMinLogicalWidth: GleanCounter;
    webkitLogicalHeight: GleanCounter;
    webkitTransformOriginZ: GleanCounter;
    webkitFontSizeDelta: GleanCounter;
    webkitLogicalWidth: GleanCounter;
    webkitMaxLogicalWidth: GleanCounter;
    webkitMinLogicalHeight: GleanCounter;
    webkitMaxLogicalHeight: GleanCounter;
    webkitBorderEndColor: GleanCounter;
    webkitBorderEndWidth: GleanCounter;
    webkitBorderStartColor: GleanCounter;
    webkitBorderStartWidth: GleanCounter;
    webkitBorderAfterColor: GleanCounter;
    webkitBorderAfterWidth: GleanCounter;
    webkitBorderEndStyle: GleanCounter;
    webkitBorderAfterStyle: GleanCounter;
    webkitBorderStartStyle: GleanCounter;
    webkitMaskRepeatX: GleanCounter;
    webkitMaskRepeatY: GleanCounter;
    userZoom: GleanCounter;
    minZoom: GleanCounter;
    webkitBoxDecorationBreak: GleanCounter;
    orientation: GleanCounter;
    maxZoom: GleanCounter;
    webkitAppRegion: GleanCounter;
    webkitColumnRule: GleanCounter;
    webkitColumnSpan: GleanCounter;
    webkitColumnGap: GleanCounter;
    webkitShapeOutside: GleanCounter;
    webkitColumnRuleWidth: GleanCounter;
    webkitColumnCount: GleanCounter;
    webkitOpacity: GleanCounter;
    webkitColumnWidth: GleanCounter;
    webkitShapeImageThreshold: GleanCounter;
    webkitColumnRuleStyle: GleanCounter;
    webkitColumns: GleanCounter;
    webkitColumnRuleColor: GleanCounter;
    webkitShapeMargin: GleanCounter;
  }

  useCounterCssDoc: {
    cssAlignContent: GleanCounter;
    cssAlignItems: GleanCounter;
    cssAlignSelf: GleanCounter;
    cssAspectRatio: GleanCounter;
    cssBackfaceVisibility: GleanCounter;
    cssBaselineSource: GleanCounter;
    cssBorderCollapse: GleanCounter;
    cssBorderImageRepeat: GleanCounter;
    cssBoxDecorationBreak: GleanCounter;
    cssBoxSizing: GleanCounter;
    cssBreakInside: GleanCounter;
    cssCaptionSide: GleanCounter;
    cssClear: GleanCounter;
    cssColorInterpolation: GleanCounter;
    cssColorInterpolationFilters: GleanCounter;
    cssColumnCount: GleanCounter;
    cssColumnFill: GleanCounter;
    cssColumnSpan: GleanCounter;
    cssContain: GleanCounter;
    cssContainerType: GleanCounter;
    cssContentVisibility: GleanCounter;
    cssDirection: GleanCounter;
    cssDisplay: GleanCounter;
    cssDominantBaseline: GleanCounter;
    cssEmptyCells: GleanCounter;
    cssFieldSizing: GleanCounter;
    cssFlexDirection: GleanCounter;
    cssFlexWrap: GleanCounter;
    cssFloat: GleanCounter;
    cssFontKerning: GleanCounter;
    cssFontLanguageOverride: GleanCounter;
    cssFontOpticalSizing: GleanCounter;
    cssFontSizeAdjust: GleanCounter;
    cssFontStretch: GleanCounter;
    cssFontStyle: GleanCounter;
    cssFontSynthesisStyle: GleanCounter;
    cssFontVariantCaps: GleanCounter;
    cssFontVariantEastAsian: GleanCounter;
    cssFontVariantEmoji: GleanCounter;
    cssFontVariantLigatures: GleanCounter;
    cssFontVariantNumeric: GleanCounter;
    cssFontVariantPosition: GleanCounter;
    cssFontWeight: GleanCounter;
    cssForcedColorAdjust: GleanCounter;
    cssGridAutoFlow: GleanCounter;
    cssHyphens: GleanCounter;
    cssImageOrientation: GleanCounter;
    cssImageRendering: GleanCounter;
    cssImeMode: GleanCounter;
    cssInitialLetter: GleanCounter;
    cssIsolation: GleanCounter;
    cssJustifyContent: GleanCounter;
    cssJustifyItems: GleanCounter;
    cssJustifySelf: GleanCounter;
    cssLineBreak: GleanCounter;
    cssListStylePosition: GleanCounter;
    cssMaskType: GleanCounter;
    cssMasonryAutoFlow: GleanCounter;
    cssMathDepth: GleanCounter;
    cssMathStyle: GleanCounter;
    cssMixBlendMode: GleanCounter;
    cssMozBoxAlign: GleanCounter;
    cssMozBoxCollapse: GleanCounter;
    cssMozBoxDirection: GleanCounter;
    cssMozBoxOrient: GleanCounter;
    cssMozBoxPack: GleanCounter;
    cssMozControlCharacterVisibility: GleanCounter;
    cssMozFloatEdge: GleanCounter;
    cssMozInert: GleanCounter;
    cssMozMathVariant: GleanCounter;
    cssMozMinFontSizeRatio: GleanCounter;
    cssMozOrient: GleanCounter;
    cssMozOsxFontSmoothing: GleanCounter;
    cssMozTextSizeAdjust: GleanCounter;
    cssMozTheme: GleanCounter;
    cssMozTopLayer: GleanCounter;
    cssMozUserFocus: GleanCounter;
    cssMozUserInput: GleanCounter;
    cssMozWindowDragging: GleanCounter;
    cssMozWindowShadow: GleanCounter;
    cssObjectFit: GleanCounter;
    cssOffsetRotate: GleanCounter;
    cssOutlineStyle: GleanCounter;
    cssOverflowAnchor: GleanCounter;
    cssOverflowWrap: GleanCounter;
    cssPageOrientation: GleanCounter;
    cssPaintOrder: GleanCounter;
    cssPointerEvents: GleanCounter;
    cssPosition: GleanCounter;
    cssPositionArea: GleanCounter;
    cssPositionTryOrder: GleanCounter;
    cssPositionVisibility: GleanCounter;
    cssPrintColorAdjust: GleanCounter;
    cssResize: GleanCounter;
    cssRubyAlign: GleanCounter;
    cssRubyPosition: GleanCounter;
    cssScrollBehavior: GleanCounter;
    cssScrollSnapAlign: GleanCounter;
    cssScrollSnapStop: GleanCounter;
    cssScrollSnapType: GleanCounter;
    cssScrollbarGutter: GleanCounter;
    cssScrollbarWidth: GleanCounter;
    cssShapeRendering: GleanCounter;
    cssStrokeLinecap: GleanCounter;
    cssStrokeLinejoin: GleanCounter;
    cssTableLayout: GleanCounter;
    cssTextAlign: GleanCounter;
    cssTextAlignLast: GleanCounter;
    cssTextAnchor: GleanCounter;
    cssTextCombineUpright: GleanCounter;
    cssTextDecorationLine: GleanCounter;
    cssTextDecorationSkipInk: GleanCounter;
    cssTextDecorationStyle: GleanCounter;
    cssTextEmphasisPosition: GleanCounter;
    cssTextJustify: GleanCounter;
    cssTextOrientation: GleanCounter;
    cssTextRendering: GleanCounter;
    cssTextTransform: GleanCounter;
    cssTextUnderlinePosition: GleanCounter;
    cssTextWrapMode: GleanCounter;
    cssTextWrapStyle: GleanCounter;
    cssTouchAction: GleanCounter;
    cssTransformBox: GleanCounter;
    cssTransformStyle: GleanCounter;
    cssUnicodeBidi: GleanCounter;
    cssUserSelect: GleanCounter;
    cssVectorEffect: GleanCounter;
    cssVisibility: GleanCounter;
    cssWebkitLineClamp: GleanCounter;
    cssWebkitTextSecurity: GleanCounter;
    cssWhiteSpaceCollapse: GleanCounter;
    cssWordBreak: GleanCounter;
    cssWritingMode: GleanCounter;
    cssXTextScale: GleanCounter;
    cssZIndex: GleanCounter;
    cssZoom: GleanCounter;
    cssAppearance: GleanCounter;
    cssMozDefaultAppearance: GleanCounter;
    cssMozForceBrokenImageIcon: GleanCounter;
    cssMozSubtreeHiddenOnlyVisually: GleanCounter;
    cssBreakAfter: GleanCounter;
    cssBreakBefore: GleanCounter;
    cssClipRule: GleanCounter;
    cssFillRule: GleanCounter;
    cssOverflowClipBoxBlock: GleanCounter;
    cssOverflowClipBoxInline: GleanCounter;
    cssFillOpacity: GleanCounter;
    cssStrokeOpacity: GleanCounter;
    cssFontSynthesisPosition: GleanCounter;
    cssFontSynthesisSmallCaps: GleanCounter;
    cssFontSynthesisWeight: GleanCounter;
    cssMozBoxOrdinalGroup: GleanCounter;
    cssOrder: GleanCounter;
    cssXSpan: GleanCounter;
    cssFlexGrow: GleanCounter;
    cssFlexShrink: GleanCounter;
    cssMozBoxFlex: GleanCounter;
    cssStrokeMiterlimit: GleanCounter;
    cssOverflowBlock: GleanCounter;
    cssOverflowInline: GleanCounter;
    cssOverflowX: GleanCounter;
    cssOverflowY: GleanCounter;
    cssOverscrollBehaviorBlock: GleanCounter;
    cssOverscrollBehaviorInline: GleanCounter;
    cssOverscrollBehaviorX: GleanCounter;
    cssOverscrollBehaviorY: GleanCounter;
    cssFloodOpacity: GleanCounter;
    cssMozWindowOpacity: GleanCounter;
    cssOpacity: GleanCounter;
    cssShapeImageThreshold: GleanCounter;
    cssStopOpacity: GleanCounter;
    cssBorderBlockEndStyle: GleanCounter;
    cssBorderBlockStartStyle: GleanCounter;
    cssBorderBottomStyle: GleanCounter;
    cssBorderInlineEndStyle: GleanCounter;
    cssBorderInlineStartStyle: GleanCounter;
    cssBorderLeftStyle: GleanCounter;
    cssBorderRightStyle: GleanCounter;
    cssBorderTopStyle: GleanCounter;
    cssColumnRuleStyle: GleanCounter;
    cssAccentColor: GleanCounter;
    cssAnchorName: GleanCounter;
    cssAnchorScope: GleanCounter;
    cssAnimationComposition: GleanCounter;
    cssAnimationDelay: GleanCounter;
    cssAnimationDirection: GleanCounter;
    cssAnimationDuration: GleanCounter;
    cssAnimationFillMode: GleanCounter;
    cssAnimationIterationCount: GleanCounter;
    cssAnimationName: GleanCounter;
    cssAnimationPlayState: GleanCounter;
    cssAnimationTimeline: GleanCounter;
    cssAnimationTimingFunction: GleanCounter;
    cssBackdropFilter: GleanCounter;
    cssBackgroundAttachment: GleanCounter;
    cssBackgroundBlendMode: GleanCounter;
    cssBackgroundClip: GleanCounter;
    cssBackgroundImage: GleanCounter;
    cssBackgroundOrigin: GleanCounter;
    cssBackgroundPositionX: GleanCounter;
    cssBackgroundPositionY: GleanCounter;
    cssBackgroundRepeat: GleanCounter;
    cssBackgroundSize: GleanCounter;
    cssBorderImageOutset: GleanCounter;
    cssBorderImageSlice: GleanCounter;
    cssBorderImageWidth: GleanCounter;
    cssBorderSpacing: GleanCounter;
    cssBoxShadow: GleanCounter;
    cssCaretColor: GleanCounter;
    cssClip: GleanCounter;
    cssClipPath: GleanCounter;
    cssColor: GleanCounter;
    cssColorScheme: GleanCounter;
    cssColumnWidth: GleanCounter;
    cssContainerName: GleanCounter;
    cssContent: GleanCounter;
    cssCounterIncrement: GleanCounter;
    cssCounterReset: GleanCounter;
    cssCounterSet: GleanCounter;
    cssCursor: GleanCounter;
    cssD: GleanCounter;
    cssFilter: GleanCounter;
    cssFlexBasis: GleanCounter;
    cssFontFamily: GleanCounter;
    cssFontFeatureSettings: GleanCounter;
    cssFontPalette: GleanCounter;
    cssFontSize: GleanCounter;
    cssFontVariantAlternates: GleanCounter;
    cssFontVariationSettings: GleanCounter;
    cssGridTemplateAreas: GleanCounter;
    cssHyphenateCharacter: GleanCounter;
    cssHyphenateLimitChars: GleanCounter;
    cssLetterSpacing: GleanCounter;
    cssLineHeight: GleanCounter;
    cssListStyleType: GleanCounter;
    cssMaskClip: GleanCounter;
    cssMaskComposite: GleanCounter;
    cssMaskImage: GleanCounter;
    cssMaskMode: GleanCounter;
    cssMaskOrigin: GleanCounter;
    cssMaskPositionX: GleanCounter;
    cssMaskPositionY: GleanCounter;
    cssMaskRepeat: GleanCounter;
    cssMaskSize: GleanCounter;
    cssMozContextProperties: GleanCounter;
    cssOffsetAnchor: GleanCounter;
    cssOffsetPath: GleanCounter;
    cssOffsetPosition: GleanCounter;
    cssPage: GleanCounter;
    cssPerspective: GleanCounter;
    cssPositionAnchor: GleanCounter;
    cssPositionTryFallbacks: GleanCounter;
    cssQuotes: GleanCounter;
    cssRotate: GleanCounter;
    cssScale: GleanCounter;
    cssScrollTimelineAxis: GleanCounter;
    cssScrollTimelineName: GleanCounter;
    cssScrollbarColor: GleanCounter;
    cssShapeOutside: GleanCounter;
    cssSize: GleanCounter;
    cssStrokeDasharray: GleanCounter;
    cssStrokeDashoffset: GleanCounter;
    cssStrokeWidth: GleanCounter;
    cssTabSize: GleanCounter;
    cssTextDecorationThickness: GleanCounter;
    cssTextEmphasisStyle: GleanCounter;
    cssTextIndent: GleanCounter;
    cssTextOverflow: GleanCounter;
    cssTextShadow: GleanCounter;
    cssTextUnderlineOffset: GleanCounter;
    cssTransformOrigin: GleanCounter;
    cssTransitionBehavior: GleanCounter;
    cssTransitionDelay: GleanCounter;
    cssTransitionDuration: GleanCounter;
    cssTransitionProperty: GleanCounter;
    cssTransitionTimingFunction: GleanCounter;
    cssTranslate: GleanCounter;
    cssVerticalAlign: GleanCounter;
    cssViewTimelineAxis: GleanCounter;
    cssViewTimelineInset: GleanCounter;
    cssViewTimelineName: GleanCounter;
    cssViewTransitionClass: GleanCounter;
    cssViewTransitionName: GleanCounter;
    cssWebkitTextStrokeWidth: GleanCounter;
    cssWillChange: GleanCounter;
    cssWordSpacing: GleanCounter;
    cssXLang: GleanCounter;
    cssObjectPosition: GleanCounter;
    cssPerspectiveOrigin: GleanCounter;
    cssFill: GleanCounter;
    cssStroke: GleanCounter;
    cssGridTemplateColumns: GleanCounter;
    cssGridTemplateRows: GleanCounter;
    cssBorderImageSource: GleanCounter;
    cssListStyleImage: GleanCounter;
    cssGridAutoColumns: GleanCounter;
    cssGridAutoRows: GleanCounter;
    cssMozWindowTransform: GleanCounter;
    cssTransform: GleanCounter;
    cssColumnGap: GleanCounter;
    cssRowGap: GleanCounter;
    cssMarkerEnd: GleanCounter;
    cssMarkerMid: GleanCounter;
    cssMarkerStart: GleanCounter;
    cssContainIntrinsicBlockSize: GleanCounter;
    cssContainIntrinsicHeight: GleanCounter;
    cssContainIntrinsicInlineSize: GleanCounter;
    cssContainIntrinsicWidth: GleanCounter;
    cssGridColumnEnd: GleanCounter;
    cssGridColumnStart: GleanCounter;
    cssGridRowEnd: GleanCounter;
    cssGridRowStart: GleanCounter;
    cssMaxBlockSize: GleanCounter;
    cssMaxHeight: GleanCounter;
    cssMaxInlineSize: GleanCounter;
    cssMaxWidth: GleanCounter;
    cssCx: GleanCounter;
    cssCy: GleanCounter;
    cssOffsetDistance: GleanCounter;
    cssX: GleanCounter;
    cssY: GleanCounter;
    cssBorderBottomLeftRadius: GleanCounter;
    cssBorderBottomRightRadius: GleanCounter;
    cssBorderEndEndRadius: GleanCounter;
    cssBorderEndStartRadius: GleanCounter;
    cssBorderStartEndRadius: GleanCounter;
    cssBorderStartStartRadius: GleanCounter;
    cssBorderTopLeftRadius: GleanCounter;
    cssBorderTopRightRadius: GleanCounter;
    cssBottom: GleanCounter;
    cssInsetBlockEnd: GleanCounter;
    cssInsetBlockStart: GleanCounter;
    cssInsetInlineEnd: GleanCounter;
    cssInsetInlineStart: GleanCounter;
    cssLeft: GleanCounter;
    cssRight: GleanCounter;
    cssTop: GleanCounter;
    cssMarginBlockEnd: GleanCounter;
    cssMarginBlockStart: GleanCounter;
    cssMarginBottom: GleanCounter;
    cssMarginInlineEnd: GleanCounter;
    cssMarginInlineStart: GleanCounter;
    cssMarginLeft: GleanCounter;
    cssMarginRight: GleanCounter;
    cssMarginTop: GleanCounter;
    cssBlockSize: GleanCounter;
    cssHeight: GleanCounter;
    cssInlineSize: GleanCounter;
    cssMinBlockSize: GleanCounter;
    cssMinHeight: GleanCounter;
    cssMinInlineSize: GleanCounter;
    cssMinWidth: GleanCounter;
    cssWidth: GleanCounter;
    cssBorderBlockEndWidth: GleanCounter;
    cssBorderBlockStartWidth: GleanCounter;
    cssBorderBottomWidth: GleanCounter;
    cssBorderInlineEndWidth: GleanCounter;
    cssBorderInlineStartWidth: GleanCounter;
    cssBorderLeftWidth: GleanCounter;
    cssBorderRightWidth: GleanCounter;
    cssBorderTopWidth: GleanCounter;
    cssColumnRuleWidth: GleanCounter;
    cssOutlineWidth: GleanCounter;
    cssPaddingBlockEnd: GleanCounter;
    cssPaddingBlockStart: GleanCounter;
    cssPaddingBottom: GleanCounter;
    cssPaddingInlineEnd: GleanCounter;
    cssPaddingInlineStart: GleanCounter;
    cssPaddingLeft: GleanCounter;
    cssPaddingRight: GleanCounter;
    cssPaddingTop: GleanCounter;
    cssR: GleanCounter;
    cssShapeMargin: GleanCounter;
    cssRx: GleanCounter;
    cssRy: GleanCounter;
    cssScrollPaddingBlockEnd: GleanCounter;
    cssScrollPaddingBlockStart: GleanCounter;
    cssScrollPaddingBottom: GleanCounter;
    cssScrollPaddingInlineEnd: GleanCounter;
    cssScrollPaddingInlineStart: GleanCounter;
    cssScrollPaddingLeft: GleanCounter;
    cssScrollPaddingRight: GleanCounter;
    cssScrollPaddingTop: GleanCounter;
    cssMozWindowInputRegionMargin: GleanCounter;
    cssOutlineOffset: GleanCounter;
    cssOverflowClipMargin: GleanCounter;
    cssScrollMarginBlockEnd: GleanCounter;
    cssScrollMarginBlockStart: GleanCounter;
    cssScrollMarginBottom: GleanCounter;
    cssScrollMarginInlineEnd: GleanCounter;
    cssScrollMarginInlineStart: GleanCounter;
    cssScrollMarginLeft: GleanCounter;
    cssScrollMarginRight: GleanCounter;
    cssScrollMarginTop: GleanCounter;
    cssBackgroundColor: GleanCounter;
    cssBorderBlockEndColor: GleanCounter;
    cssBorderBlockStartColor: GleanCounter;
    cssBorderBottomColor: GleanCounter;
    cssBorderInlineEndColor: GleanCounter;
    cssBorderInlineStartColor: GleanCounter;
    cssBorderLeftColor: GleanCounter;
    cssBorderRightColor: GleanCounter;
    cssBorderTopColor: GleanCounter;
    cssColumnRuleColor: GleanCounter;
    cssFloodColor: GleanCounter;
    cssLightingColor: GleanCounter;
    cssOutlineColor: GleanCounter;
    cssStopColor: GleanCounter;
    cssTextDecorationColor: GleanCounter;
    cssTextEmphasisColor: GleanCounter;
    cssWebkitTextFillColor: GleanCounter;
    cssWebkitTextStrokeColor: GleanCounter;
    cssBackground: GleanCounter;
    cssBackgroundPosition: GleanCounter;
    cssBorderColor: GleanCounter;
    cssBorderStyle: GleanCounter;
    cssBorderWidth: GleanCounter;
    cssBorderTop: GleanCounter;
    cssBorderRight: GleanCounter;
    cssBorderBottom: GleanCounter;
    cssBorderLeft: GleanCounter;
    cssBorderBlockStart: GleanCounter;
    cssBorderBlockEnd: GleanCounter;
    cssBorderInlineStart: GleanCounter;
    cssBorderInlineEnd: GleanCounter;
    cssBorder: GleanCounter;
    cssBorderRadius: GleanCounter;
    cssBorderImage: GleanCounter;
    cssBorderBlockWidth: GleanCounter;
    cssBorderBlockStyle: GleanCounter;
    cssBorderBlockColor: GleanCounter;
    cssBorderInlineWidth: GleanCounter;
    cssBorderInlineStyle: GleanCounter;
    cssBorderInlineColor: GleanCounter;
    cssBorderBlock: GleanCounter;
    cssBorderInline: GleanCounter;
    cssOverflow: GleanCounter;
    cssOverflowClipBox: GleanCounter;
    cssOverscrollBehavior: GleanCounter;
    cssContainer: GleanCounter;
    cssPageBreakBefore: GleanCounter;
    cssPageBreakAfter: GleanCounter;
    cssPageBreakInside: GleanCounter;
    cssOffset: GleanCounter;
    cssColumns: GleanCounter;
    cssColumnRule: GleanCounter;
    cssFont: GleanCounter;
    cssFontVariant: GleanCounter;
    cssFontSynthesis: GleanCounter;
    cssMarker: GleanCounter;
    cssTextEmphasis: GleanCounter;
    cssTextWrap: GleanCounter;
    cssWhiteSpace: GleanCounter;
    cssWebkitTextStroke: GleanCounter;
    cssListStyle: GleanCounter;
    cssMargin: GleanCounter;
    cssMarginBlock: GleanCounter;
    cssMarginInline: GleanCounter;
    cssScrollMargin: GleanCounter;
    cssScrollMarginBlock: GleanCounter;
    cssScrollMarginInline: GleanCounter;
    cssOutline: GleanCounter;
    cssPadding: GleanCounter;
    cssPaddingBlock: GleanCounter;
    cssPaddingInline: GleanCounter;
    cssScrollPadding: GleanCounter;
    cssScrollPaddingBlock: GleanCounter;
    cssScrollPaddingInline: GleanCounter;
    cssFlexFlow: GleanCounter;
    cssFlex: GleanCounter;
    cssGap: GleanCounter;
    cssGridRow: GleanCounter;
    cssGridColumn: GleanCounter;
    cssGridArea: GleanCounter;
    cssGridTemplate: GleanCounter;
    cssGrid: GleanCounter;
    cssPlaceContent: GleanCounter;
    cssPlaceSelf: GleanCounter;
    cssPlaceItems: GleanCounter;
    cssPositionTry: GleanCounter;
    cssInset: GleanCounter;
    cssInsetBlock: GleanCounter;
    cssInsetInline: GleanCounter;
    cssContainIntrinsicSize: GleanCounter;
    cssMask: GleanCounter;
    cssMaskPosition: GleanCounter;
    cssTextDecoration: GleanCounter;
    cssTransition: GleanCounter;
    cssAnimation: GleanCounter;
    cssScrollTimeline: GleanCounter;
    cssViewTimeline: GleanCounter;
    cssAll: GleanCounter;
    cssWebkitBackgroundClip: GleanCounter;
    cssWebkitBackgroundOrigin: GleanCounter;
    cssWebkitBackgroundSize: GleanCounter;
    cssMozBorderStartColor: GleanCounter;
    cssMozBorderStartStyle: GleanCounter;
    cssMozBorderStartWidth: GleanCounter;
    cssMozBorderEndColor: GleanCounter;
    cssMozBorderEndStyle: GleanCounter;
    cssMozBorderEndWidth: GleanCounter;
    cssWebkitBorderTopLeftRadius: GleanCounter;
    cssWebkitBorderTopRightRadius: GleanCounter;
    cssWebkitBorderBottomRightRadius: GleanCounter;
    cssWebkitBorderBottomLeftRadius: GleanCounter;
    cssMozTransform: GleanCounter;
    cssWebkitTransform: GleanCounter;
    cssMozPerspective: GleanCounter;
    cssWebkitPerspective: GleanCounter;
    cssMozPerspectiveOrigin: GleanCounter;
    cssWebkitPerspectiveOrigin: GleanCounter;
    cssMozBackfaceVisibility: GleanCounter;
    cssWebkitBackfaceVisibility: GleanCounter;
    cssMozTransformStyle: GleanCounter;
    cssWebkitTransformStyle: GleanCounter;
    cssMozTransformOrigin: GleanCounter;
    cssWebkitTransformOrigin: GleanCounter;
    cssMozAppearance: GleanCounter;
    cssWebkitAppearance: GleanCounter;
    cssWebkitBoxShadow: GleanCounter;
    cssWebkitFilter: GleanCounter;
    cssMozFontFeatureSettings: GleanCounter;
    cssWebkitFontFeatureSettings: GleanCounter;
    cssMozFontLanguageOverride: GleanCounter;
    cssWebkitFontSmoothing: GleanCounter;
    cssColorAdjust: GleanCounter;
    cssMozHyphens: GleanCounter;
    cssWebkitTextSizeAdjust: GleanCounter;
    cssWordWrap: GleanCounter;
    cssMozTabSize: GleanCounter;
    cssMozMarginStart: GleanCounter;
    cssMozMarginEnd: GleanCounter;
    cssMozPaddingStart: GleanCounter;
    cssMozPaddingEnd: GleanCounter;
    cssWebkitFlexDirection: GleanCounter;
    cssWebkitFlexWrap: GleanCounter;
    cssWebkitJustifyContent: GleanCounter;
    cssWebkitAlignContent: GleanCounter;
    cssWebkitAlignItems: GleanCounter;
    cssWebkitFlexGrow: GleanCounter;
    cssWebkitFlexShrink: GleanCounter;
    cssWebkitAlignSelf: GleanCounter;
    cssWebkitOrder: GleanCounter;
    cssWebkitFlexBasis: GleanCounter;
    cssMozBoxSizing: GleanCounter;
    cssWebkitBoxSizing: GleanCounter;
    cssGridColumnGap: GleanCounter;
    cssGridRowGap: GleanCounter;
    cssWebkitClipPath: GleanCounter;
    cssWebkitMaskRepeat: GleanCounter;
    cssWebkitMaskPositionX: GleanCounter;
    cssWebkitMaskPositionY: GleanCounter;
    cssWebkitMaskClip: GleanCounter;
    cssWebkitMaskOrigin: GleanCounter;
    cssWebkitMaskSize: GleanCounter;
    cssWebkitMaskComposite: GleanCounter;
    cssWebkitMaskImage: GleanCounter;
    cssMozUserSelect: GleanCounter;
    cssWebkitUserSelect: GleanCounter;
    cssMozTransitionDuration: GleanCounter;
    cssWebkitTransitionDuration: GleanCounter;
    cssMozTransitionTimingFunction: GleanCounter;
    cssWebkitTransitionTimingFunction: GleanCounter;
    cssMozTransitionProperty: GleanCounter;
    cssWebkitTransitionProperty: GleanCounter;
    cssMozTransitionDelay: GleanCounter;
    cssWebkitTransitionDelay: GleanCounter;
    cssMozAnimationName: GleanCounter;
    cssWebkitAnimationName: GleanCounter;
    cssMozAnimationDuration: GleanCounter;
    cssWebkitAnimationDuration: GleanCounter;
    cssMozAnimationTimingFunction: GleanCounter;
    cssWebkitAnimationTimingFunction: GleanCounter;
    cssMozAnimationIterationCount: GleanCounter;
    cssWebkitAnimationIterationCount: GleanCounter;
    cssMozAnimationDirection: GleanCounter;
    cssWebkitAnimationDirection: GleanCounter;
    cssMozAnimationPlayState: GleanCounter;
    cssWebkitAnimationPlayState: GleanCounter;
    cssMozAnimationFillMode: GleanCounter;
    cssWebkitAnimationFillMode: GleanCounter;
    cssMozAnimationDelay: GleanCounter;
    cssWebkitAnimationDelay: GleanCounter;
    cssWebkitBoxAlign: GleanCounter;
    cssWebkitBoxDirection: GleanCounter;
    cssWebkitBoxFlex: GleanCounter;
    cssWebkitBoxOrient: GleanCounter;
    cssWebkitBoxPack: GleanCounter;
    cssWebkitBoxOrdinalGroup: GleanCounter;
    cssMozBorderStart: GleanCounter;
    cssMozBorderEnd: GleanCounter;
    cssWebkitBorderRadius: GleanCounter;
    cssMozBorderImage: GleanCounter;
    cssWebkitBorderImage: GleanCounter;
    cssWebkitFlexFlow: GleanCounter;
    cssWebkitFlex: GleanCounter;
    cssGridGap: GleanCounter;
    cssWebkitMask: GleanCounter;
    cssWebkitMaskPosition: GleanCounter;
    cssMozTransition: GleanCounter;
    cssWebkitTransition: GleanCounter;
    cssMozAnimation: GleanCounter;
    cssWebkitAnimation: GleanCounter;
    webkitTapHighlightColor: GleanCounter;
    speak: GleanCounter;
    textSizeAdjust: GleanCounter;
    webkitUserDrag: GleanCounter;
    orphans: GleanCounter;
    widows: GleanCounter;
    webkitUserModify: GleanCounter;
    webkitMarginBefore: GleanCounter;
    webkitMarginAfter: GleanCounter;
    webkitMarginStart: GleanCounter;
    webkitColumnBreakInside: GleanCounter;
    webkitPaddingStart: GleanCounter;
    webkitMarginEnd: GleanCounter;
    webkitBoxReflect: GleanCounter;
    webkitPrintColorAdjust: GleanCounter;
    webkitMaskBoxImage: GleanCounter;
    webkitLineBreak: GleanCounter;
    alignmentBaseline: GleanCounter;
    webkitWritingMode: GleanCounter;
    baselineShift: GleanCounter;
    webkitHyphenateCharacter: GleanCounter;
    webkitHighlight: GleanCounter;
    backgroundRepeatX: GleanCounter;
    webkitPaddingEnd: GleanCounter;
    backgroundRepeatY: GleanCounter;
    webkitTextEmphasisColor: GleanCounter;
    webkitMarginTopCollapse: GleanCounter;
    webkitRtlOrdering: GleanCounter;
    webkitPaddingBefore: GleanCounter;
    webkitTextDecorationsInEffect: GleanCounter;
    webkitBorderVerticalSpacing: GleanCounter;
    webkitLocale: GleanCounter;
    webkitPaddingAfter: GleanCounter;
    webkitBorderHorizontalSpacing: GleanCounter;
    colorRendering: GleanCounter;
    webkitColumnBreakBefore: GleanCounter;
    webkitTransformOriginX: GleanCounter;
    webkitTransformOriginY: GleanCounter;
    webkitTextEmphasisPosition: GleanCounter;
    bufferedRendering: GleanCounter;
    webkitTextOrientation: GleanCounter;
    webkitTextCombine: GleanCounter;
    webkitTextEmphasisStyle: GleanCounter;
    webkitTextEmphasis: GleanCounter;
    webkitMaskBoxImageWidth: GleanCounter;
    webkitMaskBoxImageSource: GleanCounter;
    webkitMaskBoxImageOutset: GleanCounter;
    webkitMaskBoxImageSlice: GleanCounter;
    webkitMaskBoxImageRepeat: GleanCounter;
    webkitMarginAfterCollapse: GleanCounter;
    webkitBorderBeforeColor: GleanCounter;
    webkitBorderBeforeWidth: GleanCounter;
    webkitPerspectiveOriginX: GleanCounter;
    webkitPerspectiveOriginY: GleanCounter;
    webkitMarginBeforeCollapse: GleanCounter;
    webkitBorderBeforeStyle: GleanCounter;
    webkitMarginBottomCollapse: GleanCounter;
    webkitRubyPosition: GleanCounter;
    webkitColumnBreakAfter: GleanCounter;
    webkitMarginCollapse: GleanCounter;
    webkitBorderBefore: GleanCounter;
    webkitBorderEnd: GleanCounter;
    webkitBorderAfter: GleanCounter;
    webkitBorderStart: GleanCounter;
    webkitMinLogicalWidth: GleanCounter;
    webkitLogicalHeight: GleanCounter;
    webkitTransformOriginZ: GleanCounter;
    webkitFontSizeDelta: GleanCounter;
    webkitLogicalWidth: GleanCounter;
    webkitMaxLogicalWidth: GleanCounter;
    webkitMinLogicalHeight: GleanCounter;
    webkitMaxLogicalHeight: GleanCounter;
    webkitBorderEndColor: GleanCounter;
    webkitBorderEndWidth: GleanCounter;
    webkitBorderStartColor: GleanCounter;
    webkitBorderStartWidth: GleanCounter;
    webkitBorderAfterColor: GleanCounter;
    webkitBorderAfterWidth: GleanCounter;
    webkitBorderEndStyle: GleanCounter;
    webkitBorderAfterStyle: GleanCounter;
    webkitBorderStartStyle: GleanCounter;
    webkitMaskRepeatX: GleanCounter;
    webkitMaskRepeatY: GleanCounter;
    userZoom: GleanCounter;
    minZoom: GleanCounter;
    webkitBoxDecorationBreak: GleanCounter;
    orientation: GleanCounter;
    maxZoom: GleanCounter;
    webkitAppRegion: GleanCounter;
    webkitColumnRule: GleanCounter;
    webkitColumnSpan: GleanCounter;
    webkitColumnGap: GleanCounter;
    webkitShapeOutside: GleanCounter;
    webkitColumnRuleWidth: GleanCounter;
    webkitColumnCount: GleanCounter;
    webkitOpacity: GleanCounter;
    webkitColumnWidth: GleanCounter;
    webkitShapeImageThreshold: GleanCounter;
    webkitColumnRuleStyle: GleanCounter;
    webkitColumns: GleanCounter;
    webkitColumnRuleColor: GleanCounter;
    webkitShapeMargin: GleanCounter;
  }

  canvas: {
    used2d: Record<string, GleanCounter>;
    webglAcclFailureId: Record<string, GleanCounter>;
    webglFailureId: Record<string, GleanCounter>;
    webglSuccess: Record<string, GleanCounter>;
    webglUsed: Record<string, GleanCounter>;
    webgl2Success: Record<string, GleanCounter>;
  }

  webcrypto: {
    extractableImport: Record<string, GleanCounter>;
    extractableGenerate: Record<string, GleanCounter>;
    extractableEnc: Record<string, GleanCounter>;
    extractableSig: Record<string, GleanCounter>;
    resolved: Record<string, GleanCounter>;
    method: GleanCustomDistribution;
    alg: GleanCustomDistribution;
  }

  geolocation: {
    accuracy: GleanCustomDistribution;
    requestResult: Record<string, GleanCounter>;
    fallback: Record<string, GleanCounter>;
    linuxProvider: Record<string, GleanBoolean>;
  }

  localstorageRequest: {
    prepareDatastoreProcessingTime: GleanTimingDistribution;
    sendCancelCounter: GleanCounter;
    recvCancelCounter: GleanCounter;
  }

  localstorageDatabase: {
    newObjectSetupTime: GleanTimingDistribution;
    requestAllowToCloseResponseTime: GleanTimingDistribution;
  }

  mediadrm: {
    emePlayback: GleanEvent;
    decryption: Record<string, GleanBoolean>;
  }

  hls: {
    canplayRequested: GleanCounter;
    canplaySupported: GleanCounter;
    mediaLoad: GleanEvent;
  }

  gmp: {
    updateXmlFetchResult: Record<string, GleanCounter>;
  }

  mediaAudio: {
    initFailure: Record<string, GleanCounter>;
    backend: Record<string, GleanCounter>;
  }

  mediaPlayback: {
    firstFrameLoaded: GleanEvent;
    deviceHardwareDecoderSupport: Record<string, GleanBoolean>;
    notSupportedVideoPerMimeType: Record<string, GleanCounter>;
    decodeError: GleanEvent;
  }

  media: {
    elementInPageCount: GleanCounter;
    videoHardwareDecodingSupport: Record<string, GleanBoolean>;
    videoHdHardwareDecodingSupport: Record<string, GleanBoolean>;
    error: GleanEvent;
    videoPlayTime: GleanTimingDistribution;
    mediaPlayTime: Record<string, GleanTimingDistribution>;
    audiblePlayTimePercent: Record<string, GleanCustomDistribution>;
    mutedPlayTimePercent: Record<string, GleanCustomDistribution>;
    videoVisiblePlayTime: Record<string, GleanTimingDistribution>;
    videoHiddenPlayTime: GleanTimingDistribution;
    videoHiddenPlayTimePercentage: Record<string, GleanCustomDistribution>;
    videoHdrPlayTime: GleanTimingDistribution;
    videoEncryptedPlayTime: GleanTimingDistribution;
    videoClearkeyPlayTime: GleanTimingDistribution;
    videoWidevinePlayTime: GleanTimingDistribution;
    videoDroppedFramesProportion: GleanCustomDistribution;
    videoDroppedFramesProportionExponential: GleanCustomDistribution;
    videoDroppedDecodedFramesProportionExponential: GleanCustomDistribution;
    videoDroppedSinkFramesProportionExponential: GleanCustomDistribution;
    videoDroppedCompositorFramesProportionExponential: GleanCustomDistribution;
    codecUsed: Record<string, GleanCounter>;
    mseSourceBufferType: Record<string, GleanCounter>;
    decoderBackendUsed: GleanCustomDistribution;
  }

  mediaMp4Parse: {
    sampleDescriptionEntriesHaveMultipleCodecs: Record<string, GleanCounter>;
    sampleDescriptionEntriesHaveMultipleCrypto: Record<string, GleanCounter>;
    numSampleDescriptionEntries: GleanCustomDistribution;
  }

  mfcdm: {
    emePlayback: GleanEvent;
    error: GleanEvent;
  }

  rtcrtpsender: {
    count: GleanCounter;
    countSetparametersCompat: GleanCounter;
    usedSendencodings: GleanRate;
  }

  rtcrtpsenderSetparameters: {
    warnNoGetparameters: GleanRate;
    warnLengthChanged: GleanRate;
    warnNoTransactionid: GleanRate;
    failLengthChanged: GleanRate;
    failRidChanged: GleanRate;
    failNoGetparameters: GleanRate;
    failNoTransactionid: GleanRate;
    failStaleTransactionid: GleanRate;
    failNoEncodings: GleanRate;
    failOther: GleanRate;
  }

  codecStats: {
    ulpfecNegotiated: Record<string, GleanCounter>;
    otherFecSignaled: Record<string, GleanCounter>;
    videoPreferredCodec: Record<string, GleanCounter>;
    audioPreferredCodec: Record<string, GleanCounter>;
  }

  webrtcdtls: {
    protocolVersion: Record<string, GleanCounter>;
    cipher: Record<string, GleanCounter>;
    srtpCipher: Record<string, GleanCounter>;
    clientHandshakeResult: Record<string, GleanCounter>;
    serverHandshakeResult: Record<string, GleanCounter>;
    clientHandshakeStartedCounter: GleanCounter;
    serverHandshakeStartedCounter: GleanCounter;
  }

  webrtcSignaling: {
    sdpNegotiated: GleanEvent;
    audioMsectionNegotiated: GleanEvent;
    videoMsectionNegotiated: GleanEvent;
  }

  webrtcVideo: {
    recvCodecUsed: Record<string, GleanCounter>;
    sendCodecUsed: Record<string, GleanCounter>;
  }

  webrtc: {
    videoQualityInboundBandwidthKbits: GleanCustomDistribution;
    audioQualityInboundBandwidthKbits: GleanCustomDistribution;
    videoQualityInboundPacketlossRate: GleanCustomDistribution;
    audioQualityInboundPacketlossRate: GleanCustomDistribution;
    videoQualityOutboundPacketlossRate: GleanCustomDistribution;
    audioQualityOutboundPacketlossRate: GleanCustomDistribution;
    videoQualityInboundJitter: GleanTimingDistribution;
    audioQualityInboundJitter: GleanTimingDistribution;
    videoQualityOutboundJitter: GleanTimingDistribution;
    audioQualityOutboundJitter: GleanTimingDistribution;
    videoQualityOutboundRtt: GleanTimingDistribution;
    audioQualityOutboundRtt: GleanTimingDistribution;
    videoEncoderBitrateAvgPerCallKbps: GleanCustomDistribution;
    videoEncoderBitrateStdDevPerCallKbps: GleanCustomDistribution;
    videoEncoderFramerateAvgPerCall: GleanCustomDistribution;
    videoEncoderFramerate10xStdDevPerCall: GleanCustomDistribution;
    videoDecoderBitrateAvgPerCallKbps: GleanCustomDistribution;
    videoDecoderBitrateStdDevPerCallKbps: GleanCustomDistribution;
    videoDecoderFramerateAvgPerCall: GleanCustomDistribution;
    videoDecoderFramerate10xStdDevPerCall: GleanCustomDistribution;
    videoDecoderDiscardedPacketsPerCallPpm: GleanCustomDistribution;
    callDuration: GleanTimingDistribution;
    avCallDuration: GleanTimingDistribution;
    callCount3: GleanCounter;
    getUserMediaType: GleanCustomDistribution;
    renegotiations: GleanCustomDistribution;
    maxVideoSendTrack: GleanCustomDistribution;
    maxVideoReceiveTrack: GleanCustomDistribution;
    maxAudioSendTrack: GleanCustomDistribution;
    maxAudioReceiveTrack: GleanCustomDistribution;
    datachannelNegotiated: Record<string, GleanCounter>;
    callType: GleanCustomDistribution;
    softwareH264Enabled: Record<string, GleanCounter>;
    hasH264Hardware: Record<string, GleanCounter>;
    hardwareH264Enabled: Record<string, GleanCounter>;
    h264Enabled: Record<string, GleanCounter>;
    gmpInitSuccess: Record<string, GleanCounter>;
  }

  perf: {
    largestContentfulPaint: GleanTimingDistribution;
    largestContentfulPaintFromResponseStart: GleanTimingDistribution;
    pageLoad: GleanEvent;
    http3PageLoadTime: Record<string, GleanTimingDistribution>;
    http3FirstContentfulPaint: Record<string, GleanTimingDistribution>;
    h3pPageLoadTime: Record<string, GleanTimingDistribution>;
    h3pFirstContentfulPaint: Record<string, GleanTimingDistribution>;
    dnsFirstContentfulPaint: Record<string, GleanTimingDistribution>;
    dnsFirstByte: Record<string, GleanTimingDistribution>;
  }

  performancePageload: {
    loadTime: GleanTimingDistribution;
    loadTimeResponsestart: GleanTimingDistribution;
    fcp: GleanTimingDistribution;
    fcpResponsestart: GleanTimingDistribution;
    http3FcpHttp3: GleanTimingDistribution;
    http3FcpSupportsHttp3: GleanTimingDistribution;
    h3pFcpWithPriority: GleanTimingDistribution;
    http3FcpWithoutPriority: GleanTimingDistribution;
  }

  performanceTime: {
    domInteractive: GleanTimingDistribution;
    domContentLoadedStart: GleanTimingDistribution;
    domContentLoadedEnd: GleanTimingDistribution;
    domComplete: GleanTimingDistribution;
    loadEventStart: GleanTimingDistribution;
    loadEventEnd: GleanTimingDistribution;
    toFirstContentfulPaint: GleanTimingDistribution;
    toDomLoading: GleanTimingDistribution;
    responseStart: GleanTimingDistribution;
  }

  javascriptPageload: {
    executionTime: GleanTimingDistribution;
    delazificationTime: GleanTimingDistribution;
    xdrEncodeTime: GleanTimingDistribution;
    baselineCompileTime: GleanTimingDistribution;
    gcTime: GleanTimingDistribution;
    parseTime: GleanTimingDistribution;
    protectTime: GleanTimingDistribution;
  }

  domContentprocess: {
    buildIdMismatch: GleanCounter;
    buildIdMismatchFalsePositive: GleanCounter;
    osPriorityLowered: GleanCounter;
    osPriorityRaised: GleanCounter;
    osPriorityChangeConsidered: GleanCounter;
    launchMainthread: GleanTimingDistribution;
    launchTotal: GleanTimingDistribution;
    syncLaunch: GleanTimingDistribution;
    launchIsSync: Record<string, GleanCounter>;
  }

  domParentprocess: {
    privateWindowUsed: GleanBoolean;
    processLaunchErrors: Record<string, GleanCounter>;
  }

  domTextfragment: {
    findDirectives: GleanTimingDistribution;
    createDirective: GleanTimingDistribution;
  }

  dom: {
    forgetSkippableDuringIdle: GleanCustomDistribution;
    forgetSkippableFrequency: GleanCustomDistribution;
    fullscreenTransitionBlack: GleanTimingDistribution;
    gcInProgress: GleanTimingDistribution;
    gcSliceDuringIdle: GleanCustomDistribution;
    innerwindowsWithMutationListeners: Record<string, GleanCounter>;
    xmlhttprequestAsyncOrSync: Record<string, GleanCounter>;
    storageAccessApiUi: Record<string, GleanCounter>;
    slowScriptNoticeCount: GleanCounter;
    slowScriptPageCount: GleanCounter;
    scriptLoadingSource: Record<string, GleanCounter>;
    blinkFilesystemUsed: Record<string, GleanCounter>;
    webkitDirectoryUsed: Record<string, GleanCounter>;
  }

  webNotification: {
    insecureContextPermissionRequest: GleanCounter;
    showOrigin: Record<string, GleanCounter>;
    permissionOrigin: Record<string, GleanCounter>;
    requestPermissionOrigin: Record<string, GleanCounter>;
    iconUrlEncoding: Record<string, GleanCounter>;
  }

  screenwakelock: {
    heldDuration: GleanTimingDistribution;
    releaseBatteryLevelDischarging: GleanCustomDistribution;
  }

  webPush: {
    detectedDuplicatedMessageIds: GleanCounter;
    errorCode: Record<string, GleanCounter>;
    contentEncoding: Record<string, GleanCounter>;
    unsubscribedByClearingData: GleanCounter;
    apiNotify: GleanCounter;
  }

  domQuotaTry: {
    errorStep: GleanEvent;
  }

  quotamanager: {
    restoreOriginDirectoryMetadataCounter: GleanCounter;
  }

  quotamanagerInitializeRepository: {
    numberOfIterations: Record<string, GleanCustomDistribution>;
  }

  quotamanagerInitializeTemporarystorage: {
    totalTimeExcludingSuspend: GleanTimingDistribution;
  }

  quotamanagerShutdown: {
    totalTimeExcludingSuspend: GleanTimingDistribution;
  }

  domQuota: {
    infoLoadTime: Record<string, GleanTimingDistribution>;
    shutdownTime: Record<string, GleanTimingDistribution>;
  }

  httpsfirst: {
    upgraded: GleanCounter;
    upgradedSchemeless: GleanCounter;
    downgraded: GleanCounter;
    downgradedSchemeless: GleanCounter;
    downgradedOnTimer: GleanRate;
    downgradedOnTimerSchemeless: GleanRate;
    downgradeTime: GleanTimingDistribution;
    downgradeTimeSchemeless: GleanTimingDistribution;
  }

  mixedContent: {
    pageLoad: GleanCustomDistribution;
    unblockCounter: GleanCustomDistribution;
    hsts: GleanCustomDistribution;
    images: Record<string, GleanCounter>;
    video: Record<string, GleanCounter>;
    audio: Record<string, GleanCounter>;
  }

  securityUi: {
    events: GleanCustomDistribution;
  }

  serviceWorker: {
    launchTime: GleanTimingDistribution;
    isolatedLaunchTime: GleanTimingDistribution;
    registrationLoading: GleanTimingDistribution;
    fetchInterceptionDuration: Record<string, GleanTimingDistribution>;
    fetchEventDispatch: Record<string, GleanTimingDistribution>;
    fetchEventFinishSynthesizedResponse: Record<string, GleanTimingDistribution>;
    fetchEventChannelReset: Record<string, GleanTimingDistribution>;
    running: Record<string, GleanCustomDistribution>;
  }

  localdomstorage: {
    shutdownDatabase: GleanTimingDistribution;
    preloadPendingOnFirstAccess: Record<string, GleanCounter>;
  }

  webauthnCreate: {
    success: GleanCounter;
    failure: GleanCounter;
    authenticatorAttachment: Record<string, GleanCounter>;
    passkey: GleanCounter;
  }

  webauthnGet: {
    success: GleanCounter;
    failure: GleanCounter;
    authenticatorAttachment: Record<string, GleanCounter>;
  }

  workers: {
    serviceWorkerSpawnGetsQueued: GleanCounter;
    sharedWorkerSpawnGetsQueued: GleanCounter;
    dedicatedWorkerSpawnGetsQueued: GleanCounter;
    syncWorkerOperation: Record<string, GleanTimingDistribution>;
  }

  htmleditors: {
    withBeforeinputListeners: Record<string, GleanCounter>;
    overriddenByBeforeinputListeners: Record<string, GleanCounter>;
    withMutationListenersWithoutBeforeinputListeners: Record<string, GleanCounter>;
    withMutationObserversWithoutBeforeinputListeners: Record<string, GleanCounter>;
  }

  permissions: {
    sqlCorrupted: GleanCounter;
    defectiveSqlRemoved: GleanCounter;
  }

  paint: {
    buildDisplaylistTime: GleanTimingDistribution;
  }

  gpuProcess: {
    featureStatus: GleanString;
    crashFallbacks: Record<string, GleanCounter>;
    totalLaunchAttempts: GleanQuantity;
    unstableLaunchAttempts: GleanQuantity;
    launchTime: GleanTimingDistribution;
    initializationTime: GleanTimingDistribution;
  }

  wr: {
    gpuWaitTime: GleanTimingDistribution;
    rasterizeGlyphsTime: GleanTimingDistribution;
    rasterizeBlobsTime: GleanTimingDistribution;
    rendererTime: GleanTimingDistribution;
    rendererTimeNoSc: GleanTimingDistribution;
    framebuildTime: GleanTimingDistribution;
    scenebuildTime: GleanTimingDistribution;
    shaderloadTime: GleanTimingDistribution;
    sceneswapTime: GleanTimingDistribution;
    textureCacheUpdateTime: GleanTimingDistribution;
    timeToFrameBuild: GleanTimingDistribution;
    timeToRenderStart: GleanTimingDistribution;
  }

  gfx: {
    compositeTime: GleanTimingDistribution;
    scrollPresentLatency: GleanTimingDistribution;
    skippedComposites: GleanCounter;
    osCompositor: GleanBoolean;
    linuxWindowProtocol: GleanString;
    supportsHdr: GleanBoolean;
    compositeSwapTime: GleanCustomDistribution;
    compositeFrameRoundtripTime: GleanTimingDistribution;
    deviceResetReason: GleanCustomDistribution;
    forcedDeviceResetReason: GleanCustomDistribution;
    graphicsDriverStartupTest: GleanCustomDistribution;
    contentFailedToAcquireDevice: GleanCustomDistribution;
    crash: GleanCustomDistribution;
    macosVideoLowPower: Record<string, GleanCounter>;
    sanityTest: GleanCustomDistribution;
    d2dEnabled: GleanBoolean;
    dwriteEnabled: GleanBoolean;
    contentBackend: GleanString;
    headless: GleanBoolean;
    targetFrameRate: GleanQuantity;
    textScaleFactor: GleanString;
    monitors: GleanObject;
    adapters: GleanObject;
  }

  gfxDisplay: {
    count: GleanQuantity;
    primaryWidth: GleanQuantity;
    primaryHeight: GleanQuantity;
    scaling: GleanCustomDistribution;
  }

  gfxCheckerboard: {
    duration: GleanTimingDistribution;
    peakPixelCount: GleanCustomDistribution;
    potentialDuration: GleanTimingDistribution;
    severity: GleanCustomDistribution;
  }

  gfxFeature: {
    webrender: GleanString;
  }

  gfxStatus: {
    compositor: GleanString;
    lastCompositorGeckoVersion: GleanString;
    headless: GleanBoolean;
  }

  gfxContentFrameTime: {
    fromPaint: GleanCustomDistribution;
    fromVsync: GleanCustomDistribution;
    withSvg: GleanCustomDistribution;
    withoutResourceUpload: GleanCustomDistribution;
    withoutUpload: GleanCustomDistribution;
    reason: Record<string, GleanCounter>;
  }

  gfxContent: {
    paintTime: GleanTimingDistribution;
    fullPaintTime: GleanTimingDistribution;
    smallPaintPhaseWeightPartial: Record<string, GleanCustomDistribution>;
    largePaintPhaseWeightPartial: Record<string, GleanCustomDistribution>;
    smallPaintPhaseWeightFull: Record<string, GleanCustomDistribution>;
    largePaintPhaseWeightFull: Record<string, GleanCustomDistribution>;
  }

  gfxAdapterPrimary: {
    description: GleanString;
    vendorId: GleanString;
    deviceId: GleanString;
    subsystemId: GleanString;
    ram: GleanQuantity;
    driverFiles: GleanString;
    driverVendor: GleanString;
    driverVersion: GleanString;
    driverDate: GleanString;
  }

  gfxHdr: {
    windowsDisplayColorspaceBitfield: GleanQuantity;
  }

  fontlist: {
    initotherfamilynames: GleanTimingDistribution;
    initotherfamilynamesNoDeferring: GleanTimingDistribution;
    initfacenamelists: GleanTimingDistribution;
    bundledfontsActivate: GleanTimingDistribution;
    dwritefontDelayedinitTotal: GleanTimingDistribution;
    dwritefontDelayedinitCount: GleanCustomDistribution;
    dwritefontDelayedinitCollect: GleanTimingDistribution;
    dwritefontInitProblem: GleanCustomDistribution;
    systemFontFallback: GleanTimingDistribution;
    systemFontFallbackFirst: GleanTimingDistribution;
    fontCacheHit: Record<string, GleanCounter>;
    badFallbackFont: Record<string, GleanCounter>;
    gdiInitTotal: GleanTimingDistribution;
    macInitTotal: GleanTimingDistribution;
  }

  apzZoom: {
    activity: Record<string, GleanCounter>;
    pinchsource: GleanCustomDistribution;
  }

  webfont: {
    downloadTime: GleanTimingDistribution;
    fonttype: GleanCustomDistribution;
    srctype: GleanCustomDistribution;
    perPage: GleanCounter;
    sizePerPage: GleanMemoryDistribution;
    size: GleanMemoryDistribution;
    compressionWoff: GleanCustomDistribution;
    compressionWoff2: GleanCustomDistribution;
  }

  avif: {
    decodeResult: Record<string, GleanCounter>;
    decoder: Record<string, GleanCounter>;
    aomDecodeError: Record<string, GleanCounter>;
    yuvColorSpace: Record<string, GleanCounter>;
    bitDepth: Record<string, GleanCounter>;
    alpha: Record<string, GleanCounter>;
    colr: Record<string, GleanCounter>;
    cicpCp: Record<string, GleanCounter>;
    cicpTc: Record<string, GleanCounter>;
    cicpMc: Record<string, GleanCounter>;
    ispe: Record<string, GleanCounter>;
    pixi: Record<string, GleanCounter>;
    pasp: Record<string, GleanCounter>;
    a1lx: Record<string, GleanCounter>;
    a1op: Record<string, GleanCounter>;
    clap: Record<string, GleanCounter>;
    grid: Record<string, GleanCounter>;
    ipro: Record<string, GleanCounter>;
    lsel: Record<string, GleanCounter>;
    dav1dGetPictureReturnValue: GleanEvent;
    majorBrand: Record<string, GleanCounter>;
    sequence: Record<string, GleanCounter>;
  }

  imageDecode: {
    time: GleanTimingDistribution;
    onDrawLatency: GleanTimingDistribution;
    chunks: GleanCustomDistribution;
    count: GleanCustomDistribution;
    speedJpeg: GleanMemoryDistribution;
    speedGif: GleanMemoryDistribution;
    speedPng: GleanMemoryDistribution;
    speedWebp: GleanMemoryDistribution;
    speedAvif: GleanMemoryDistribution;
  }

  intl: {
    requestedLocales: GleanStringList;
    availableLocales: GleanStringList;
    appLocales: GleanStringList;
    systemLocales: GleanStringList;
    regionalPrefsLocales: GleanStringList;
    acceptLanguages: GleanStringList;
  }

  process: {
    childLaunch: GleanTimingDistribution;
    lifetime: GleanTimingDistribution;
  }

  ipc: {
    transactionCancel: Record<string, GleanCounter>;
  }

  subprocess: {
    abnormalAbort: Record<string, GleanCounter>;
    crashesWithDump: Record<string, GleanCounter>;
    launchFailure: Record<string, GleanCounter>;
    killHard: Record<string, GleanCounter>;
  }

  javascriptIon: {
    compileTime: GleanTimingDistribution;
  }

  javascriptGc: {
    totalTime: GleanTimingDistribution;
    minorTime: GleanTimingDistribution;
    prepareTime: GleanTimingDistribution;
    markRootsTime: GleanTimingDistribution;
    markTime: GleanTimingDistribution;
    sweepTime: GleanTimingDistribution;
    compactTime: GleanTimingDistribution;
    sliceTime: GleanTimingDistribution;
    budget: GleanTimingDistribution;
    budgetOverrun: GleanTimingDistribution;
    animation: GleanTimingDistribution;
    maxPause: GleanTimingDistribution;
    markGray: GleanTimingDistribution;
    markWeak: GleanTimingDistribution;
    timeBetween: GleanTimingDistribution;
    timeBetweenSlices: GleanTimingDistribution;
    taskStartDelay: GleanTimingDistribution;
    nurseryBytes: GleanMemoryDistribution;
    effectiveness: GleanCustomDistribution;
    zoneCount: GleanCustomDistribution;
    zonesCollected: GleanCustomDistribution;
    pretenureCount: GleanCustomDistribution;
    markRate: GleanCustomDistribution;
    sliceCount: GleanCustomDistribution;
    parallelMarkSpeedup: GleanCustomDistribution;
    parallelMarkInterruptions: GleanCustomDistribution;
    parallelMarkUtilization: GleanCustomDistribution;
    mmu50: GleanCustomDistribution;
    nurseryPromotionRate: GleanCustomDistribution;
    tenuredSurvivalRate: GleanCustomDistribution;
    isZoneGc: Record<string, GleanCounter>;
    budgetWasIncreased: Record<string, GleanCounter>;
    sliceWasLong: Record<string, GleanCounter>;
    reset: Record<string, GleanCounter>;
    nonIncremental: Record<string, GleanCounter>;
    parallelMarkUsed: Record<string, GleanCounter>;
    reason: Record<string, GleanCounter>;
    slowPhase: Record<string, GleanCounter>;
    slowTask: Record<string, GleanCounter>;
    resetReason: Record<string, GleanCounter>;
    nonIncrementalReason: Record<string, GleanCounter>;
    minorReason: Record<string, GleanCounter>;
    minorReasonLong: Record<string, GleanCounter>;
  }

  slowScriptWarning: {
    shownBrowser: GleanEvent;
    shownContent: GleanEvent;
    notifyDelay: GleanTimingDistribution;
  }

  scriptPreloader: {
    mainthreadRecompile: GleanCounter;
    requests: Record<string, GleanCounter>;
    waitTime: GleanTimingDistribution;
  }

  layout: {
    refreshDriverTick: GleanTimingDistribution;
    paintRasterizeTime: GleanTimingDistribution;
    refreshDriverChromeFrameDelay: GleanTimingDistribution;
    refreshDriverContentFrameDelay: GleanTimingDistribution;
    inputEventResponse: GleanTimingDistribution;
    inputEventResponseCoalesced: GleanTimingDistribution;
    loadInputEventResponse: GleanTimingDistribution;
    longReflowInterruptible: Record<string, GleanCounter>;
    timeToFirstInteraction: GleanTimingDistribution;
    inputEventQueuedClick: GleanTimingDistribution;
    inputEventQueuedKeyboard: GleanTimingDistribution;
  }

  geckoview: {
    pageLoadProgressTime: GleanTimingDistribution;
    pageLoadTime: GleanTimingDistribution;
    pageReloadTime: GleanTimingDistribution;
    documentSiteOrigins: GleanCustomDistribution;
    perDocumentSiteOrigins: GleanCustomDistribution;
    startupRuntime: GleanTimingDistribution;
    contentProcessLifetime: GleanTimingDistribution;
  }

  zeroByteLoad: {
    loadFtl: GleanEvent;
    loadDtd: GleanEvent;
    loadProperties: GleanEvent;
    loadJs: GleanEvent;
    loadXml: GleanEvent;
    loadXhtml: GleanEvent;
    loadCss: GleanEvent;
    loadJson: GleanEvent;
    loadHtml: GleanEvent;
    loadPng: GleanEvent;
    loadSvg: GleanEvent;
    loadOthers: GleanEvent;
  }

  preferences: {
    prefsFileWasInvalid: GleanBoolean;
    userPrefs: GleanObject;
  }

  network: {
    diskCacheShutdownV2: GleanTimingDistribution;
    diskCache2ShutdownClearPrivate: GleanTimingDistribution;
    cacheV2OutputStreamStatus: GleanCustomDistribution;
    cacheV2InputStreamStatus: GleanCustomDistribution;
    cacheSize: Record<string, GleanMemoryDistribution>;
    cacheEntryCount: Record<string, GleanCustomDistribution>;
    cacheSizeShare: Record<string, GleanCustomDistribution>;
    cacheEntryCountShare: Record<string, GleanCustomDistribution>;
    httpCacheEntryReloadTime: GleanTimingDistribution;
    httpCacheEntryAliveTime: GleanTimingDistribution;
    httpCacheEntryReuseCount: GleanCustomDistribution;
    id: GleanCustomDistribution;
    idOnline: Record<string, GleanCounter>;
    backgroundfilesaverThreadCount: GleanCustomDistribution;
    ipv4AndIpv6AddressConnectivity: GleanCustomDistribution;
    relPreloadMissRatio: Record<string, GleanCounter>;
    byteRangeRequest: Record<string, GleanCounter>;
    cacheReadTime: GleanTimingDistribution;
    completeLoad: GleanTimingDistribution;
    completeLoadCached: GleanTimingDistribution;
    completeLoadNet: GleanTimingDistribution;
    corsAuthorizationHeader: Record<string, GleanCounter>;
    cacheHitTime: GleanTimingDistribution;
    cacheMissTime: GleanTimingDistribution;
    cacheHitMissStatPerCacheSize: Record<string, GleanCounter>;
    cacheHitRatePerCacheSize: Record<string, GleanCustomDistribution>;
    fontDownloadEnd: GleanTimingDistribution;
    firstFromCache: GleanTimingDistribution;
    tcpConnection: GleanTimingDistribution;
    dnsStart: GleanTimingDistribution;
    dnsEnd: GleanTimingDistribution;
    httpRevalidation: GleanTimingDistribution;
    firstSentToLastReceived: GleanTimingDistribution;
    openToFirstSent: GleanTimingDistribution;
    openToFirstReceived: GleanTimingDistribution;
    subCacheReadTime: GleanTimingDistribution;
    subCompleteLoad: GleanTimingDistribution;
    subCompleteLoadCached: GleanTimingDistribution;
    subCompleteLoadNet: GleanTimingDistribution;
    subDnsStart: GleanTimingDistribution;
    subDnsEnd: GleanTimingDistribution;
    subFirstFromCache: GleanTimingDistribution;
    subFirstSentToLastReceived: GleanTimingDistribution;
    subHttpRevalidation: GleanTimingDistribution;
    subOpenToFirstSent: GleanTimingDistribution;
    subOpenToFirstReceived: GleanTimingDistribution;
    subTlsHandshake: GleanTimingDistribution;
    subTcpConnection: GleanTimingDistribution;
    pageLoadSize: Record<string, GleanMemoryDistribution>;
    tlsEarlyDataNegotiated: Record<string, GleanCounter>;
    tlsEarlyDataAccepted: Record<string, GleanCounter>;
    tlsEarlyDataBytesWritten: GleanCustomDistribution;
    tlsHandshake: GleanTimingDistribution;
    http3TlsHandshake: Record<string, GleanTimingDistribution>;
    supHttp3TcpConnection: Record<string, GleanTimingDistribution>;
    http3OpenToFirstSent: Record<string, GleanTimingDistribution>;
    http3FirstSentToLastReceived: Record<string, GleanTimingDistribution>;
    http3OpenToFirstReceived: Record<string, GleanTimingDistribution>;
    http3CompleteLoad: Record<string, GleanTimingDistribution>;
    httpFetchDuration: Record<string, GleanTimingDistribution>;
    systemChannelSuccessOrFailure: Record<string, GleanCounter>;
    systemChannelUpdateStatus: Record<string, GleanCounter>;
    systemChannelAddonversionStatus: Record<string, GleanCounter>;
    systemChannelAddonStatus: Record<string, GleanCounter>;
    systemChannelRemoteSettingsStatus: Record<string, GleanCounter>;
    systemChannelTelemetryStatus: Record<string, GleanCounter>;
    systemChannelOtherStatus: Record<string, GleanCounter>;
    alpnMismatchCount: Record<string, GleanCounter>;
    raceCacheWithNetworkUsage: Record<string, GleanCounter>;
    raceCacheWithNetworkSavedTime: GleanTimingDistribution;
    raceCacheWithNetworkOcecOnStartDiff: GleanTimingDistribution;
    raceCacheBandwidthRaceNetworkWin: GleanMemoryDistribution;
    raceCacheBandwidthRaceCacheWin: GleanMemoryDistribution;
    raceCacheBandwidthNotRace: GleanMemoryDistribution;
    raceCacheValidation: Record<string, GleanCounter>;
    backPressureSuspensionRate: Record<string, GleanCounter>;
    backPressureSuspensionCpType: GleanCustomDistribution;
    backPressureSuspensionDelayTime: GleanTimingDistribution;
    asyncOpenChildToTransactionPendingExp: Record<string, GleanTimingDistribution>;
    responseStartParentToContentExp: Record<string, GleanTimingDistribution>;
    dnsEndToConnectStartExp: Record<string, GleanTimingDistribution>;
    responseEndParentToContent: Record<string, GleanTimingDistribution>;
    trrIdleCloseTimeH1: Record<string, GleanTimingDistribution>;
    trrIdleCloseTimeH2: Record<string, GleanTimingDistribution>;
    trrIdleCloseTimeH3: Record<string, GleanTimingDistribution>;
  }

  dns: {
    lookupMethod: GleanCustomDistribution;
    gracePeriodRenewal: Record<string, GleanCounter>;
    cleanupAge: GleanTimingDistribution;
    byTypeCleanupAge: GleanTimingDistribution;
    prematureEviction: GleanTimingDistribution;
    byTypePrematureEviction: GleanTimingDistribution;
    trrLookupTime: Record<string, GleanTimingDistribution>;
    trrProcessingTime: GleanTimingDistribution;
    trrSkipReasonTrrFirst: Record<string, GleanCustomDistribution>;
    trrSkipReasonNativeSuccess: Record<string, GleanCustomDistribution>;
    trrSkipReasonNativeFailed: Record<string, GleanCustomDistribution>;
    trrRelevantSkipReasonTrrFirst: Record<string, GleanCustomDistribution>;
    trrRelevantSkipReasonNativeSuccess: Record<string, GleanCustomDistribution>;
    trrRelevantSkipReasonNativeFailed: Record<string, GleanCustomDistribution>;
    trrSkipReasonStrictMode: Record<string, GleanCustomDistribution>;
    trrSkipReasonRetrySuccess: Record<string, GleanCustomDistribution>;
    trrSkipReasonRetryFailed: Record<string, GleanCustomDistribution>;
    trrRelevantSkipReasonTrrFirstTypeRec: Record<string, GleanCustomDistribution>;
    trrAttemptCount: Record<string, GleanCustomDistribution>;
    nativeLookupTime: GleanTimingDistribution;
    byTypeFailedLookupTime: GleanTimingDistribution;
    byTypeSucceededLookupTime: GleanTimingDistribution;
    nativeQueuing: GleanTimingDistribution;
    lookupAlgorithm: Record<string, GleanCounter>;
    blocklistCount: GleanCustomDistribution;
  }

  networkDns: {
    trrConfirmationContext: GleanEvent;
  }

  networkSso: {
    entraSuccess: Record<string, GleanCounter>;
    totalEntraUses: GleanCounter;
  }

  predictor: {
    learnAttempts: GleanCustomDistribution;
    waitTime: GleanTimingDistribution;
    predictWorkTime: GleanTimingDistribution;
    learnWorkTime: GleanTimingDistribution;
    totalPredictions: GleanCustomDistribution;
    totalPrefetches: GleanCustomDistribution;
    prefetchUseStatus: Record<string, GleanCounter>;
    prefetchTime: GleanTimingDistribution;
    totalPreconnects: GleanCustomDistribution;
    totalPreresolves: GleanCustomDistribution;
    predictionsCalculated: GleanCustomDistribution;
    globalDegradation: GleanCustomDistribution;
    subresourceDegradation: GleanCustomDistribution;
    baseConfidence: GleanCustomDistribution;
    confidence: GleanCustomDistribution;
    predictTimeToAction: GleanTimingDistribution;
    predictTimeToInaction: GleanTimingDistribution;
    prefetchDecisionReason: GleanCustomDistribution;
    prefetchIgnoreReason: GleanCustomDistribution;
  }

  sts: {
    pollAndEventsCycle: GleanTimingDistribution;
    pollCycle: GleanTimingDistribution;
    pollAndEventTheLastCycle: GleanTimingDistribution;
    pollBlockTime: GleanTimingDistribution;
  }

  networkCookies: {
    sqliteOpenReadahead: GleanTimingDistribution;
  }

  netwerk: {
    parentConnectTimeout: GleanCounter;
    http30rttState: Record<string, GleanCounter>;
    http30rttStateDuration: Record<string, GleanTimingDistribution>;
    http3TimeToReuseIdleConnection: Record<string, GleanTimingDistribution>;
  }

  opaqueResponseBlocking: {
    javascriptValidationCount: GleanCounter;
    crossOriginOpaqueResponseCount: GleanCounter;
  }

  orb: {
    javascriptValidation: Record<string, GleanTimingDistribution>;
    receiveDataForValidation: Record<string, GleanTimingDistribution>;
    didEverBlockResponse: Record<string, GleanCounter>;
    blockReason: Record<string, GleanCounter>;
    blockInitiator: Record<string, GleanCounter>;
  }

  hpack: {
    elementsEvictedDecompressor: GleanCustomDistribution;
    bytesEvictedDecompressor: GleanMemoryDistribution;
    bytesEvictedRatioDecompressor: GleanCustomDistribution;
    peakCountDecompressor: GleanCustomDistribution;
    peakSizeDecompressor: GleanMemoryDistribution;
    elementsEvictedCompressor: GleanCustomDistribution;
    bytesEvictedCompressor: GleanMemoryDistribution;
    bytesEvictedRatioCompressor: GleanCustomDistribution;
    peakCountCompressor: GleanCustomDistribution;
    peakSizeCompressor: GleanMemoryDistribution;
  }

  spdy: {
    parallelStreams: GleanCustomDistribution;
    requestPerConn: GleanCustomDistribution;
    serverInitiatedStreams: GleanCustomDistribution;
    chunkRecvd: GleanMemoryDistribution;
    synSize: GleanMemoryDistribution;
    synRatio: GleanCustomDistribution;
    synReplySize: GleanMemoryDistribution;
    synReplyRatio: GleanCustomDistribution;
    kbreadPerConn: GleanMemoryDistribution;
    settingsMaxStreams: GleanCustomDistribution;
    settingsIw: GleanMemoryDistribution;
    goawayLocal: GleanCustomDistribution;
    goawayPeer: GleanCustomDistribution;
    continuedHeaders: GleanMemoryDistribution;
  }

  http: {
    subitemOpenLatencyTime: GleanTimingDistribution;
    subitemFirstByteLatencyTime: GleanTimingDistribution;
    requestPerPage: GleanCustomDistribution;
    requestPerPageFromCache: GleanCustomDistribution;
    requestPerConn: GleanCustomDistribution;
    kbreadPerConn2: GleanMemoryDistribution;
    proxyType: GleanCustomDistribution;
    transactionIsSsl: Record<string, GleanCounter>;
    pageloadIsSsl: Record<string, GleanCounter>;
    transactionUseAltsvc: Record<string, GleanCounter>;
    altsvcEntriesPerHeader: GleanCustomDistribution;
    altsvcMappingChangedTarget: Record<string, GleanCounter>;
    uploadBandwidthMbps: Record<string, GleanCustomDistribution>;
    responseVersion: GleanCustomDistribution;
    channelDisposition: GleanCustomDistribution;
    channelOnstartSuccess: Record<string, GleanCounter>;
    channelPageOnstartSuccessTrr: Record<string, GleanCustomDistribution>;
    channelSubOnstartSuccessTrr: Record<string, GleanCustomDistribution>;
    connectionEntryCacheHit: Record<string, GleanCounter>;
    sawQuicAltProtocol: GleanCustomDistribution;
    contentEncoding: GleanCustomDistribution;
    connectionCloseReason: Record<string, GleanCustomDistribution>;
    transactionRestartReason: GleanCustomDistribution;
    transactionEchRetryWithEchCount: GleanCustomDistribution;
    transactionEchRetryWithoutEchCount: GleanCustomDistribution;
    transactionEchRetryEchFailedCount: GleanCustomDistribution;
    transactionEchRetryOthersCount: GleanCustomDistribution;
    transactionWaitTimeHttp: GleanTimingDistribution;
    transactionWaitTimeSpdy: GleanTimingDistribution;
    transactionWaitTimeHttp3: GleanTimingDistribution;
    transactionWaitTimeHttp2SupHttp3: GleanTimingDistribution;
    tlsEarlyDataNegotiated: GleanCustomDistribution;
    tlsEarlyDataAccepted: Record<string, GleanCounter>;
    http2FailBeforeSettings: Record<string, GleanCounter>;
    cacheLmInconsistent: Record<string, GleanCounter>;
    dntUsage: GleanCustomDistribution;
    dnsHttpssvcRecordReceivingStage: GleanCustomDistribution;
    dnsHttpssvcConnectionFailedReason: GleanCustomDistribution;
    scriptBlockIncorrectMime: Record<string, GleanCounter>;
    echconfigSuccessRate: Record<string, GleanCounter>;
  }

  http3: {
    echOutcome: Record<string, GleanCustomDistribution>;
    connectionCloseCode: Record<string, GleanCustomDistribution>;
    timerDelayed: GleanTimingDistribution;
    requestPerConn: GleanCustomDistribution;
    blockedByStreamLimitPerConn: GleanCustomDistribution;
    transBlockedByStreamLimitPerConn: GleanCustomDistribution;
    transSendingBlockedByFlowControlPerConn: GleanCustomDistribution;
    sendingBlockedByFlowControlPerTrans: GleanCustomDistribution;
    lossRatio: GleanCustomDistribution;
    lateAckRatio: Record<string, GleanCustomDistribution>;
    lateAck: Record<string, GleanCustomDistribution>;
    countsPto: Record<string, GleanCustomDistribution>;
    dropDgrams: GleanCustomDistribution;
    savedDgrams: GleanCustomDistribution;
    receivedSentDgrams: Record<string, GleanCustomDistribution>;
  }

  websockets: {
    handshakeType: GleanCustomDistribution;
  }

  parsing: {
    svgUnusualPcdata: GleanRate;
  }

  ysod: {
    shownYsod: GleanEvent;
  }

  certVerifier: {
    crliteStatus: Record<string, GleanCounter>;
    crliteVsOcspResult: Record<string, GleanCounter>;
    certRevocationMechanisms: Record<string, GleanCounter>;
    trustObjCount: GleanQuantity;
  }

  certSignatureCache: {
    hits: GleanRate;
    total: GleanCounter;
  }

  certTrustCache: {
    hits: GleanRate;
    total: GleanCounter;
  }

  sctSignatureCache: {
    hits: GleanRate;
    total: GleanCounter;
  }

  certStorage: {
    memory: GleanMemoryDistribution;
  }

  dataStorage: {
    alternateServices: GleanQuantity;
    clientAuthRememberList: GleanQuantity;
    siteSecurityServiceState: GleanQuantity;
  }

  tls: {
    certificateVerifications: GleanCounter;
    xyberIntoleranceReason: Record<string, GleanCounter>;
    cipherSuite: GleanCustomDistribution;
  }

  certCompression: {
    failures: Record<string, GleanCounter>;
  }

  verificationUsedCertFrom: {
    tlsHandshake: GleanRate;
    preloadedIntermediates: GleanRate;
    thirdPartyCertificates: GleanRate;
    nssCertDb: GleanRate;
    builtInRootsModule: GleanRate;
  }

  pkcs11: {
    thirdPartyModulesLoaded: GleanQuantity;
    externalTrustAnchorModuleLoaded: GleanBoolean;
  }

  certVerificationTime: {
    success: GleanTimingDistribution;
    failure: GleanTimingDistribution;
  }

  ocspRequestTime: {
    success: GleanTimingDistribution;
    failure: GleanTimingDistribution;
    cancel: GleanTimingDistribution;
  }

  cert: {
    evStatus: GleanCustomDistribution;
    validationSuccessByCa: GleanCustomDistribution;
    chainKeySizeStatus: GleanCustomDistribution;
    validationHttpRequestResult: GleanCustomDistribution;
  }

  certPinning: {
    failuresByCa: GleanCustomDistribution;
    results: Record<string, GleanCounter>;
    testResults: Record<string, GleanCounter>;
    mozResultsByHost: GleanCustomDistribution;
    mozTestResultsByHost: GleanCustomDistribution;
  }

  sslHandshake: {
    version: GleanCustomDistribution;
    privacy: GleanCustomDistribution;
    result: GleanCustomDistribution;
    resultFirstTry: GleanCustomDistribution;
    resultConservative: GleanCustomDistribution;
    resultEch: GleanCustomDistribution;
    resultEchGrease: GleanCustomDistribution;
    completed: GleanCustomDistribution;
  }

  ssl: {
    timeUntilReady: GleanTimingDistribution;
    timeUntilReadyFirstTry: GleanTimingDistribution;
    timeUntilReadyConservative: GleanTimingDistribution;
    timeUntilReadyEch: GleanTimingDistribution;
    timeUntilReadyEchGrease: GleanTimingDistribution;
    timeUntilHandshakeFinishedKeyedByKa: Record<string, GleanTimingDistribution>;
    bytesBeforeCertCallback: GleanMemoryDistribution;
    npnType: GleanCustomDistribution;
    resumedSession: Record<string, GleanCounter>;
    keyExchangeAlgorithmFull: GleanCustomDistribution;
    keyExchangeAlgorithmResumed: GleanCustomDistribution;
    tls13IntoleranceReasonPre: GleanCustomDistribution;
    tls13IntoleranceReasonPost: GleanCustomDistribution;
    tls12IntoleranceReasonPre: GleanCustomDistribution;
    tls12IntoleranceReasonPost: GleanCustomDistribution;
    tls11IntoleranceReasonPre: GleanCustomDistribution;
    tls11IntoleranceReasonPost: GleanCustomDistribution;
    tls10IntoleranceReasonPre: GleanCustomDistribution;
    tls10IntoleranceReasonPost: GleanCustomDistribution;
    versionFallbackInappropriate: GleanCustomDistribution;
    keaRsaKeySizeFull: GleanCustomDistribution;
    keaDheKeySizeFull: GleanCustomDistribution;
    keaEcdheCurveFull: GleanCustomDistribution;
    authAlgorithmFull: GleanCustomDistribution;
    authRsaKeySizeFull: GleanCustomDistribution;
    authEcdsaCurveFull: GleanCustomDistribution;
    reasonsForNotFalseStarting: GleanCustomDistribution;
    ocspStapling: GleanCustomDistribution;
    certErrorOverrides: GleanCustomDistribution;
    certVerificationErrors: GleanCustomDistribution;
    ctPolicyNonCompliantConnectionsByCa: GleanCustomDistribution;
    permanentCertErrorOverrides: GleanCustomDistribution;
    sctsOrigin: GleanCustomDistribution;
    sctsPerConnection: GleanCustomDistribution;
    sctsVerificationStatus: GleanCustomDistribution;
  }

  sandbox: {
    rejectedSyscalls: Record<string, GleanCounter>;
    failedLaunchKeyed: Record<string, GleanCustomDistribution>;
    hasUserNamespaces: Record<string, GleanCounter>;
    effectiveContentProcessLevel: GleanQuantity;
    contentWin32kLockdownState: GleanQuantity;
  }

  uptakeRemotecontentResult: {
    uptakeRemotesettings: GleanEvent;
    uptakeNormandy: GleanEvent;
  }

  clientAssociation: {
    uid: GleanString;
    legacyClientId: GleanUuid;
  }

  fxa: {
    connectAccount: GleanEvent;
    disconnectAccount: GleanEvent;
    syncEnabled: GleanBoolean;
    accountEnabled: GleanBoolean;
  }

  syncSettings: {
    openChooseWhatToSyncMenu: GleanEvent;
    save: GleanEvent;
  }

  fxaAvatarMenu: {
    clickAccountSettings: GleanEvent;
    clickCad: GleanEvent;
    clickLogin: GleanEvent;
    clickSendTab: GleanEvent;
    clickSyncNow: GleanEvent;
    clickSyncSettings: GleanEvent;
    clickSyncTabs: GleanEvent;
    clickSyncTabsSidebar: GleanEvent;
    clickToolbarIcon: GleanEvent;
    clickUnverSyncSettings: GleanEvent;
    clickOpenMonitor: GleanEvent;
    clickOpenSend: GleanEvent;
    clickMonitorCta: GleanEvent;
    clickRelayCta: GleanEvent;
    clickVpnCta: GleanEvent;
    clickSyncCta: GleanEvent;
  }

  fxaAppMenu: {
    clickAccountSettings: GleanEvent;
    clickCad: GleanEvent;
    clickLogin: GleanEvent;
    clickSendTab: GleanEvent;
    clickSyncNow: GleanEvent;
    clickSyncSettings: GleanEvent;
    clickSyncTabs: GleanEvent;
    clickSyncTabsSidebar: GleanEvent;
    clickToolbarIcon: GleanEvent;
    clickUnverSyncSettings: GleanEvent;
    clickOpenMonitor: GleanEvent;
    clickOpenSend: GleanEvent;
    clickMonitorCta: GleanEvent;
    clickRelayCta: GleanEvent;
    clickVpnCta: GleanEvent;
    clickSyncCta: GleanEvent;
  }

  syncMergeDialog: {
    clicked: GleanEvent;
  }

  sync: {
    deviceCountDesktop: GleanCustomDistribution;
    deviceCountMobile: GleanCustomDistribution;
  }

  startupCache: {
    requests: Record<string, GleanCounter>;
  }

  bounceTrackingProtection: {
    purgeDuration: GleanTimingDistribution;
    numHostsPerPurgeRun: GleanCustomDistribution;
    purgeCount: Record<string, GleanCounter>;
    purgeAction: GleanEvent;
    mode: GleanQuantity;
    purgeCountClassifiedTracker: GleanCounter;
  }

  contentblocking: {
    category: GleanQuantity;
    cryptominingBlockingEnabled: GleanBoolean;
    fingerprintingBlockingEnabled: GleanBoolean;
    trackersBlockedCount: GleanCounter;
    canvasFingerprintingPerTab: Record<string, GleanCustomDistribution>;
    fontFingerprintingPerTab: Record<string, GleanCounter>;
    storageAccessGrantedCount: Record<string, GleanCounter>;
    storageAccessRemainingDays: GleanCustomDistribution;
    queryStrippingCount: Record<string, GleanCounter>;
    queryStrippingParamCount: GleanCustomDistribution;
    queryStrippingCountByParam: Record<string, GleanCounter>;
    emailTrackerCount: Record<string, GleanCounter>;
    emailTrackerEmbeddedPerTab: Record<string, GleanCustomDistribution>;
    stripOnShareParamsRemoved: GleanCustomDistribution;
    stripOnShareLengthDecrease: GleanCustomDistribution;
    cookieBehavior: GleanCustomDistribution;
    trackingProtectionEnabled: Record<string, GleanCounter>;
    trackingProtectionPbmDisabled: Record<string, GleanCounter>;
    trackingProtectionShield: GleanCustomDistribution;
    fingerprintersBlockedCount: Record<string, GleanCounter>;
    cryptominersBlockedCount: Record<string, GleanCounter>;
  }

  cookiePurging: {
    originsPurged: GleanCustomDistribution;
    trackersWithUserInteraction: GleanCustomDistribution;
    trackersUserInteractionRemainingDays: GleanTimingDistribution;
    duration: GleanTimingDistribution;
    intervalHours: GleanTimingDistribution;
  }

  hangs: {
    reports: GleanObject;
    modules: GleanObject;
  }

  backgroundTasksRmdirBase: {
    metricBase: GleanEvent;
    elapsedMs: GleanQuantity;
    wasFirst: GleanBoolean;
    retryCount: GleanQuantity;
    removalCount: GleanQuantity;
    succeeded: GleanBoolean;
    suffixRemovalCount: GleanQuantity;
    suffixEverFailed: GleanBoolean;
  }

  backgroundTasksRmdirQuota: {
    metricBase: GleanEvent;
    elapsedMs: GleanQuantity;
    wasFirst: GleanBoolean;
    retryCount: GleanQuantity;
    removalCount: GleanQuantity;
    succeeded: GleanBoolean;
    suffixRemovalCount: GleanQuantity;
    suffixEverFailed: GleanBoolean;
  }

  backgroundTasksRmdirHttpCache: {
    metricBase: GleanEvent;
    elapsedMs: GleanQuantity;
    wasFirst: GleanBoolean;
    retryCount: GleanQuantity;
    removalCount: GleanQuantity;
    succeeded: GleanBoolean;
    suffixRemovalCount: GleanQuantity;
    suffixEverFailed: GleanBoolean;
  }

  captchaDetection: {
    googleRecaptchaV2Oc: GleanCounter;
    googleRecaptchaV2Ps: GleanCounter;
    googleRecaptchaV2Pc: GleanCounter;
    googleRecaptchaV2Ac: GleanCounter;
    cloudflareTurnstileOc: GleanCounter;
    cloudflareTurnstileCc: GleanCounter;
    cloudflareTurnstileCf: GleanCounter;
    datadomeOc: GleanCounter;
    datadomePs: GleanCounter;
    datadomeBl: GleanCounter;
    datadomePc: GleanCounter;
    hcaptchaOc: GleanCounter;
    hcaptchaPs: GleanCounter;
    hcaptchaPc: GleanCounter;
    hcaptchaAc: GleanCounter;
    arkoselabsOc: GleanCounter;
    arkoselabsPs: GleanCounter;
    arkoselabsPc: GleanCounter;
    arkoselabsPf: GleanCounter;
    arkoselabsSolutionsRequired: GleanCustomDistribution;
    googleRecaptchaV2OcPbm: GleanCounter;
    googleRecaptchaV2PsPbm: GleanCounter;
    googleRecaptchaV2PcPbm: GleanCounter;
    googleRecaptchaV2AcPbm: GleanCounter;
    cloudflareTurnstileOcPbm: GleanCounter;
    cloudflareTurnstileCcPbm: GleanCounter;
    cloudflareTurnstileCfPbm: GleanCounter;
    datadomePsPbm: GleanCounter;
    datadomeBlPbm: GleanCounter;
    datadomePcPbm: GleanCounter;
    hcaptchaOcPbm: GleanCounter;
    hcaptchaPsPbm: GleanCounter;
    hcaptchaPcPbm: GleanCounter;
    hcaptchaAcPbm: GleanCounter;
    arkoselabsOcPbm: GleanCounter;
    arkoselabsPsPbm: GleanCounter;
    arkoselabsPcPbm: GleanCounter;
    arkoselabsPfPbm: GleanCounter;
    arkoselabsSolutionsRequiredPbm: GleanCustomDistribution;
    networkCookieCookiebehavior: GleanString;
    privacyTrackingprotectionEnabled: GleanBoolean;
    privacyTrackingprotectionCryptominingEnabled: GleanBoolean;
    privacyTrackingprotectionFingerprintingEnabled: GleanBoolean;
    privacyFingerprintingprotection: GleanBoolean;
    networkCookieCookiebehaviorOptinpartitioning: GleanBoolean;
    privacyResistfingerprinting: GleanBoolean;
    privacyTrackingprotectionPbmEnabled: GleanBoolean;
    privacyFingerprintingprotectionPbm: GleanBoolean;
    networkCookieCookiebehaviorOptinpartitioningPbm: GleanBoolean;
    privacyResistfingerprintingPbmode: GleanBoolean;
    pagesVisited: GleanCounter;
    pagesVisitedPbm: GleanCounter;
  }

  relevancyClassify: {
    succeed: GleanEvent;
    fail: GleanEvent;
    duration: GleanTimingDistribution;
  }

  cookieBanners: {
    normalWindowServiceMode: Record<string, GleanBoolean>;
    privateWindowServiceMode: Record<string, GleanBoolean>;
    serviceDetectOnly: GleanBoolean;
    googleGdprChoiceCookie: Record<string, GleanString>;
    googleGdprChoiceCookieEvent: GleanEvent;
    googleGdprChoiceCookieEventPbm: GleanEvent;
  }

  crash: {
    processType: GleanString;
    time: GleanDatetime;
    startup: GleanBoolean;
    appChannel: GleanString;
    appDisplayVersion: GleanString;
    appBuild: GleanString;
    minidumpSha256Hash: GleanString;
    stackTraces: GleanObject;
    asyncShutdownTimeout: GleanObject;
    backgroundTaskName: GleanString;
    eventLoopNestingLevel: GleanQuantity;
    fontName: GleanString;
    gpuProcessLaunch: GleanQuantity;
    ipcChannelError: GleanString;
    isGarbageCollecting: GleanBoolean;
    mainThreadRunnableName: GleanString;
    mozCrashReason: GleanString;
    profilerChildShutdownPhase: GleanString;
    quotaManagerShutdownTimeout: GleanObject;
    remoteType: GleanString;
    utilityActorsName: GleanStringList;
    shutdownProgress: GleanString;
    compressedStoreSize: GleanMemoryDistribution;
    submitAttempt: Record<string, GleanCounter>;
  }

  crashWindows: {
    errorReporting: GleanBoolean;
    fileDialogErrorCode: GleanString;
  }

  windows: {
    packageFamilyName: GleanString;
  }

  memory: {
    availableCommit: GleanQuantity;
    availablePhysical: GleanQuantity;
    availableSwap: GleanQuantity;
    availableVirtual: GleanQuantity;
    jsLargeAllocationFailure: GleanString;
    jsOutOfMemory: GleanString;
    lowPhysical: GleanQuantity;
    oomAllocationSize: GleanQuantity;
    purgeablePhysical: GleanQuantity;
    systemUsePercentage: GleanQuantity;
    texture: GleanQuantity;
    totalPageFile: GleanQuantity;
    totalPhysical: GleanQuantity;
    totalVirtual: GleanQuantity;
    residentFast: GleanMemoryDistribution;
    residentPeak: GleanMemoryDistribution;
    total: GleanMemoryDistribution;
    distributionAmongContent: Record<string, GleanCustomDistribution>;
    unique: GleanMemoryDistribution;
    vsize: GleanMemoryDistribution;
    vsizeMaxContiguous: GleanMemoryDistribution;
    jsCompartmentsSystem: GleanCustomDistribution;
    jsCompartmentsUser: GleanCustomDistribution;
    jsRealmsSystem: GleanCustomDistribution;
    jsRealmsUser: GleanCustomDistribution;
    jsGcHeap: GleanMemoryDistribution;
    storageSqlite: GleanMemoryDistribution;
    imagesContentUsedUncompressed: GleanMemoryDistribution;
    heapAllocated: GleanMemoryDistribution;
    heapOverheadFraction: GleanCustomDistribution;
    ghostWindows: GleanCustomDistribution;
    lowMemoryEventsPhysical: GleanCustomDistribution;
    pageFaultsHard: GleanCustomDistribution;
    collectionTime: GleanTimingDistribution;
    freePurgedPages: GleanTimingDistribution;
    uniqueContentStartup: GleanMemoryDistribution;
  }

  dllBlocklist: {
    list: GleanStringList;
    initFailed: GleanBoolean;
    user32LoadedBefore: GleanBoolean;
  }

  environment: {
    nimbusEnrollments: GleanStringList;
    headlessMode: GleanBoolean;
    uptime: GleanTimespan;
  }

  crashSubmission: {
    success: GleanCounter;
    failure: GleanCounter;
    pending: GleanCounter;
    collectorErrors: Record<string, GleanCounter>;
    channelStatus: Record<string, GleanCounter>;
  }

  doh: {
    evaluateV2Heuristics: GleanEvent;
    stateEnabled: GleanEvent;
    stateDisabled: GleanEvent;
    stateManuallyDisabled: GleanEvent;
    statePolicyDisabled: GleanEvent;
    stateUninstalled: GleanEvent;
    stateUiok: GleanEvent;
    stateUidisabled: GleanEvent;
    stateRollback: GleanEvent;
    stateShutdown: GleanEvent;
  }

  securityDohTrrPerformance: {
    resolvedRecord: GleanEvent;
    trrselectDryrunresult: GleanEvent;
  }

  policies: {
    count: GleanQuantity;
    isEnterprise: GleanBoolean;
  }

  extensions: {
    useRemotePref: GleanBoolean;
    useRemotePolicy: GleanBoolean;
    startupCacheLoadTime: GleanTimespan;
    startupCacheReadErrors: Record<string, GleanCounter>;
    startupCacheWriteBytelength: GleanQuantity;
    processEvent: Record<string, GleanCounter>;
  }

  extensionsApisDnr: {
    startupCacheReadSize: GleanMemoryDistribution;
    startupCacheReadTime: GleanTimingDistribution;
    startupCacheWriteSize: GleanMemoryDistribution;
    startupCacheWriteTime: GleanTimingDistribution;
    startupCacheEntries: Record<string, GleanCounter>;
    validateRulesTime: GleanTimingDistribution;
    evaluateRulesTime: GleanTimingDistribution;
    evaluateRulesCountMax: GleanQuantity;
  }

  extensionsData: {
    migrateResult: GleanEvent;
    storageLocalError: GleanEvent;
    syncUsageQuotas: GleanEvent;
    migrateResultCount: Record<string, GleanCounter>;
  }

  extensionsCounters: {
    browserActionPreloadResult: Record<string, GleanCounter>;
    eventPageIdleResult: Record<string, GleanCounter>;
  }

  extensionsTiming: {
    backgroundPageLoad: GleanTimingDistribution;
    backgroundPageLoadByAddonid: Record<string, GleanTimingDistribution>;
    browserActionPopupOpen: GleanTimingDistribution;
    browserActionPopupOpenByAddonid: Record<string, GleanTimingDistribution>;
    contentScriptInjection: GleanTimingDistribution;
    contentScriptInjectionByAddonid: Record<string, GleanTimingDistribution>;
    eventPageRunningTime: GleanCustomDistribution;
    eventPageRunningTimeByAddonid: Record<string, GleanTimingDistribution>;
    extensionStartup: GleanTimingDistribution;
    extensionStartupByAddonid: Record<string, GleanTimingDistribution>;
    pageActionPopupOpen: GleanTimingDistribution;
    pageActionPopupOpenByAddonid: Record<string, GleanTimingDistribution>;
    storageLocalGetIdb: GleanTimingDistribution;
    storageLocalGetIdbByAddonid: Record<string, GleanTimingDistribution>;
    storageLocalSetIdb: GleanTimingDistribution;
    storageLocalSetIdbByAddonid: Record<string, GleanTimingDistribution>;
  }

  formautofillCreditcards: {
    autofillProfilesCount: GleanQuantity;
  }

  formautofill: {
    formSubmissionHeuristic: Record<string, GleanCounter>;
    iframeLayoutDetection: GleanEvent;
    availability: GleanBoolean;
    promptShownOsReauth: GleanEvent;
    requireOsReauthToggle: GleanEvent;
    osAuthEnabled: GleanBoolean;
  }

  address: {
    showCaptureDoorhanger: GleanEvent;
    showUpdateDoorhanger: GleanEvent;
    showEditDoorhanger: GleanEvent;
    saveCaptureDoorhanger: GleanEvent;
    saveUpdateDoorhanger: GleanEvent;
    saveEditDoorhanger: GleanEvent;
    updateCaptureDoorhanger: GleanEvent;
    updateUpdateDoorhanger: GleanEvent;
    updateEditDoorhanger: GleanEvent;
    cancelCaptureDoorhanger: GleanEvent;
    cancelUpdateDoorhanger: GleanEvent;
    cancelEditDoorhanger: GleanEvent;
    disableCaptureDoorhanger: GleanEvent;
    disableUpdateDoorhanger: GleanEvent;
    disableEditDoorhanger: GleanEvent;
    prefCaptureDoorhanger: GleanEvent;
    prefUpdateDoorhanger: GleanEvent;
    prefEditDoorhanger: GleanEvent;
    learnMoreCaptureDoorhanger: GleanEvent;
    learnMoreUpdateDoorhanger: GleanEvent;
    learnMoreEditDoorhanger: GleanEvent;
    showManage: GleanEvent;
    addManage: GleanEvent;
    deleteManage: GleanEvent;
    showEntryManage: GleanEvent;
    editManage: GleanEvent;
    detectedAddressForm: GleanEvent;
    popupShownAddressForm: GleanEvent;
    filledAddressForm: GleanEvent;
    filledOnFieldsUpdateAddressForm: GleanEvent;
    filledModifiedAddressForm: GleanEvent;
    submittedAddressForm: GleanEvent;
    clearedAddressForm: GleanEvent;
    detectedAddressFormExt: GleanEvent;
    filledAddressFormExt: GleanEvent;
    submittedAddressFormExt: GleanEvent;
  }

  creditcard: {
    showCaptureDoorhanger: GleanEvent;
    showUpdateDoorhanger: GleanEvent;
    saveCaptureDoorhanger: GleanEvent;
    saveUpdateDoorhanger: GleanEvent;
    updateCaptureDoorhanger: GleanEvent;
    updateUpdateDoorhanger: GleanEvent;
    cancelCaptureDoorhanger: GleanEvent;
    cancelUpdateDoorhanger: GleanEvent;
    disableCaptureDoorhanger: GleanEvent;
    disableUpdateDoorhanger: GleanEvent;
    showManage: GleanEvent;
    addManage: GleanEvent;
    deleteManage: GleanEvent;
    showEntryManage: GleanEvent;
    editManage: GleanEvent;
    detectedCcFormV2: GleanEvent;
    popupShownCcFormV2: GleanEvent;
    filledCcFormV2: GleanEvent;
    filledOnFieldsUpdateCcFormV2: GleanEvent;
    filledModifiedCcFormV2: GleanEvent;
    submittedCcFormV2: GleanEvent;
    clearedCcFormV2: GleanEvent;
    detectedCcNumberFieldsCount: Record<string, GleanCounter>;
    osKeystoreDecrypt: GleanEvent;
  }

  formautofillMl: {
    fieldInferResult: GleanEvent;
  }

  formautofillAddresses: {
    autofillProfilesCount: GleanQuantity;
  }

  fog: {
    initialization: GleanTimespan;
    failedIdleRegistration: GleanBoolean;
    initsDuringShutdown: GleanCounter;
    maxPingsPerMinute: GleanQuantity;
  }

  fogIpc: {
    replayFailures: GleanCounter;
    bufferSizes: GleanMemoryDistribution;
    flushDurations: GleanTimingDistribution;
    flushFailures: GleanCounter;
    shutdownRegistrationFailures: GleanCounter;
  }

  testOnly: {
    badCode: GleanCounter;
    canWeTimeIt: GleanTimespan;
    cheesyString: GleanString;
    cheesyStringList: GleanStringList;
    whatADate: GleanDatetime;
    whatIdIt: GleanUuid;
    canWeFlagIt: GleanBoolean;
    doYouRemember: GleanMemoryDistribution;
    whatTimeIsIt: GleanTimingDistribution;
    mabelsKitchenCounters: Record<string, GleanCounter>;
    mabelsLabeledCounters: Record<string, GleanCounter>;
    mabelsBathroomCounters: Record<string, GleanCounter>;
    mabelsLikeBalloons: Record<string, GleanBoolean>;
    mabelsLikeLabeledBalloons: Record<string, GleanBoolean>;
    mabelsBalloonStrings: Record<string, GleanString>;
    mabelsBalloonLabels: Record<string, GleanString>;
    mabelsLabelMaker: Record<string, GleanString>;
    mabelsCustomLabelLengths: Record<string, GleanCustomDistribution>;
    whatDoYouRemember: Record<string, GleanMemoryDistribution>;
    whereHasTheTimeGone: Record<string, GleanTimingDistribution>;
    buttonJars: Record<string, GleanQuantity>;
    mirrorTime: GleanTimespan;
    mirrorTimeNanos: GleanTimespan;
    mirrorsForLabeledBools: Record<string, GleanBoolean>;
    onePingOneBool: GleanBoolean;
    meaningOfLife: GleanQuantity;
    balloons: GleanObject;
    crashStack: GleanObject;
    mainOnly: GleanQuantity;
    impressionIdOnly: GleanString;
    expired: GleanCounter;
    keyedExpired: Record<string, GleanCounter>;
    unexpired: GleanCounter;
    releaseOptin: GleanCounter;
    releaseOptout: GleanCounter;
    keyedReleaseOptin: Record<string, GleanCounter>;
    keyedReleaseOptout: Record<string, GleanCounter>;
    defaultProducts: GleanCounter;
    desktopOnly: GleanCounter;
    multiproduct: GleanCounter;
    mobileOnly: GleanCounter;
    keyedMobileOnly: Record<string, GleanCounter>;
    disabledCounter: GleanCounter;
    collectionDisabledCounter: GleanCounter;
    expiredHist: GleanCustomDistribution;
  }

  testOnlyIpc: {
    aCounter: GleanCounter;
    aCounterForHgram: GleanCounter;
    aLabeledCounterForHgram: Record<string, GleanCounter>;
    aLabeledCounterForKeyedCountHgram: Record<string, GleanCounter>;
    aLabeledCounterForCategorical: Record<string, GleanCounter>;
    anUnorderedBool: GleanBoolean;
    aBool: GleanBoolean;
    anUnorderedLabeledBoolean: Record<string, GleanBoolean>;
    aDate: GleanDatetime;
    aString: GleanString;
    aText: GleanText;
    aMemoryDist: GleanMemoryDistribution;
    aTimingDist: GleanTimingDistribution;
    aCustomDist: GleanCustomDistribution;
    aStringList: GleanStringList;
    anEvent: GleanEvent;
    eventWithExtra: GleanEvent;
    noExtraEvent: GleanEvent;
    aUuid: GleanUuid;
    aLabeledCounter: Record<string, GleanCounter>;
    anotherLabeledCounter: Record<string, GleanCounter>;
    aQuantity: GleanQuantity;
    irate: GleanRate;
    rateWithExternalDenominator: GleanRate;
    anExternalDenominator: GleanCounter;
    aUrl: GleanUrl;
  }

  testOnlyJog: {
    aCounter: GleanCounter;
    anEvent: GleanEvent;
  }

  mediaSniffer: {
    mp4BrandPattern: Record<string, GleanCounter>;
  }

  messagingExperiments: {
    targetingAttributeError: GleanEvent;
    targetingAttributeTimeout: GleanEvent;
    reachCfr: GleanEvent;
    reachMomentsPage: GleanEvent;
    reachInfobar: GleanEvent;
    reachSpotlight: GleanEvent;
    reachFeatureCallout: GleanEvent;
    reachFxmsBmbButton: GleanEvent;
    reachFxmsMessage1: GleanEvent;
    reachFxmsMessage2: GleanEvent;
    reachFxmsMessage3: GleanEvent;
    reachFxmsMessage4: GleanEvent;
    reachFxmsMessage5: GleanEvent;
    reachFxmsMessage6: GleanEvent;
    reachFxmsMessage7: GleanEvent;
    reachFxmsMessage8: GleanEvent;
    reachFxmsMessage9: GleanEvent;
    reachFxmsMessage10: GleanEvent;
    reachFxmsMessage11: GleanEvent;
    reachFxmsMessage12: GleanEvent;
    reachFxmsMessage13: GleanEvent;
    reachFxmsMessage14: GleanEvent;
    reachFxmsMessage15: GleanEvent;
  }

  firefoxAiRuntime: {
    engineCreationSuccess: Record<string, GleanTimingDistribution>;
    engineCreationFailure: GleanEvent;
    runInferenceFailure: GleanEvent;
    runInferenceSuccess: Record<string, GleanTimingDistribution>;
    modelDownload: GleanEvent;
    modelDeletion: GleanEvent;
  }

  modelManagement: {
    removeInitiated: GleanEvent;
    removeConfirmation: GleanEvent;
    listItemManage: GleanEvent;
    extensionModelLink: GleanEvent;
    listView: GleanEvent;
    detailsView: GleanEvent;
  }

  nimbusTargetingEnvironment: {
    targetingContextValue: GleanText;
    prefTypeErrors: Record<string, GleanCounter>;
    attrEvalErrors: Record<string, GleanCounter>;
    userSetPrefs: GleanObject;
    prefValues: GleanObject;
  }

  nimbusTargetingContext: {
    activeExperiments: GleanObject;
    activeRollouts: GleanObject;
    addonsInfo: GleanObject;
    addressesSaved: GleanQuantity;
    archBits: GleanQuantity;
    attributionData: GleanObject;
    browserSettings: GleanObject;
    buildId: GleanQuantity;
    currentDate: GleanString;
    defaultPdfHandler: GleanObject;
    distributionId: GleanString;
    doesAppNeedPin: GleanBoolean;
    enrollmentsMap: GleanObject;
    firefoxVersion: GleanQuantity;
    hasActiveEnterprisePolicies: GleanBoolean;
    homePageSettings: GleanObject;
    isDefaultBrowser: GleanBoolean;
    isDefaultHandler: GleanObject;
    isFirstStartup: GleanBoolean;
    isFxAEnabled: GleanBoolean;
    isFxASignedIn: GleanBoolean;
    isMsix: GleanBoolean;
    locale: GleanString;
    memoryMb: GleanQuantity;
    os: GleanObject;
    primaryResolution: GleanObject;
    profileAgeCreated: GleanQuantity;
    region: GleanString;
    totalBookmarksCount: GleanQuantity;
    userMonthlyActivity: GleanObject;
    userPrefersReducedMotion: GleanBoolean;
    usesFirefoxSync: GleanBoolean;
    version: GleanString;
  }

  nimbusEvents: {
    enrollment: GleanEvent;
    enrollFailed: GleanEvent;
    unenrollment: GleanEvent;
    unenrollFailed: GleanEvent;
    exposure: GleanEvent;
    validationFailed: GleanEvent;
    isReady: GleanEvent;
    enrollmentStatus: GleanEvent;
    migration: GleanEvent;
  }

  normandy: {
    exposeNimbusExperiment: GleanEvent;
    enrollPreferenceStudy: GleanEvent;
    enrollAddonStudy: GleanEvent;
    enrollPreferenceRollout: GleanEvent;
    enrollAddonRollout: GleanEvent;
    enrollNimbusExperiment: GleanEvent;
    enrollFailedAddonStudy: GleanEvent;
    enrollFailedPreferenceRollout: GleanEvent;
    enrollFailedPreferenceStudy: GleanEvent;
    enrollFailedAddonRollout: GleanEvent;
    enrollFailedNimbusExperiment: GleanEvent;
    updateAddonStudy: GleanEvent;
    updatePreferenceRollout: GleanEvent;
    updateAddonRollout: GleanEvent;
    updateNimbusExperiment: GleanEvent;
    updateFailedAddonStudy: GleanEvent;
    updateFailedAddonRollout: GleanEvent;
    unenrollPreferenceStudy: GleanEvent;
    unenrollAddonStudy: GleanEvent;
    unenrollPreferenceRollback: GleanEvent;
    unenrollAddonRollback: GleanEvent;
    unenrollNimbusExperiment: GleanEvent;
    unenrollFailedPreferenceRollback: GleanEvent;
    unenrollFailedPreferenceStudy: GleanEvent;
    unenrollFailedAddonRollback: GleanEvent;
    unenrollFailedNimbusExperiment: GleanEvent;
    graduatePreferenceRollout: GleanEvent;
    expPrefChangedPreferenceStudy: GleanEvent;
    validationFailedNimbusExperiment: GleanEvent;
    recipeFreshness: Record<string, GleanQuantity>;
  }

  heartbeat: {
    flowId: GleanUuid;
    offered: GleanDatetime;
    learnMore: GleanDatetime;
    voted: GleanDatetime;
    engaged: GleanDatetime;
    closed: GleanDatetime;
    expired: GleanDatetime;
    windowClosed: GleanDatetime;
    score: GleanQuantity;
    surveyId: GleanString;
  }

  pwmgr: {
    formAutofillResult: Record<string, GleanCounter>;
    autocompleteFieldGeneratedpassword: GleanEvent;
    autocompleteShownGeneratedpassword: GleanEvent;
    filledFieldEditedGeneratedpassword: GleanEvent;
    doorhangerSubmittedSave: GleanEvent;
    doorhangerSubmittedUpdate: GleanEvent;
    savedLoginUsedFormLogin: GleanEvent;
    savedLoginUsedFormPassword: GleanEvent;
    savedLoginUsedAuthLogin: GleanEvent;
    savedLoginUsedPromptLogin: GleanEvent;
    mgmtMenuItemUsedImportFromBrowser: GleanEvent;
    mgmtMenuItemUsedImportFromCsv: GleanEvent;
    mgmtMenuItemUsedImportCsvComplete: GleanEvent;
    mgmtMenuItemUsedExport: GleanEvent;
    mgmtMenuItemUsedExportComplete: GleanEvent;
    mgmtMenuItemUsedPreferences: GleanEvent;
    reauthenticateMasterPassword: GleanEvent;
    reauthenticateOsAuth: GleanEvent;
    promptShownOsReauth: GleanEvent;
    requireOsReauthToggle: GleanEvent;
    osAuthEnabled: GleanBoolean;
    openManagementAboutprotections: GleanEvent;
    openManagementAutocomplete: GleanEvent;
    openManagementContextmenu: GleanEvent;
    openManagementDirect: GleanEvent;
    openManagementMainmenu: GleanEvent;
    openManagementPageinfo: GleanEvent;
    openManagementPreferences: GleanEvent;
    openManagementSnippet: GleanEvent;
    cancelExistingLogin: GleanEvent;
    cancelNewLogin: GleanEvent;
    copyPassword: GleanEvent;
    copyUsername: GleanEvent;
    deleteExistingLogin: GleanEvent;
    deleteNewLogin: GleanEvent;
    editExistingLogin: GleanEvent;
    filterList: GleanEvent;
    hidePassword: GleanEvent;
    learnMoreVulnExistingLogin: GleanEvent;
    newNewLogin: GleanEvent;
    openSiteExistingLogin: GleanEvent;
    saveExistingLogin: GleanEvent;
    saveNewLogin: GleanEvent;
    selectExistingLogin: GleanEvent;
    showPassword: GleanEvent;
    sortList: GleanEvent;
    potentiallyBreachedPasswords: GleanQuantity;
    numSavedPasswords: GleanQuantity;
    savingEnabled: GleanBoolean;
    importLoginsFromFileCategorical: Record<string, GleanCounter>;
    loginPageSafety: GleanCustomDistribution;
    numImprovedGeneratedPasswords: Record<string, GleanCounter>;
    promptRememberAction: GleanCustomDistribution;
    promptUpdateAction: GleanCustomDistribution;
    isUsernameOnlyForm: Record<string, GleanCounter>;
    signupFormDetection: GleanTimingDistribution;
  }

  formAutocomplete: {
    showLogins: GleanEvent;
  }

  relayIntegration: {
    enabledPrefChange: GleanEvent;
    disabledPrefChange: GleanEvent;
    shownOfferRelay: GleanEvent;
    clickedOfferRelay: GleanEvent;
    shownFillUsername: GleanEvent;
    clickedFillUsername: GleanEvent;
    shownReusePanel: GleanEvent;
    getUnlimitedMasksReusePanel: GleanEvent;
    reuseMaskReusePanel: GleanEvent;
    shownOptInPanel: GleanEvent;
    enabledOptInPanel: GleanEvent;
    postponedOptInPanel: GleanEvent;
    disabledOptInPanel: GleanEvent;
  }

  pdfjs: {
    editing: Record<string, GleanCounter>;
    stamp: Record<string, GleanCounter>;
    buttons: Record<string, GleanCounter>;
    geckoview: Record<string, GleanCounter>;
    used: GleanCounter;
    timeToView: GleanCustomDistribution;
  }

  pdfjsEditingHighlight: {
    kind: Record<string, GleanCounter>;
    method: Record<string, GleanCounter>;
    color: Record<string, GleanCounter>;
    colorChanged: GleanCounter;
    numberOfColors: Record<string, GleanCounter>;
    thickness: GleanCustomDistribution;
    thicknessChanged: GleanCounter;
    save: GleanCounter;
    print: GleanCounter;
    edited: GleanCounter;
    deleted: GleanCounter;
    toggleVisibility: GleanCounter;
  }

  pdfjsImageAltText: {
    calloutDisplayed: GleanEvent;
    calloutDismissed: GleanEvent;
    info: GleanEvent;
    aiGenerationCheck: GleanEvent;
    settingsDisplayed: GleanEvent;
    settingsAiGenerationCheck: GleanEvent;
    settingsEditAltTextCheck: GleanEvent;
    save: GleanEvent;
    dismiss: GleanEvent;
    modelDownloadStart: GleanEvent;
    modelDownloadComplete: GleanEvent;
    modelDownloadError: GleanEvent;
    modelDeleted: GleanEvent;
    modelResult: GleanEvent;
    userEdit: GleanEvent;
    imageStatusLabelDisplayed: GleanEvent;
    imageStatusLabelClicked: GleanEvent;
  }

  pdfjsImage: {
    iconClick: GleanEvent;
    addImageClick: GleanEvent;
    imageSelected: GleanEvent;
    imageAdded: GleanEvent;
    altTextEdit: Record<string, GleanBoolean>;
    added: Record<string, GleanCounter>;
  }

  pdfjsSignature: {
    clear: Record<string, GleanCounter>;
    deleteSaved: GleanEvent;
    created: GleanEvent;
    added: GleanEvent;
    inserted: GleanEvent;
    editDescription: Record<string, GleanCounter>;
  }

  pictureinpictureSettings: {
    enableSettings: GleanEvent;
    enableAutotriggerSettings: GleanEvent;
    disablePlayer: GleanEvent;
    disableSettings: GleanEvent;
  }

  pictureinpicture: {
    createPlayer: GleanEvent;
    resizePlayer: GleanEvent;
    sawToggleToggle: GleanEvent;
    openedMethodToggle: GleanEvent;
    openedMethodContextMenu: GleanEvent;
    openedMethodUrlBar: GleanEvent;
    openedMethodShortcut: GleanEvent;
    openedMethodAutoPip: GleanEvent;
    closedMethodCloseButton: GleanEvent;
    closedMethodUnpip: GleanEvent;
    closedMethodPagehide: GleanEvent;
    closedMethodForegrounded: GleanEvent;
    closedMethodFullscreen: GleanEvent;
    closedMethodSetupFailure: GleanEvent;
    closedMethodClosePlayerShortcut: GleanEvent;
    closedMethodContextMenu: GleanEvent;
    closedMethodVideoElRemove: GleanEvent;
    closedMethodVideoElEmptied: GleanEvent;
    closedMethodUrlBar: GleanEvent;
    closedMethodShortcut: GleanEvent;
    closedMethodBrowserCrash: GleanEvent;
    subtitlesShownSubtitles: GleanEvent;
    fullscreenPlayer: GleanEvent;
    disrespectDisableUrlBar: GleanEvent;
    mostConcurrentPlayers: GleanQuantity;
    toggleEnabled: GleanBoolean;
    windowOpenDuration: GleanTimingDistribution;
    backgroundTabPlayingDuration: GleanTimingDistribution;
    foregroundTabPlayingDuration: GleanTimingDistribution;
  }

  places: {
    placesDatabaseCorruptionHandlingStage: Record<string, GleanString>;
    sponsoredVisitNoTriggeringUrl: GleanCounter;
    pagesNeedFrecencyRecalculation: GleanQuantity;
    previousdayVisits: GleanQuantity;
    pagesCount: GleanCustomDistribution;
    mostRecentExpiredVisit: GleanTimingDistribution;
    bookmarksCount: GleanCustomDistribution;
    tagsCount: GleanCustomDistribution;
    keywordsCount: GleanCustomDistribution;
    backupsDaysfromlast: GleanTimingDistribution;
    backupsBookmarkstree: GleanTimingDistribution;
    backupsTojson: GleanTimingDistribution;
    exportTohtml: GleanTimingDistribution;
    sortedBookmarksPerc: GleanCustomDistribution;
    taggedBookmarksPerc: GleanCustomDistribution;
    databaseFilesize: GleanMemoryDistribution;
    databaseFaviconsFilesize: GleanMemoryDistribution;
    expirationStepsToClean: GleanCustomDistribution;
    idleFrecencyDecayTime: GleanTimingDistribution;
    idleMaintenanceTime: GleanTimingDistribution;
    frecencyRecalcChunkTime: GleanTimingDistribution;
    annosPagesCount: GleanCustomDistribution;
    maintenanceDaysfromlast: GleanTimingDistribution;
  }

  pageIcon: {
    smallIconCount: GleanCounter;
    fitIconCount: GleanCounter;
  }

  printing: {
    dialogOpenedViaPreviewTm: GleanCounter;
    dialogViaPreviewCancelledTm: GleanCounter;
    error: Record<string, GleanCounter>;
    previewOpenedTm: GleanCounter;
    previewCancelledTm: GleanCounter;
    settingsChanged: Record<string, GleanCounter>;
    silentPrint: GleanCounter;
    targetType: Record<string, GleanCounter>;
  }

  power: {
    cpuTimeBogusValues: GleanCounter;
    cpuTimePerProcessTypeMs: Record<string, GleanCounter>;
    cpuTimePerTrackerTypeMs: Record<string, GleanCounter>;
    gpuTimePerProcessTypeMs: Record<string, GleanCounter>;
    gpuTimeBogusValues: GleanCounter;
    energyPerProcessType: Record<string, GleanCounter>;
    wakeupsPerProcessType: Record<string, GleanCounter>;
    totalCpuTimeMs: GleanCounter;
    totalGpuTimeMs: GleanCounter;
    totalThreadWakeups: GleanCounter;
  }

  powerWakeupsPerThread: {
    parentActive: Record<string, GleanCounter>;
    parentInactive: Record<string, GleanCounter>;
    contentForeground: Record<string, GleanCounter>;
    contentBackground: Record<string, GleanCounter>;
    gpuProcess: Record<string, GleanCounter>;
  }

  powerCpuMsPerThread: {
    parentActive: Record<string, GleanCounter>;
    parentInactive: Record<string, GleanCounter>;
    contentForeground: Record<string, GleanCounter>;
    contentBackground: Record<string, GleanCounter>;
    gpuProcess: Record<string, GleanCounter>;
  }

  powerBattery: {
    percentageWhenUserActive: GleanCustomDistribution;
  }

  readermode: {
    viewOn: GleanEvent;
    viewOff: GleanEvent;
    buttonClick: GleanEvent;
    parseResult: GleanCustomDistribution;
    downloadResult: GleanCustomDistribution;
  }

  brokenSiteReport: {
    breakageCategory: GleanString;
    description: GleanText;
    url: GleanUrl;
  }

  brokenSiteReportTabInfo: {
    languages: GleanStringList;
    useragentString: GleanText;
  }

  brokenSiteReportTabInfoAntitracking: {
    blockList: GleanString;
    hasMixedActiveContentBlocked: GleanBoolean;
    hasMixedDisplayContentBlocked: GleanBoolean;
    hasTrackingContentBlocked: GleanBoolean;
    isPrivateBrowsing: GleanBoolean;
    btpHasPurgedSite: GleanBoolean;
    etpCategory: GleanString;
  }

  brokenSiteReportTabInfoFrameworks: {
    fastclick: GleanBoolean;
    marfeel: GleanBoolean;
    mobify: GleanBoolean;
  }

  brokenSiteReportBrowserInfo: {
    addons: GleanObject;
    experiments: GleanObject;
  }

  brokenSiteReportBrowserInfoApp: {
    defaultLocales: GleanStringList;
    defaultUseragentString: GleanText;
    fissionEnabled: GleanBoolean;
  }

  brokenSiteReportBrowserInfoGraphics: {
    devicePixelRatio: GleanString;
    hasTouchScreen: GleanBoolean;
    devicesJson: GleanText;
    driversJson: GleanText;
    featuresJson: GleanText;
    monitorsJson: GleanText;
  }

  brokenSiteReportBrowserInfoSystem: {
    isTablet: GleanBoolean;
    memory: GleanQuantity;
  }

  brokenSiteReportBrowserInfoPrefs: {
    opaqueResponseBlocking: GleanBoolean;
    installtriggerEnabled: GleanBoolean;
    softwareWebrender: GleanBoolean;
    forcedAcceleratedLayers: GleanBoolean;
    cookieBehavior: GleanQuantity;
    globalPrivacyControlEnabled: GleanBoolean;
    h1InSectionUseragentStylesEnabled: GleanBoolean;
    resistFingerprintingEnabled: GleanBoolean;
    thirdPartyCookieBlockingEnabled: GleanBoolean;
    thirdPartyCookieBlockingEnabledInPbm: GleanBoolean;
  }

  brokenSiteReportBrowserInfoSecurity: {
    antivirus: GleanStringList;
    antispyware: GleanStringList;
    firewall: GleanStringList;
  }

  webcompatreporting: {
    opened: GleanEvent;
    reasonDropdown: GleanEvent;
    send: GleanEvent;
    sendMoreInfo: GleanEvent;
  }

  applicationReputation: {
    binaryType: Record<string, GleanCounter>;
    binaryArchive: Record<string, GleanCounter>;
    shouldBlock: Record<string, GleanCounter>;
    local: GleanCustomDistribution;
    server: GleanCustomDistribution;
    server2: Record<string, GleanCounter>;
    serverVerdict: GleanCustomDistribution;
    remoteLookupResponseTime: GleanTimingDistribution;
    remoteLookupTimeout: Record<string, GleanCounter>;
    reason: Record<string, GleanCounter>;
  }

  fingerprintingProtection: {
    canvasNoiseCalculateTime2: GleanTimingDistribution;
  }

  characteristics: {
    clientIdentifier: GleanUuid;
    submissionSchema: GleanQuantity;
    maxTouchPoints: GleanQuantity;
    prefersReducedTransparency: GleanBoolean;
    prefersReducedMotion: GleanBoolean;
    prefersContrast: GleanQuantity;
    invertedColors: GleanBoolean;
    colorScheme: GleanQuantity;
    colorAccentcolor: GleanQuantity;
    colorAccentcolortext: GleanQuantity;
    colorCanvas: GleanQuantity;
    colorCanvastext: GleanQuantity;
    colorHighlight: GleanQuantity;
    colorHighlighttext: GleanQuantity;
    colorSelecteditem: GleanQuantity;
    colorSelecteditemtext: GleanQuantity;
    useDocumentColors: GleanBoolean;
    missingFonts: GleanText;
    processorCount: GleanQuantity;
    timezone: GleanString;
    systemLocale: GleanString;
    targetFrameRate: GleanQuantity;
    gamepads: GleanStringList;
    prefsIntlAcceptLanguages: GleanString;
    prefsMediaEmeEnabled: GleanBoolean;
    prefsZoomTextOnly: GleanBoolean;
    prefsPrivacyDonottrackheaderEnabled: GleanBoolean;
    prefsPrivacyGlobalprivacycontrolEnabled: GleanBoolean;
    prefsGeneralAutoscroll: GleanBoolean;
    prefsGeneralSmoothscroll: GleanBoolean;
    prefsOverlayScrollbars: GleanBoolean;
    prefsBlockPopups: GleanBoolean;
    prefsBrowserDisplayUseDocumentFonts: GleanBoolean;
    fontDefaultWestern: GleanString;
    fontDefaultDefaultGroup: GleanString;
    fontDefaultModified: GleanQuantity;
    fontNameSerifWestern: GleanString;
    fontNameSerifDefaultGroup: GleanString;
    fontNameSerifModified: GleanQuantity;
    fontNameSansSerifWestern: GleanString;
    fontNameSansSerifDefaultGroup: GleanString;
    fontNameSansSerifModified: GleanQuantity;
    fontNameMonospaceWestern: GleanString;
    fontNameMonospaceDefaultGroup: GleanString;
    fontNameMonospaceModified: GleanQuantity;
    fontSizeVariableWestern: GleanString;
    fontSizeVariableDefaultGroup: GleanString;
    fontSizeVariableModified: GleanQuantity;
    fontSizeMonospaceWestern: GleanString;
    fontSizeMonospaceDefaultGroup: GleanString;
    canvasdata1: GleanString;
    canvasdata2: GleanString;
    canvasdata3: GleanString;
    canvasdata4: GleanString;
    canvasdata5: GleanString;
    canvasdata6: GleanString;
    canvasdata7: GleanString;
    canvasdata8: GleanString;
    canvasdata9: GleanString;
    canvasdata10: GleanString;
    canvasdata11Webgl: GleanString;
    canvasdata12Fingerprintjs1: GleanString;
    canvasdata13Fingerprintjs2: GleanString;
    canvasdata1software: GleanString;
    canvasdata2software: GleanString;
    canvasdata3software: GleanString;
    canvasdata4software: GleanString;
    canvasdata5software: GleanString;
    canvasdata6software: GleanString;
    canvasdata7software: GleanString;
    canvasdata8software: GleanString;
    canvasdata9software: GleanString;
    canvasdata10software: GleanString;
    canvasdata11Webglsoftware: GleanString;
    canvasdata12Fingerprintjs1software: GleanString;
    canvasdata13Fingerprintjs2software: GleanString;
    canvasDpr: GleanString;
    fontSizeMonospaceModified: GleanQuantity;
    fontMinimumSizeWestern: GleanString;
    fontMinimumSizeDefaultGroup: GleanString;
    fontMinimumSizeModified: GleanQuantity;
    fontNameListSerifModified: GleanQuantity;
    fontNameListSansSerifModified: GleanQuantity;
    fontNameListMonospaceModified: GleanQuantity;
    fontNameListCursiveModified: GleanQuantity;
    fontNameListEmojiModified: GleanBoolean;
    glExtensions: GleanText;
    glExtensionsRaw: GleanText;
    glRenderer: GleanString;
    glRendererRaw: GleanString;
    glVendor: GleanString;
    glVendorRaw: GleanString;
    glVersionRaw: GleanString;
    glFragmentShader: GleanString;
    glVertexShader: GleanString;
    glMinimalSource: GleanText;
    glParamsExtensions: GleanText;
    glParams: GleanText;
    glPrecisionFragment: GleanText;
    glPrecisionVertex: GleanText;
    glContextType: GleanString;
    glExtensionsSoftware: GleanText;
    glExtensionsRawSoftware: GleanText;
    glRendererSoftware: GleanString;
    glRendererRawSoftware: GleanString;
    glVendorSoftware: GleanString;
    glVendorRawSoftware: GleanString;
    glVersionRawSoftware: GleanString;
    glFragmentShaderSoftware: GleanString;
    glVertexShaderSoftware: GleanString;
    glMinimalSourceSoftware: GleanText;
    glParamsExtensionsSoftware: GleanText;
    glParamsSoftware: GleanText;
    glPrecisionFragmentSoftware: GleanText;
    glPrecisionVertexSoftware: GleanText;
    glContextTypeSoftware: GleanString;
    gl2Extensions: GleanText;
    gl2ExtensionsRaw: GleanText;
    gl2Renderer: GleanString;
    gl2RendererRaw: GleanString;
    gl2Vendor: GleanString;
    gl2VendorRaw: GleanString;
    gl2VersionRaw: GleanString;
    gl2FragmentShader: GleanString;
    gl2VertexShader: GleanString;
    gl2MinimalSource: GleanText;
    gl2ParamsExtensions: GleanText;
    gl2Params: GleanText;
    gl2PrecisionFragment: GleanText;
    gl2PrecisionVertex: GleanText;
    gl2ContextType: GleanString;
    gl2ExtensionsSoftware: GleanText;
    gl2ExtensionsRawSoftware: GleanText;
    gl2RendererSoftware: GleanString;
    gl2RendererRawSoftware: GleanString;
    gl2VendorSoftware: GleanString;
    gl2VendorRawSoftware: GleanString;
    gl2VersionRawSoftware: GleanString;
    gl2FragmentShaderSoftware: GleanString;
    gl2VertexShaderSoftware: GleanString;
    gl2MinimalSourceSoftware: GleanText;
    gl2ParamsExtensionsSoftware: GleanText;
    gl2ParamsSoftware: GleanText;
    gl2PrecisionFragmentSoftware: GleanText;
    gl2PrecisionVertexSoftware: GleanText;
    gl2ContextTypeSoftware: GleanString;
    prefsNetworkCookieCookiebehavior: GleanQuantity;
    voicesCount: GleanQuantity;
    voicesLocalCount: GleanQuantity;
    voicesDefault: GleanString;
    voicesSample: GleanText;
    voicesSha1: GleanText;
    voicesAllSsdeep: GleanString;
    voicesLocalSsdeep: GleanString;
    voicesNonlocalSsdeep: GleanString;
    zoomCount: GleanQuantity;
    availHeight: GleanQuantity;
    outerHeight: GleanQuantity;
    innerHeight: GleanQuantity;
    screenHeight: GleanQuantity;
    outerWidth: GleanQuantity;
    innerWidth: GleanQuantity;
    screenWidth: GleanQuantity;
    sizeMode: GleanQuantity;
    availWidth: GleanQuantity;
    cameraCount: GleanQuantity;
    microphoneCount: GleanQuantity;
    speakerCount: GleanQuantity;
    groupCount: GleanQuantity;
    groupCountWoSpeakers: GleanQuantity;
    audioFrames: GleanQuantity;
    audioRate: GleanQuantity;
    audioChannels: GleanQuantity;
    languages: GleanString;
    changedMediaPrefs: GleanString;
    mediaCapabilitiesUnsupported: GleanText;
    mediaCapabilitiesNotSmooth: GleanText;
    mediaCapabilitiesNotEfficient: GleanText;
    mediaCapabilitiesH264: GleanText;
    textAntiAliasing: GleanString;
    audioFingerprint: GleanQuantity;
    pixelRatio: GleanString;
    intlLocale: GleanString;
    mathOps: GleanText;
    mathOpsFdlibm: GleanText;
    keyboardLayout: GleanString;
    errors: GleanText;
    jsErrors: GleanText;
    pointerType: GleanQuantity;
    anyPointerType: GleanQuantity;
    iceOrder: GleanQuantity;
    iceSd: GleanQuantity;
    pointerHeight: GleanQuantity;
    pointerWidth: GleanQuantity;
    pointerPressure: GleanString;
    pointerTangentinalPressure: GleanString;
    pointerTiltx: GleanQuantity;
    pointerTilty: GleanQuantity;
    pointerTwist: GleanQuantity;
    touchRotationAngle: GleanString;
    motionDecimals: GleanQuantity;
    orientationDecimals: GleanQuantity;
    orientationabsDecimals: GleanQuantity;
    motionFreq: GleanQuantity;
    orientationFreq: GleanQuantity;
    orientationabsFreq: GleanQuantity;
    version: GleanString;
    channel: GleanString;
    buildDate: GleanQuantity;
    osName: GleanString;
    osVersion: GleanString;
    cpuModel: GleanString;
    cpuArch: GleanString;
    mathml1: GleanString;
    mathml2: GleanString;
    mathml3: GleanString;
    mathml4: GleanString;
    mathml5: GleanString;
    mathml6: GleanString;
    mathml7: GleanString;
    mathml8: GleanString;
    mathml9: GleanString;
    mathml10: GleanString;
    monochrome: GleanBoolean;
    oscpu: GleanString;
    pdfViewer: GleanBoolean;
    platform: GleanString;
    usingAcceleratedCanvas: GleanBoolean;
    canvasFeatureStatus: GleanString;
    wgpuMissingFeatures: GleanString;
    wgpuMaxtexturedimension1d: GleanQuantity;
    wgpuMaxtexturedimension2d: GleanQuantity;
    wgpuMaxtexturedimension3d: GleanQuantity;
    wgpuMaxtexturearraylayers: GleanQuantity;
    wgpuMaxbindgroups: GleanQuantity;
    wgpuMaxbindgroupsplusvertexbuffers: GleanQuantity;
    wgpuMaxbindingsperbindgroup: GleanQuantity;
    wgpuMaxdynamicuniformbuffersperpipelinelayout: GleanQuantity;
    wgpuMaxdynamicstoragebuffersperpipelinelayout: GleanQuantity;
    wgpuMaxsampledtexturespershaderstage: GleanQuantity;
    wgpuMaxsamplerspershaderstage: GleanQuantity;
    wgpuMaxstoragebufferspershaderstage: GleanQuantity;
    wgpuMaxstoragetexturespershaderstage: GleanQuantity;
    wgpuMaxuniformbufferspershaderstage: GleanQuantity;
    wgpuMaxuniformbufferbindingsize: GleanQuantity;
    wgpuMaxstoragebufferbindingsize: GleanQuantity;
    wgpuMinuniformbufferoffsetalignment: GleanQuantity;
    wgpuMinstoragebufferoffsetalignment: GleanQuantity;
    wgpuMaxvertexbuffers: GleanQuantity;
    wgpuMaxbuffersize: GleanQuantity;
    wgpuMaxvertexattributes: GleanQuantity;
    wgpuMaxvertexbufferarraystride: GleanQuantity;
    wgpuMaxinterstageshadervariables: GleanQuantity;
    wgpuMaxcolorattachments: GleanQuantity;
    wgpuMaxcolorattachmentbytespersample: GleanQuantity;
    wgpuMaxcomputeworkgroupstoragesize: GleanQuantity;
    wgpuMaxcomputeinvocationsperworkgroup: GleanQuantity;
    wgpuMaxcomputeworkgroupsizex: GleanQuantity;
    wgpuMaxcomputeworkgroupsizey: GleanQuantity;
    wgpuMaxcomputeworkgroupsizez: GleanQuantity;
    wgpuMaxcomputeworkgroupsperdimension: GleanQuantity;
    userAgent: GleanText;
    machineModelName: GleanString;
    fontsFpjsAllowlisted: GleanString;
    fontsFpjsNonallowlisted: GleanString;
    fontsVariantAAllowlisted: GleanString;
    fontsVariantANonallowlisted: GleanString;
    fontsVariantBAllowlisted: GleanString;
    fontsVariantBNonallowlisted: GleanString;
    screens: GleanText;
  }

  searchEngineDefault: {
    engineId: GleanString;
    providerId: GleanString;
    partnerCode: GleanString;
    overriddenByThirdParty: GleanBoolean;
    displayName: GleanString;
    loadPath: GleanString;
    submissionUrl: GleanUrl;
    changed: GleanEvent;
  }

  searchEnginePrivate: {
    engineId: GleanString;
    providerId: GleanString;
    partnerCode: GleanString;
    overriddenByThirdParty: GleanBoolean;
    displayName: GleanString;
    loadPath: GleanString;
    submissionUrl: GleanUrl;
    changed: GleanEvent;
  }

  searchService: {
    startupTime: GleanTimingDistribution;
    initializationStatus: Record<string, GleanCounter>;
  }

  browserSearchinit: {
    engineInvalidWebextension: Record<string, GleanQuantity>;
    secureOpensearchEngineCount: GleanQuantity;
    insecureOpensearchEngineCount: GleanQuantity;
    secureOpensearchUpdateCount: GleanQuantity;
    insecureOpensearchUpdateCount: GleanQuantity;
  }

  search: {
    suggestionsLatency: Record<string, GleanTimingDistribution>;
  }

  searchSuggestions: {
    successfulRequests: Record<string, GleanCounter>;
    abortedRequests: Record<string, GleanCounter>;
    failedRequests: Record<string, GleanCounter>;
  }

  legacyTelemetry: {
    clientId: GleanUuid;
    profileGroupId: GleanUuid;
  }

  telemetry: {
    dataUploadOptin: GleanBoolean;
    archiveDirectoriesCount: GleanCustomDistribution;
    archiveOldestDirectoryAge: GleanCustomDistribution;
    archiveScanPingCount: GleanCustomDistribution;
    archiveSessionPingCount: GleanCounter;
    archiveSize: GleanMemoryDistribution;
    archiveEvictedOverQuota: GleanCustomDistribution;
    archiveEvictedOldDirs: GleanCustomDistribution;
    archiveEvictingDirs: GleanTimingDistribution;
    archiveCheckingOverQuota: GleanTimingDistribution;
    archiveEvictingOverQuota: GleanTimingDistribution;
    pendingLoadFailureRead: GleanCounter;
    pendingLoadFailureParse: GleanCounter;
    pendingPingsSize: GleanMemoryDistribution;
    pendingPingsAge: GleanTimingDistribution;
    pendingPingsEvictedOverQuota: GleanCustomDistribution;
    pendingEvictingOverQuota: GleanTimingDistribution;
    pendingCheckingOverQuota: GleanTimingDistribution;
    pingSizeExceededSend: GleanCounter;
    pingSizeExceededPending: GleanCounter;
    pingSizeExceededArchived: GleanCounter;
    pingSubmissionWaitingClientid: GleanCounter;
    discardedPendingPingsSize: GleanMemoryDistribution;
    discardedArchivedPingsSize: GleanMemoryDistribution;
    discardedSendPingsSize: GleanMemoryDistribution;
    compress: GleanTimingDistribution;
    sendSuccess: GleanTimingDistribution;
    sendFailure: GleanTimingDistribution;
    sendFailureType: Record<string, GleanCounter>;
    stringify: GleanTimingDistribution;
    success: Record<string, GleanCounter>;
    invalidPingTypeSubmitted: Record<string, GleanCounter>;
    invalidPayloadSubmitted: GleanCounter;
    pingEvictedForServerErrors: GleanCounter;
    eventPingSent: Record<string, GleanCounter>;
    eventRegistrationError: Record<string, GleanCounter>;
    eventRecordingError: Record<string, GleanCounter>;
  }

  usage: {
    profileId: GleanUuid;
    profileGroupId: GleanUuid;
    os: GleanString;
    osVersion: GleanString;
    windowsBuildNumber: GleanQuantity;
    appBuild: GleanString;
    appDisplayVersion: GleanString;
    appChannel: GleanString;
    firstRunDate: GleanDatetime;
    reason: GleanString;
    isDefaultBrowser: GleanBoolean;
    distributionId: GleanString;
  }

  onboardingOptOut: {
    activeExperiments: GleanObject;
    activeRollouts: GleanObject;
    enrollmentsMap: GleanObject;
  }

  telemetryTest: {
    test1Object1: GleanEvent;
    test2Object1: GleanEvent;
    test2Object2: GleanEvent;
  }

  thumbnails: {
    captureTime: GleanTimingDistribution;
    storeTime: GleanTimingDistribution;
    queueSizeOnCapture: GleanCustomDistribution;
    captureQueueTime: GleanTimingDistribution;
    captureDoneReason2: GleanCustomDistribution;
    capturePageLoadTime: GleanTimingDistribution;
    captureCanvasDrawTime: GleanTimingDistribution;
  }

  translations: {
    requestCount: Record<string, GleanCounter>;
    error: GleanEvent;
    translationRequest: GleanEvent;
    restorePage: GleanEvent;
    enginePerformance: GleanEvent;
  }

  translationsPanel: {
    open: GleanEvent;
    close: GleanEvent;
    openFromLanguageMenu: GleanEvent;
    changeFromLanguage: GleanEvent;
    closeFromLanguageMenu: GleanEvent;
    openToLanguageMenu: GleanEvent;
    changeToLanguage: GleanEvent;
    closeToLanguageMenu: GleanEvent;
    openSettingsMenu: GleanEvent;
    closeSettingsMenu: GleanEvent;
    cancelButton: GleanEvent;
    changeSourceLanguageButton: GleanEvent;
    dismissErrorButton: GleanEvent;
    restorePageButton: GleanEvent;
    translateButton: GleanEvent;
    alwaysOfferTranslations: GleanEvent;
    alwaysTranslateLanguage: GleanEvent;
    neverTranslateLanguage: GleanEvent;
    neverTranslateSite: GleanEvent;
    manageLanguages: GleanEvent;
    aboutTranslations: GleanEvent;
    learnMore: GleanEvent;
  }

  translationsSelectTranslationsPanel: {
    open: GleanEvent;
    close: GleanEvent;
    cancelButton: GleanEvent;
    copyButton: GleanEvent;
    doneButton: GleanEvent;
    translateButton: GleanEvent;
    translateFullPageButton: GleanEvent;
    tryAgainButton: GleanEvent;
    changeFromLanguage: GleanEvent;
    changeToLanguage: GleanEvent;
    openSettingsMenu: GleanEvent;
    translationSettings: GleanEvent;
    aboutTranslations: GleanEvent;
    initializationFailureMessage: GleanEvent;
    translationFailureMessage: GleanEvent;
    unsupportedLanguageMessage: GleanEvent;
  }

  translationsAboutTranslationsPage: {
    open: GleanEvent;
  }

  urlclassifier: {
    lookupTime2: GleanTimingDistribution;
    shutdownTime: GleanTimingDistribution;
    clCheckTime: GleanTimingDistribution;
    clKeyedUpdateTime: Record<string, GleanTimingDistribution>;
    asyncClassifylocalTime: GleanTimingDistribution;
    vlpsFileloadTime: GleanTimingDistribution;
    vlpsFallocateTime: GleanTimingDistribution;
    vlpsConstructTime: GleanTimingDistribution;
    vlpsMetadataCorrupt: Record<string, GleanCounter>;
    updateRemoteNetworkError: Record<string, GleanCustomDistribution>;
    updateRemoteStatus2: Record<string, GleanCustomDistribution>;
    updateServerResponseTime: Record<string, GleanTimingDistribution>;
    updateTimeout: Record<string, GleanCustomDistribution>;
    completeRemoteStatus2: Record<string, GleanCustomDistribution>;
    completionError: GleanCustomDistribution;
    completeServerResponseTime: Record<string, GleanTimingDistribution>;
    updateError: Record<string, GleanCustomDistribution>;
    threathitNetworkError: GleanCustomDistribution;
    threathitRemoteStatus: GleanCustomDistribution;
    uiEvents: GleanCustomDistribution;
  }

  securityDohNeterror: {
    loadDohwarning: GleanEvent;
    clickTryAgainButton: GleanEvent;
    clickAddExceptionButton: GleanEvent;
    clickSettingsButton: GleanEvent;
    clickContinueButton: GleanEvent;
    clickDisableWarning: GleanEvent;
    clickLearnMoreLink: GleanEvent;
  }

  securityUiCerterror: {
    loadAboutcerterror: GleanEvent;
    clickAdvancedButton: GleanEvent;
    clickExceptionButton: GleanEvent;
    clickReturnButtonTop: GleanEvent;
    clickReturnButtonAdv: GleanEvent;
    clickLearnMoreLink: GleanEvent;
    clickAutoReportCb: GleanEvent;
    clickErrorCodeLink: GleanEvent;
    clickClipboardButtonTop: GleanEvent;
    clickClipboardButtonBot: GleanEvent;
  }

  securityUiTlserror: {
    loadAbouttlserror: GleanEvent;
  }

  findbar: {
    shown: GleanCounter;
    findPrev: GleanCounter;
    findNext: GleanCounter;
    highlightAll: GleanCounter;
    matchCase: GleanCounter;
    matchDiacritics: GleanCounter;
    wholeWords: GleanCounter;
  }

  mozstorage: {
    sqlitejsmTransactionTimeout: Record<string, GleanCounter>;
  }

  region: {
    fetchTime: GleanTimingDistribution;
    fetchResult: GleanCustomDistribution;
    homeRegion: GleanString;
    storeRegionResult: Record<string, GleanCounter>;
  }

  firstStartup: {
    statusCode: GleanQuantity;
    elapsed: GleanQuantity;
    normandyInitTime: GleanQuantity;
    deleteTasksTime: GleanQuantity;
    newProfile: GleanBoolean;
  }

  serviceRequest: {
    bypassProxyInfo: GleanEvent;
  }

  jsonfile: {
    loadLogins: GleanEvent;
    loadAutofillprofiles: GleanEvent;
  }

  newtabPage: {
    pinnedSitesCount: GleanCustomDistribution;
    blockedSitesCount: GleanCustomDistribution;
  }

  popupNotification: {
    stats: Record<string, GleanCustomDistribution>;
    mainAction: Record<string, GleanTimingDistribution>;
    dismissal: Record<string, GleanTimingDistribution>;
  }

  system: {
    osVersion: GleanString;
    previousOsVersion: GleanString;
    memory: GleanQuantity;
    virtualMemory: GleanQuantity;
    isWow64: GleanBoolean;
    isWowArm64: GleanBoolean;
    hasWinPackageId: GleanBoolean;
    winPackageFamilyName: GleanString;
    appleModelId: GleanString;
  }

  systemDefault: {
    browser: GleanString;
    previousBrowser: GleanString;
    pdfHandler: GleanString;
  }

  notification: {
    showSuccess: GleanBoolean;
    action: GleanString;
  }

  defaultagent: {
    daysSinceLastAppLaunch: GleanQuantity;
  }

  addons: {
    activeAddons: GleanObject;
    theme: GleanObject;
    activeGMPlugins: GleanObject;
  }

  addonsManager: {
    install: GleanEvent;
    update: GleanEvent;
    installStats: GleanEvent;
    manage: GleanEvent;
    reportSuspiciousSite: GleanEvent;
    compatibilityCheckEnabled: GleanBoolean;
    xpistatesWriteErrors: GleanEvent;
    installExtension: GleanEvent;
    installTheme: GleanEvent;
    installLocale: GleanEvent;
    installDictionary: GleanEvent;
    installSitepermission: GleanEvent;
    installSitepermDeprecated: GleanEvent;
    installOther: GleanEvent;
    installUnknown: GleanEvent;
    updateExtension: GleanEvent;
    updateTheme: GleanEvent;
    updateLocale: GleanEvent;
    updateDictionary: GleanEvent;
    updateSitepermission: GleanEvent;
    updateSitepermDeprecated: GleanEvent;
    updateOther: GleanEvent;
    updateUnknown: GleanEvent;
    installStatsExtension: GleanEvent;
    installStatsTheme: GleanEvent;
    installStatsLocale: GleanEvent;
    installStatsDictionary: GleanEvent;
    installStatsSitepermission: GleanEvent;
    installStatsSitepermDeprecated: GleanEvent;
    installStatsOther: GleanEvent;
    installStatsUnknown: GleanEvent;
    disableExtension: GleanEvent;
    disableTheme: GleanEvent;
    disableLocale: GleanEvent;
    disableDictionary: GleanEvent;
    disableSitepermission: GleanEvent;
    disableSitepermDeprecated: GleanEvent;
    disableOther: GleanEvent;
    disableUnknown: GleanEvent;
    enableExtension: GleanEvent;
    enableTheme: GleanEvent;
    enableLocale: GleanEvent;
    enableDictionary: GleanEvent;
    enableSitepermission: GleanEvent;
    enableSitepermDeprecated: GleanEvent;
    enableOther: GleanEvent;
    enableUnknown: GleanEvent;
    sideloadPromptExtension: GleanEvent;
    sideloadPromptTheme: GleanEvent;
    sideloadPromptLocale: GleanEvent;
    sideloadPromptDictionary: GleanEvent;
    sideloadPromptSitepermission: GleanEvent;
    sideloadPromptSitepermDeprecated: GleanEvent;
    sideloadPromptOther: GleanEvent;
    sideloadPromptUnknown: GleanEvent;
    uninstallExtension: GleanEvent;
    uninstallTheme: GleanEvent;
    uninstallLocale: GleanEvent;
    uninstallDictionary: GleanEvent;
    uninstallSitepermission: GleanEvent;
    uninstallSitepermDeprecated: GleanEvent;
    uninstallOther: GleanEvent;
    uninstallUnknown: GleanEvent;
  }

  blocklist: {
    lastModifiedRsAddonsMblf: GleanDatetime;
    mlbfSource: GleanString;
    mlbfSoftblocksSource: GleanString;
    mlbfGenerationTime: GleanDatetime;
    mlbfSoftblocksGenerationTime: GleanDatetime;
    mlbfStashTimeOldest: GleanDatetime;
    mlbfStashTimeNewest: GleanDatetime;
    addonBlockChange: GleanEvent;
    enabled: GleanBoolean;
  }

  update: {
    autoDownload: GleanBoolean;
    backgroundUpdate: GleanBoolean;
    canUsuallyApplyUpdates: GleanBoolean;
    canUsuallyCheckForUpdates: GleanBoolean;
    canUsuallyStageUpdates: GleanBoolean;
    canUsuallyUseBits: GleanBoolean;
    channel: GleanString;
    enabled: GleanBoolean;
    serviceEnabled: GleanBoolean;
    checkNoUpdateExternal: GleanCounter;
    checkNoUpdateNotify: GleanCounter;
    checkNoUpdateSubsequent: GleanCounter;
    checkCodeExternal: GleanCustomDistribution;
    checkCodeNotify: GleanCustomDistribution;
    checkCodeSubsequent: GleanCustomDistribution;
    checkExtendedErrorExternal: Record<string, GleanCounter>;
    checkExtendedErrorNotify: Record<string, GleanCounter>;
    checkExtendedErrorSubsequent: Record<string, GleanCounter>;
    invalidLastupdatetimeExternal: GleanCounter;
    invalidLastupdatetimeNotify: GleanCounter;
    invalidLastupdatetimeSubsequent: GleanCounter;
    lastNotifyIntervalDaysExternal: GleanTimingDistribution;
    lastNotifyIntervalDaysNotify: GleanTimingDistribution;
    lastNotifyIntervalDaysSubsequent: GleanTimingDistribution;
    pingCountExternal: GleanCounter;
    pingCountNotify: GleanCounter;
    pingCountSubsequent: GleanCounter;
    serviceInstalledExternal: Record<string, GleanCounter>;
    serviceInstalledNotify: Record<string, GleanCounter>;
    serviceInstalledSubsequent: Record<string, GleanCounter>;
    serviceManuallyUninstalledExternal: GleanCounter;
    serviceManuallyUninstalledNotify: GleanCounter;
    serviceManuallyUninstalledSubsequent: GleanCounter;
    unableToApplyExternal: GleanCounter;
    unableToApplyNotify: GleanCounter;
    unableToApplySubsequent: GleanCounter;
    cannotStageExternal: GleanCounter;
    cannotStageNotify: GleanCounter;
    cannotStageSubsequent: GleanCounter;
    prefUpdateCancelationsExternal: GleanCustomDistribution;
    prefUpdateCancelationsNotify: GleanCustomDistribution;
    prefUpdateCancelationsSubsequent: GleanCustomDistribution;
    prefServiceErrorsExternal: GleanCustomDistribution;
    prefServiceErrorsNotify: GleanCustomDistribution;
    prefServiceErrorsSubsequent: GleanCustomDistribution;
    notPrefUpdateAutoExternal: GleanCounter;
    notPrefUpdateAutoNotify: GleanCounter;
    notPrefUpdateAutoSubsequent: GleanCounter;
    notPrefUpdateStagingEnabledExternal: GleanCounter;
    notPrefUpdateStagingEnabledNotify: GleanCounter;
    notPrefUpdateStagingEnabledSubsequent: GleanCounter;
    notPrefUpdateServiceEnabledExternal: GleanCounter;
    notPrefUpdateServiceEnabledNotify: GleanCounter;
    notPrefUpdateServiceEnabledSubsequent: GleanCounter;
    canUseBitsExternal: Record<string, GleanCounter>;
    canUseBitsNotify: Record<string, GleanCounter>;
    canUseBitsSubsequent: Record<string, GleanCounter>;
    downloadCodeComplete: GleanCustomDistribution;
    downloadCodePartial: GleanCustomDistribution;
    downloadCodeUnknown: GleanCustomDistribution;
    stateCodeCompleteStartup: GleanCustomDistribution;
    stateCodePartialStartup: GleanCustomDistribution;
    stateCodeUnknownStartup: GleanCustomDistribution;
    stateCodeCompleteStage: GleanCustomDistribution;
    stateCodePartialStage: GleanCustomDistribution;
    stateCodeUnknownStage: GleanCustomDistribution;
    statusErrorCodeCompleteStartup: GleanCustomDistribution;
    statusErrorCodePartialStartup: GleanCustomDistribution;
    statusErrorCodeUnknownStartup: GleanCustomDistribution;
    statusErrorCodeCompleteStage: GleanCustomDistribution;
    statusErrorCodePartialStage: GleanCustomDistribution;
    statusErrorCodeUnknownStage: GleanCustomDistribution;
    bitsResultComplete: GleanCustomDistribution;
    bitsResultPartial: GleanCustomDistribution;
    notificationShown: Record<string, GleanCounter>;
    notificationBadgeShown: Record<string, GleanCounter>;
    notificationDismissed: Record<string, GleanCounter>;
    notificationMainActionDoorhanger: Record<string, GleanCounter>;
    notificationMainActionMenu: Record<string, GleanCounter>;
    langpackOvertime: GleanTimingDistribution;
    bitshresult: Record<string, GleanCounter>;
    moveResult: Record<string, GleanCounter>;
    noWindowAutoRestarts: GleanCounter;
    suppressPrompts: GleanBoolean;
    versionPin: GleanString;
  }

  updater: {
    available: GleanBoolean;
  }

  updateSettings: {
    channel: GleanString;
    enabled: GleanBoolean;
    autoDownload: GleanBoolean;
    background: GleanBoolean;
  }

  profiles: {
    creationDate: GleanQuantity;
    resetDate: GleanQuantity;
    firstUseDate: GleanQuantity;
    recoveredFromBackup: GleanQuantity;
  }

  gecko: {
    version: GleanString;
    buildId: GleanString;
    safeModeUsage: GleanCustomDistribution;
  }

  launcherProcess: {
    state: GleanQuantity;
  }

  e10s: {
    enabled: GleanBoolean;
    multiProcesses: GleanQuantity;
  }

  fission: {
    enabled: GleanBoolean;
  }

  widget: {
    imeNameOnMac: Record<string, GleanBoolean>;
    imeNameOnLinux: Record<string, GleanBoolean>;
    gtkVersion: GleanString;
    darkMode: GleanBoolean;
    pointingDevices: Record<string, GleanBoolean>;
    notifyIdle: GleanTimingDistribution;
    imeNameOnWindows: Record<string, GleanBoolean>;
    imeNameOnWindowsInsertedCrlf: Record<string, GleanBoolean>;
    touchEnabledDevice: Record<string, GleanCounter>;
  }

  gfxFeatures: {
    compositor: GleanString;
    d3d11: GleanObject;
    d2d: GleanObject;
    hwCompositing: GleanObject;
    gpuProcess: GleanObject;
    webrender: GleanObject;
    wrCompositor: GleanObject;
    openglCompositing: GleanObject;
    omtp: GleanObject;
  }

  windowsSecurity: {
    antivirus: GleanStringList;
    antispyware: GleanStringList;
    firewall: GleanStringList;
  }

  timerThread: {
    timersFiredPerWakeup: GleanCustomDistribution;
  }

  memoryWatcher: {
    onHighMemoryStats: GleanEvent;
  }

  memoryPhc: {
    slop: GleanMemoryDistribution;
    slotsAllocated: GleanCustomDistribution;
    slotsFreed: GleanCustomDistribution;
  }

  cycleCollector: {
    time: GleanTimingDistribution;
    workerTime: GleanTimingDistribution;
    visitedRefCounted: GleanCustomDistribution;
    workerVisitedRefCounted: GleanCustomDistribution;
    visitedGced: GleanCustomDistribution;
    workerVisitedGced: GleanCustomDistribution;
    collected: GleanCustomDistribution;
    workerCollected: GleanCustomDistribution;
    needGc: Record<string, GleanCounter>;
    workerNeedGc: Record<string, GleanCounter>;
    full: GleanTimingDistribution;
    maxPause: GleanTimingDistribution;
    finishIgc: Record<string, GleanCounter>;
    syncSkippable: Record<string, GleanCounter>;
    timeBetween: GleanTimingDistribution;
    sliceDuringIdle: GleanCustomDistribution;
    asyncSnowWhiteFreeing: GleanTimingDistribution;
    deferredFinalizeAsync: GleanTimingDistribution;
    forgetSkippableMax: GleanTimingDistribution;
  }

  event: {
    longtask: Record<string, GleanTimingDistribution>;
  }

  xpcom: {
    abi: GleanString;
  }

  systemCpu: {
    name: GleanString;
    vendor: GleanString;
    logicalCores: GleanQuantity;
    physicalCores: GleanQuantity;
    bigCores: GleanQuantity;
    mediumCores: GleanQuantity;
    littleCores: GleanQuantity;
    family: GleanQuantity;
    model: GleanQuantity;
    stepping: GleanQuantity;
    l2Cache: GleanQuantity;
    l3Cache: GleanQuantity;
    speed: GleanQuantity;
    extensions: GleanStringList;
  }

  hdd: {
    profile: GleanObject;
    binary: GleanObject;
    system: GleanObject;
  }

  systemOs: {
    name: GleanString;
    version: GleanString;
    locale: GleanString;
    distro: GleanString;
    distroVersion: GleanString;
    servicePackMajor: GleanQuantity;
    servicePackMinor: GleanQuantity;
    windowsBuildNumber: GleanQuantity;
    windowsUbr: GleanQuantity;
  }
}

interface GleanPingsImpl {
  messagingSystem: nsIGleanPingNoReason;
  newtab: nsIGleanPingWithReason<"newtab_session_end"|"component_init">;
  newtabContent: nsIGleanPingWithReason<"newtab_session_end"|"component_init">;
  topSites: nsIGleanPingNoReason;
  spoc: nsIGleanPingWithReason<"impression"|"click"|"save">;
  pocketButton: nsIGleanPingNoReason;
  searchWith: nsIGleanPingNoReason;
  serpCategorization: nsIGleanPingWithReason<"startup"|"inactivity"|"threshold_reached">;
  quickSuggest: nsIGleanPingNoReason;
  quickSuggestDeletionRequest: nsIGleanPingNoReason;
  urlbarKeywordExposure: nsIGleanPingNoReason;
  prototypeNoCodeEvents: nsIGleanPingNoReason;
  contextIdDeletionRequest: nsIGleanPingNoReason;
  pageload: nsIGleanPingWithReason<"startup"|"threshold">;
  useCounters: nsIGleanPingWithReason<"app_shutdown_confirmed"|"idle_startup">;
  fxAccounts: nsIGleanPingWithReason<"active"|"dirty_startup"|"inactive">;
  bounceTrackingProtection: nsIGleanPingNoReason;
  hangReport: nsIGleanPingNoReason;
  backgroundTasks: nsIGleanPingNoReason;
  captchaDetection: nsIGleanPingNoReason;
  crash: nsIGleanPingWithReason<"crash"|"event_found">;
  dauReporting: nsIGleanPingWithReason<"dirty_startup"|"inactive"|"active">;
  onePingOnly: nsIGleanPingNoReason;
  testPing: nsIGleanPingNoReason;
  testOhttpPing: nsIGleanPingNoReason;
  rideAlongPing: nsIGleanPingNoReason;
  collectionDisabledPing: nsIGleanPingNoReason;
  disabledPing: nsIGleanPingNoReason;
  nimbusTargetingContext: nsIGleanPingNoReason;
  heartbeat: nsIGleanPingNoReason;
  brokenSiteReport: nsIGleanPingNoReason;
  userCharacteristics: nsIGleanPingNoReason;
  usageReporting: nsIGleanPingWithReason<"dirty_startup"|"inactive"|"active">;
  usageDeletionRequest: nsIGleanPingWithReason<"set_upload_enabled">;
  onboardingOptOut: nsIGleanPingWithReason<"set_upload_enabled">;
  firstStartup: nsIGleanPingNoReason;
  defaultAgent: nsIGleanPingWithReason<"daily_ping">;
  backgroundUpdate: nsIGleanPingWithReason<"backgroundupdate_task">;
}

// @ts-nocheck
/**
 * NOTE: Do not modify this file by hand.
 * Content was generated from source XPCOM .idl files.
 * If you're updating some of the sources, see README for instructions.
 */

declare global {

// https://searchfox.org/mozilla-central/source/browser/components/shell/nsIGNOMEShellService.idl

interface nsIGNOMEShellService extends nsIShellService {
  readonly canSetDesktopBackground: boolean;
  isDefaultForScheme(aScheme: string): boolean;
}

// https://searchfox.org/mozilla-central/source/browser/components/shell/nsIOpenTabsProvider.idl

interface nsIOpenTabsProvider extends nsISupports {
  getOpenTabs(): string[];
  switchToOpenTab(url: string): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIApplicationChooser.idl

type nsIApplicationChooserFinishedCallback = Callable<{
  done(handlerApp: nsIHandlerApp): void;
}>

interface nsIApplicationChooser extends nsISupports {
  init(parent: mozIDOMWindowProxy, title: string): void;
  open(contentType: string, applicationChooserFinishedCallback: nsIApplicationChooserFinishedCallback): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIGtkTaskbarProgress.idl

interface nsIGtkTaskbarProgress extends nsITaskbarProgress {
  setPrimaryWindow(aWindow: mozIDOMWindowProxy): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsITaskbarProgress.idl

interface nsITaskbarProgress extends nsISupports {
  readonly STATE_NO_PROGRESS?: 0;
  readonly STATE_INDETERMINATE?: 1;
  readonly STATE_NORMAL?: 2;
  readonly STATE_ERROR?: 3;
  readonly STATE_PAUSED?: 4;

  setProgressState(state: nsTaskbarProgressState, currentValue?: u64, maxValue?: u64): void;
}

interface nsIXPCComponents_Interfaces {
  nsIGNOMEShellService: nsJSIID<nsIGNOMEShellService>;
  nsIOpenTabsProvider: nsJSIID<nsIOpenTabsProvider>;
  nsIApplicationChooserFinishedCallback: nsJSIID<nsIApplicationChooserFinishedCallback>;
  nsIApplicationChooser: nsJSIID<nsIApplicationChooser>;
  nsIGtkTaskbarProgress: nsJSIID<nsIGtkTaskbarProgress>;
  nsITaskbarProgress: nsJSIID<nsITaskbarProgress>;
}

}  // global

// Typedefs from xpidl.
type PRTime = i64;
type nsHandlerInfoAction = i32;
type nsTaskbarProgressState = i32;

// XPCOM internal utility types.

/** XPCOM inout param is passed in as a js object with a value property. */
type InOutParam<T> = { value: T };

/** XPCOM out param is written to the passed in object's value property. */
type OutParam<T> = { value?: T };

/** Enable interfaces to inherit from enums: pick variants as optional. */
type Enums<enums> = Partial<Pick<enums, keyof enums>>;

/** Callable accepts either form of a [function] interface. */
type Callable<iface> = iface | Extract<iface[keyof iface], Function>


// @ts-nocheck
/**
 * NOTE: Do not modify this file by hand.
 * Content was generated by running "mach ts paths".
 */

  "chrome://browser/content/backup/backup-constants.mjs": typeof import("chrome://browser/content/backup/backup-constants.mjs"),
  "chrome://browser/content/migration/migration-wizard-constants.mjs": typeof import("chrome://browser/content/migration/migration-wizard-constants.mjs"),
  "chrome://browser/content/nsContextMenu.sys.mjs": typeof import("chrome://browser/content/nsContextMenu.sys.mjs"),
  "chrome://devtools-startup/content/DevToolsShim.sys.mjs": typeof import("chrome://devtools-startup/content/DevToolsShim.sys.mjs"),
  "chrome://global/content/ml/BlockWords.sys.mjs": typeof import("chrome://global/content/ml/BlockWords.sys.mjs"),
  "chrome://global/content/ml/EmbeddingsGenerator.sys.mjs": typeof import("chrome://global/content/ml/EmbeddingsGenerator.sys.mjs"),
  "chrome://global/content/ml/EngineProcess.sys.mjs": typeof import("chrome://global/content/ml/EngineProcess.sys.mjs"),
  "chrome://global/content/ml/HttpInference.sys.mjs": typeof import("chrome://global/content/ml/HttpInference.sys.mjs"),
  "chrome://global/content/ml/ModelHub.sys.mjs": typeof import("chrome://global/content/ml/ModelHub.sys.mjs"),
  "chrome://global/content/ml/OPFS.sys.mjs": typeof import("chrome://global/content/ml/OPFS.sys.mjs"),
  "chrome://global/content/ml/Utils.sys.mjs": typeof import("chrome://global/content/ml/Utils.sys.mjs"),
  "chrome://global/content/ml/backends/LlamaPipeline.mjs": typeof import("chrome://global/content/ml/backends/LlamaPipeline.mjs"),
  "chrome://global/content/ml/backends/ONNXPipeline.mjs": typeof import("chrome://global/content/ml/backends/ONNXPipeline.mjs"),
  "chrome://global/content/ml/backends/Pipeline.mjs": typeof import("chrome://global/content/ml/backends/Pipeline.mjs"),
  "chrome://global/content/translations/TranslationsTelemetry.sys.mjs": typeof import("chrome://global/content/translations/TranslationsTelemetry.sys.mjs"),
  "chrome://global/content/translations/TranslationsUtils.mjs": typeof import("chrome://global/content/translations/TranslationsUtils.mjs"),
  "chrome://global/content/translations/translations-document.sys.mjs": typeof import("chrome://global/content/translations/translations-document.sys.mjs"),
  "chrome://global/content/translations/translations-engine.sys.mjs": typeof import("chrome://global/content/translations/translations-engine.sys.mjs"),
  "chrome://mochitests/content/browser/remote/shared/messagehandler/test/browser/resources/modules/ModuleRegistry.sys.mjs": typeof import("chrome://mochitests/content/browser/remote/shared/messagehandler/test/browser/resources/modules/ModuleRegistry.sys.mjs"),
  "chrome://pocket/content/Pocket.sys.mjs": typeof import("chrome://pocket/content/Pocket.sys.mjs"),
  "chrome://pocket/content/SaveToPocket.sys.mjs": typeof import("chrome://pocket/content/SaveToPocket.sys.mjs"),
  "chrome://pocket/content/pktApi.sys.mjs": typeof import("chrome://pocket/content/pktApi.sys.mjs"),
  "chrome://pocket/content/pktTelemetry.sys.mjs": typeof import("chrome://pocket/content/pktTelemetry.sys.mjs"),
  "chrome://remote/content/cdp/CDP.sys.mjs": typeof import("chrome://remote/content/cdp/CDP.sys.mjs"),
  "chrome://remote/content/cdp/CDPConnection.sys.mjs": typeof import("chrome://remote/content/cdp/CDPConnection.sys.mjs"),
  "chrome://remote/content/cdp/Error.sys.mjs": typeof import("chrome://remote/content/cdp/Error.sys.mjs"),
  "chrome://remote/content/cdp/JSONHandler.sys.mjs": typeof import("chrome://remote/content/cdp/JSONHandler.sys.mjs"),
  "chrome://remote/content/cdp/Protocol.sys.mjs": typeof import("chrome://remote/content/cdp/Protocol.sys.mjs"),
  "chrome://remote/content/cdp/StreamRegistry.sys.mjs": typeof import("chrome://remote/content/cdp/StreamRegistry.sys.mjs"),
  "chrome://remote/content/cdp/domains/ContentProcessDomains.sys.mjs": typeof import("chrome://remote/content/cdp/domains/ContentProcessDomains.sys.mjs"),
  "chrome://remote/content/cdp/domains/Domain.sys.mjs": typeof import("chrome://remote/content/cdp/domains/Domain.sys.mjs"),
  "chrome://remote/content/cdp/domains/DomainCache.sys.mjs": typeof import("chrome://remote/content/cdp/domains/DomainCache.sys.mjs"),
  "chrome://remote/content/cdp/domains/ParentProcessDomains.sys.mjs": typeof import("chrome://remote/content/cdp/domains/ParentProcessDomains.sys.mjs"),
  "chrome://remote/content/cdp/domains/content/DOM.sys.mjs": typeof import("chrome://remote/content/cdp/domains/content/DOM.sys.mjs"),
  "chrome://remote/content/cdp/domains/content/Emulation.sys.mjs": typeof import("chrome://remote/content/cdp/domains/content/Emulation.sys.mjs"),
  "chrome://remote/content/cdp/domains/content/Input.sys.mjs": typeof import("chrome://remote/content/cdp/domains/content/Input.sys.mjs"),
  "chrome://remote/content/cdp/domains/content/Log.sys.mjs": typeof import("chrome://remote/content/cdp/domains/content/Log.sys.mjs"),
  "chrome://remote/content/cdp/domains/content/Network.sys.mjs": typeof import("chrome://remote/content/cdp/domains/content/Network.sys.mjs"),
  "chrome://remote/content/cdp/domains/content/Page.sys.mjs": typeof import("chrome://remote/content/cdp/domains/content/Page.sys.mjs"),
  "chrome://remote/content/cdp/domains/content/Performance.sys.mjs": typeof import("chrome://remote/content/cdp/domains/content/Performance.sys.mjs"),
  "chrome://remote/content/cdp/domains/content/Runtime.sys.mjs": typeof import("chrome://remote/content/cdp/domains/content/Runtime.sys.mjs"),
  "chrome://remote/content/cdp/domains/content/Security.sys.mjs": typeof import("chrome://remote/content/cdp/domains/content/Security.sys.mjs"),
  "chrome://remote/content/cdp/domains/content/runtime/ExecutionContext.sys.mjs": typeof import("chrome://remote/content/cdp/domains/content/runtime/ExecutionContext.sys.mjs"),
  "chrome://remote/content/cdp/domains/parent/Browser.sys.mjs": typeof import("chrome://remote/content/cdp/domains/parent/Browser.sys.mjs"),
  "chrome://remote/content/cdp/domains/parent/Emulation.sys.mjs": typeof import("chrome://remote/content/cdp/domains/parent/Emulation.sys.mjs"),
  "chrome://remote/content/cdp/domains/parent/Fetch.sys.mjs": typeof import("chrome://remote/content/cdp/domains/parent/Fetch.sys.mjs"),
  "chrome://remote/content/cdp/domains/parent/IO.sys.mjs": typeof import("chrome://remote/content/cdp/domains/parent/IO.sys.mjs"),
  "chrome://remote/content/cdp/domains/parent/Input.sys.mjs": typeof import("chrome://remote/content/cdp/domains/parent/Input.sys.mjs"),
  "chrome://remote/content/cdp/domains/parent/Network.sys.mjs": typeof import("chrome://remote/content/cdp/domains/parent/Network.sys.mjs"),
  "chrome://remote/content/cdp/domains/parent/Page.sys.mjs": typeof import("chrome://remote/content/cdp/domains/parent/Page.sys.mjs"),
  "chrome://remote/content/cdp/domains/parent/Security.sys.mjs": typeof import("chrome://remote/content/cdp/domains/parent/Security.sys.mjs"),
  "chrome://remote/content/cdp/domains/parent/SystemInfo.sys.mjs": typeof import("chrome://remote/content/cdp/domains/parent/SystemInfo.sys.mjs"),
  "chrome://remote/content/cdp/domains/parent/Target.sys.mjs": typeof import("chrome://remote/content/cdp/domains/parent/Target.sys.mjs"),
  "chrome://remote/content/cdp/domains/parent/page/DialogHandler.sys.mjs": typeof import("chrome://remote/content/cdp/domains/parent/page/DialogHandler.sys.mjs"),
  "chrome://remote/content/cdp/observers/ChannelEventSink.sys.mjs": typeof import("chrome://remote/content/cdp/observers/ChannelEventSink.sys.mjs"),
  "chrome://remote/content/cdp/observers/ContextObserver.sys.mjs": typeof import("chrome://remote/content/cdp/observers/ContextObserver.sys.mjs"),
  "chrome://remote/content/cdp/observers/NetworkObserver.sys.mjs": typeof import("chrome://remote/content/cdp/observers/NetworkObserver.sys.mjs"),
  "chrome://remote/content/cdp/observers/TargetObserver.sys.mjs": typeof import("chrome://remote/content/cdp/observers/TargetObserver.sys.mjs"),
  "chrome://remote/content/cdp/sessions/MainProcessSession.sys.mjs": typeof import("chrome://remote/content/cdp/sessions/MainProcessSession.sys.mjs"),
  "chrome://remote/content/cdp/sessions/TabSession.sys.mjs": typeof import("chrome://remote/content/cdp/sessions/TabSession.sys.mjs"),
  "chrome://remote/content/cdp/targets/MainProcessTarget.sys.mjs": typeof import("chrome://remote/content/cdp/targets/MainProcessTarget.sys.mjs"),
  "chrome://remote/content/cdp/targets/TabTarget.sys.mjs": typeof import("chrome://remote/content/cdp/targets/TabTarget.sys.mjs"),
  "chrome://remote/content/cdp/targets/TargetList.sys.mjs": typeof import("chrome://remote/content/cdp/targets/TargetList.sys.mjs"),
  "chrome://remote/content/components/Marionette.sys.mjs": typeof import("chrome://remote/content/components/Marionette.sys.mjs"),
  "chrome://remote/content/components/RemoteAgent.sys.mjs": typeof import("chrome://remote/content/components/RemoteAgent.sys.mjs"),
  "chrome://remote/content/marionette/actors/MarionetteCommandsParent.sys.mjs": typeof import("chrome://remote/content/marionette/actors/MarionetteCommandsParent.sys.mjs"),
  "chrome://remote/content/marionette/actors/MarionetteEventsParent.sys.mjs": typeof import("chrome://remote/content/marionette/actors/MarionetteEventsParent.sys.mjs"),
  "chrome://remote/content/marionette/atom.sys.mjs": typeof import("chrome://remote/content/marionette/atom.sys.mjs"),
  "chrome://remote/content/marionette/browser.sys.mjs": typeof import("chrome://remote/content/marionette/browser.sys.mjs"),
  "chrome://remote/content/marionette/cookie.sys.mjs": typeof import("chrome://remote/content/marionette/cookie.sys.mjs"),
  "chrome://remote/content/marionette/driver.sys.mjs": typeof import("chrome://remote/content/marionette/driver.sys.mjs"),
  "chrome://remote/content/marionette/evaluate.sys.mjs": typeof import("chrome://remote/content/marionette/evaluate.sys.mjs"),
  "chrome://remote/content/marionette/interaction.sys.mjs": typeof import("chrome://remote/content/marionette/interaction.sys.mjs"),
  "chrome://remote/content/marionette/json.sys.mjs": typeof import("chrome://remote/content/marionette/json.sys.mjs"),
  "chrome://remote/content/marionette/l10n.sys.mjs": typeof import("chrome://remote/content/marionette/l10n.sys.mjs"),
  "chrome://remote/content/marionette/message.sys.mjs": typeof import("chrome://remote/content/marionette/message.sys.mjs"),
  "chrome://remote/content/marionette/navigate.sys.mjs": typeof import("chrome://remote/content/marionette/navigate.sys.mjs"),
  "chrome://remote/content/marionette/packets.sys.mjs": typeof import("chrome://remote/content/marionette/packets.sys.mjs"),
  "chrome://remote/content/marionette/prefs.sys.mjs": typeof import("chrome://remote/content/marionette/prefs.sys.mjs"),
  "chrome://remote/content/marionette/reftest.sys.mjs": typeof import("chrome://remote/content/marionette/reftest.sys.mjs"),
  "chrome://remote/content/marionette/server.sys.mjs": typeof import("chrome://remote/content/marionette/server.sys.mjs"),
  "chrome://remote/content/marionette/stream-utils.sys.mjs": typeof import("chrome://remote/content/marionette/stream-utils.sys.mjs"),
  "chrome://remote/content/marionette/sync.sys.mjs": typeof import("chrome://remote/content/marionette/sync.sys.mjs"),
  "chrome://remote/content/marionette/transport.sys.mjs": typeof import("chrome://remote/content/marionette/transport.sys.mjs"),
  "chrome://remote/content/marionette/web-reference.sys.mjs": typeof import("chrome://remote/content/marionette/web-reference.sys.mjs"),
  "chrome://remote/content/marionette/webauthn.sys.mjs": typeof import("chrome://remote/content/marionette/webauthn.sys.mjs"),
  "chrome://remote/content/server/WebSocketHandshake.sys.mjs": typeof import("chrome://remote/content/server/WebSocketHandshake.sys.mjs"),
  "chrome://remote/content/server/WebSocketTransport.sys.mjs": typeof import("chrome://remote/content/server/WebSocketTransport.sys.mjs"),
  "chrome://remote/content/server/httpd.sys.mjs": typeof import("chrome://remote/content/server/httpd.sys.mjs"),
  "chrome://remote/content/shared/Addon.sys.mjs": typeof import("chrome://remote/content/shared/Addon.sys.mjs"),
  "chrome://remote/content/shared/AppInfo.sys.mjs": typeof import("chrome://remote/content/shared/AppInfo.sys.mjs"),
  "chrome://remote/content/shared/AsyncQueue.sys.mjs": typeof import("chrome://remote/content/shared/AsyncQueue.sys.mjs"),
  "chrome://remote/content/shared/Browser.sys.mjs": typeof import("chrome://remote/content/shared/Browser.sys.mjs"),
  "chrome://remote/content/shared/Capture.sys.mjs": typeof import("chrome://remote/content/shared/Capture.sys.mjs"),
  "chrome://remote/content/shared/ChallengeHeaderParser.sys.mjs": typeof import("chrome://remote/content/shared/ChallengeHeaderParser.sys.mjs"),
  "chrome://remote/content/shared/DOM.sys.mjs": typeof import("chrome://remote/content/shared/DOM.sys.mjs"),
  "chrome://remote/content/shared/Format.sys.mjs": typeof import("chrome://remote/content/shared/Format.sys.mjs"),
  "chrome://remote/content/shared/Log.sys.mjs": typeof import("chrome://remote/content/shared/Log.sys.mjs"),
  "chrome://remote/content/shared/MobileTabBrowser.sys.mjs": typeof import("chrome://remote/content/shared/MobileTabBrowser.sys.mjs"),
  "chrome://remote/content/shared/Navigate.sys.mjs": typeof import("chrome://remote/content/shared/Navigate.sys.mjs"),
  "chrome://remote/content/shared/NavigationManager.sys.mjs": typeof import("chrome://remote/content/shared/NavigationManager.sys.mjs"),
  "chrome://remote/content/shared/NetworkCacheManager.sys.mjs": typeof import("chrome://remote/content/shared/NetworkCacheManager.sys.mjs"),
  "chrome://remote/content/shared/NetworkDecodedBodySizeMap.sys.mjs": typeof import("chrome://remote/content/shared/NetworkDecodedBodySizeMap.sys.mjs"),
  "chrome://remote/content/shared/NetworkRequest.sys.mjs": typeof import("chrome://remote/content/shared/NetworkRequest.sys.mjs"),
  "chrome://remote/content/shared/NetworkResponse.sys.mjs": typeof import("chrome://remote/content/shared/NetworkResponse.sys.mjs"),
  "chrome://remote/content/shared/PDF.sys.mjs": typeof import("chrome://remote/content/shared/PDF.sys.mjs"),
  "chrome://remote/content/shared/Permissions.sys.mjs": typeof import("chrome://remote/content/shared/Permissions.sys.mjs"),
  "chrome://remote/content/shared/Prompt.sys.mjs": typeof import("chrome://remote/content/shared/Prompt.sys.mjs"),
  "chrome://remote/content/shared/Realm.sys.mjs": typeof import("chrome://remote/content/shared/Realm.sys.mjs"),
  "chrome://remote/content/shared/RecommendedPreferences.sys.mjs": typeof import("chrome://remote/content/shared/RecommendedPreferences.sys.mjs"),
  "chrome://remote/content/shared/Stack.sys.mjs": typeof import("chrome://remote/content/shared/Stack.sys.mjs"),
  "chrome://remote/content/shared/Sync.sys.mjs": typeof import("chrome://remote/content/shared/Sync.sys.mjs"),
  "chrome://remote/content/shared/TabManager.sys.mjs": typeof import("chrome://remote/content/shared/TabManager.sys.mjs"),
  "chrome://remote/content/shared/UUID.sys.mjs": typeof import("chrome://remote/content/shared/UUID.sys.mjs"),
  "chrome://remote/content/shared/UserContextManager.sys.mjs": typeof import("chrome://remote/content/shared/UserContextManager.sys.mjs"),
  "chrome://remote/content/shared/WindowManager.sys.mjs": typeof import("chrome://remote/content/shared/WindowManager.sys.mjs"),
  "chrome://remote/content/shared/js-window-actors/WebProgressListenerActor.sys.mjs": typeof import("chrome://remote/content/shared/js-window-actors/WebProgressListenerActor.sys.mjs"),
  "chrome://remote/content/shared/listeners/BeforeStopRequestListener.sys.mjs": typeof import("chrome://remote/content/shared/listeners/BeforeStopRequestListener.sys.mjs"),
  "chrome://remote/content/shared/listeners/BrowsingContextListener.sys.mjs": typeof import("chrome://remote/content/shared/listeners/BrowsingContextListener.sys.mjs"),
  "chrome://remote/content/shared/listeners/CachedResourceListener.sys.mjs": typeof import("chrome://remote/content/shared/listeners/CachedResourceListener.sys.mjs"),
  "chrome://remote/content/shared/listeners/ConsoleAPIListener.sys.mjs": typeof import("chrome://remote/content/shared/listeners/ConsoleAPIListener.sys.mjs"),
  "chrome://remote/content/shared/listeners/ConsoleListener.sys.mjs": typeof import("chrome://remote/content/shared/listeners/ConsoleListener.sys.mjs"),
  "chrome://remote/content/shared/listeners/ContextualIdentityListener.sys.mjs": typeof import("chrome://remote/content/shared/listeners/ContextualIdentityListener.sys.mjs"),
  "chrome://remote/content/shared/listeners/DataChannelListener.sys.mjs": typeof import("chrome://remote/content/shared/listeners/DataChannelListener.sys.mjs"),
  "chrome://remote/content/shared/listeners/LoadListener.sys.mjs": typeof import("chrome://remote/content/shared/listeners/LoadListener.sys.mjs"),
  "chrome://remote/content/shared/listeners/NavigationListener.sys.mjs": typeof import("chrome://remote/content/shared/listeners/NavigationListener.sys.mjs"),
  "chrome://remote/content/shared/listeners/NetworkEventRecord.sys.mjs": typeof import("chrome://remote/content/shared/listeners/NetworkEventRecord.sys.mjs"),
  "chrome://remote/content/shared/listeners/NetworkListener.sys.mjs": typeof import("chrome://remote/content/shared/listeners/NetworkListener.sys.mjs"),
  "chrome://remote/content/shared/listeners/ParentWebProgressListener.sys.mjs": typeof import("chrome://remote/content/shared/listeners/ParentWebProgressListener.sys.mjs"),
  "chrome://remote/content/shared/listeners/PromptListener.sys.mjs": typeof import("chrome://remote/content/shared/listeners/PromptListener.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/Errors.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/Errors.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/EventsDispatcher.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/EventsDispatcher.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/MessageHandler.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/MessageHandler.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/MessageHandlerRegistry.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/MessageHandlerRegistry.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/ModuleCache.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/ModuleCache.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/RootMessageHandler.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/RootMessageHandler.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/RootMessageHandlerRegistry.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/RootMessageHandlerRegistry.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/WindowGlobalMessageHandler.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/WindowGlobalMessageHandler.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/sessiondata/SessionData.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/sessiondata/SessionData.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/sessiondata/SessionDataReader.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/sessiondata/SessionDataReader.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/transports/BrowsingContextUtils.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/transports/BrowsingContextUtils.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/transports/RootTransport.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/transports/RootTransport.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/transports/js-window-actors/MessageHandlerFrameActor.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/transports/js-window-actors/MessageHandlerFrameActor.sys.mjs"),
  "chrome://remote/content/shared/messagehandler/transports/js-window-actors/MessageHandlerFrameChild.sys.mjs": typeof import("chrome://remote/content/shared/messagehandler/transports/js-window-actors/MessageHandlerFrameChild.sys.mjs"),
  "chrome://remote/content/shared/webdriver/Accessibility.sys.mjs": typeof import("chrome://remote/content/shared/webdriver/Accessibility.sys.mjs"),
  "chrome://remote/content/shared/webdriver/Actions.sys.mjs": typeof import("chrome://remote/content/shared/webdriver/Actions.sys.mjs"),
  "chrome://remote/content/shared/webdriver/Assert.sys.mjs": typeof import("chrome://remote/content/shared/webdriver/Assert.sys.mjs"),
  "chrome://remote/content/shared/webdriver/Capabilities.sys.mjs": typeof import("chrome://remote/content/shared/webdriver/Capabilities.sys.mjs"),
  "chrome://remote/content/shared/webdriver/Certificates.sys.mjs": typeof import("chrome://remote/content/shared/webdriver/Certificates.sys.mjs"),
  "chrome://remote/content/shared/webdriver/Errors.sys.mjs": typeof import("chrome://remote/content/shared/webdriver/Errors.sys.mjs"),
  "chrome://remote/content/shared/webdriver/Event.sys.mjs": typeof import("chrome://remote/content/shared/webdriver/Event.sys.mjs"),
  "chrome://remote/content/shared/webdriver/KeyData.sys.mjs": typeof import("chrome://remote/content/shared/webdriver/KeyData.sys.mjs"),
  "chrome://remote/content/shared/webdriver/NodeCache.sys.mjs": typeof import("chrome://remote/content/shared/webdriver/NodeCache.sys.mjs"),
  "chrome://remote/content/shared/webdriver/Session.sys.mjs": typeof import("chrome://remote/content/shared/webdriver/Session.sys.mjs"),
  "chrome://remote/content/shared/webdriver/URLPattern.sys.mjs": typeof import("chrome://remote/content/shared/webdriver/URLPattern.sys.mjs"),
  "chrome://remote/content/shared/webdriver/UserPromptHandler.sys.mjs": typeof import("chrome://remote/content/shared/webdriver/UserPromptHandler.sys.mjs"),
  "chrome://remote/content/shared/webdriver/process-actors/WebDriverProcessDataParent.sys.mjs": typeof import("chrome://remote/content/shared/webdriver/process-actors/WebDriverProcessDataParent.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/NewSessionHandler.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/NewSessionHandler.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/RemoteValue.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/RemoteValue.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/WebDriverBiDi.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/WebDriverBiDi.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/WebDriverBiDiConnection.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/WebDriverBiDiConnection.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/Intercept.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/Intercept.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/ModuleRegistry.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/ModuleRegistry.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/root/browser.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/root/browser.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/root/browsingContext.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/root/browsingContext.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/root/emulation.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/root/emulation.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/root/input.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/root/input.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/root/log.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/root/log.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/root/network.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/root/network.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/root/permissions.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/root/permissions.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/root/script.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/root/script.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/root/session.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/root/session.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/root/storage.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/root/storage.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/root/webExtension.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/root/webExtension.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/windowglobal-in-root/browsingContext.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/windowglobal-in-root/browsingContext.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/windowglobal-in-root/log.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/windowglobal-in-root/log.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/windowglobal-in-root/network.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/windowglobal-in-root/network.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/windowglobal-in-root/script.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/windowglobal-in-root/script.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/windowglobal/_configuration.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/windowglobal/_configuration.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/windowglobal/browsingContext.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/windowglobal/browsingContext.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/windowglobal/emulation.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/windowglobal/emulation.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/windowglobal/input.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/windowglobal/input.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/windowglobal/log.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/windowglobal/log.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/windowglobal/network.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/windowglobal/network.sys.mjs"),
  "chrome://remote/content/webdriver-bidi/modules/windowglobal/script.sys.mjs": typeof import("chrome://remote/content/webdriver-bidi/modules/windowglobal/script.sys.mjs"),
  "moz-src:///browser/components/DefaultBrowserCheck.sys.mjs": typeof import("moz-src:///browser/components/DefaultBrowserCheck.sys.mjs"),
  "moz-src:///browser/components/DesktopActorRegistry.sys.mjs": typeof import("moz-src:///browser/components/DesktopActorRegistry.sys.mjs"),
  "moz-src:///browser/components/ProfileDataUpgrader.sys.mjs": typeof import("moz-src:///browser/components/ProfileDataUpgrader.sys.mjs"),
  "moz-src:///browser/components/genai/LinkPreview.sys.mjs": typeof import("moz-src:///browser/components/genai/LinkPreview.sys.mjs"),
  "moz-src:///browser/components/genai/LinkPreviewModel.sys.mjs": typeof import("moz-src:///browser/components/genai/LinkPreviewModel.sys.mjs"),
  "moz-src:///browser/components/places/Interactions.sys.mjs": typeof import("moz-src:///browser/components/places/Interactions.sys.mjs"),
  "moz-src:///browser/components/places/InteractionsBlocklist.sys.mjs": typeof import("moz-src:///browser/components/places/InteractionsBlocklist.sys.mjs"),
  "moz-src:///browser/components/places/PlacesBrowserStartup.sys.mjs": typeof import("moz-src:///browser/components/places/PlacesBrowserStartup.sys.mjs"),
  "moz-src:///browser/components/places/PlacesUIUtils.sys.mjs": typeof import("moz-src:///browser/components/places/PlacesUIUtils.sys.mjs"),
  "moz-src:///browser/components/protections/ContentBlockingPrefs.sys.mjs": typeof import("moz-src:///browser/components/protections/ContentBlockingPrefs.sys.mjs"),
  "moz-src:///browser/components/search/BrowserSearchTelemetry.sys.mjs": typeof import("moz-src:///browser/components/search/BrowserSearchTelemetry.sys.mjs"),
  "moz-src:///browser/components/search/OpenSearchManager.sys.mjs": typeof import("moz-src:///browser/components/search/OpenSearchManager.sys.mjs"),
  "moz-src:///browser/components/search/SERPCategorization.sys.mjs": typeof import("moz-src:///browser/components/search/SERPCategorization.sys.mjs"),
  "moz-src:///browser/components/search/SearchOneOffs.sys.mjs": typeof import("moz-src:///browser/components/search/SearchOneOffs.sys.mjs"),
  "moz-src:///browser/components/search/SearchSERPTelemetry.sys.mjs": typeof import("moz-src:///browser/components/search/SearchSERPTelemetry.sys.mjs"),
  "moz-src:///browser/components/search/SearchUIUtils.sys.mjs": typeof import("moz-src:///browser/components/search/SearchUIUtils.sys.mjs"),
  "moz-src:///browser/components/shell/StartupOSIntegration.sys.mjs": typeof import("moz-src:///browser/components/shell/StartupOSIntegration.sys.mjs"),
  "moz-src:///browser/components/sidebar/SidebarManager.sys.mjs": typeof import("moz-src:///browser/components/sidebar/SidebarManager.sys.mjs"),
  "moz-src:///browser/components/sidebar/SidebarState.sys.mjs": typeof import("moz-src:///browser/components/sidebar/SidebarState.sys.mjs"),
  "moz-src:///browser/components/tabbrowser/AsyncTabSwitcher.sys.mjs": typeof import("moz-src:///browser/components/tabbrowser/AsyncTabSwitcher.sys.mjs"),
  "moz-src:///browser/components/tabbrowser/GroupsList.sys.mjs": typeof import("moz-src:///browser/components/tabbrowser/GroupsList.sys.mjs"),
  "moz-src:///browser/components/tabbrowser/NewTabPagePreloading.sys.mjs": typeof import("moz-src:///browser/components/tabbrowser/NewTabPagePreloading.sys.mjs"),
  "moz-src:///browser/components/tabbrowser/OpenInTabsUtils.sys.mjs": typeof import("moz-src:///browser/components/tabbrowser/OpenInTabsUtils.sys.mjs"),
  "moz-src:///browser/components/tabbrowser/SmartTabGrouping.sys.mjs": typeof import("moz-src:///browser/components/tabbrowser/SmartTabGrouping.sys.mjs"),
  "moz-src:///browser/components/tabbrowser/TabMetrics.sys.mjs": typeof import("moz-src:///browser/components/tabbrowser/TabMetrics.sys.mjs"),
  "moz-src:///browser/components/tabbrowser/TabsList.sys.mjs": typeof import("moz-src:///browser/components/tabbrowser/TabsList.sys.mjs"),
  "moz-src:///browser/components/uitour/UITour.sys.mjs": typeof import("moz-src:///browser/components/uitour/UITour.sys.mjs"),
  "moz-src:///browser/modules/ContextId.sys.mjs": typeof import("moz-src:///browser/modules/ContextId.sys.mjs"),
  "moz-src:///browser/themes/ToolbarIconColor.sys.mjs": typeof import("moz-src:///browser/themes/ToolbarIconColor.sys.mjs"),
  "moz-src:///toolkit/components/reader/AboutReader.sys.mjs": typeof import("moz-src:///toolkit/components/reader/AboutReader.sys.mjs"),
  "moz-src:///toolkit/components/reader/ReaderMode.sys.mjs": typeof import("moz-src:///toolkit/components/reader/ReaderMode.sys.mjs"),
  "moz-src:///toolkit/components/reader/ReaderWorker.sys.mjs": typeof import("moz-src:///toolkit/components/reader/ReaderWorker.sys.mjs"),
  "moz-src:///toolkit/components/search/AddonSearchEngine.sys.mjs": typeof import("moz-src:///toolkit/components/search/AddonSearchEngine.sys.mjs"),
  "moz-src:///toolkit/components/search/AppProvidedSearchEngine.sys.mjs": typeof import("moz-src:///toolkit/components/search/AppProvidedSearchEngine.sys.mjs"),
  "moz-src:///toolkit/components/search/OpenSearchEngine.sys.mjs": typeof import("moz-src:///toolkit/components/search/OpenSearchEngine.sys.mjs"),
  "moz-src:///toolkit/components/search/OpenSearchLoader.sys.mjs": typeof import("moz-src:///toolkit/components/search/OpenSearchLoader.sys.mjs"),
  "moz-src:///toolkit/components/search/PolicySearchEngine.sys.mjs": typeof import("moz-src:///toolkit/components/search/PolicySearchEngine.sys.mjs"),
  "moz-src:///toolkit/components/search/SearchEngine.sys.mjs": typeof import("moz-src:///toolkit/components/search/SearchEngine.sys.mjs"),
  "moz-src:///toolkit/components/search/SearchEngineSelector.sys.mjs": typeof import("moz-src:///toolkit/components/search/SearchEngineSelector.sys.mjs"),
  "moz-src:///toolkit/components/search/SearchSettings.sys.mjs": typeof import("moz-src:///toolkit/components/search/SearchSettings.sys.mjs"),
  "moz-src:///toolkit/components/search/SearchShortcuts.sys.mjs": typeof import("moz-src:///toolkit/components/search/SearchShortcuts.sys.mjs"),
  "moz-src:///toolkit/components/search/SearchStaticData.sys.mjs": typeof import("moz-src:///toolkit/components/search/SearchStaticData.sys.mjs"),
  "moz-src:///toolkit/components/search/SearchSuggestionController.sys.mjs": typeof import("moz-src:///toolkit/components/search/SearchSuggestionController.sys.mjs"),
  "moz-src:///toolkit/components/search/SearchUtils.sys.mjs": typeof import("moz-src:///toolkit/components/search/SearchUtils.sys.mjs"),
  "moz-src:///toolkit/components/search/UserSearchEngine.sys.mjs": typeof import("moz-src:///toolkit/components/search/UserSearchEngine.sys.mjs"),
  "moz-src:///toolkit/components/uniffi-bindgen-gecko-js/components/generated/RustRelevancy.sys.mjs": typeof import("moz-src:///toolkit/components/uniffi-bindgen-gecko-js/components/generated/RustRelevancy.sys.mjs"),
  "moz-src:///toolkit/components/uniffi-bindgen-gecko-js/components/generated/RustRemoteSettings.sys.mjs": typeof import("moz-src:///toolkit/components/uniffi-bindgen-gecko-js/components/generated/RustRemoteSettings.sys.mjs"),
  "moz-src:///toolkit/components/uniffi-bindgen-gecko-js/components/generated/RustSearch.sys.mjs": typeof import("moz-src:///toolkit/components/uniffi-bindgen-gecko-js/components/generated/RustSearch.sys.mjs"),
  "moz-src:///toolkit/components/uniffi-bindgen-gecko-js/components/generated/RustSuggest.sys.mjs": typeof import("moz-src:///toolkit/components/uniffi-bindgen-gecko-js/components/generated/RustSuggest.sys.mjs"),
  "moz-src:///toolkit/components/uniffi-bindgen-gecko-js/components/generated/RustTabs.sys.mjs": typeof import("moz-src:///toolkit/components/uniffi-bindgen-gecko-js/components/generated/RustTabs.sys.mjs"),
  "moz-src:///toolkit/components/uniffi-bindgen-gecko-js/components/generated/RustWebextstorage.sys.mjs": typeof import("moz-src:///toolkit/components/uniffi-bindgen-gecko-js/components/generated/RustWebextstorage.sys.mjs"),
  "moz-src:///toolkit/profile/ProfilesDatastoreService.sys.mjs": typeof import("moz-src:///toolkit/profile/ProfilesDatastoreService.sys.mjs"),
  "resource:///actors/AboutNewTabParent.sys.mjs": typeof import("resource:///actors/AboutNewTabParent.sys.mjs"),
  "resource:///actors/AboutReaderParent.sys.mjs": typeof import("resource:///actors/AboutReaderParent.sys.mjs"),
  "resource:///actors/AboutWelcomeParent.sys.mjs": typeof import("resource:///actors/AboutWelcomeParent.sys.mjs"),
  "resource:///actors/ClickHandlerParent.sys.mjs": typeof import("resource:///actors/ClickHandlerParent.sys.mjs"),
  "resource:///actors/ContentSearchParent.sys.mjs": typeof import("resource:///actors/ContentSearchParent.sys.mjs"),
  "resource:///actors/ContextMenuChild.sys.mjs": typeof import("resource:///actors/ContextMenuChild.sys.mjs"),
  "resource:///actors/LinkHandlerParent.sys.mjs": typeof import("resource:///actors/LinkHandlerParent.sys.mjs"),
  "resource:///actors/PluginParent.sys.mjs": typeof import("resource:///actors/PluginParent.sys.mjs"),
  "resource:///actors/SearchSERPTelemetryChild.sys.mjs": typeof import("resource:///actors/SearchSERPTelemetryChild.sys.mjs"),
  "resource:///actors/WebRTCChild.sys.mjs": typeof import("resource:///actors/WebRTCChild.sys.mjs"),
  "resource:///modules/360seMigrationUtils.sys.mjs": typeof import("resource:///modules/360seMigrationUtils.sys.mjs"),
  "resource:///modules/AboutHomeStartupCache.sys.mjs": typeof import("resource:///modules/AboutHomeStartupCache.sys.mjs"),
  "resource:///modules/AboutNewTab.sys.mjs": typeof import("resource:///modules/AboutNewTab.sys.mjs"),
  "resource:///modules/AboutNewTabRedirector.sys.mjs": typeof import("resource:///modules/AboutNewTabRedirector.sys.mjs"),
  "resource:///modules/ActionsProviderContextualSearch.sys.mjs": typeof import("resource:///modules/ActionsProviderContextualSearch.sys.mjs"),
  "resource:///modules/ActionsProviderQuickActions.sys.mjs": typeof import("resource:///modules/ActionsProviderQuickActions.sys.mjs"),
  "resource:///modules/AttributionCode.sys.mjs": typeof import("resource:///modules/AttributionCode.sys.mjs"),
  "resource:///modules/BrowserGlue.sys.mjs": typeof import("resource:///modules/BrowserGlue.sys.mjs"),
  "resource:///modules/BrowserUIUtils.sys.mjs": typeof import("resource:///modules/BrowserUIUtils.sys.mjs"),
  "resource:///modules/BrowserUsageTelemetry.sys.mjs": typeof import("resource:///modules/BrowserUsageTelemetry.sys.mjs"),
  "resource:///modules/BrowserWindowTracker.sys.mjs": typeof import("resource:///modules/BrowserWindowTracker.sys.mjs"),
  "resource:///modules/BuiltInThemeConfig.sys.mjs": typeof import("resource:///modules/BuiltInThemeConfig.sys.mjs"),
  "resource:///modules/BuiltInThemes.sys.mjs": typeof import("resource:///modules/BuiltInThemes.sys.mjs"),
  "resource:///modules/ChromeMigrationUtils.sys.mjs": typeof import("resource:///modules/ChromeMigrationUtils.sys.mjs"),
  "resource:///modules/ContentAnalysis.sys.mjs": typeof import("resource:///modules/ContentAnalysis.sys.mjs"),
  "resource:///modules/ContentCrashHandlers.sys.mjs": typeof import("resource:///modules/ContentCrashHandlers.sys.mjs"),
  "resource:///modules/CustomizableUI.sys.mjs": typeof import("resource:///modules/CustomizableUI.sys.mjs"),
  "resource:///modules/CustomizableWidgets.sys.mjs": typeof import("resource:///modules/CustomizableWidgets.sys.mjs"),
  "resource:///modules/Discovery.sys.mjs": typeof import("resource:///modules/Discovery.sys.mjs"),
  "resource:///modules/DownloadSpamProtection.sys.mjs": typeof import("resource:///modules/DownloadSpamProtection.sys.mjs"),
  "resource:///modules/DownloadsCommon.sys.mjs": typeof import("resource:///modules/DownloadsCommon.sys.mjs"),
  "resource:///modules/DownloadsViewUI.sys.mjs": typeof import("resource:///modules/DownloadsViewUI.sys.mjs"),
  "resource:///modules/DownloadsViewableInternally.sys.mjs": typeof import("resource:///modules/DownloadsViewableInternally.sys.mjs"),
  "resource:///modules/DragPositionManager.sys.mjs": typeof import("resource:///modules/DragPositionManager.sys.mjs"),
  "resource:///modules/ESEDBReader.sys.mjs": typeof import("resource:///modules/ESEDBReader.sys.mjs"),
  "resource:///modules/EveryWindow.sys.mjs": typeof import("resource:///modules/EveryWindow.sys.mjs"),
  "resource:///modules/ExtensionBrowsingData.sys.mjs": typeof import("resource:///modules/ExtensionBrowsingData.sys.mjs"),
  "resource:///modules/ExtensionControlledPopup.sys.mjs": typeof import("resource:///modules/ExtensionControlledPopup.sys.mjs"),
  "resource:///modules/ExtensionPopups.sys.mjs": typeof import("resource:///modules/ExtensionPopups.sys.mjs"),
  "resource:///modules/ExtensionsUI.sys.mjs": typeof import("resource:///modules/ExtensionsUI.sys.mjs"),
  "resource:///modules/FaviconLoader.sys.mjs": typeof import("resource:///modules/FaviconLoader.sys.mjs"),
  "resource:///modules/FileMigrators.sys.mjs": typeof import("resource:///modules/FileMigrators.sys.mjs"),
  "resource:///modules/FilePickerCrashed.sys.mjs": typeof import("resource:///modules/FilePickerCrashed.sys.mjs"),
  "resource:///modules/FilterAdult.sys.mjs": typeof import("resource:///modules/FilterAdult.sys.mjs"),
  "resource:///modules/FirefoxBridgeExtensionUtils.sys.mjs": typeof import("resource:///modules/FirefoxBridgeExtensionUtils.sys.mjs"),
  "resource:///modules/FirefoxProfileMigrator.sys.mjs": typeof import("resource:///modules/FirefoxProfileMigrator.sys.mjs"),
  "resource:///modules/GenAI.sys.mjs": typeof import("resource:///modules/GenAI.sys.mjs"),
  "resource:///modules/HeadlessShell.sys.mjs": typeof import("resource:///modules/HeadlessShell.sys.mjs"),
  "resource:///modules/HistoryController.sys.mjs": typeof import("resource:///modules/HistoryController.sys.mjs"),
  "resource:///modules/HomePage.sys.mjs": typeof import("resource:///modules/HomePage.sys.mjs"),
  "resource:///modules/InternalTestingProfileMigrator.sys.mjs": typeof import("resource:///modules/InternalTestingProfileMigrator.sys.mjs"),
  "resource:///modules/LaterRun.sys.mjs": typeof import("resource:///modules/LaterRun.sys.mjs"),
  "resource:///modules/LinksCache.sys.mjs": typeof import("resource:///modules/LinksCache.sys.mjs"),
  "resource:///modules/LoginBreaches.sys.mjs": typeof import("resource:///modules/LoginBreaches.sys.mjs"),
  "resource:///modules/MacAttribution.sys.mjs": typeof import("resource:///modules/MacAttribution.sys.mjs"),
  "resource:///modules/MerinoClient.sys.mjs": typeof import("resource:///modules/MerinoClient.sys.mjs"),
  "resource:///modules/MigrationUtils.sys.mjs": typeof import("resource:///modules/MigrationUtils.sys.mjs"),
  "resource:///modules/OpenTabs.sys.mjs": typeof import("resource:///modules/OpenTabs.sys.mjs"),
  "resource:///modules/PageActions.sys.mjs": typeof import("resource:///modules/PageActions.sys.mjs"),
  "resource:///modules/PanelMultiView.sys.mjs": typeof import("resource:///modules/PanelMultiView.sys.mjs"),
  "resource:///modules/PartnerLinkAttribution.sys.mjs": typeof import("resource:///modules/PartnerLinkAttribution.sys.mjs"),
  "resource:///modules/PermissionUI.sys.mjs": typeof import("resource:///modules/PermissionUI.sys.mjs"),
  "resource:///modules/PopupBlockerObserver.sys.mjs": typeof import("resource:///modules/PopupBlockerObserver.sys.mjs"),
  "resource:///modules/ProcessHangMonitor.sys.mjs": typeof import("resource:///modules/ProcessHangMonitor.sys.mjs"),
  "resource:///modules/QuickActionsLoaderDefault.sys.mjs": typeof import("resource:///modules/QuickActionsLoaderDefault.sys.mjs"),
  "resource:///modules/QuickSuggest.sys.mjs": typeof import("resource:///modules/QuickSuggest.sys.mjs"),
  "resource:///modules/ReportBrokenSite.sys.mjs": typeof import("resource:///modules/ReportBrokenSite.sys.mjs"),
  "resource:///modules/ResetPBMPanel.sys.mjs": typeof import("resource:///modules/ResetPBMPanel.sys.mjs"),
  "resource:///modules/SafariProfileMigrator.sys.mjs": typeof import("resource:///modules/SafariProfileMigrator.sys.mjs"),
  "resource:///modules/Sanitizer.sys.mjs": typeof import("resource:///modules/Sanitizer.sys.mjs"),
  "resource:///modules/ScreenshotsOverlayChild.sys.mjs": typeof import("resource:///modules/ScreenshotsOverlayChild.sys.mjs"),
  "resource:///modules/ScreenshotsUtils.sys.mjs": typeof import("resource:///modules/ScreenshotsUtils.sys.mjs"),
  "resource:///modules/SearchModeSwitcher.sys.mjs": typeof import("resource:///modules/SearchModeSwitcher.sys.mjs"),
  "resource:///modules/SelectionChangedMenulist.sys.mjs": typeof import("resource:///modules/SelectionChangedMenulist.sys.mjs"),
  "resource:///modules/SharingUtils.sys.mjs": typeof import("resource:///modules/SharingUtils.sys.mjs"),
  "resource:///modules/ShellService.sys.mjs": typeof import("resource:///modules/ShellService.sys.mjs"),
  "resource:///modules/SiteDataManager.sys.mjs": typeof import("resource:///modules/SiteDataManager.sys.mjs"),
  "resource:///modules/SitePermissions.sys.mjs": typeof import("resource:///modules/SitePermissions.sys.mjs"),
  "resource:///modules/SyncedTabsController.sys.mjs": typeof import("resource:///modules/SyncedTabsController.sys.mjs"),
  "resource:///modules/TRRPerformance.sys.mjs": typeof import("resource:///modules/TRRPerformance.sys.mjs"),
  "resource:///modules/ThemeVariableMap.sys.mjs": typeof import("resource:///modules/ThemeVariableMap.sys.mjs"),
  "resource:///modules/ToolbarContextMenu.sys.mjs": typeof import("resource:///modules/ToolbarContextMenu.sys.mjs"),
  "resource:///modules/ToolbarDropHandler.sys.mjs": typeof import("resource:///modules/ToolbarDropHandler.sys.mjs"),
  "resource:///modules/TransientPrefs.sys.mjs": typeof import("resource:///modules/TransientPrefs.sys.mjs"),
  "resource:///modules/URILoadingHelper.sys.mjs": typeof import("resource:///modules/URILoadingHelper.sys.mjs"),
  "resource:///modules/UrlbarController.sys.mjs": typeof import("resource:///modules/UrlbarController.sys.mjs"),
  "resource:///modules/UrlbarEventBufferer.sys.mjs": typeof import("resource:///modules/UrlbarEventBufferer.sys.mjs"),
  "resource:///modules/UrlbarInput.sys.mjs": typeof import("resource:///modules/UrlbarInput.sys.mjs"),
  "resource:///modules/UrlbarPrefs.sys.mjs": typeof import("resource:///modules/UrlbarPrefs.sys.mjs"),
  "resource:///modules/UrlbarProviderAutofill.sys.mjs": typeof import("resource:///modules/UrlbarProviderAutofill.sys.mjs"),
  "resource:///modules/UrlbarProviderCalculator.sys.mjs": typeof import("resource:///modules/UrlbarProviderCalculator.sys.mjs"),
  "resource:///modules/UrlbarProviderClipboard.sys.mjs": typeof import("resource:///modules/UrlbarProviderClipboard.sys.mjs"),
  "resource:///modules/UrlbarProviderGlobalActions.sys.mjs": typeof import("resource:///modules/UrlbarProviderGlobalActions.sys.mjs"),
  "resource:///modules/UrlbarProviderInterventions.sys.mjs": typeof import("resource:///modules/UrlbarProviderInterventions.sys.mjs"),
  "resource:///modules/UrlbarProviderOpenTabs.sys.mjs": typeof import("resource:///modules/UrlbarProviderOpenTabs.sys.mjs"),
  "resource:///modules/UrlbarProviderPlaces.sys.mjs": typeof import("resource:///modules/UrlbarProviderPlaces.sys.mjs"),
  "resource:///modules/UrlbarProviderQuickSuggest.sys.mjs": typeof import("resource:///modules/UrlbarProviderQuickSuggest.sys.mjs"),
  "resource:///modules/UrlbarProviderQuickSuggestContextualOptIn.sys.mjs": typeof import("resource:///modules/UrlbarProviderQuickSuggestContextualOptIn.sys.mjs"),
  "resource:///modules/UrlbarProviderRecentSearches.sys.mjs": typeof import("resource:///modules/UrlbarProviderRecentSearches.sys.mjs"),
  "resource:///modules/UrlbarProviderSearchSuggestions.sys.mjs": typeof import("resource:///modules/UrlbarProviderSearchSuggestions.sys.mjs"),
  "resource:///modules/UrlbarProviderSearchTips.sys.mjs": typeof import("resource:///modules/UrlbarProviderSearchTips.sys.mjs"),
  "resource:///modules/UrlbarProviderTabToSearch.sys.mjs": typeof import("resource:///modules/UrlbarProviderTabToSearch.sys.mjs"),
  "resource:///modules/UrlbarProviderTopSites.sys.mjs": typeof import("resource:///modules/UrlbarProviderTopSites.sys.mjs"),
  "resource:///modules/UrlbarProviderUnitConversion.sys.mjs": typeof import("resource:///modules/UrlbarProviderUnitConversion.sys.mjs"),
  "resource:///modules/UrlbarProvidersManager.sys.mjs": typeof import("resource:///modules/UrlbarProvidersManager.sys.mjs"),
  "resource:///modules/UrlbarResult.sys.mjs": typeof import("resource:///modules/UrlbarResult.sys.mjs"),
  "resource:///modules/UrlbarSearchOneOffs.sys.mjs": typeof import("resource:///modules/UrlbarSearchOneOffs.sys.mjs"),
  "resource:///modules/UrlbarSearchTermsPersistence.sys.mjs": typeof import("resource:///modules/UrlbarSearchTermsPersistence.sys.mjs"),
  "resource:///modules/UrlbarSearchUtils.sys.mjs": typeof import("resource:///modules/UrlbarSearchUtils.sys.mjs"),
  "resource:///modules/UrlbarTokenizer.sys.mjs": typeof import("resource:///modules/UrlbarTokenizer.sys.mjs"),
  "resource:///modules/UrlbarUtils.sys.mjs": typeof import("resource:///modules/UrlbarUtils.sys.mjs"),
  "resource:///modules/UrlbarValueFormatter.sys.mjs": typeof import("resource:///modules/UrlbarValueFormatter.sys.mjs"),
  "resource:///modules/UrlbarView.sys.mjs": typeof import("resource:///modules/UrlbarView.sys.mjs"),
  "resource:///modules/WebProtocolHandlerRegistrar.sys.mjs": typeof import("resource:///modules/WebProtocolHandlerRegistrar.sys.mjs"),
  "resource:///modules/WindowsJumpLists.sys.mjs": typeof import("resource:///modules/WindowsJumpLists.sys.mjs"),
  "resource:///modules/ZoomUI.sys.mjs": typeof import("resource:///modules/ZoomUI.sys.mjs"),
  "resource:///modules/aboutwelcome/AWScreenUtils.sys.mjs": typeof import("resource:///modules/aboutwelcome/AWScreenUtils.sys.mjs"),
  "resource:///modules/aboutwelcome/AWToolbarUtils.sys.mjs": typeof import("resource:///modules/aboutwelcome/AWToolbarUtils.sys.mjs"),
  "resource:///modules/aboutwelcome/AboutWelcomeDefaults.sys.mjs": typeof import("resource:///modules/aboutwelcome/AboutWelcomeDefaults.sys.mjs"),
  "resource:///modules/aboutwelcome/AboutWelcomeTelemetry.sys.mjs": typeof import("resource:///modules/aboutwelcome/AboutWelcomeTelemetry.sys.mjs"),
  "resource:///modules/asrouter/ASRouter.sys.mjs": typeof import("resource:///modules/asrouter/ASRouter.sys.mjs"),
  "resource:///modules/asrouter/ASRouterDefaultConfig.sys.mjs": typeof import("resource:///modules/asrouter/ASRouterDefaultConfig.sys.mjs"),
  "resource:///modules/asrouter/ASRouterNewTabHook.sys.mjs": typeof import("resource:///modules/asrouter/ASRouterNewTabHook.sys.mjs"),
  "resource:///modules/asrouter/ASRouterPreferences.sys.mjs": typeof import("resource:///modules/asrouter/ASRouterPreferences.sys.mjs"),
  "resource:///modules/asrouter/ASRouterStorage.sys.mjs": typeof import("resource:///modules/asrouter/ASRouterStorage.sys.mjs"),
  "resource:///modules/asrouter/ASRouterTargeting.sys.mjs": typeof import("resource:///modules/asrouter/ASRouterTargeting.sys.mjs"),
  "resource:///modules/asrouter/ASRouterTriggerListeners.sys.mjs": typeof import("resource:///modules/asrouter/ASRouterTriggerListeners.sys.mjs"),
  "resource:///modules/asrouter/ActorConstants.mjs": typeof import("resource:///modules/asrouter/ActorConstants.mjs"),
  "resource:///modules/asrouter/BookmarksBarButton.sys.mjs": typeof import("resource:///modules/asrouter/BookmarksBarButton.sys.mjs"),
  "resource:///modules/asrouter/CFRMessageProvider.sys.mjs": typeof import("resource:///modules/asrouter/CFRMessageProvider.sys.mjs"),
  "resource:///modules/asrouter/CFRPageActions.sys.mjs": typeof import("resource:///modules/asrouter/CFRPageActions.sys.mjs"),
  "resource:///modules/asrouter/FeatureCallout.sys.mjs": typeof import("resource:///modules/asrouter/FeatureCallout.sys.mjs"),
  "resource:///modules/asrouter/FeatureCalloutBroker.sys.mjs": typeof import("resource:///modules/asrouter/FeatureCalloutBroker.sys.mjs"),
  "resource:///modules/asrouter/FeatureCalloutMessages.sys.mjs": typeof import("resource:///modules/asrouter/FeatureCalloutMessages.sys.mjs"),
  "resource:///modules/asrouter/InfoBar.sys.mjs": typeof import("resource:///modules/asrouter/InfoBar.sys.mjs"),
  "resource:///modules/asrouter/MenuMessage.sys.mjs": typeof import("resource:///modules/asrouter/MenuMessage.sys.mjs"),
  "resource:///modules/asrouter/MomentsPageHub.sys.mjs": typeof import("resource:///modules/asrouter/MomentsPageHub.sys.mjs"),
  "resource:///modules/asrouter/OnboardingMessageProvider.sys.mjs": typeof import("resource:///modules/asrouter/OnboardingMessageProvider.sys.mjs"),
  "resource:///modules/asrouter/PageEventManager.sys.mjs": typeof import("resource:///modules/asrouter/PageEventManager.sys.mjs"),
  "resource:///modules/asrouter/PanelTestProvider.sys.mjs": typeof import("resource:///modules/asrouter/PanelTestProvider.sys.mjs"),
  "resource:///modules/asrouter/RemoteL10n.sys.mjs": typeof import("resource:///modules/asrouter/RemoteL10n.sys.mjs"),
  "resource:///modules/asrouter/Spotlight.sys.mjs": typeof import("resource:///modules/asrouter/Spotlight.sys.mjs"),
  "resource:///modules/asrouter/ToastNotification.sys.mjs": typeof import("resource:///modules/asrouter/ToastNotification.sys.mjs"),
  "resource:///modules/asrouter/ToolbarBadgeHub.sys.mjs": typeof import("resource:///modules/asrouter/ToolbarBadgeHub.sys.mjs"),
  "resource:///modules/backup/ArchiveEncryption.sys.mjs": typeof import("resource:///modules/backup/ArchiveEncryption.sys.mjs"),
  "resource:///modules/backup/ArchiveEncryptionState.sys.mjs": typeof import("resource:///modules/backup/ArchiveEncryptionState.sys.mjs"),
  "resource:///modules/backup/ArchiveUtils.sys.mjs": typeof import("resource:///modules/backup/ArchiveUtils.sys.mjs"),
  "resource:///modules/backup/BackupError.mjs": typeof import("resource:///modules/backup/BackupError.mjs"),
  "resource:///modules/backup/BackupService.sys.mjs": typeof import("resource:///modules/backup/BackupService.sys.mjs"),
  "resource:///modules/distribution.sys.mjs": typeof import("resource:///modules/distribution.sys.mjs"),
  "resource:///modules/firefox-view-synced-tabs-error-handler.sys.mjs": typeof import("resource:///modules/firefox-view-synced-tabs-error-handler.sys.mjs"),
  "resource:///modules/firefox-view-tabs-setup-manager.sys.mjs": typeof import("resource:///modules/firefox-view-tabs-setup-manager.sys.mjs"),
  "resource:///modules/pagedata/OpenGraphPageData.sys.mjs": typeof import("resource:///modules/pagedata/OpenGraphPageData.sys.mjs"),
  "resource:///modules/pagedata/PageDataSchema.sys.mjs": typeof import("resource:///modules/pagedata/PageDataSchema.sys.mjs"),
  "resource:///modules/pagedata/PageDataService.sys.mjs": typeof import("resource:///modules/pagedata/PageDataService.sys.mjs"),
  "resource:///modules/pagedata/SchemaOrgPageData.sys.mjs": typeof import("resource:///modules/pagedata/SchemaOrgPageData.sys.mjs"),
  "resource:///modules/pagedata/TwitterPageData.sys.mjs": typeof import("resource:///modules/pagedata/TwitterPageData.sys.mjs"),
  "resource:///modules/policies/BookmarksPolicies.sys.mjs": typeof import("resource:///modules/policies/BookmarksPolicies.sys.mjs"),
  "resource:///modules/policies/Policies.sys.mjs": typeof import("resource:///modules/policies/Policies.sys.mjs"),
  "resource:///modules/policies/ProxyPolicies.sys.mjs": typeof import("resource:///modules/policies/ProxyPolicies.sys.mjs"),
  "resource:///modules/policies/WebsiteFilter.sys.mjs": typeof import("resource:///modules/policies/WebsiteFilter.sys.mjs"),
  "resource:///modules/policies/schema.sys.mjs": typeof import("resource:///modules/policies/schema.sys.mjs"),
  "resource:///modules/profiles/SelectableProfileService.sys.mjs": typeof import("resource:///modules/profiles/SelectableProfileService.sys.mjs"),
  "resource:///modules/sessionstore/PageWireframes.sys.mjs": typeof import("resource:///modules/sessionstore/PageWireframes.sys.mjs"),
  "resource:///modules/sessionstore/RecentlyClosedTabsAndWindowsMenuUtils.sys.mjs": typeof import("resource:///modules/sessionstore/RecentlyClosedTabsAndWindowsMenuUtils.sys.mjs"),
  "resource:///modules/sessionstore/RunState.sys.mjs": typeof import("resource:///modules/sessionstore/RunState.sys.mjs"),
  "resource:///modules/sessionstore/SessionCookies.sys.mjs": typeof import("resource:///modules/sessionstore/SessionCookies.sys.mjs"),
  "resource:///modules/sessionstore/SessionFile.sys.mjs": typeof import("resource:///modules/sessionstore/SessionFile.sys.mjs"),
  "resource:///modules/sessionstore/SessionLogger.sys.mjs": typeof import("resource:///modules/sessionstore/SessionLogger.sys.mjs"),
  "resource:///modules/sessionstore/SessionMigration.sys.mjs": typeof import("resource:///modules/sessionstore/SessionMigration.sys.mjs"),
  "resource:///modules/sessionstore/SessionSaver.sys.mjs": typeof import("resource:///modules/sessionstore/SessionSaver.sys.mjs"),
  "resource:///modules/sessionstore/SessionStartup.sys.mjs": typeof import("resource:///modules/sessionstore/SessionStartup.sys.mjs"),
  "resource:///modules/sessionstore/SessionStore.sys.mjs": typeof import("resource:///modules/sessionstore/SessionStore.sys.mjs"),
  "resource:///modules/sessionstore/SessionWriter.sys.mjs": typeof import("resource:///modules/sessionstore/SessionWriter.sys.mjs"),
  "resource:///modules/sessionstore/StartupPerformance.sys.mjs": typeof import("resource:///modules/sessionstore/StartupPerformance.sys.mjs"),
  "resource:///modules/sessionstore/TabAttributes.sys.mjs": typeof import("resource:///modules/sessionstore/TabAttributes.sys.mjs"),
  "resource:///modules/sessionstore/TabGroupState.sys.mjs": typeof import("resource:///modules/sessionstore/TabGroupState.sys.mjs"),
  "resource:///modules/sessionstore/TabState.sys.mjs": typeof import("resource:///modules/sessionstore/TabState.sys.mjs"),
  "resource:///modules/sessionstore/TabStateCache.sys.mjs": typeof import("resource:///modules/sessionstore/TabStateCache.sys.mjs"),
  "resource:///modules/sessionstore/TabStateFlusher.sys.mjs": typeof import("resource:///modules/sessionstore/TabStateFlusher.sys.mjs"),
  "resource:///modules/taskbartabs/TaskbarTabUI.sys.mjs": typeof import("resource:///modules/taskbartabs/TaskbarTabUI.sys.mjs"),
  "resource:///modules/topsites/TippyTopProvider.sys.mjs": typeof import("resource:///modules/topsites/TippyTopProvider.sys.mjs"),
  "resource:///modules/topsites/TopSites.sys.mjs": typeof import("resource:///modules/topsites/TopSites.sys.mjs"),
  "resource:///modules/topsites/constants.mjs": typeof import("resource:///modules/topsites/constants.mjs"),
  "resource:///modules/urlbar/private/AmpSuggestions.sys.mjs": typeof import("resource:///modules/urlbar/private/AmpSuggestions.sys.mjs"),
  "resource:///modules/urlbar/private/GeolocationUtils.sys.mjs": typeof import("resource:///modules/urlbar/private/GeolocationUtils.sys.mjs"),
  "resource:///modules/urlbar/private/MLSuggest.sys.mjs": typeof import("resource:///modules/urlbar/private/MLSuggest.sys.mjs"),
  "resource:///modules/webrtcUI.sys.mjs": typeof import("resource:///modules/webrtcUI.sys.mjs"),
  "resource://autofill/FormAutofill.sys.mjs": typeof import("resource://autofill/FormAutofill.sys.mjs"),
  "resource://autofill/FormAutofillContent.sys.mjs": typeof import("resource://autofill/FormAutofillContent.sys.mjs"),
  "resource://autofill/FormAutofillParent.sys.mjs": typeof import("resource://autofill/FormAutofillParent.sys.mjs"),
  "resource://autofill/FormAutofillPreferences.sys.mjs": typeof import("resource://autofill/FormAutofillPreferences.sys.mjs"),
  "resource://autofill/FormAutofillPrompter.sys.mjs": typeof import("resource://autofill/FormAutofillPrompter.sys.mjs"),
  "resource://autofill/FormAutofillStorage.sys.mjs": typeof import("resource://autofill/FormAutofillStorage.sys.mjs"),
  "resource://autofill/MLAutofill.sys.mjs": typeof import("resource://autofill/MLAutofill.sys.mjs"),
  "resource://autofill/ProfileAutoCompleteResult.sys.mjs": typeof import("resource://autofill/ProfileAutoCompleteResult.sys.mjs"),
  "resource://devtools/client/framework/browser-toolbox/Launcher.sys.mjs": typeof import("resource://devtools/client/framework/browser-toolbox/Launcher.sys.mjs"),
  "resource://devtools/client/performance-new/popup/menu-button.sys.mjs": typeof import("resource://devtools/client/performance-new/popup/menu-button.sys.mjs"),
  "resource://devtools/client/shared/components/reps/reps/constants.mjs": typeof import("resource://devtools/client/shared/components/reps/reps/constants.mjs"),
  "resource://devtools/client/shared/components/reps/reps/rep-utils.mjs": typeof import("resource://devtools/client/shared/components/reps/reps/rep-utils.mjs"),
  "resource://devtools/client/shared/focus.mjs": typeof import("resource://devtools/client/shared/focus.mjs"),
  "resource://devtools/client/storage/VariablesView.sys.mjs": typeof import("resource://devtools/client/storage/VariablesView.sys.mjs"),
  "resource://devtools/server/actors/targets/target-actor-registry.sys.mjs": typeof import("resource://devtools/server/actors/targets/target-actor-registry.sys.mjs"),
  "resource://devtools/server/actors/watcher/SessionDataHelpers.sys.mjs": typeof import("resource://devtools/server/actors/watcher/SessionDataHelpers.sys.mjs"),
  "resource://devtools/server/actors/watcher/browsing-context-helpers.sys.mjs": typeof import("resource://devtools/server/actors/watcher/browsing-context-helpers.sys.mjs"),
  "resource://devtools/server/connectors/js-process-actor/target-watchers/content_script.sys.mjs": typeof import("resource://devtools/server/connectors/js-process-actor/target-watchers/content_script.sys.mjs"),
  "resource://devtools/server/connectors/js-process-actor/target-watchers/process.sys.mjs": typeof import("resource://devtools/server/connectors/js-process-actor/target-watchers/process.sys.mjs"),
  "resource://devtools/server/connectors/js-process-actor/target-watchers/service_worker.sys.mjs": typeof import("resource://devtools/server/connectors/js-process-actor/target-watchers/service_worker.sys.mjs"),
  "resource://devtools/server/connectors/js-process-actor/target-watchers/shared_worker.sys.mjs": typeof import("resource://devtools/server/connectors/js-process-actor/target-watchers/shared_worker.sys.mjs"),
  "resource://devtools/server/connectors/js-process-actor/target-watchers/window-global.sys.mjs": typeof import("resource://devtools/server/connectors/js-process-actor/target-watchers/window-global.sys.mjs"),
  "resource://devtools/server/connectors/js-process-actor/target-watchers/worker.sys.mjs": typeof import("resource://devtools/server/connectors/js-process-actor/target-watchers/worker.sys.mjs"),
  "resource://devtools/server/tracer/tracer.sys.mjs": typeof import("resource://devtools/server/tracer/tracer.sys.mjs"),
  "resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs": typeof import("resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs"),
  "resource://devtools/shared/highlighters.mjs": typeof import("resource://devtools/shared/highlighters.mjs"),
  "resource://devtools/shared/loader/DistinctSystemPrincipalLoader.sys.mjs": typeof import("resource://devtools/shared/loader/DistinctSystemPrincipalLoader.sys.mjs"),
  "resource://devtools/shared/loader/Loader.sys.mjs": typeof import("resource://devtools/shared/loader/Loader.sys.mjs"),
  "resource://devtools/shared/network-observer/ChannelMap.sys.mjs": typeof import("resource://devtools/shared/network-observer/ChannelMap.sys.mjs"),
  "resource://devtools/shared/network-observer/NetworkAuthListener.sys.mjs": typeof import("resource://devtools/shared/network-observer/NetworkAuthListener.sys.mjs"),
  "resource://devtools/shared/network-observer/NetworkHelper.sys.mjs": typeof import("resource://devtools/shared/network-observer/NetworkHelper.sys.mjs"),
  "resource://devtools/shared/network-observer/NetworkObserver.sys.mjs": typeof import("resource://devtools/shared/network-observer/NetworkObserver.sys.mjs"),
  "resource://devtools/shared/network-observer/NetworkOverride.sys.mjs": typeof import("resource://devtools/shared/network-observer/NetworkOverride.sys.mjs"),
  "resource://devtools/shared/network-observer/NetworkResponseListener.sys.mjs": typeof import("resource://devtools/shared/network-observer/NetworkResponseListener.sys.mjs"),
  "resource://devtools/shared/network-observer/NetworkThrottleManager.sys.mjs": typeof import("resource://devtools/shared/network-observer/NetworkThrottleManager.sys.mjs"),
  "resource://devtools/shared/network-observer/NetworkTimings.sys.mjs": typeof import("resource://devtools/shared/network-observer/NetworkTimings.sys.mjs"),
  "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs": typeof import("resource://devtools/shared/network-observer/NetworkUtils.sys.mjs"),
  "resource://devtools/shared/network-observer/WildcardToRegexp.sys.mjs": typeof import("resource://devtools/shared/network-observer/WildcardToRegexp.sys.mjs"),
  "resource://devtools/shared/performance-new/recording-utils.sys.mjs": typeof import("resource://devtools/shared/performance-new/recording-utils.sys.mjs"),
  "resource://devtools/shared/platform/CacheEntry.sys.mjs": typeof import("resource://devtools/shared/platform/CacheEntry.sys.mjs"),
  "resource://devtools/shared/security/DevToolsSocketStatus.sys.mjs": typeof import("resource://devtools/shared/security/DevToolsSocketStatus.sys.mjs"),
  "resource://devtools/shared/validate-breakpoint.sys.mjs": typeof import("resource://devtools/shared/validate-breakpoint.sys.mjs"),
  "resource://devtools/shared/worker/worker.sys.mjs": typeof import("resource://devtools/shared/worker/worker.sys.mjs"),
  "resource://gre/actors/AutoCompleteParent.sys.mjs": typeof import("resource://gre/actors/AutoCompleteParent.sys.mjs"),
  "resource://gre/actors/FormHandlerChild.sys.mjs": typeof import("resource://gre/actors/FormHandlerChild.sys.mjs"),
  "resource://gre/actors/MLEngineParent.sys.mjs": typeof import("resource://gre/actors/MLEngineParent.sys.mjs"),
  "resource://gre/actors/PopupBlockingParent.sys.mjs": typeof import("resource://gre/actors/PopupBlockingParent.sys.mjs"),
  "resource://gre/actors/SelectParent.sys.mjs": typeof import("resource://gre/actors/SelectParent.sys.mjs"),
  "resource://gre/actors/TranslationsParent.sys.mjs": typeof import("resource://gre/actors/TranslationsParent.sys.mjs"),
  "resource://gre/actors/ViewSourcePageChild.sys.mjs": typeof import("resource://gre/actors/ViewSourcePageChild.sys.mjs"),
  "resource://gre/modules/AboutPagesUtils.sys.mjs": typeof import("resource://gre/modules/AboutPagesUtils.sys.mjs"),
  "resource://gre/modules/AbuseReporter.sys.mjs": typeof import("resource://gre/modules/AbuseReporter.sys.mjs"),
  "resource://gre/modules/ActorManagerParent.sys.mjs": typeof import("resource://gre/modules/ActorManagerParent.sys.mjs"),
  "resource://gre/modules/AddonManager.sys.mjs": typeof import("resource://gre/modules/AddonManager.sys.mjs"),
  "resource://gre/modules/AndroidLog.sys.mjs": typeof import("resource://gre/modules/AndroidLog.sys.mjs"),
  "resource://gre/modules/AppConstants.sys.mjs": typeof import("resource://gre/modules/AppConstants.sys.mjs"),
  "resource://gre/modules/AppMenuNotifications.sys.mjs": typeof import("resource://gre/modules/AppMenuNotifications.sys.mjs"),
  "resource://gre/modules/AppUpdater.sys.mjs": typeof import("resource://gre/modules/AppUpdater.sys.mjs"),
  "resource://gre/modules/AsyncPrefs.sys.mjs": typeof import("resource://gre/modules/AsyncPrefs.sys.mjs"),
  "resource://gre/modules/AsyncShutdown.sys.mjs": typeof import("resource://gre/modules/AsyncShutdown.sys.mjs"),
  "resource://gre/modules/BackgroundPageThumbs.sys.mjs": typeof import("resource://gre/modules/BackgroundPageThumbs.sys.mjs"),
  "resource://gre/modules/BackgroundTasksUtils.sys.mjs": typeof import("resource://gre/modules/BackgroundTasksUtils.sys.mjs"),
  "resource://gre/modules/BackgroundUpdate.sys.mjs": typeof import("resource://gre/modules/BackgroundUpdate.sys.mjs"),
  "resource://gre/modules/BinarySearch.sys.mjs": typeof import("resource://gre/modules/BinarySearch.sys.mjs"),
  "resource://gre/modules/Blocklist.sys.mjs": typeof import("resource://gre/modules/Blocklist.sys.mjs"),
  "resource://gre/modules/BookmarkHTMLUtils.sys.mjs": typeof import("resource://gre/modules/BookmarkHTMLUtils.sys.mjs"),
  "resource://gre/modules/BookmarkJSONUtils.sys.mjs": typeof import("resource://gre/modules/BookmarkJSONUtils.sys.mjs"),
  "resource://gre/modules/BookmarkList.sys.mjs": typeof import("resource://gre/modules/BookmarkList.sys.mjs"),
  "resource://gre/modules/Bookmarks.sys.mjs": typeof import("resource://gre/modules/Bookmarks.sys.mjs"),
  "resource://gre/modules/BrowserTelemetryUtils.sys.mjs": typeof import("resource://gre/modules/BrowserTelemetryUtils.sys.mjs"),
  "resource://gre/modules/BrowserUtils.sys.mjs": typeof import("resource://gre/modules/BrowserUtils.sys.mjs"),
  "resource://gre/modules/CSV.sys.mjs": typeof import("resource://gre/modules/CSV.sys.mjs"),
  "resource://gre/modules/CanonicalJSON.sys.mjs": typeof import("resource://gre/modules/CanonicalJSON.sys.mjs"),
  "resource://gre/modules/CaptchaDetectionPingUtils.sys.mjs": typeof import("resource://gre/modules/CaptchaDetectionPingUtils.sys.mjs"),
  "resource://gre/modules/CaptchaResponseObserver.sys.mjs": typeof import("resource://gre/modules/CaptchaResponseObserver.sys.mjs"),
  "resource://gre/modules/CertUtils.sys.mjs": typeof import("resource://gre/modules/CertUtils.sys.mjs"),
  "resource://gre/modules/ChildCrashHandler.sys.mjs": typeof import("resource://gre/modules/ChildCrashHandler.sys.mjs"),
  "resource://gre/modules/ClientID.sys.mjs": typeof import("resource://gre/modules/ClientID.sys.mjs"),
  "resource://gre/modules/ClipboardContextMenu.sys.mjs": typeof import("resource://gre/modules/ClipboardContextMenu.sys.mjs"),
  "resource://gre/modules/Color.sys.mjs": typeof import("resource://gre/modules/Color.sys.mjs"),
  "resource://gre/modules/ColorwayThemeMigration.sys.mjs": typeof import("resource://gre/modules/ColorwayThemeMigration.sys.mjs"),
  "resource://gre/modules/CommonDialog.sys.mjs": typeof import("resource://gre/modules/CommonDialog.sys.mjs"),
  "resource://gre/modules/ConduitsParent.sys.mjs": typeof import("resource://gre/modules/ConduitsParent.sys.mjs"),
  "resource://gre/modules/Console.sys.mjs": typeof import("resource://gre/modules/Console.sys.mjs"),
  "resource://gre/modules/ContentAnalysisUtils.sys.mjs": typeof import("resource://gre/modules/ContentAnalysisUtils.sys.mjs"),
  "resource://gre/modules/ContentBlockingAllowList.sys.mjs": typeof import("resource://gre/modules/ContentBlockingAllowList.sys.mjs"),
  "resource://gre/modules/ContentDOMReference.sys.mjs": typeof import("resource://gre/modules/ContentDOMReference.sys.mjs"),
  "resource://gre/modules/ContentPrefUtils.sys.mjs": typeof import("resource://gre/modules/ContentPrefUtils.sys.mjs"),
  "resource://gre/modules/ContentRelevancyManager.sys.mjs": typeof import("resource://gre/modules/ContentRelevancyManager.sys.mjs"),
  "resource://gre/modules/ContextualIdentityService.sys.mjs": typeof import("resource://gre/modules/ContextualIdentityService.sys.mjs"),
  "resource://gre/modules/CoveragePing.sys.mjs": typeof import("resource://gre/modules/CoveragePing.sys.mjs"),
  "resource://gre/modules/CrashMonitor.sys.mjs": typeof import("resource://gre/modules/CrashMonitor.sys.mjs"),
  "resource://gre/modules/CrashService.sys.mjs": typeof import("resource://gre/modules/CrashService.sys.mjs"),
  "resource://gre/modules/CrashSubmit.sys.mjs": typeof import("resource://gre/modules/CrashSubmit.sys.mjs"),
  "resource://gre/modules/CreditCard.sys.mjs": typeof import("resource://gre/modules/CreditCard.sys.mjs"),
  "resource://gre/modules/DAPTelemetrySender.sys.mjs": typeof import("resource://gre/modules/DAPTelemetrySender.sys.mjs"),
  "resource://gre/modules/DAPVisitCounter.sys.mjs": typeof import("resource://gre/modules/DAPVisitCounter.sys.mjs"),
  "resource://gre/modules/DateTimePickerPanel.sys.mjs": typeof import("resource://gre/modules/DateTimePickerPanel.sys.mjs"),
  "resource://gre/modules/DeferredTask.sys.mjs": typeof import("resource://gre/modules/DeferredTask.sys.mjs"),
  "resource://gre/modules/DoHConfig.sys.mjs": typeof import("resource://gre/modules/DoHConfig.sys.mjs"),
  "resource://gre/modules/DoHController.sys.mjs": typeof import("resource://gre/modules/DoHController.sys.mjs"),
  "resource://gre/modules/DoHHeuristics.sys.mjs": typeof import("resource://gre/modules/DoHHeuristics.sys.mjs"),
  "resource://gre/modules/DownloadCore.sys.mjs": typeof import("resource://gre/modules/DownloadCore.sys.mjs"),
  "resource://gre/modules/DownloadHistory.sys.mjs": typeof import("resource://gre/modules/DownloadHistory.sys.mjs"),
  "resource://gre/modules/DownloadIntegration.sys.mjs": typeof import("resource://gre/modules/DownloadIntegration.sys.mjs"),
  "resource://gre/modules/DownloadLastDir.sys.mjs": typeof import("resource://gre/modules/DownloadLastDir.sys.mjs"),
  "resource://gre/modules/DownloadList.sys.mjs": typeof import("resource://gre/modules/DownloadList.sys.mjs"),
  "resource://gre/modules/DownloadPaths.sys.mjs": typeof import("resource://gre/modules/DownloadPaths.sys.mjs"),
  "resource://gre/modules/DownloadStore.sys.mjs": typeof import("resource://gre/modules/DownloadStore.sys.mjs"),
  "resource://gre/modules/DownloadUIHelper.sys.mjs": typeof import("resource://gre/modules/DownloadUIHelper.sys.mjs"),
  "resource://gre/modules/DownloadUtils.sys.mjs": typeof import("resource://gre/modules/DownloadUtils.sys.mjs"),
  "resource://gre/modules/Downloads.sys.mjs": typeof import("resource://gre/modules/Downloads.sys.mjs"),
  "resource://gre/modules/E10SUtils.sys.mjs": typeof import("resource://gre/modules/E10SUtils.sys.mjs"),
  "resource://gre/modules/EssentialDomainsRemoteSettings.sys.mjs": typeof import("resource://gre/modules/EssentialDomainsRemoteSettings.sys.mjs"),
  "resource://gre/modules/EventEmitter.sys.mjs": typeof import("resource://gre/modules/EventEmitter.sys.mjs"),
  "resource://gre/modules/EventPing.sys.mjs": typeof import("resource://gre/modules/EventPing.sys.mjs"),
  "resource://gre/modules/Extension.sys.mjs": typeof import("resource://gre/modules/Extension.sys.mjs"),
  "resource://gre/modules/ExtensionActivityLog.sys.mjs": typeof import("resource://gre/modules/ExtensionActivityLog.sys.mjs"),
  "resource://gre/modules/ExtensionChild.sys.mjs": typeof import("resource://gre/modules/ExtensionChild.sys.mjs"),
  "resource://gre/modules/ExtensionChildDevToolsUtils.sys.mjs": typeof import("resource://gre/modules/ExtensionChildDevToolsUtils.sys.mjs"),
  "resource://gre/modules/ExtensionCommon.sys.mjs": typeof import("resource://gre/modules/ExtensionCommon.sys.mjs"),
  "resource://gre/modules/ExtensionContent.sys.mjs": typeof import("resource://gre/modules/ExtensionContent.sys.mjs"),
  "resource://gre/modules/ExtensionDNR.sys.mjs": typeof import("resource://gre/modules/ExtensionDNR.sys.mjs"),
  "resource://gre/modules/ExtensionDNRLimits.sys.mjs": typeof import("resource://gre/modules/ExtensionDNRLimits.sys.mjs"),
  "resource://gre/modules/ExtensionDNRStore.sys.mjs": typeof import("resource://gre/modules/ExtensionDNRStore.sys.mjs"),
  "resource://gre/modules/ExtensionMenus.sys.mjs": typeof import("resource://gre/modules/ExtensionMenus.sys.mjs"),
  "resource://gre/modules/ExtensionPageChild.sys.mjs": typeof import("resource://gre/modules/ExtensionPageChild.sys.mjs"),
  "resource://gre/modules/ExtensionParent.sys.mjs": typeof import("resource://gre/modules/ExtensionParent.sys.mjs"),
  "resource://gre/modules/ExtensionPermissionMessages.sys.mjs": typeof import("resource://gre/modules/ExtensionPermissionMessages.sys.mjs"),
  "resource://gre/modules/ExtensionPermissions.sys.mjs": typeof import("resource://gre/modules/ExtensionPermissions.sys.mjs"),
  "resource://gre/modules/ExtensionPreferencesManager.sys.mjs": typeof import("resource://gre/modules/ExtensionPreferencesManager.sys.mjs"),
  "resource://gre/modules/ExtensionProcessScript.sys.mjs": typeof import("resource://gre/modules/ExtensionProcessScript.sys.mjs"),
  "resource://gre/modules/ExtensionScriptingStore.sys.mjs": typeof import("resource://gre/modules/ExtensionScriptingStore.sys.mjs"),
  "resource://gre/modules/ExtensionSearchHandler.sys.mjs": typeof import("resource://gre/modules/ExtensionSearchHandler.sys.mjs"),
  "resource://gre/modules/ExtensionSettingsStore.sys.mjs": typeof import("resource://gre/modules/ExtensionSettingsStore.sys.mjs"),
  "resource://gre/modules/ExtensionShortcuts.sys.mjs": typeof import("resource://gre/modules/ExtensionShortcuts.sys.mjs"),
  "resource://gre/modules/ExtensionStorage.sys.mjs": typeof import("resource://gre/modules/ExtensionStorage.sys.mjs"),
  "resource://gre/modules/ExtensionStorageComponents.sys.mjs": typeof import("resource://gre/modules/ExtensionStorageComponents.sys.mjs"),
  "resource://gre/modules/ExtensionStorageIDB.sys.mjs": typeof import("resource://gre/modules/ExtensionStorageIDB.sys.mjs"),
  "resource://gre/modules/ExtensionStorageSync.sys.mjs": typeof import("resource://gre/modules/ExtensionStorageSync.sys.mjs"),
  "resource://gre/modules/ExtensionStorageSyncKinto.sys.mjs": typeof import("resource://gre/modules/ExtensionStorageSyncKinto.sys.mjs"),
  "resource://gre/modules/ExtensionTelemetry.sys.mjs": typeof import("resource://gre/modules/ExtensionTelemetry.sys.mjs"),
  "resource://gre/modules/ExtensionUserScripts.sys.mjs": typeof import("resource://gre/modules/ExtensionUserScripts.sys.mjs"),
  "resource://gre/modules/ExtensionUserScriptsContent.sys.mjs": typeof import("resource://gre/modules/ExtensionUserScriptsContent.sys.mjs"),
  "resource://gre/modules/ExtensionUtils.sys.mjs": typeof import("resource://gre/modules/ExtensionUtils.sys.mjs"),
  "resource://gre/modules/ExtensionWorkerChild.sys.mjs": typeof import("resource://gre/modules/ExtensionWorkerChild.sys.mjs"),
  "resource://gre/modules/FileUtils.sys.mjs": typeof import("resource://gre/modules/FileUtils.sys.mjs"),
  "resource://gre/modules/FillHelpers.sys.mjs": typeof import("resource://gre/modules/FillHelpers.sys.mjs"),
  "resource://gre/modules/FindContent.sys.mjs": typeof import("resource://gre/modules/FindContent.sys.mjs"),
  "resource://gre/modules/Finder.sys.mjs": typeof import("resource://gre/modules/Finder.sys.mjs"),
  "resource://gre/modules/FinderHighlighter.sys.mjs": typeof import("resource://gre/modules/FinderHighlighter.sys.mjs"),
  "resource://gre/modules/FinderIterator.sys.mjs": typeof import("resource://gre/modules/FinderIterator.sys.mjs"),
  "resource://gre/modules/FinderParent.sys.mjs": typeof import("resource://gre/modules/FinderParent.sys.mjs"),
  "resource://gre/modules/FirefoxRelay.sys.mjs": typeof import("resource://gre/modules/FirefoxRelay.sys.mjs"),
  "resource://gre/modules/FirstStartup.sys.mjs": typeof import("resource://gre/modules/FirstStartup.sys.mjs"),
  "resource://gre/modules/ForgetAboutSite.sys.mjs": typeof import("resource://gre/modules/ForgetAboutSite.sys.mjs"),
  "resource://gre/modules/FormHistory.sys.mjs": typeof import("resource://gre/modules/FormHistory.sys.mjs"),
  "resource://gre/modules/FormHistoryAutoComplete.sys.mjs": typeof import("resource://gre/modules/FormHistoryAutoComplete.sys.mjs"),
  "resource://gre/modules/FormLikeFactory.sys.mjs": typeof import("resource://gre/modules/FormLikeFactory.sys.mjs"),
  "resource://gre/modules/FormScenarios.sys.mjs": typeof import("resource://gre/modules/FormScenarios.sys.mjs"),
  "resource://gre/modules/FxAccounts.sys.mjs": typeof import("resource://gre/modules/FxAccounts.sys.mjs"),
  "resource://gre/modules/FxAccountsClient.sys.mjs": typeof import("resource://gre/modules/FxAccountsClient.sys.mjs"),
  "resource://gre/modules/FxAccountsCommands.sys.mjs": typeof import("resource://gre/modules/FxAccountsCommands.sys.mjs"),
  "resource://gre/modules/FxAccountsCommon.sys.mjs": typeof import("resource://gre/modules/FxAccountsCommon.sys.mjs"),
  "resource://gre/modules/FxAccountsConfig.sys.mjs": typeof import("resource://gre/modules/FxAccountsConfig.sys.mjs"),
  "resource://gre/modules/FxAccountsDevice.sys.mjs": typeof import("resource://gre/modules/FxAccountsDevice.sys.mjs"),
  "resource://gre/modules/FxAccountsKeys.sys.mjs": typeof import("resource://gre/modules/FxAccountsKeys.sys.mjs"),
  "resource://gre/modules/FxAccountsOAuth.sys.mjs": typeof import("resource://gre/modules/FxAccountsOAuth.sys.mjs"),
  "resource://gre/modules/FxAccountsPairing.sys.mjs": typeof import("resource://gre/modules/FxAccountsPairing.sys.mjs"),
  "resource://gre/modules/FxAccountsPairingChannel.sys.mjs": typeof import("resource://gre/modules/FxAccountsPairingChannel.sys.mjs"),
  "resource://gre/modules/FxAccountsProfile.sys.mjs": typeof import("resource://gre/modules/FxAccountsProfile.sys.mjs"),
  "resource://gre/modules/FxAccountsProfileClient.sys.mjs": typeof import("resource://gre/modules/FxAccountsProfileClient.sys.mjs"),
  "resource://gre/modules/FxAccountsStorage.sys.mjs": typeof import("resource://gre/modules/FxAccountsStorage.sys.mjs"),
  "resource://gre/modules/FxAccountsTelemetry.sys.mjs": typeof import("resource://gre/modules/FxAccountsTelemetry.sys.mjs"),
  "resource://gre/modules/FxAccountsWebChannel.sys.mjs": typeof import("resource://gre/modules/FxAccountsWebChannel.sys.mjs"),
  "resource://gre/modules/GMPInstallManager.sys.mjs": typeof import("resource://gre/modules/GMPInstallManager.sys.mjs"),
  "resource://gre/modules/GeckoViewActorManager.sys.mjs": typeof import("resource://gre/modules/GeckoViewActorManager.sys.mjs"),
  "resource://gre/modules/GeckoViewAutocomplete.sys.mjs": typeof import("resource://gre/modules/GeckoViewAutocomplete.sys.mjs"),
  "resource://gre/modules/GeckoViewAutofill.sys.mjs": typeof import("resource://gre/modules/GeckoViewAutofill.sys.mjs"),
  "resource://gre/modules/GeckoViewClipboardPermission.sys.mjs": typeof import("resource://gre/modules/GeckoViewClipboardPermission.sys.mjs"),
  "resource://gre/modules/GeckoViewIdentityCredential.sys.mjs": typeof import("resource://gre/modules/GeckoViewIdentityCredential.sys.mjs"),
  "resource://gre/modules/GeckoViewPrompter.sys.mjs": typeof import("resource://gre/modules/GeckoViewPrompter.sys.mjs"),
  "resource://gre/modules/GeckoViewSettings.sys.mjs": typeof import("resource://gre/modules/GeckoViewSettings.sys.mjs"),
  "resource://gre/modules/GeckoViewTab.sys.mjs": typeof import("resource://gre/modules/GeckoViewTab.sys.mjs"),
  "resource://gre/modules/GeckoViewTelemetry.sys.mjs": typeof import("resource://gre/modules/GeckoViewTelemetry.sys.mjs"),
  "resource://gre/modules/GeckoViewTestUtils.sys.mjs": typeof import("resource://gre/modules/GeckoViewTestUtils.sys.mjs"),
  "resource://gre/modules/GeckoViewUtils.sys.mjs": typeof import("resource://gre/modules/GeckoViewUtils.sys.mjs"),
  "resource://gre/modules/GeckoViewWebExtension.sys.mjs": typeof import("resource://gre/modules/GeckoViewWebExtension.sys.mjs"),
  "resource://gre/modules/Geometry.sys.mjs": typeof import("resource://gre/modules/Geometry.sys.mjs"),
  "resource://gre/modules/HPKEConfigManager.sys.mjs": typeof import("resource://gre/modules/HPKEConfigManager.sys.mjs"),
  "resource://gre/modules/HealthPing.sys.mjs": typeof import("resource://gre/modules/HealthPing.sys.mjs"),
  "resource://gre/modules/HiddenFrame.sys.mjs": typeof import("resource://gre/modules/HiddenFrame.sys.mjs"),
  "resource://gre/modules/History.sys.mjs": typeof import("resource://gre/modules/History.sys.mjs"),
  "resource://gre/modules/IgnoreLists.sys.mjs": typeof import("resource://gre/modules/IgnoreLists.sys.mjs"),
  "resource://gre/modules/IndexedDB.sys.mjs": typeof import("resource://gre/modules/IndexedDB.sys.mjs"),
  "resource://gre/modules/InlineSpellChecker.sys.mjs": typeof import("resource://gre/modules/InlineSpellChecker.sys.mjs"),
  "resource://gre/modules/InlineSpellCheckerContent.sys.mjs": typeof import("resource://gre/modules/InlineSpellCheckerContent.sys.mjs"),
  "resource://gre/modules/InsecurePasswordUtils.sys.mjs": typeof import("resource://gre/modules/InsecurePasswordUtils.sys.mjs"),
  "resource://gre/modules/Integration.sys.mjs": typeof import("resource://gre/modules/Integration.sys.mjs"),
  "resource://gre/modules/JSONFile.sys.mjs": typeof import("resource://gre/modules/JSONFile.sys.mjs"),
  "resource://gre/modules/JsonSchema.sys.mjs": typeof import("resource://gre/modules/JsonSchema.sys.mjs"),
  "resource://gre/modules/KeywordUtils.sys.mjs": typeof import("resource://gre/modules/KeywordUtils.sys.mjs"),
  "resource://gre/modules/LangPackMatcher.sys.mjs": typeof import("resource://gre/modules/LangPackMatcher.sys.mjs"),
  "resource://gre/modules/LayoutUtils.sys.mjs": typeof import("resource://gre/modules/LayoutUtils.sys.mjs"),
  "resource://gre/modules/LightweightThemeConsumer.sys.mjs": typeof import("resource://gre/modules/LightweightThemeConsumer.sys.mjs"),
  "resource://gre/modules/LightweightThemeManager.sys.mjs": typeof import("resource://gre/modules/LightweightThemeManager.sys.mjs"),
  "resource://gre/modules/LoadURIDelegate.sys.mjs": typeof import("resource://gre/modules/LoadURIDelegate.sys.mjs"),
  "resource://gre/modules/LocationHelper.sys.mjs": typeof import("resource://gre/modules/LocationHelper.sys.mjs"),
  "resource://gre/modules/Log.sys.mjs": typeof import("resource://gre/modules/Log.sys.mjs"),
  "resource://gre/modules/LoginAutoComplete.sys.mjs": typeof import("resource://gre/modules/LoginAutoComplete.sys.mjs"),
  "resource://gre/modules/LoginCSVImport.sys.mjs": typeof import("resource://gre/modules/LoginCSVImport.sys.mjs"),
  "resource://gre/modules/LoginExport.sys.mjs": typeof import("resource://gre/modules/LoginExport.sys.mjs"),
  "resource://gre/modules/LoginHelper.sys.mjs": typeof import("resource://gre/modules/LoginHelper.sys.mjs"),
  "resource://gre/modules/LoginManager.shared.sys.mjs": typeof import("resource://gre/modules/LoginManager.shared.sys.mjs"),
  "resource://gre/modules/LoginManagerChild.sys.mjs": typeof import("resource://gre/modules/LoginManagerChild.sys.mjs"),
  "resource://gre/modules/LoginManagerContextMenu.sys.mjs": typeof import("resource://gre/modules/LoginManagerContextMenu.sys.mjs"),
  "resource://gre/modules/LoginManagerParent.sys.mjs": typeof import("resource://gre/modules/LoginManagerParent.sys.mjs"),
  "resource://gre/modules/LoginRecipes.sys.mjs": typeof import("resource://gre/modules/LoginRecipes.sys.mjs"),
  "resource://gre/modules/LoginStore.sys.mjs": typeof import("resource://gre/modules/LoginStore.sys.mjs"),
  "resource://gre/modules/ManifestFinder.sys.mjs": typeof import("resource://gre/modules/ManifestFinder.sys.mjs"),
  "resource://gre/modules/ManifestIcons.sys.mjs": typeof import("resource://gre/modules/ManifestIcons.sys.mjs"),
  "resource://gre/modules/ManifestObtainer.sys.mjs": typeof import("resource://gre/modules/ManifestObtainer.sys.mjs"),
  "resource://gre/modules/MatchURLFilters.sys.mjs": typeof import("resource://gre/modules/MatchURLFilters.sys.mjs"),
  "resource://gre/modules/MediaUtils.sys.mjs": typeof import("resource://gre/modules/MediaUtils.sys.mjs"),
  "resource://gre/modules/MessageManagerProxy.sys.mjs": typeof import("resource://gre/modules/MessageManagerProxy.sys.mjs"),
  "resource://gre/modules/Messaging.sys.mjs": typeof import("resource://gre/modules/Messaging.sys.mjs"),
  "resource://gre/modules/NLP.sys.mjs": typeof import("resource://gre/modules/NLP.sys.mjs"),
  "resource://gre/modules/NativeManifests.sys.mjs": typeof import("resource://gre/modules/NativeManifests.sys.mjs"),
  "resource://gre/modules/NativeMessaging.sys.mjs": typeof import("resource://gre/modules/NativeMessaging.sys.mjs"),
  "resource://gre/modules/NetUtil.sys.mjs": typeof import("resource://gre/modules/NetUtil.sys.mjs"),
  "resource://gre/modules/NewTabUtils.sys.mjs": typeof import("resource://gre/modules/NewTabUtils.sys.mjs"),
  "resource://gre/modules/OSCrypto_win.sys.mjs": typeof import("resource://gre/modules/OSCrypto_win.sys.mjs"),
  "resource://gre/modules/OSKeyStore.sys.mjs": typeof import("resource://gre/modules/OSKeyStore.sys.mjs"),
  "resource://gre/modules/ObjectUtils.sys.mjs": typeof import("resource://gre/modules/ObjectUtils.sys.mjs"),
  "resource://gre/modules/ObliviousHTTP.sys.mjs": typeof import("resource://gre/modules/ObliviousHTTP.sys.mjs"),
  "resource://gre/modules/OsEnvironment.sys.mjs": typeof import("resource://gre/modules/OsEnvironment.sys.mjs"),
  "resource://gre/modules/PageThumbUtils.sys.mjs": typeof import("resource://gre/modules/PageThumbUtils.sys.mjs"),
  "resource://gre/modules/PageThumbs.sys.mjs": typeof import("resource://gre/modules/PageThumbs.sys.mjs"),
  "resource://gre/modules/PermissionsUtils.sys.mjs": typeof import("resource://gre/modules/PermissionsUtils.sys.mjs"),
  "resource://gre/modules/PictureInPicture.sys.mjs": typeof import("resource://gre/modules/PictureInPicture.sys.mjs"),
  "resource://gre/modules/PictureInPictureControls.sys.mjs": typeof import("resource://gre/modules/PictureInPictureControls.sys.mjs"),
  "resource://gre/modules/PlacesBackups.sys.mjs": typeof import("resource://gre/modules/PlacesBackups.sys.mjs"),
  "resource://gre/modules/PlacesDBUtils.sys.mjs": typeof import("resource://gre/modules/PlacesDBUtils.sys.mjs"),
  "resource://gre/modules/PlacesPreviews.sys.mjs": typeof import("resource://gre/modules/PlacesPreviews.sys.mjs"),
  "resource://gre/modules/PlacesQuery.sys.mjs": typeof import("resource://gre/modules/PlacesQuery.sys.mjs"),
  "resource://gre/modules/PlacesSemanticHistoryDatabase.sys.mjs": typeof import("resource://gre/modules/PlacesSemanticHistoryDatabase.sys.mjs"),
  "resource://gre/modules/PlacesSemanticHistoryManager.sys.mjs": typeof import("resource://gre/modules/PlacesSemanticHistoryManager.sys.mjs"),
  "resource://gre/modules/PlacesSyncUtils.sys.mjs": typeof import("resource://gre/modules/PlacesSyncUtils.sys.mjs"),
  "resource://gre/modules/PlacesTransactions.sys.mjs": typeof import("resource://gre/modules/PlacesTransactions.sys.mjs"),
  "resource://gre/modules/PlacesUtils.sys.mjs": typeof import("resource://gre/modules/PlacesUtils.sys.mjs"),
  "resource://gre/modules/Preferences.sys.mjs": typeof import("resource://gre/modules/Preferences.sys.mjs"),
  "resource://gre/modules/PrincipalsCollector.sys.mjs": typeof import("resource://gre/modules/PrincipalsCollector.sys.mjs"),
  "resource://gre/modules/PrivateBrowsingUtils.sys.mjs": typeof import("resource://gre/modules/PrivateBrowsingUtils.sys.mjs"),
  "resource://gre/modules/ProcessType.sys.mjs": typeof import("resource://gre/modules/ProcessType.sys.mjs"),
  "resource://gre/modules/ProfileAge.sys.mjs": typeof import("resource://gre/modules/ProfileAge.sys.mjs"),
  "resource://gre/modules/PromiseWorker.sys.mjs": typeof import("resource://gre/modules/PromiseWorker.sys.mjs"),
  "resource://gre/modules/PromptUtils.sys.mjs": typeof import("resource://gre/modules/PromptUtils.sys.mjs"),
  "resource://gre/modules/PropertyListUtils.sys.mjs": typeof import("resource://gre/modules/PropertyListUtils.sys.mjs"),
  "resource://gre/modules/ProxyChannelFilter.sys.mjs": typeof import("resource://gre/modules/ProxyChannelFilter.sys.mjs"),
  "resource://gre/modules/PushBroadcastService.sys.mjs": typeof import("resource://gre/modules/PushBroadcastService.sys.mjs"),
  "resource://gre/modules/PushCrypto.sys.mjs": typeof import("resource://gre/modules/PushCrypto.sys.mjs"),
  "resource://gre/modules/PushService.sys.mjs": typeof import("resource://gre/modules/PushService.sys.mjs"),
  "resource://gre/modules/PushServiceWebSocket.sys.mjs": typeof import("resource://gre/modules/PushServiceWebSocket.sys.mjs"),
  "resource://gre/modules/Readerable.sys.mjs": typeof import("resource://gre/modules/Readerable.sys.mjs"),
  "resource://gre/modules/Region.sys.mjs": typeof import("resource://gre/modules/Region.sys.mjs"),
  "resource://gre/modules/RemotePageAccessManager.sys.mjs": typeof import("resource://gre/modules/RemotePageAccessManager.sys.mjs"),
  "resource://gre/modules/RemoteSettingsCrashPull.sys.mjs": typeof import("resource://gre/modules/RemoteSettingsCrashPull.sys.mjs"),
  "resource://gre/modules/RemoteWebNavigation.sys.mjs": typeof import("resource://gre/modules/RemoteWebNavigation.sys.mjs"),
  "resource://gre/modules/ResetProfile.sys.mjs": typeof import("resource://gre/modules/ResetProfile.sys.mjs"),
  "resource://gre/modules/SafeBrowsing.sys.mjs": typeof import("resource://gre/modules/SafeBrowsing.sys.mjs"),
  "resource://gre/modules/Schemas.sys.mjs": typeof import("resource://gre/modules/Schemas.sys.mjs"),
  "resource://gre/modules/SearchService.sys.mjs": typeof import("resource://gre/modules/SearchService.sys.mjs"),
  "resource://gre/modules/SecurityInfo.sys.mjs": typeof import("resource://gre/modules/SecurityInfo.sys.mjs"),
  "resource://gre/modules/SelectionUtils.sys.mjs": typeof import("resource://gre/modules/SelectionUtils.sys.mjs"),
  "resource://gre/modules/ServiceRequest.sys.mjs": typeof import("resource://gre/modules/ServiceRequest.sys.mjs"),
  "resource://gre/modules/ServiceWorkerCleanUp.sys.mjs": typeof import("resource://gre/modules/ServiceWorkerCleanUp.sys.mjs"),
  "resource://gre/modules/ShortcutUtils.sys.mjs": typeof import("resource://gre/modules/ShortcutUtils.sys.mjs"),
  "resource://gre/modules/Sqlite.sys.mjs": typeof import("resource://gre/modules/Sqlite.sys.mjs"),
  "resource://gre/modules/SubDialog.sys.mjs": typeof import("resource://gre/modules/SubDialog.sys.mjs"),
  "resource://gre/modules/Subprocess.sys.mjs": typeof import("resource://gre/modules/Subprocess.sys.mjs"),
  "resource://gre/modules/SyncedBookmarksMirror.sys.mjs": typeof import("resource://gre/modules/SyncedBookmarksMirror.sys.mjs"),
  "resource://gre/modules/TaskScheduler.sys.mjs": typeof import("resource://gre/modules/TaskScheduler.sys.mjs"),
  "resource://gre/modules/TaskSchedulerMacOSImpl.sys.mjs": typeof import("resource://gre/modules/TaskSchedulerMacOSImpl.sys.mjs"),
  "resource://gre/modules/TaskSchedulerWinImpl.sys.mjs": typeof import("resource://gre/modules/TaskSchedulerWinImpl.sys.mjs"),
  "resource://gre/modules/TelemetryArchive.sys.mjs": typeof import("resource://gre/modules/TelemetryArchive.sys.mjs"),
  "resource://gre/modules/TelemetryController.sys.mjs": typeof import("resource://gre/modules/TelemetryController.sys.mjs"),
  "resource://gre/modules/TelemetryEnvironment.sys.mjs": typeof import("resource://gre/modules/TelemetryEnvironment.sys.mjs"),
  "resource://gre/modules/TelemetryReportingPolicy.sys.mjs": typeof import("resource://gre/modules/TelemetryReportingPolicy.sys.mjs"),
  "resource://gre/modules/TelemetryScheduler.sys.mjs": typeof import("resource://gre/modules/TelemetryScheduler.sys.mjs"),
  "resource://gre/modules/TelemetrySend.sys.mjs": typeof import("resource://gre/modules/TelemetrySend.sys.mjs"),
  "resource://gre/modules/TelemetrySession.sys.mjs": typeof import("resource://gre/modules/TelemetrySession.sys.mjs"),
  "resource://gre/modules/TelemetryStorage.sys.mjs": typeof import("resource://gre/modules/TelemetryStorage.sys.mjs"),
  "resource://gre/modules/TelemetryTimestamps.sys.mjs": typeof import("resource://gre/modules/TelemetryTimestamps.sys.mjs"),
  "resource://gre/modules/TelemetryUtils.sys.mjs": typeof import("resource://gre/modules/TelemetryUtils.sys.mjs"),
  "resource://gre/modules/Timer.sys.mjs": typeof import("resource://gre/modules/Timer.sys.mjs"),
  "resource://gre/modules/UninstallPing.sys.mjs": typeof import("resource://gre/modules/UninstallPing.sys.mjs"),
  "resource://gre/modules/UntrustedModulesPing.sys.mjs": typeof import("resource://gre/modules/UntrustedModulesPing.sys.mjs"),
  "resource://gre/modules/UpdateListener.sys.mjs": typeof import("resource://gre/modules/UpdateListener.sys.mjs"),
  "resource://gre/modules/UpdateLog.sys.mjs": typeof import("resource://gre/modules/UpdateLog.sys.mjs"),
  "resource://gre/modules/UpdatePing.sys.mjs": typeof import("resource://gre/modules/UpdatePing.sys.mjs"),
  "resource://gre/modules/UpdateService.sys.mjs": typeof import("resource://gre/modules/UpdateService.sys.mjs"),
  "resource://gre/modules/UpdateUtils.sys.mjs": typeof import("resource://gre/modules/UpdateUtils.sys.mjs"),
  "resource://gre/modules/UsageReporting.sys.mjs": typeof import("resource://gre/modules/UsageReporting.sys.mjs"),
  "resource://gre/modules/WebAuthnFeature.sys.mjs": typeof import("resource://gre/modules/WebAuthnFeature.sys.mjs"),
  "resource://gre/modules/WebChannel.sys.mjs": typeof import("resource://gre/modules/WebChannel.sys.mjs"),
  "resource://gre/modules/WebNavigation.sys.mjs": typeof import("resource://gre/modules/WebNavigation.sys.mjs"),
  "resource://gre/modules/WebNavigationFrames.sys.mjs": typeof import("resource://gre/modules/WebNavigationFrames.sys.mjs"),
  "resource://gre/modules/WebRequest.sys.mjs": typeof import("resource://gre/modules/WebRequest.sys.mjs"),
  "resource://gre/modules/WebRequestUpload.sys.mjs": typeof import("resource://gre/modules/WebRequestUpload.sys.mjs"),
  "resource://gre/modules/WindowsLaunchOnLogin.sys.mjs": typeof import("resource://gre/modules/WindowsLaunchOnLogin.sys.mjs"),
  "resource://gre/modules/WindowsRegistry.sys.mjs": typeof import("resource://gre/modules/WindowsRegistry.sys.mjs"),
  "resource://gre/modules/addons/AddonRepository.sys.mjs": typeof import("resource://gre/modules/addons/AddonRepository.sys.mjs"),
  "resource://gre/modules/addons/AddonSettings.sys.mjs": typeof import("resource://gre/modules/addons/AddonSettings.sys.mjs"),
  "resource://gre/modules/addons/ProductAddonChecker.sys.mjs": typeof import("resource://gre/modules/addons/ProductAddonChecker.sys.mjs"),
  "resource://gre/modules/addons/XPIDatabase.sys.mjs": typeof import("resource://gre/modules/addons/XPIDatabase.sys.mjs"),
  "resource://gre/modules/addons/XPIInstall.sys.mjs": typeof import("resource://gre/modules/addons/XPIInstall.sys.mjs"),
  "resource://gre/modules/addons/XPIProvider.sys.mjs": typeof import("resource://gre/modules/addons/XPIProvider.sys.mjs"),
  "resource://gre/modules/addons/crypto-utils.sys.mjs": typeof import("resource://gre/modules/addons/crypto-utils.sys.mjs"),
  "resource://gre/modules/addons/siteperms-addon-utils.sys.mjs": typeof import("resource://gre/modules/addons/siteperms-addon-utils.sys.mjs"),
  "resource://gre/modules/components-utils/ClientEnvironment.sys.mjs": typeof import("resource://gre/modules/components-utils/ClientEnvironment.sys.mjs"),
  "resource://gre/modules/components-utils/FilterExpressions.sys.mjs": typeof import("resource://gre/modules/components-utils/FilterExpressions.sys.mjs"),
  "resource://gre/modules/components-utils/JsonSchemaValidator.sys.mjs": typeof import("resource://gre/modules/components-utils/JsonSchemaValidator.sys.mjs"),
  "resource://gre/modules/components-utils/Sampling.sys.mjs": typeof import("resource://gre/modules/components-utils/Sampling.sys.mjs"),
  "resource://gre/modules/components-utils/WindowsInstallsInfo.sys.mjs": typeof import("resource://gre/modules/components-utils/WindowsInstallsInfo.sys.mjs"),
  "resource://gre/modules/components-utils/WindowsVersionInfo.sys.mjs": typeof import("resource://gre/modules/components-utils/WindowsVersionInfo.sys.mjs"),
  "resource://gre/modules/components-utils/mozjexl.sys.mjs": typeof import("resource://gre/modules/components-utils/mozjexl.sys.mjs"),
  "resource://gre/modules/contentrelevancy/private/InputUtils.sys.mjs": typeof import("resource://gre/modules/contentrelevancy/private/InputUtils.sys.mjs"),
  "resource://gre/modules/ctypes.sys.mjs": typeof import("resource://gre/modules/ctypes.sys.mjs"),
  "resource://gre/modules/handlers/HandlerList.sys.mjs": typeof import("resource://gre/modules/handlers/HandlerList.sys.mjs"),
  "resource://gre/modules/jsdebugger.sys.mjs": typeof import("resource://gre/modules/jsdebugger.sys.mjs"),
  "resource://gre/modules/kvstore.sys.mjs": typeof import("resource://gre/modules/kvstore.sys.mjs"),
  "resource://gre/modules/media/IdpSandbox.sys.mjs": typeof import("resource://gre/modules/media/IdpSandbox.sys.mjs"),
  "resource://gre/modules/media/PeerConnectionIdp.sys.mjs": typeof import("resource://gre/modules/media/PeerConnectionIdp.sys.mjs"),
  "resource://gre/modules/narrate/NarrateControls.sys.mjs": typeof import("resource://gre/modules/narrate/NarrateControls.sys.mjs"),
  "resource://gre/modules/policies/WindowsGPOParser.sys.mjs": typeof import("resource://gre/modules/policies/WindowsGPOParser.sys.mjs"),
  "resource://gre/modules/policies/macOSPoliciesParser.sys.mjs": typeof import("resource://gre/modules/policies/macOSPoliciesParser.sys.mjs"),
  "resource://gre/modules/psm/RemoteSecuritySettings.sys.mjs": typeof import("resource://gre/modules/psm/RemoteSecuritySettings.sys.mjs"),
  "resource://gre/modules/reflect.sys.mjs": typeof import("resource://gre/modules/reflect.sys.mjs"),
  "resource://gre/modules/sessionstore/PrivacyFilter.sys.mjs": typeof import("resource://gre/modules/sessionstore/PrivacyFilter.sys.mjs"),
  "resource://gre/modules/sessionstore/PrivacyLevel.sys.mjs": typeof import("resource://gre/modules/sessionstore/PrivacyLevel.sys.mjs"),
  "resource://gre/modules/sessionstore/SessionHistory.sys.mjs": typeof import("resource://gre/modules/sessionstore/SessionHistory.sys.mjs"),
  "resource://gre/modules/sessionstore/SessionStoreHelper.sys.mjs": typeof import("resource://gre/modules/sessionstore/SessionStoreHelper.sys.mjs"),
  "resource://gre/modules/shared/AddressComponent.sys.mjs": typeof import("resource://gre/modules/shared/AddressComponent.sys.mjs"),
  "resource://gre/modules/shared/AddressMetaData.sys.mjs": typeof import("resource://gre/modules/shared/AddressMetaData.sys.mjs"),
  "resource://gre/modules/shared/AddressMetaDataExtension.sys.mjs": typeof import("resource://gre/modules/shared/AddressMetaDataExtension.sys.mjs"),
  "resource://gre/modules/shared/AddressMetaDataLoader.sys.mjs": typeof import("resource://gre/modules/shared/AddressMetaDataLoader.sys.mjs"),
  "resource://gre/modules/shared/AddressParser.sys.mjs": typeof import("resource://gre/modules/shared/AddressParser.sys.mjs"),
  "resource://gre/modules/shared/AutofillFormFactory.sys.mjs": typeof import("resource://gre/modules/shared/AutofillFormFactory.sys.mjs"),
  "resource://gre/modules/shared/AutofillTelemetry.sys.mjs": typeof import("resource://gre/modules/shared/AutofillTelemetry.sys.mjs"),
  "resource://gre/modules/shared/CreditCardRecord.sys.mjs": typeof import("resource://gre/modules/shared/CreditCardRecord.sys.mjs"),
  "resource://gre/modules/shared/CreditCardRuleset.sys.mjs": typeof import("resource://gre/modules/shared/CreditCardRuleset.sys.mjs"),
  "resource://gre/modules/shared/FieldScanner.sys.mjs": typeof import("resource://gre/modules/shared/FieldScanner.sys.mjs"),
  "resource://gre/modules/shared/FormAutofillHandler.sys.mjs": typeof import("resource://gre/modules/shared/FormAutofillHandler.sys.mjs"),
  "resource://gre/modules/shared/FormAutofillHeuristics.sys.mjs": typeof import("resource://gre/modules/shared/FormAutofillHeuristics.sys.mjs"),
  "resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs": typeof import("resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs"),
  "resource://gre/modules/shared/FormAutofillSection.sys.mjs": typeof import("resource://gre/modules/shared/FormAutofillSection.sys.mjs"),
  "resource://gre/modules/shared/FormAutofillUtils.sys.mjs": typeof import("resource://gre/modules/shared/FormAutofillUtils.sys.mjs"),
  "resource://gre/modules/shared/FormStateManager.sys.mjs": typeof import("resource://gre/modules/shared/FormStateManager.sys.mjs"),
  "resource://gre/modules/shared/LabelUtils.sys.mjs": typeof import("resource://gre/modules/shared/LabelUtils.sys.mjs"),
  "resource://gre/modules/shared/LoginFormFactory.sys.mjs": typeof import("resource://gre/modules/shared/LoginFormFactory.sys.mjs"),
  "resource://gre/modules/shared/PasswordGenerator.sys.mjs": typeof import("resource://gre/modules/shared/PasswordGenerator.sys.mjs"),
  "resource://gre/modules/shared/PasswordRulesParser.sys.mjs": typeof import("resource://gre/modules/shared/PasswordRulesParser.sys.mjs"),
  "resource://gre/modules/shared/PhoneNumber.sys.mjs": typeof import("resource://gre/modules/shared/PhoneNumber.sys.mjs"),
  "resource://gre/modules/shared/PhoneNumberNormalizer.sys.mjs": typeof import("resource://gre/modules/shared/PhoneNumberNormalizer.sys.mjs"),
  "resource://gre/modules/subprocess/subprocess_unix.sys.mjs": typeof import("resource://gre/modules/subprocess/subprocess_unix.sys.mjs"),
  "resource://gre/modules/subprocess/subprocess_win.sys.mjs": typeof import("resource://gre/modules/subprocess/subprocess_win.sys.mjs"),
  "resource://gre/modules/translations/LanguageDetector.sys.mjs": typeof import("resource://gre/modules/translations/LanguageDetector.sys.mjs"),
  "resource://gre/modules/workers/PromiseWorker.mjs": typeof import("resource://gre/modules/workers/PromiseWorker.mjs"),
  "resource://messaging-system/lib/SpecialMessageActions.sys.mjs": typeof import("resource://messaging-system/lib/SpecialMessageActions.sys.mjs"),
  "resource://messaging-system/targeting/Targeting.sys.mjs": typeof import("resource://messaging-system/targeting/Targeting.sys.mjs"),
  "resource://mozscreenshots/Screenshot.sys.mjs": typeof import("resource://mozscreenshots/Screenshot.sys.mjs"),
  "resource://newtab/common/Actions.mjs": typeof import("resource://newtab/common/Actions.mjs"),
  "resource://newtab/lib/AboutPreferences.sys.mjs": typeof import("resource://newtab/lib/AboutPreferences.sys.mjs"),
  "resource://newtab/lib/ActivityStream.sys.mjs": typeof import("resource://newtab/lib/ActivityStream.sys.mjs"),
  "resource://newtab/lib/ActivityStreamMessageChannel.sys.mjs": typeof import("resource://newtab/lib/ActivityStreamMessageChannel.sys.mjs"),
  "resource://newtab/lib/ActivityStreamPrefs.sys.mjs": typeof import("resource://newtab/lib/ActivityStreamPrefs.sys.mjs"),
  "resource://newtab/lib/AdsFeed.sys.mjs": typeof import("resource://newtab/lib/AdsFeed.sys.mjs"),
  "resource://newtab/lib/DefaultSites.sys.mjs": typeof import("resource://newtab/lib/DefaultSites.sys.mjs"),
  "resource://newtab/lib/DiscoveryStreamFeed.sys.mjs": typeof import("resource://newtab/lib/DiscoveryStreamFeed.sys.mjs"),
  "resource://newtab/lib/DownloadsManager.sys.mjs": typeof import("resource://newtab/lib/DownloadsManager.sys.mjs"),
  "resource://newtab/lib/FaviconFeed.sys.mjs": typeof import("resource://newtab/lib/FaviconFeed.sys.mjs"),
  "resource://newtab/lib/HighlightsFeed.sys.mjs": typeof import("resource://newtab/lib/HighlightsFeed.sys.mjs"),
  "resource://newtab/lib/InferredModel/FeatureModel.sys.mjs": typeof import("resource://newtab/lib/InferredModel/FeatureModel.sys.mjs"),
  "resource://newtab/lib/InferredPersonalizationFeed.sys.mjs": typeof import("resource://newtab/lib/InferredPersonalizationFeed.sys.mjs"),
  "resource://newtab/lib/NewTabGleanUtils.sys.mjs": typeof import("resource://newtab/lib/NewTabGleanUtils.sys.mjs"),
  "resource://newtab/lib/NewTabInit.sys.mjs": typeof import("resource://newtab/lib/NewTabInit.sys.mjs"),
  "resource://newtab/lib/NewTabMessaging.sys.mjs": typeof import("resource://newtab/lib/NewTabMessaging.sys.mjs"),
  "resource://newtab/lib/PersistentCache.sys.mjs": typeof import("resource://newtab/lib/PersistentCache.sys.mjs"),
  "resource://newtab/lib/PersonalityProvider/PersonalityProvider.sys.mjs": typeof import("resource://newtab/lib/PersonalityProvider/PersonalityProvider.sys.mjs"),
  "resource://newtab/lib/PlacesFeed.sys.mjs": typeof import("resource://newtab/lib/PlacesFeed.sys.mjs"),
  "resource://newtab/lib/PrefsFeed.sys.mjs": typeof import("resource://newtab/lib/PrefsFeed.sys.mjs"),
  "resource://newtab/lib/RecommendationProvider.sys.mjs": typeof import("resource://newtab/lib/RecommendationProvider.sys.mjs"),
  "resource://newtab/lib/Screenshots.sys.mjs": typeof import("resource://newtab/lib/Screenshots.sys.mjs"),
  "resource://newtab/lib/SectionsManager.sys.mjs": typeof import("resource://newtab/lib/SectionsManager.sys.mjs"),
  "resource://newtab/lib/StartupCacheInit.sys.mjs": typeof import("resource://newtab/lib/StartupCacheInit.sys.mjs"),
  "resource://newtab/lib/Store.sys.mjs": typeof import("resource://newtab/lib/Store.sys.mjs"),
  "resource://newtab/lib/SystemTickFeed.sys.mjs": typeof import("resource://newtab/lib/SystemTickFeed.sys.mjs"),
  "resource://newtab/lib/TelemetryFeed.sys.mjs": typeof import("resource://newtab/lib/TelemetryFeed.sys.mjs"),
  "resource://newtab/lib/TopSitesFeed.sys.mjs": typeof import("resource://newtab/lib/TopSitesFeed.sys.mjs"),
  "resource://newtab/lib/TopStoriesFeed.sys.mjs": typeof import("resource://newtab/lib/TopStoriesFeed.sys.mjs"),
  "resource://newtab/lib/UTEventReporting.sys.mjs": typeof import("resource://newtab/lib/UTEventReporting.sys.mjs"),
  "resource://newtab/lib/WallpaperFeed.sys.mjs": typeof import("resource://newtab/lib/WallpaperFeed.sys.mjs"),
  "resource://newtab/lib/WeatherFeed.sys.mjs": typeof import("resource://newtab/lib/WeatherFeed.sys.mjs"),
  "resource://nimbus/ExperimentAPI.sys.mjs": typeof import("resource://nimbus/ExperimentAPI.sys.mjs"),
  "resource://nimbus/FeatureManifest.sys.mjs": typeof import("resource://nimbus/FeatureManifest.sys.mjs"),
  "resource://nimbus/FirefoxLabs.sys.mjs": typeof import("resource://nimbus/FirefoxLabs.sys.mjs"),
  "resource://nimbus/lib/ExperimentManager.sys.mjs": typeof import("resource://nimbus/lib/ExperimentManager.sys.mjs"),
  "resource://nimbus/lib/ExperimentStore.sys.mjs": typeof import("resource://nimbus/lib/ExperimentStore.sys.mjs"),
  "resource://nimbus/lib/Migrations.sys.mjs": typeof import("resource://nimbus/lib/Migrations.sys.mjs"),
  "resource://nimbus/lib/RemoteSettingsExperimentLoader.sys.mjs": typeof import("resource://nimbus/lib/RemoteSettingsExperimentLoader.sys.mjs"),
  "resource://nimbus/lib/TargetingContextRecorder.sys.mjs": typeof import("resource://nimbus/lib/TargetingContextRecorder.sys.mjs"),
  "resource://nimbus/lib/Telemetry.sys.mjs": typeof import("resource://nimbus/lib/Telemetry.sys.mjs"),
  "resource://normandy-content/AboutPages.sys.mjs": typeof import("resource://normandy-content/AboutPages.sys.mjs"),
  "resource://normandy/Normandy.sys.mjs": typeof import("resource://normandy/Normandy.sys.mjs"),
  "resource://normandy/NormandyMigrations.sys.mjs": typeof import("resource://normandy/NormandyMigrations.sys.mjs"),
  "resource://normandy/actions/AddonRollbackAction.sys.mjs": typeof import("resource://normandy/actions/AddonRollbackAction.sys.mjs"),
  "resource://normandy/actions/AddonRolloutAction.sys.mjs": typeof import("resource://normandy/actions/AddonRolloutAction.sys.mjs"),
  "resource://normandy/actions/BaseAction.sys.mjs": typeof import("resource://normandy/actions/BaseAction.sys.mjs"),
  "resource://normandy/actions/BranchedAddonStudyAction.sys.mjs": typeof import("resource://normandy/actions/BranchedAddonStudyAction.sys.mjs"),
  "resource://normandy/actions/ConsoleLogAction.sys.mjs": typeof import("resource://normandy/actions/ConsoleLogAction.sys.mjs"),
  "resource://normandy/actions/PreferenceExperimentAction.sys.mjs": typeof import("resource://normandy/actions/PreferenceExperimentAction.sys.mjs"),
  "resource://normandy/actions/PreferenceRollbackAction.sys.mjs": typeof import("resource://normandy/actions/PreferenceRollbackAction.sys.mjs"),
  "resource://normandy/actions/PreferenceRolloutAction.sys.mjs": typeof import("resource://normandy/actions/PreferenceRolloutAction.sys.mjs"),
  "resource://normandy/actions/ShowHeartbeatAction.sys.mjs": typeof import("resource://normandy/actions/ShowHeartbeatAction.sys.mjs"),
  "resource://normandy/actions/schemas/index.sys.mjs": typeof import("resource://normandy/actions/schemas/index.sys.mjs"),
  "resource://normandy/lib/ActionsManager.sys.mjs": typeof import("resource://normandy/lib/ActionsManager.sys.mjs"),
  "resource://normandy/lib/AddonRollouts.sys.mjs": typeof import("resource://normandy/lib/AddonRollouts.sys.mjs"),
  "resource://normandy/lib/AddonStudies.sys.mjs": typeof import("resource://normandy/lib/AddonStudies.sys.mjs"),
  "resource://normandy/lib/CleanupManager.sys.mjs": typeof import("resource://normandy/lib/CleanupManager.sys.mjs"),
  "resource://normandy/lib/ClientEnvironment.sys.mjs": typeof import("resource://normandy/lib/ClientEnvironment.sys.mjs"),
  "resource://normandy/lib/Heartbeat.sys.mjs": typeof import("resource://normandy/lib/Heartbeat.sys.mjs"),
  "resource://normandy/lib/LegacyHeartbeat.sys.mjs": typeof import("resource://normandy/lib/LegacyHeartbeat.sys.mjs"),
  "resource://normandy/lib/LogManager.sys.mjs": typeof import("resource://normandy/lib/LogManager.sys.mjs"),
  "resource://normandy/lib/NormandyAddonManager.sys.mjs": typeof import("resource://normandy/lib/NormandyAddonManager.sys.mjs"),
  "resource://normandy/lib/NormandyApi.sys.mjs": typeof import("resource://normandy/lib/NormandyApi.sys.mjs"),
  "resource://normandy/lib/NormandyUtils.sys.mjs": typeof import("resource://normandy/lib/NormandyUtils.sys.mjs"),
  "resource://normandy/lib/PrefUtils.sys.mjs": typeof import("resource://normandy/lib/PrefUtils.sys.mjs"),
  "resource://normandy/lib/PreferenceExperiments.sys.mjs": typeof import("resource://normandy/lib/PreferenceExperiments.sys.mjs"),
  "resource://normandy/lib/PreferenceRollouts.sys.mjs": typeof import("resource://normandy/lib/PreferenceRollouts.sys.mjs"),
  "resource://normandy/lib/RecipeRunner.sys.mjs": typeof import("resource://normandy/lib/RecipeRunner.sys.mjs"),
  "resource://normandy/lib/ShieldPreferences.sys.mjs": typeof import("resource://normandy/lib/ShieldPreferences.sys.mjs"),
  "resource://normandy/lib/Storage.sys.mjs": typeof import("resource://normandy/lib/Storage.sys.mjs"),
  "resource://normandy/lib/TelemetryEvents.sys.mjs": typeof import("resource://normandy/lib/TelemetryEvents.sys.mjs"),
  "resource://normandy/lib/Uptake.sys.mjs": typeof import("resource://normandy/lib/Uptake.sys.mjs"),
  "resource://pdf.js/PdfJs.sys.mjs": typeof import("resource://pdf.js/PdfJs.sys.mjs"),
  "resource://pdf.js/PdfJsNetwork.sys.mjs": typeof import("resource://pdf.js/PdfJsNetwork.sys.mjs"),
  "resource://pdf.js/PdfJsTelemetry.sys.mjs": typeof import("resource://pdf.js/PdfJsTelemetry.sys.mjs"),
  "resource://pdf.js/PdfSandbox.sys.mjs": typeof import("resource://pdf.js/PdfSandbox.sys.mjs"),
  "resource://pdf.js/PdfStreamConverter.sys.mjs": typeof import("resource://pdf.js/PdfStreamConverter.sys.mjs"),
  "resource://services-common/async.sys.mjs": typeof import("resource://services-common/async.sys.mjs"),
  "resource://services-common/kinto-http-client.sys.mjs": typeof import("resource://services-common/kinto-http-client.sys.mjs"),
  "resource://services-common/kinto-offline-client.sys.mjs": typeof import("resource://services-common/kinto-offline-client.sys.mjs"),
  "resource://services-common/kinto-storage-adapter.sys.mjs": typeof import("resource://services-common/kinto-storage-adapter.sys.mjs"),
  "resource://services-common/observers.sys.mjs": typeof import("resource://services-common/observers.sys.mjs"),
  "resource://services-common/uptake-telemetry.sys.mjs": typeof import("resource://services-common/uptake-telemetry.sys.mjs"),
  "resource://services-common/utils.sys.mjs": typeof import("resource://services-common/utils.sys.mjs"),
  "resource://services-crypto/jwcrypto.sys.mjs": typeof import("resource://services-crypto/jwcrypto.sys.mjs"),
  "resource://services-crypto/utils.sys.mjs": typeof import("resource://services-crypto/utils.sys.mjs"),
  "resource://services-settings/Attachments.sys.mjs": typeof import("resource://services-settings/Attachments.sys.mjs"),
  "resource://services-settings/Database.sys.mjs": typeof import("resource://services-settings/Database.sys.mjs"),
  "resource://services-settings/IDBHelpers.sys.mjs": typeof import("resource://services-settings/IDBHelpers.sys.mjs"),
  "resource://services-settings/RemoteSettingsClient.sys.mjs": typeof import("resource://services-settings/RemoteSettingsClient.sys.mjs"),
  "resource://services-settings/RemoteSettingsWorker.sys.mjs": typeof import("resource://services-settings/RemoteSettingsWorker.sys.mjs"),
  "resource://services-settings/SharedUtils.sys.mjs": typeof import("resource://services-settings/SharedUtils.sys.mjs"),
  "resource://services-settings/SyncHistory.sys.mjs": typeof import("resource://services-settings/SyncHistory.sys.mjs"),
  "resource://services-settings/Utils.sys.mjs": typeof import("resource://services-settings/Utils.sys.mjs"),
  "resource://services-settings/remote-settings.sys.mjs": typeof import("resource://services-settings/remote-settings.sys.mjs"),
  "resource://services-sync/SyncedTabs.sys.mjs": typeof import("resource://services-sync/SyncedTabs.sys.mjs"),
  "resource://services-sync/TabsStore.sys.mjs": typeof import("resource://services-sync/TabsStore.sys.mjs"),
  "resource://services-sync/UIState.sys.mjs": typeof import("resource://services-sync/UIState.sys.mjs"),
  "resource://services-sync/constants.sys.mjs": typeof import("resource://services-sync/constants.sys.mjs"),
  "resource://services-sync/doctor.sys.mjs": typeof import("resource://services-sync/doctor.sys.mjs"),
  "resource://services-sync/engines/addons.sys.mjs": typeof import("resource://services-sync/engines/addons.sys.mjs"),
  "resource://services-sync/engines/forms.sys.mjs": typeof import("resource://services-sync/engines/forms.sys.mjs"),
  "resource://services-sync/engines/passwords.sys.mjs": typeof import("resource://services-sync/engines/passwords.sys.mjs"),
  "resource://services-sync/keys.sys.mjs": typeof import("resource://services-sync/keys.sys.mjs"),
  "resource://services-sync/main.sys.mjs": typeof import("resource://services-sync/main.sys.mjs"),
  "resource://services-sync/record.sys.mjs": typeof import("resource://services-sync/record.sys.mjs"),
  "resource://services-sync/resource.sys.mjs": typeof import("resource://services-sync/resource.sys.mjs"),
  "resource://services-sync/service.sys.mjs": typeof import("resource://services-sync/service.sys.mjs"),
  "resource://services-sync/status.sys.mjs": typeof import("resource://services-sync/status.sys.mjs"),
  "resource://services-sync/sync_auth.sys.mjs": typeof import("resource://services-sync/sync_auth.sys.mjs"),
  "resource://services-sync/telemetry.sys.mjs": typeof import("resource://services-sync/telemetry.sys.mjs"),
  "resource://services-sync/util.sys.mjs": typeof import("resource://services-sync/util.sys.mjs"),
  "resource://talos-powers/TalosParentProfiler.sys.mjs": typeof import("resource://talos-powers/TalosParentProfiler.sys.mjs"),
  "resource://test/es6module_devtoolsLoader.js": typeof import("resource://test/es6module_devtoolsLoader.js"),
  "resource://test/esm_lazy-1.sys.mjs": typeof import("resource://test/esm_lazy-1.sys.mjs"),
  "resource://test/esm_lazy-2.sys.mjs": typeof import("resource://test/esm_lazy-2.sys.mjs"),
  "resource://test/esmified-1.sys.mjs": typeof import("resource://test/esmified-1.sys.mjs"),
  "resource://testing-common/AddonTestUtils.sys.mjs": typeof import("resource://testing-common/AddonTestUtils.sys.mjs"),
  "resource://testing-common/AppInfo.sys.mjs": typeof import("resource://testing-common/AppInfo.sys.mjs"),
  "resource://testing-common/AppUiTestDelegate.sys.mjs": typeof import("resource://testing-common/AppUiTestDelegate.sys.mjs"),
  "resource://testing-common/Assert.sys.mjs": typeof import("resource://testing-common/Assert.sys.mjs"),
  "resource://testing-common/BrowserTestUtils.sys.mjs": typeof import("resource://testing-common/BrowserTestUtils.sys.mjs"),
  "resource://testing-common/ContentTask.sys.mjs": typeof import("resource://testing-common/ContentTask.sys.mjs"),
  "resource://testing-common/ContentTaskUtils.sys.mjs": typeof import("resource://testing-common/ContentTaskUtils.sys.mjs"),
  "resource://testing-common/CustomizableUITestUtils.sys.mjs": typeof import("resource://testing-common/CustomizableUITestUtils.sys.mjs"),
  "resource://testing-common/DoHTestUtils.sys.mjs": typeof import("resource://testing-common/DoHTestUtils.sys.mjs"),
  "resource://testing-common/EnterprisePolicyTesting.sys.mjs": typeof import("resource://testing-common/EnterprisePolicyTesting.sys.mjs"),
  "resource://testing-common/ExtensionTestCommon.sys.mjs": typeof import("resource://testing-common/ExtensionTestCommon.sys.mjs"),
  "resource://testing-common/ExtensionXPCShellUtils.sys.mjs": typeof import("resource://testing-common/ExtensionXPCShellUtils.sys.mjs"),
  "resource://testing-common/FileTestUtils.sys.mjs": typeof import("resource://testing-common/FileTestUtils.sys.mjs"),
  "resource://testing-common/FormHistoryTestUtils.sys.mjs": typeof import("resource://testing-common/FormHistoryTestUtils.sys.mjs"),
  "resource://testing-common/MerinoTestUtils.sys.mjs": typeof import("resource://testing-common/MerinoTestUtils.sys.mjs"),
  "resource://testing-common/MessageChannel.sys.mjs": typeof import("resource://testing-common/MessageChannel.sys.mjs"),
  "resource://testing-common/MockColorPicker.sys.mjs": typeof import("resource://testing-common/MockColorPicker.sys.mjs"),
  "resource://testing-common/MockFilePicker.sys.mjs": typeof import("resource://testing-common/MockFilePicker.sys.mjs"),
  "resource://testing-common/MockPermissionPrompt.sys.mjs": typeof import("resource://testing-common/MockPermissionPrompt.sys.mjs"),
  "resource://testing-common/MockPromptCollection.sys.mjs": typeof import("resource://testing-common/MockPromptCollection.sys.mjs"),
  "resource://testing-common/MockRegistrar.sys.mjs": typeof import("resource://testing-common/MockRegistrar.sys.mjs"),
  "resource://testing-common/MockRegistry.sys.mjs": typeof import("resource://testing-common/MockRegistry.sys.mjs"),
  "resource://testing-common/MockSound.sys.mjs": typeof import("resource://testing-common/MockSound.sys.mjs"),
  "resource://testing-common/NimbusTestUtils.sys.mjs": typeof import("resource://testing-common/NimbusTestUtils.sys.mjs"),
  "resource://testing-common/NormandyTestUtils.sys.mjs": typeof import("resource://testing-common/NormandyTestUtils.sys.mjs"),
  "resource://testing-common/PerTestCoverageUtils.sys.mjs": typeof import("resource://testing-common/PerTestCoverageUtils.sys.mjs"),
  "resource://testing-common/PerfTestHelpers.sys.mjs": typeof import("resource://testing-common/PerfTestHelpers.sys.mjs"),
  "resource://testing-common/PermissionTestUtils.sys.mjs": typeof import("resource://testing-common/PermissionTestUtils.sys.mjs"),
  "resource://testing-common/PlacesTestUtils.sys.mjs": typeof import("resource://testing-common/PlacesTestUtils.sys.mjs"),
  "resource://testing-common/PromiseTestUtils.sys.mjs": typeof import("resource://testing-common/PromiseTestUtils.sys.mjs"),
  "resource://testing-common/PromptTestUtils.sys.mjs": typeof import("resource://testing-common/PromptTestUtils.sys.mjs"),
  "resource://testing-common/QuickSuggestTestUtils.sys.mjs": typeof import("resource://testing-common/QuickSuggestTestUtils.sys.mjs"),
  "resource://testing-common/RegionTestUtils.sys.mjs": typeof import("resource://testing-common/RegionTestUtils.sys.mjs"),
  "resource://testing-common/RemoteSettingsServer.sys.mjs": typeof import("resource://testing-common/RemoteSettingsServer.sys.mjs"),
  "resource://testing-common/SearchTestUtils.sys.mjs": typeof import("resource://testing-common/SearchTestUtils.sys.mjs"),
  "resource://testing-common/SearchUITestUtils.sys.mjs": typeof import("resource://testing-common/SearchUITestUtils.sys.mjs"),
  "resource://testing-common/Sinon.sys.mjs": typeof import("resource://testing-common/Sinon.sys.mjs"),
  "resource://testing-common/SiteDataTestUtils.sys.mjs": typeof import("resource://testing-common/SiteDataTestUtils.sys.mjs"),
  "resource://testing-common/SpecialPowersParent.sys.mjs": typeof import("resource://testing-common/SpecialPowersParent.sys.mjs"),
  "resource://testing-common/SpecialPowersProcessActor.sys.mjs": typeof import("resource://testing-common/SpecialPowersProcessActor.sys.mjs"),
  "resource://testing-common/SpecialPowersSandbox.sys.mjs": typeof import("resource://testing-common/SpecialPowersSandbox.sys.mjs"),
  "resource://testing-common/TabGroupTestUtils.sys.mjs": typeof import("resource://testing-common/TabGroupTestUtils.sys.mjs"),
  "resource://testing-common/TelemetryArchiveTesting.sys.mjs": typeof import("resource://testing-common/TelemetryArchiveTesting.sys.mjs"),
  "resource://testing-common/TelemetryTestUtils.sys.mjs": typeof import("resource://testing-common/TelemetryTestUtils.sys.mjs"),
  "resource://testing-common/TestIntegration.sys.mjs": typeof import("resource://testing-common/TestIntegration.sys.mjs"),
  "resource://testing-common/TestUtils.sys.mjs": typeof import("resource://testing-common/TestUtils.sys.mjs"),
  "resource://testing-common/UrlbarTestUtils.sys.mjs": typeof import("resource://testing-common/UrlbarTestUtils.sys.mjs"),
  "resource://testing-common/WrapPrivileged.sys.mjs": typeof import("resource://testing-common/WrapPrivileged.sys.mjs"),
  "resource://testing-common/XPCShellContentUtils.sys.mjs": typeof import("resource://testing-common/XPCShellContentUtils.sys.mjs"),
  "resource://testing-common/httpd.sys.mjs": typeof import("resource://testing-common/httpd.sys.mjs"),
  "resource://tps/auth/fxaccounts.sys.mjs": typeof import("resource://tps/auth/fxaccounts.sys.mjs"),
  "resource://tps/logger.sys.mjs": typeof import("resource://tps/logger.sys.mjs"),
  "resource://tps/modules/addons.sys.mjs": typeof import("resource://tps/modules/addons.sys.mjs"),
  "resource://tps/modules/bookmarkValidator.sys.mjs": typeof import("resource://tps/modules/bookmarkValidator.sys.mjs"),
  "resource://tps/modules/bookmarks.sys.mjs": typeof import("resource://tps/modules/bookmarks.sys.mjs"),
  "resource://tps/modules/formautofill.sys.mjs": typeof import("resource://tps/modules/formautofill.sys.mjs"),
  "resource://tps/modules/forms.sys.mjs": typeof import("resource://tps/modules/forms.sys.mjs"),
  "resource://tps/modules/history.sys.mjs": typeof import("resource://tps/modules/history.sys.mjs"),
  "resource://tps/modules/passwords.sys.mjs": typeof import("resource://tps/modules/passwords.sys.mjs"),
  "resource://tps/modules/prefs.sys.mjs": typeof import("resource://tps/modules/prefs.sys.mjs"),
  "resource://tps/modules/tabs.sys.mjs": typeof import("resource://tps/modules/tabs.sys.mjs"),
  "resource://tps/modules/windows.sys.mjs": typeof import("resource://tps/modules/windows.sys.mjs"),
}

// @ts-nocheck
/**
 * NOTE: Do not modify this file by hand.
 * Content was generated from xpc.msg and error_list.json.
 * If you're updating some of the sources, see README for instructions.
 */

interface nsIXPCComponents_Results {

  // Error Message definitions.

  // xpconnect specific codes (from nsIXPConnect.h)

  /** Not enough arguments */
  NS_ERROR_XPC_NOT_ENOUGH_ARGS: 0x80570001;

  /** 'Out' argument must be an object */
  NS_ERROR_XPC_NEED_OUT_OBJECT: 0x80570002;

  /** Cannot set 'value' property of 'out' argument */
  NS_ERROR_XPC_CANT_SET_OUT_VAL: 0x80570003;

  /** Component returned failure code: */
  NS_ERROR_XPC_NATIVE_RETURNED_FAILURE: 0x80570004;

  /** Cannot find interface information */
  NS_ERROR_XPC_CANT_GET_INTERFACE_INFO: 0x80570005;

  /** Cannot find interface information for parameter */
  NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO: 0x80570006;

  /** Cannot find method information */
  NS_ERROR_XPC_CANT_GET_METHOD_INFO: 0x80570007;

  /** Unexpected error in XPConnect */
  NS_ERROR_XPC_UNEXPECTED: 0x80570008;

  /** Could not convert JavaScript argument */
  NS_ERROR_XPC_BAD_CONVERT_JS: 0x80570009;

  /** Could not convert Native argument */
  NS_ERROR_XPC_BAD_CONVERT_NATIVE: 0x8057000a;

  /** Could not convert JavaScript argument (NULL value cannot be used for a C++ reference type) */
  NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF: 0x8057000b;

  /** Illegal operation on WrappedNative prototype object */
  NS_ERROR_XPC_BAD_OP_ON_WN_PROTO: 0x8057000c;

  /** Cannot convert WrappedNative to function */
  NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN: 0x8057000d;

  /** Cannot define new property in a WrappedNative */
  NS_ERROR_XPC_CANT_DEFINE_PROP_ON_WN: 0x8057000e;

  /** Cannot place watchpoints on WrappedNative object static properties */
  NS_ERROR_XPC_CANT_WATCH_WN_STATIC: 0x8057000f;

  /** Cannot   NS_ERROR_XPC_CANT_EXPORT_WN_STATIC: 0x80570010;

  /** nsIXPCScriptable::Call failed */
  NS_ERROR_XPC_SCRIPTABLE_CALL_FAILED: 0x80570011;

  /** nsIXPCScriptable::Construct failed */
  NS_ERROR_XPC_SCRIPTABLE_CTOR_FAILED: 0x80570012;

  /** Cannot use wrapper as function unless it implements nsIXPCScriptable */
  NS_ERROR_XPC_CANT_CALL_WO_SCRIPTABLE: 0x80570013;

  /** Cannot use wrapper as constructor unless it implements nsIXPCScriptable */
  NS_ERROR_XPC_CANT_CTOR_WO_SCRIPTABLE: 0x80570014;

  /** ComponentManager::CreateInstance returned failure code: */
  NS_ERROR_XPC_CI_RETURNED_FAILURE: 0x80570015;

  /** ServiceManager::GetService returned failure code: */
  NS_ERROR_XPC_GS_RETURNED_FAILURE: 0x80570016;

  /** Invalid ClassID or ContractID */
  NS_ERROR_XPC_BAD_CID: 0x80570017;

  /** Invalid InterfaceID */
  NS_ERROR_XPC_BAD_IID: 0x80570018;

  /** Cannot create wrapper around native interface */
  NS_ERROR_XPC_CANT_CREATE_WN: 0x80570019;

  /** JavaScript component threw exception */
  NS_ERROR_XPC_JS_THREW_EXCEPTION: 0x8057001a;

  /** JavaScript component threw a native object that is not an exception */
  NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT: 0x8057001b;

  /** JavaScript component threw a JavaScript object */
  NS_ERROR_XPC_JS_THREW_JS_OBJECT: 0x8057001c;

  /** JavaScript component threw a null value as an exception */
  NS_ERROR_XPC_JS_THREW_NULL: 0x8057001d;

  /** JavaScript component threw a string as an exception */
  NS_ERROR_XPC_JS_THREW_STRING: 0x8057001e;

  /** JavaScript component threw a number as an exception */
  NS_ERROR_XPC_JS_THREW_NUMBER: 0x8057001f;

  /** JavaScript component caused a JavaScript error */
  NS_ERROR_XPC_JAVASCRIPT_ERROR: 0x80570020;

  /** JavaScript component caused a JavaScript error (detailed report attached) */
  NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS: 0x80570021;

  /** Cannot convert primitive JavaScript value into an array */
  NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY: 0x80570022;

  /** Cannot convert JavaScript object into an array */
  NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY: 0x80570023;

  /** JavaScript Array does not have as many elements as indicated by size argument */
  NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY: 0x80570024;

  /** Cannot find array information */
  NS_ERROR_XPC_CANT_GET_ARRAY_INFO: 0x80570025;

  /** JavaScript String does not have as many characters as indicated by size argument */
  NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING: 0x80570026;

  /** Security Manager vetoed action */
  NS_ERROR_XPC_SECURITY_MANAGER_VETO: 0x80570027;

  /** Failed to build a wrapper because the interface that was not declared [scriptable] */
  NS_ERROR_XPC_INTERFACE_NOT_SCRIPTABLE: 0x80570028;

  /** Failed to build a wrapper because the interface does not inherit from nsISupports */
  NS_ERROR_XPC_INTERFACE_NOT_FROM_NSISUPPORTS: 0x80570029;

  /** Property is a constant and cannot be changed */
  NS_ERROR_XPC_CANT_SET_READ_ONLY_CONSTANT: 0x8057002b;

  /** Property is a read only attribute and cannot be changed */
  NS_ERROR_XPC_CANT_SET_READ_ONLY_ATTRIBUTE: 0x8057002c;

  /** Property is an interface method and cannot be changed */
  NS_ERROR_XPC_CANT_SET_READ_ONLY_METHOD: 0x8057002d;

  /** Cannot add property to WrappedNative object */
  NS_ERROR_XPC_CANT_ADD_PROP_TO_WRAPPED_NATIVE: 0x8057002e;

  /** Call to nsIXPCScriptable interface for WrappedNative failed unexpecedly */
  NS_ERROR_XPC_CALL_TO_SCRIPTABLE_FAILED: 0x8057002f;

  /** JavaScript component does not have a method named: */
  NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED: 0x80570030;

  /** Bad ID string */
  NS_ERROR_XPC_BAD_ID_STRING: 0x80570031;

  /** Bad initializer name in Constructor - Component has no method with that name */
  NS_ERROR_XPC_BAD_INITIALIZER_NAME: 0x80570032;

  /** Operation failed because the XPConnect subsystem has been shutdown */
  NS_ERROR_XPC_HAS_BEEN_SHUTDOWN: 0x80570033;

  /** Cannot modify properties of a WrappedNative */
  NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN: 0x80570034;

  /** Could not convert JavaScript argument - 0 was passed, expected object. Did you mean null? */
  NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL: 0x80570035;

  // common global codes (from nsError.h)

  /** Success */
  NS_OK: 0x0;

  /** Component not initialized */
  NS_ERROR_NOT_INITIALIZED: 0xc1f30001;

  /** Component already initialized */
  NS_ERROR_ALREADY_INITIALIZED: 0xc1f30002;

  /** Method not implemented */
  NS_ERROR_NOT_IMPLEMENTED: 0x80004001;

  /** Component does not have requested interface */
  NS_NOINTERFACE: 0x80004002;

  /** Component does not have requested interface */
  NS_ERROR_NO_INTERFACE: 0x80004002;

  /** Illegal value */
  NS_ERROR_ILLEGAL_VALUE: 0x80070057;

  /** Invalid pointer */
  NS_ERROR_INVALID_POINTER: 0x80070057;

  /** Null pointer */
  NS_ERROR_NULL_POINTER: 0x80070057;

  /** Abort */
  NS_ERROR_ABORT: 0x80004004;

  /** Failure */
  NS_ERROR_FAILURE: 0x80004005;

  /** Unexpected error */
  NS_ERROR_UNEXPECTED: 0x8000ffff;

  /** Out of Memory */
  NS_ERROR_OUT_OF_MEMORY: 0x8007000e;

  /** Invalid argument */
  NS_ERROR_INVALID_ARG: 0x80070057;

  /** Component is not available */
  NS_ERROR_NOT_AVAILABLE: 0x80040111;

  /** Factory not registered */
  NS_ERROR_FACTORY_NOT_REGISTERED: 0x80040154;

  /** Factory not registered (may be tried again) */
  NS_ERROR_FACTORY_REGISTER_AGAIN: 0x80040155;

  /** Factory not loaded */
  NS_ERROR_FACTORY_NOT_LOADED: 0x800401f8;

  /** Factory does not support signatures */
  NS_ERROR_FACTORY_NO_SIGNATURE_SUPPORT: 0xc1f30101;

  /** Factory already exists */
  NS_ERROR_FACTORY_EXISTS: 0xc1f30100;

  // added from nsError.h on Feb 28 2001...

  /** Stream closed */
  NS_BASE_STREAM_CLOSED: 0x80470002;

  /** Error from the operating system */
  NS_BASE_STREAM_OSERROR: 0x80470003;

  /** Illegal arguments */
  NS_BASE_STREAM_ILLEGAL_ARGS: 0x80470004;

  /** No converter for unichar streams */
  NS_BASE_STREAM_NO_CONVERTER: 0x80470005;

  /** Bad converter for unichar streams */
  NS_BASE_STREAM_BAD_CONVERSION: 0x80470006;

  /** Stream would block */
  NS_BASE_STREAM_WOULD_BLOCK: 0x80470007;

  /** File error: Unrecognized path */
  NS_ERROR_FILE_UNRECOGNIZED_PATH: 0x80520001;

  /** File error: Unresolvable symlink */
  NS_ERROR_FILE_UNRESOLVABLE_SYMLINK: 0x80520002;

  /** File error: Execution failed */
  NS_ERROR_FILE_EXECUTION_FAILED: 0x80520003;

  /** File error: Unknown type */
  NS_ERROR_FILE_UNKNOWN_TYPE: 0x80520004;

  /** File error: Destination not dir */
  NS_ERROR_FILE_DESTINATION_NOT_DIR: 0x80520005;

  /** File error: Copy or move failed */
  NS_ERROR_FILE_COPY_OR_MOVE_FAILED: 0x80520007;

  /** File error: Already exists */
  NS_ERROR_FILE_ALREADY_EXISTS: 0x80520008;

  /** File error: Invalid path */
  NS_ERROR_FILE_INVALID_PATH: 0x80520009;

  /** File error: Corrupted */
  NS_ERROR_FILE_CORRUPTED: 0x8052000b;

  /** File error: Not directory */
  NS_ERROR_FILE_NOT_DIRECTORY: 0x8052000c;

  /** File error: Is directory */
  NS_ERROR_FILE_IS_DIRECTORY: 0x8052000d;

  /** File error: Is locked */
  NS_ERROR_FILE_IS_LOCKED: 0x8052000e;

  /** File error: Too big */
  NS_ERROR_FILE_TOO_BIG: 0x8052000f;

  /** File error: No device space */
  NS_ERROR_FILE_NO_DEVICE_SPACE: 0x80520010;

  /** File error: Name too long */
  NS_ERROR_FILE_NAME_TOO_LONG: 0x80520011;

  /** File error: Not found */
  NS_ERROR_FILE_NOT_FOUND: 0x80520012;

  /** File error: Read only */
  NS_ERROR_FILE_READ_ONLY: 0x80520013;

  /** File error: Dir not empty */
  NS_ERROR_FILE_DIR_NOT_EMPTY: 0x80520014;

  /** File error: Access denied */
  NS_ERROR_FILE_ACCESS_DENIED: 0x80520015;

  // added from nsError.h on Sept 6 2001...

  /** Data conversion error */
  NS_ERROR_CANNOT_CONVERT_DATA: 0x80460001;

  /** Can not modify immutable data container */
  NS_ERROR_OBJECT_IS_IMMUTABLE: 0x80460002;

  /** Data conversion failed because significant data would be lost */
  NS_ERROR_LOSS_OF_SIGNIFICANT_DATA: 0x80460003;

  /** Data conversion succeeded but data was rounded to fit */
  NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA: 0x460001;

  // network related codes (from nsNetError.h)

  /** The async request failed for some unknown reason */
  NS_BINDING_FAILED: 0x804b0001;

  /** The async request failed because it was aborted by some user action */
  NS_BINDING_ABORTED: 0x804b0002;

  /** The async request has been redirected to a different async request */
  NS_BINDING_REDIRECTED: 0x804b0003;

  /** The async request has been retargeted to a different handler */
  NS_BINDING_RETARGETED: 0x804b0004;

  /** The URI is malformed */
  NS_ERROR_MALFORMED_URI: 0x804b000a;

  /** The URI scheme corresponds to an unknown protocol handler */
  NS_ERROR_UNKNOWN_PROTOCOL: 0x804b0012;

  /** Channel opened successfully but no data will be returned */
  NS_ERROR_NO_CONTENT: 0x804b0011;

  /** The requested action could not be completed while the object is busy */
  NS_ERROR_IN_PROGRESS: 0x804b000f;

  /** Channel is already open */
  NS_ERROR_ALREADY_OPENED: 0x804b0049;

  /** The content encoding of the source document is incorrect */
  NS_ERROR_INVALID_CONTENT_ENCODING: 0x804b001b;

  /** Corrupted content received from server (potentially MIME type mismatch because of 'X-Content-Type-Options: nosniff') */
  NS_ERROR_CORRUPTED_CONTENT: 0x804b001d;

  /** Couldn't extract first component from potentially corrupted header field */
  NS_ERROR_FIRST_HEADER_FIELD_COMPONENT_EMPTY: 0x804b0022;

  /** The connection is already established */
  NS_ERROR_ALREADY_CONNECTED: 0x804b000b;

  /** The connection does not exist */
  NS_ERROR_NOT_CONNECTED: 0x804b000c;

  /** The connection was refused */
  NS_ERROR_CONNECTION_REFUSED: 0x804b000d;

  /** User refused navigation to potentially unsafe URL with embedded credentials/superfluos authentication */
  NS_ERROR_SUPERFLUOS_AUTH: 0x804b005b;

  /** User attempted basic HTTP authentication when it is disabled */
  NS_ERROR_BASIC_HTTP_AUTH_DISABLED: 0x804b005c;

  // Error codes return from the proxy

  /** The connection to the proxy server was refused */
  NS_ERROR_PROXY_CONNECTION_REFUSED: 0x804b0048;

  /** The proxy requires authentication */
  NS_ERROR_PROXY_AUTHENTICATION_FAILED: 0x804b057f;

  /** The request failed on the proxy */
  NS_ERROR_PROXY_BAD_GATEWAY: 0x804b05de;

  /** The request timed out on the proxy */
  NS_ERROR_PROXY_GATEWAY_TIMEOUT: 0x804b05e0;

  /** Sending too many requests to a proxy */
  NS_ERROR_PROXY_TOO_MANY_REQUESTS: 0x804b0595;

  /** The proxy does not support the version of the HTTP request */
  NS_ERROR_PROXY_VERSION_NOT_SUPPORTED: 0x804b05e1;

  /** The user is banned from the proxy */
  NS_ERROR_PROXY_FORBIDDEN: 0x804b057b;

  /** The proxy is not available */
  NS_ERROR_PROXY_SERVICE_UNAVAILABLE: 0x804b05df;

  /** The desired destination is unavailable for legal reasons */
  NS_ERROR_PROXY_UNAVAILABLE_FOR_LEGAL_REASONS: 0x804b05ab;

  /** The connection has timed out */
  NS_ERROR_NET_TIMEOUT: 0x804b000e;

  /** The request has been cancelled because of a timeout */
  NS_ERROR_NET_TIMEOUT_EXTERNAL: 0x804b0055;

  /** The requested action could not be completed in the offline state */
  NS_ERROR_OFFLINE: 0x804b0010;

  /** Establishing a connection to an unsafe or otherwise banned port was prohibited */
  NS_ERROR_PORT_ACCESS_NOT_ALLOWED: 0x804b0013;

  /** The connection was established, but no data was ever received */
  NS_ERROR_NET_RESET: 0x804b0014;

  /** The connection was established, but the browser received an empty page with an error response */
  NS_ERROR_NET_EMPTY_RESPONSE: 0x804b0024;

  /** The connection was established, but the browser received an error response from the server */
  NS_ERROR_NET_ERROR_RESPONSE: 0x804b0023;

  /** The connection was established, but the data transfer was interrupted */
  NS_ERROR_NET_INTERRUPT: 0x804b0047;

  /** A transfer was only partially done when it completed */
  NS_ERROR_NET_PARTIAL_TRANSFER: 0x804b004c;

  /** There has been a http3 protocol error */
  NS_ERROR_NET_HTTP3_PROTOCOL_ERROR: 0x804b0054;

  /** This request is not resumable, but it was tried to resume it, or to request resume-specific data */
  NS_ERROR_NOT_RESUMABLE: 0x804b0019;

  /** It was attempted to resume the request, but the entity has changed in the meantime */
  NS_ERROR_ENTITY_CHANGED: 0x804b0020;

  /** The request failed as a result of a detected redirection loop */
  NS_ERROR_REDIRECT_LOOP: 0x804b001f;

  /** The request failed because the content type returned by the server was not a type expected by the channel */
  NS_ERROR_UNSAFE_CONTENT_TYPE: 0x804b004a;

  /** The load caused an error page to be displayed. */
  NS_ERROR_LOAD_SHOWED_ERRORPAGE: 0x804b004d;

  /** The request was blocked by a policy set by the system administrator. */
  NS_ERROR_BLOCKED_BY_POLICY: 0x80780003;

  /** The lookup of the hostname failed */
  NS_ERROR_UNKNOWN_HOST: 0x804b001e;

  /** The DNS lookup queue is full */
  NS_ERROR_DNS_LOOKUP_QUEUE_FULL: 0x804b0021;

  /** The lookup of the proxy hostname failed */
  NS_ERROR_UNKNOWN_PROXY_HOST: 0x804b002a;

  /** The specified socket type does not exist */
  NS_ERROR_UNKNOWN_SOCKET_TYPE: 0x804b0033;

  /** The specified socket type could not be created */
  NS_ERROR_SOCKET_CREATE_FAILED: 0x804b0034;

  /** The specified socket address type is not supported */
  NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED: 0x804b0035;

  /** Some other socket is already using the specified address. */
  NS_ERROR_SOCKET_ADDRESS_IN_USE: 0x804b0036;

  /** Cache key could not be found */
  NS_ERROR_CACHE_KEY_NOT_FOUND: 0x804b003d;

  /** Cache data is a stream */
  NS_ERROR_CACHE_DATA_IS_STREAM: 0x804b003e;

  /** Cache data is not a stream */
  NS_ERROR_CACHE_DATA_IS_NOT_STREAM: 0x804b003f;

  /** Cache entry exists but needs to be validated first */
  NS_ERROR_CACHE_WAIT_FOR_VALIDATION: 0x804b0040;

  /** Cache entry has been  doomed */
  NS_ERROR_CACHE_ENTRY_DOOMED: 0x804b0041;

  /** Read access to cache denied */
  NS_ERROR_CACHE_READ_ACCESS_DENIED: 0x804b0042;

  /** Write access to cache denied */
  NS_ERROR_CACHE_WRITE_ACCESS_DENIED: 0x804b0043;

  /** Cache is currently in use */
  NS_ERROR_CACHE_IN_USE: 0x804b0044;

  /** Document does not exist in cache */
  NS_ERROR_DOCUMENT_NOT_CACHED: 0x804b0046;

  /** The requested number of domain levels exceeds those present in the host string */
  NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS: 0x804b0050;

  /** The host string is an IP address */
  NS_ERROR_HOST_IS_IP_ADDRESS: 0x804b0051;

  /** Can't access a wrapped JS object from a different thread */
  NS_ERROR_NOT_SAME_THREAD: 0x80460004;

  // storage related codes (from mozStorage.h)

  /** SQLite database connection is busy */
  NS_ERROR_STORAGE_BUSY: 0x80630001;

  /** SQLite encountered an IO error */
  NS_ERROR_STORAGE_IOERR: 0x80630002;

  /** SQLite database operation failed because a constraint was violated */
  NS_ERROR_STORAGE_CONSTRAINT: 0x80630003;

  // plugin related codes (from nsPluginError.h)

  /** Clearing site data by time range not supported by plugin */
  NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED: 0x804c03eb;

  // character converter related codes

  /** The input characters have illegal sequences */
  NS_ERROR_ILLEGAL_INPUT: 0x8050000e;

  // Codes related to signd jars

  /** The JAR is not signed. */
  NS_ERROR_SIGNED_JAR_NOT_SIGNED: 0x80680001;

  /** An entry in the JAR has been modified after the JAR was signed. */
  NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY: 0x80680002;

  /** An entry in the JAR has not been signed. */
  NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY: 0x80680003;

  /** An entry is missing from the JAR file. */
  NS_ERROR_SIGNED_JAR_ENTRY_MISSING: 0x80680004;

  /** The JAR's signature is wrong. */
  NS_ERROR_SIGNED_JAR_WRONG_SIGNATURE: 0x80680005;

  /** An entry in the JAR is too large. */
  NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE: 0x80680006;

  /** An entry in the JAR is invalid. */
  NS_ERROR_SIGNED_JAR_ENTRY_INVALID: 0x80680007;

  /** The JAR's manifest or signature file is invalid. */
  NS_ERROR_SIGNED_JAR_MANIFEST_INVALID: 0x80680008;

  /** The PKCS#7 signature is malformed or invalid. */
  NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO: 0x805a0401;

  /** The PKCS#7 information is not signed. */
  NS_ERROR_CMS_VERIFY_NOT_SIGNED: 0x805a0400;

  // Codes related to signed manifests

  /** The signed app manifest or signature file is invalid. */
  NS_ERROR_SIGNED_APP_MANIFEST_INVALID: 0x806b0001;

  // Codes for printing-related errors.

  /** No printers available. */
  NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE: 0x80480001;

  /** The selected printer could not be found. */
  NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND: 0x80480002;

  /** Failed to open output file for print to file. */
  NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE: 0x80480003;

  /** Printing failed while starting the print job. */
  NS_ERROR_GFX_PRINTER_STARTDOC: 0x80480004;

  /** Printing failed while completing the print job. */
  NS_ERROR_GFX_PRINTER_ENDDOC: 0x80480005;

  /** Printing failed while starting a new page. */
  NS_ERROR_GFX_PRINTER_STARTPAGE: 0x80480006;

  /** Cannot print this document yet, it is still being loaded. */
  NS_ERROR_GFX_PRINTER_DOC_IS_BUSY: 0x80480007;

  // Codes related to content

  /** The process that hosted this content has crashed. */
  NS_ERROR_CONTENT_CRASHED: 0x805e0010;

  /** The process that hosted this frame has crashed. */
  NS_ERROR_FRAME_CRASHED: 0x805e000e;

  /** The process that hosted this content did not have the same buildID as the parent. */
  NS_ERROR_BUILDID_MISMATCH: 0x805e0011;

  /** The load for this content was blocked. */
  NS_ERROR_CONTENT_BLOCKED: 0x805e0006;

  // Codes for the JS-implemented Push DOM API. These can be removed as part of bug 1252660.

  /** Invalid raw ECDSA P-256 public key. */
  NS_ERROR_DOM_PUSH_INVALID_KEY_ERR: 0x806d0005;

  /** A subscription with a different application server key already exists. */
  NS_ERROR_DOM_PUSH_MISMATCHED_KEY_ERR: 0x806d0006;

  // Codes defined in WebIDL https://heycam.github.io/webidl/#idl-DOMException-error-names

  /** The object can not be found here. */
  NS_ERROR_DOM_NOT_FOUND_ERR: 0x80530008;

  /** The request is not allowed. */
  NS_ERROR_DOM_NOT_ALLOWED_ERR: 0x80530021;

  // Codes related to the URIClassifier service

  /** The URI is malware */
  NS_ERROR_MALWARE_URI: 0x805d001e;

  /** The URI is phishing */
  NS_ERROR_PHISHING_URI: 0x805d001f;

  /** The URI is tracking */
  NS_ERROR_TRACKING_URI: 0x805d0022;

  /** The URI is unwanted */
  NS_ERROR_UNWANTED_URI: 0x805d0023;

  /** The URI is blocked */
  NS_ERROR_BLOCKED_URI: 0x805d0025;

  /** The URI is harmful */
  NS_ERROR_HARMFUL_URI: 0x805d0026;

  /** The URI is fingerprinting */
  NS_ERROR_FINGERPRINTING_URI: 0x805d0029;

  /** The URI is cryptomining */
  NS_ERROR_CRYPTOMINING_URI: 0x805d002a;

  /** The URI is social tracking */
  NS_ERROR_SOCIALTRACKING_URI: 0x805d002b;

  /** The URI is email tracking */
  NS_ERROR_EMAILTRACKING_URI: 0x805d002c;

  // Profile manager error codes

  /** Flushing the profiles to disk would have overwritten changes made elsewhere. */
  NS_ERROR_DATABASE_CHANGED: 0x805800ca;

  // Codes related to URILoader

  /** The data from a channel has already been parsed and cached so it doesn't need to be reparsed from the original source. */
  NS_ERROR_PARSED_DATA_CACHED: 0x805d0021;

  /** The async request has been cancelled by another async request */
  NS_BINDING_CANCELLED_OLD_LOAD: 0x805d0027;

  /** The ProgID classes had not been registered. */
  NS_ERROR_WDBA_NO_PROGID: 0x80720001;

  /** The existing UserChoice Hash could not be verified. */
  NS_ERROR_WDBA_HASH_CHECK: 0x80720002;

  /** UserChoice was set, but checking the default did not return our ProgID. */
  NS_ERROR_WDBA_REJECTED: 0x80720003;

  /** The existing UserChoice Hash was verified, but we're on an older, unsupported Windows build, so do not attempt to update the UserChoice hash. */
  NS_ERROR_WDBA_BUILD: 0x80720004;

  // Codes related to QuotaManager

  /** Client initialization attempted before origin has been initialized. */
  NS_ERROR_DOM_QM_CLIENT_INIT_ORIGIN_UNINITIALIZED: 0x80730001;
}

type nsIXPCComponents_Values = nsIXPCComponents_Results[keyof nsIXPCComponents_Results];

// @ts-nocheck
/**
 * NOTE: Do not modify this file by hand.
 * Content was generated from services.json.
 * If you're updating some of the sources, see README for instructions.
 */

interface JSServices {
  DAPTelemetry: nsIDAPTelemetry;
  appShell: nsIAppShellService;
  appinfo: nsICrashReporter & nsIXULAppInfo & nsIXULRuntime;
  blocklist: nsIBlocklistService;
  cache2: nsICacheStorageService;
  catMan: nsICategoryManager;
  clearData: nsIClearDataService;
  clipboard: nsIClipboard;
  console: nsIConsoleService;
  cookieBanners: nsICookieBannerService;
  cookies: nsICookieManager & nsICookieService;
  cpmm: ContentProcessMessageManager;
  dirsvc: nsIDirectoryService & nsIProperties;
  dns: nsIDNSService;
  domStorageManager: nsIDOMStorageManager & nsILocalStorageManager;
  droppedLinkHandler: nsIDroppedLinkHandler;
  eTLD: nsIEffectiveTLDService;
  els: nsIEventListenerService;
  env: nsIEnvironment;
  focus: nsIFocusManager;
  fog: nsIFOG;
  intl: mozIMozIntl;
  io: nsIIOService & nsINetUtil & nsISpeculativeConnect;
  loadContextInfo: nsILoadContextInfoFactory;
  locale: mozILocaleService;
  logins: nsILoginManager;
  mm: ChromeMessageBroadcaster;
  obs: nsIObserverService;
  perms: nsIPermissionManager;
  policies: nsIEnterprisePolicies;
  ppmm: ParentProcessMessageManager;
  prefs: nsIPrefBranch & nsIPrefService;
  profiler: nsIProfiler;
  prompt: nsIPromptService;
  qms: nsIQuotaManagerService;
  rfp: nsIRFPService;
  scriptSecurityManager: nsIScriptSecurityManager;
  scriptloader: mozIJSSubScriptLoader;
  search: nsISearchService;
  sessionStorage: nsISessionStorageService;
  startup: nsIAppStartup;
  storage: mozIStorageService;
  strings: nsIStringBundleService;
  sysinfo: nsIPropertyBag2 & nsISystemInfo;
  telemetry: nsITelemetry;
  textToSubURI: nsITextToSubURI;
  tm: nsIThreadManager;
  uriFixup: nsIURIFixup;
  urlFormatter: nsIURLFormatter;
  uuid: nsIUUIDGenerator;
  vc: nsIVersionComparator;
  wm: nsIWindowMediator;
  ww: nsIWindowWatcher;
  xulStore: nsIXULStore;
}

// @ts-nocheck
/**
 * NOTE: Do not modify this file by hand.
 * Content was generated from source XPCOM .idl files.
 * If you're updating some of the sources, see README for instructions.
 */

declare global {

// https://searchfox.org/mozilla-central/source/toolkit/components/aboutthirdparty/nsIAboutThirdParty.idl

interface nsIInstalledApplication extends nsISupports {
  readonly name: string;
  readonly publisher: string;
}

interface nsIAboutThirdParty extends nsISupports {
  readonly ModuleType_Unknown?: 1;
  readonly ModuleType_IME?: 2;
  readonly ModuleType_ShellExtension?: 4;
  readonly ModuleType_BlockedByUser?: 8;
  readonly ModuleType_BlockedByUserAtLaunch?: 16;

  lookupModuleType(aLeafName: string): u32;
  lookupApplication(aModulePath: string): nsIInstalledApplication;
  readonly isDynamicBlocklistAvailable: boolean;
  readonly isDynamicBlocklistDisabled: boolean;
  updateBlocklist(aLeafName: string, aNewBlockStatus: boolean): Promise<any>;
  collectSystemInfo(): Promise<any>;
  loadModuleForTesting(aModulePath: string): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/aboutwindowsmessages/nsIAboutWindowsMessages.idl

interface nsIAboutWindowsMessages extends nsISupports {
  getMessages(currentWindow: mozIDOMWindowProxy, messages: OutParam<string[][]>, windowTitles: OutParam<string[]>): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/alerts/nsIWindowsAlertsService.idl

}  // global

declare enum nsIWindowsAlertNotification_ImagePlacement {
  eInline = 0,
  eHero = 1,
  eIcon = 2,
}

declare global {

namespace nsIWindowsAlertNotification {
  type ImagePlacement = nsIWindowsAlertNotification_ImagePlacement;
}

interface nsIWindowsAlertNotification extends nsIAlertNotification, Enums<typeof nsIWindowsAlertNotification_ImagePlacement> {
  imagePlacement: nsIWindowsAlertNotification.ImagePlacement;
}

interface nsIWindowsAlertsService extends nsIAlertsService {
  handleWindowsTag(aWindowsTag: string): Promise<any>;
  getXmlStringForWindowsAlert(aAlert: nsIAlertNotification, aWindowsTag?: string): string;
  removeAllNotificationsForInstall(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/mozapps/defaultagent/nsIDefaultAgent.idl

interface nsIDefaultAgent extends nsISupports {
  registerTask(aUniqueToken: string): void;
  updateTask(aUniqueToken: string): void;
  unregisterTask(aUniqueToken: string): void;
  uninstall(aUniqueToken: string): void;
  secondsSinceLastAppRun(): i64;
  getDefaultBrowser(): string;
  getReplacePreviousDefaultBrowser(aCurrentBrowser: string): string;
  getDefaultPdfHandler(): string;
  sendPing(aCurrentBrowser: string, aPreviousBrowser: string, aPdfHandler: string, aNotificationShown: string, aNotificationAction: string, daysSinceLastAppLaunch: u32): void;
  setDefaultBrowserUserChoice(aAumid: string, aExtraFileExtensions: string[]): void;
  setDefaultBrowserUserChoiceAsync(aAumid: string, aExtraFileExtensions: string[]): Promise<any>;
  setDefaultExtensionHandlersUserChoice(aAumid: string, aFileExtensions: string[]): void;
  agentDisabled(): boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/mozapps/defaultagent/nsIWindowsMutex.idl

interface nsIWindowsMutex extends nsISupports {
  tryLock(): void;
  isLocked(): boolean;
  unlock(): void;
}

interface nsIWindowsMutexFactory extends nsISupports {
  createMutex(aName: string): nsIWindowsMutex;
}

// https://searchfox.org/mozilla-central/source/dom/geolocation/nsIGeolocationUIUtilsWin.idl

interface nsIGeolocationUIUtilsWin extends nsISupports {
  dismissPrompts(aBC: BrowsingContext): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/socket/nsINamedPipeService.idl

// https://searchfox.org/mozilla-central/source/browser/components/shell/nsIWindowsShellService.idl

}  // global

declare enum nsIWindowsShellService_LaunchOnLoginEnabledEnumerator {
  LAUNCH_ON_LOGIN_DISABLED_BY_SETTINGS = 0,
  LAUNCH_ON_LOGIN_DISABLED = 1,
  LAUNCH_ON_LOGIN_ENABLED = 2,
  LAUNCH_ON_LOGIN_ENABLED_BY_POLICY = 3,
}

declare global {

namespace nsIWindowsShellService {
  type LaunchOnLoginEnabledEnumerator = nsIWindowsShellService_LaunchOnLoginEnabledEnumerator;
}

interface nsIWindowsShellService extends nsIShellService, Enums<typeof nsIWindowsShellService_LaunchOnLoginEnabledEnumerator> {
  createShortcut(aBinary: nsIFile, aArguments: string[], aDescription: string, aIconFile: nsIFile, aIconIndex: u16, aAppUserModelId: string, aShortcutFolder: string, aShortcutName: string): Promise<any>;
  getLaunchOnLoginShortcuts(): string[];
  pinCurrentAppToStartMenuAsync(aCheckOnly: boolean): Promise<any>;
  isCurrentAppPinnedToStartMenuAsync(): Promise<any>;
  enableLaunchOnLoginMSIXAsync(aTaskId: string): Promise<any>;
  disableLaunchOnLoginMSIXAsync(aTaskId: string): Promise<any>;
  getLaunchOnLoginEnabledMSIXAsync(aTaskId: string): Promise<any>;
  pinCurrentAppToTaskbarAsync(aPrivateBrowsing: boolean): Promise<any>;
  checkPinCurrentAppToTaskbarAsync(aPrivateBrowsing: boolean): Promise<any>;
  isCurrentAppPinnedToTaskbarAsync(aumid: string): Promise<any>;
  pinShortcutToTaskbar(aAppUserModelId: string, aShortcutPath: string): Promise<any>;
  createWindowsIcon(aFile: nsIFile, aContainer: imgIContainer): Promise<any>;
  unpinShortcutFromTaskbar(aShortcutPath: string): void;
  getTaskbarTabShortcutPath(aShortcutName: string): string;
  getTaskbarTabPins(): string[];
  classifyShortcut(aPath: string): string;
  hasPinnableShortcut(aAUMID: string, aPrivateBrowsing: boolean): Promise<any>;
  canSetDefaultBrowserUserChoice(): boolean;
  checkAllProgIDsExist(): boolean;
  checkBrowserUserChoiceHashes(): boolean;
  checkCurrentProcessAUMIDForTesting(): string;
  isDefaultHandlerFor(aFileExtensionOrProtocol: string): boolean;
  queryCurrentDefaultHandlerFor(aFileExtensionOrProtocol: string): string;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/taskscheduler/nsIWinTaskSchedulerService.idl

interface nsIWinTaskSchedulerService extends nsISupports {
  registerTask(aFolderName: string, aTaskName: string, aDefinitionXML: string, aUpdateExisting?: boolean): void;
  validateTaskDefinition(aDefinitionXML: string): i32;
  getTaskXML(aFolderName: string, aTaskName: string): string;
  getCurrentUserSid(): string;
  deleteTask(aFolderName: string, aTaskName: string): void;
  getFolderTasks(aFolderName: string): string[];
  createFolder(aParentFolderName: string, aSubFolderName: string): void;
  deleteFolder(aParentFolderName: string, aSubFolderName: string): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIJumpListBuilder.idl

interface nsIJumpListBuilder extends nsISupports {
  obtainAndCacheFavicon(faviconURL: nsIURI): string;
  obtainAndCacheFaviconAsync(faviconURL: nsIURI): Promise<any>;
  isAvailable(): Promise<any>;
  checkForRemovals(): Promise<any>;
  populateJumpList(aTaskDescriptions: any, aCustomTitle: string, aCustomDescriptions: any): Promise<any>;
  clearJumpList(): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/widget/nsIPrintSettingsWin.idl

// https://searchfox.org/mozilla-central/source/widget/nsITaskbarOverlayIconController.idl

interface nsITaskbarOverlayIconController extends nsISupports {
  setOverlayIcon(statusIcon: imgIContainer, statusDescription: string, paintContext?: nsISVGPaintContext): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsITaskbarPreview.idl

interface nsITaskbarPreview extends nsISupports {
  controller: nsITaskbarPreviewController;
  tooltip: string;
  visible: boolean;
  active: boolean;
  invalidate(): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsITaskbarPreviewButton.idl

interface nsITaskbarPreviewButton extends nsISupports {
  tooltip: string;
  dismissOnClick: boolean;
  hasBorder: boolean;
  disabled: boolean;
  image: imgIContainer;
  visible: boolean;
}

// https://searchfox.org/mozilla-central/source/widget/nsITaskbarPreviewController.idl

type nsITaskbarPreviewCallback = Callable<{
  done(aCanvas: nsISupports, aDrawBorder: boolean): void;
}>

interface nsITaskbarPreviewController extends nsISupports {
  readonly width: u32;
  readonly height: u32;
  readonly thumbnailAspectRatio: float;
  requestPreview(aCallback: nsITaskbarPreviewCallback): void;
  requestThumbnail(aCallback: nsITaskbarPreviewCallback, width: u32, height: u32): void;
  onClose(): void;
  onActivate(): boolean;
  onClick(button: nsITaskbarPreviewButton): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsITaskbarProgress.idl

interface nsITaskbarProgress extends nsISupports {
  readonly STATE_NO_PROGRESS?: 0;
  readonly STATE_INDETERMINATE?: 1;
  readonly STATE_NORMAL?: 2;
  readonly STATE_ERROR?: 3;
  readonly STATE_PAUSED?: 4;

  setProgressState(state: nsTaskbarProgressState, currentValue?: u64, maxValue?: u64): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsITaskbarTabPreview.idl

interface nsITaskbarTabPreview extends nsITaskbarPreview {
  title: string;
  icon: imgIContainer;
  move(aNext: nsITaskbarTabPreview): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsITaskbarWindowPreview.idl

interface nsITaskbarWindowPreview extends nsITaskbarPreview {
  readonly NUM_TOOLBAR_BUTTONS?: 7;

  getButton(index: u32): nsITaskbarPreviewButton;
  enableCustomDrawing: boolean;
}

// https://searchfox.org/mozilla-central/source/widget/nsIWinTaskbar.idl

interface nsIWinTaskbar extends nsISupports {
  readonly available: boolean;
  readonly defaultGroupId: string;
  readonly defaultPrivateGroupId: string;
  createTaskbarTabPreview(shell: nsIDocShell, controller: nsITaskbarPreviewController): nsITaskbarTabPreview;
  getTaskbarWindowPreview(shell: nsIDocShell): nsITaskbarWindowPreview;
  getTaskbarProgress(shell: nsIDocShell): nsITaskbarProgress;
  getOverlayIconController(shell: nsIDocShell): nsITaskbarOverlayIconController;
  createJumpListBuilder(aPrivateBrowsing: boolean): nsIJumpListBuilder;
  getGroupIdForWindow(aParent: mozIDOMWindow): string;
  setGroupIdForWindow(aParent: mozIDOMWindow, aIdentifier: string): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIWindowsUIUtils.idl

interface nsIWindowsUIUtils extends nsISupports {
  readonly systemSmallIconSize: i32;
  readonly systemLargeIconSize: i32;
  setWindowIcon(aWindow: mozIDOMWindowProxy, aSmallIcon: imgIContainer, aLargeIcon: imgIContainer): void;
  setWindowIconFromExe(aWindow: mozIDOMWindowProxy, aExe: string, aIndex: u16): void;
  setWindowIconNoData(aWindow: mozIDOMWindowProxy): void;
  readonly inWin10TabletMode: boolean;
  readonly inWin11TabletMode: boolean;
  shareUrl(urlToShare: string, shareTitle: string): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/system/windowsPackageManager/nsIWindowsPackageManager.idl

interface nsIWindowsPackageManager extends nsISupports {
  findUserInstalledPackages(prefix: string[]): string[];
  getInstalledDate(): u64;
  campaignId(): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIWindowsRegKey.idl

interface nsIWindowsRegKey extends nsISupports {
  readonly ROOT_KEY_CLASSES_ROOT?: 2147483648;
  readonly ROOT_KEY_CURRENT_USER?: 2147483649;
  readonly ROOT_KEY_LOCAL_MACHINE?: 2147483650;
  readonly ACCESS_BASIC?: 131072;
  readonly ACCESS_QUERY_VALUE?: 1;
  readonly ACCESS_SET_VALUE?: 2;
  readonly ACCESS_CREATE_SUB_KEY?: 4;
  readonly ACCESS_ENUMERATE_SUB_KEYS?: 8;
  readonly ACCESS_NOTIFY?: 16;
  readonly ACCESS_READ?: 131097;
  readonly ACCESS_WRITE?: 131078;
  readonly ACCESS_ALL?: 131103;
  readonly WOW64_32?: 512;
  readonly WOW64_64?: 256;
  readonly TYPE_NONE?: 0;
  readonly TYPE_STRING?: 1;
  readonly TYPE_BINARY?: 3;
  readonly TYPE_INT?: 4;
  readonly TYPE_INT64?: 11;

  close(): void;
  open(rootKey: u32, relPath: string, mode: u32): void;
  create(rootKey: u32, relPath: string, mode: u32): void;
  openChild(relPath: string, mode: u32): nsIWindowsRegKey;
  createChild(relPath: string, mode: u32): nsIWindowsRegKey;
  readonly childCount: u32;
  getChildName(index: u32): string;
  hasChild(name: string): boolean;
  readonly valueCount: u32;
  getValueName(index: u32): string;
  hasValue(name: string): boolean;
  removeChild(relPath: string): void;
  removeValue(name: string): void;
  getValueType(name: string): u32;
  readStringValue(name: string): string;
  readIntValue(name: string): u32;
  readInt64Value(name: string): u64;
  readBinaryValue(name: string): string;
  writeStringValue(name: string, data: string): void;
  writeIntValue(name: string, data: u32): void;
  writeInt64Value(name: string, data: u64): void;
  writeBinaryValue(name: string, data: string): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/xre/nsIWinAppHelper.idl

interface nsIWinAppHelper extends nsISupports {
  readonly userCanElevate: boolean;
}

interface nsIXPCComponents_Interfaces {
  nsIInstalledApplication: nsJSIID<nsIInstalledApplication>;
  nsIAboutThirdParty: nsJSIID<nsIAboutThirdParty>;
  nsIAboutWindowsMessages: nsJSIID<nsIAboutWindowsMessages>;
  nsIWindowsAlertNotification: nsJSIID<nsIWindowsAlertNotification, typeof nsIWindowsAlertNotification_ImagePlacement>;
  nsIWindowsAlertsService: nsJSIID<nsIWindowsAlertsService>;
  nsIDefaultAgent: nsJSIID<nsIDefaultAgent>;
  nsIWindowsMutex: nsJSIID<nsIWindowsMutex>;
  nsIWindowsMutexFactory: nsJSIID<nsIWindowsMutexFactory>;
  nsIGeolocationUIUtilsWin: nsJSIID<nsIGeolocationUIUtilsWin>;
  nsIWindowsShellService: nsJSIID<nsIWindowsShellService, typeof nsIWindowsShellService_LaunchOnLoginEnabledEnumerator>;
  nsIWinTaskSchedulerService: nsJSIID<nsIWinTaskSchedulerService>;
  nsIJumpListBuilder: nsJSIID<nsIJumpListBuilder>;
  nsITaskbarOverlayIconController: nsJSIID<nsITaskbarOverlayIconController>;
  nsITaskbarPreview: nsJSIID<nsITaskbarPreview>;
  nsITaskbarPreviewButton: nsJSIID<nsITaskbarPreviewButton>;
  nsITaskbarPreviewCallback: nsJSIID<nsITaskbarPreviewCallback>;
  nsITaskbarPreviewController: nsJSIID<nsITaskbarPreviewController>;
  nsITaskbarProgress: nsJSIID<nsITaskbarProgress>;
  nsITaskbarTabPreview: nsJSIID<nsITaskbarTabPreview>;
  nsITaskbarWindowPreview: nsJSIID<nsITaskbarWindowPreview>;
  nsIWinTaskbar: nsJSIID<nsIWinTaskbar>;
  nsIWindowsUIUtils: nsJSIID<nsIWindowsUIUtils>;
  nsIWindowsPackageManager: nsJSIID<nsIWindowsPackageManager>;
  nsIWindowsRegKey: nsJSIID<nsIWindowsRegKey>;
  nsIWinAppHelper: nsJSIID<nsIWinAppHelper>;
}

}  // global

// Typedefs from xpidl.
type PRTime = i64;
type nsTaskbarProgressState = i32;

// XPCOM internal utility types.

/** XPCOM inout param is passed in as a js object with a value property. */
type InOutParam<T> = { value: T };

/** XPCOM out param is written to the passed in object's value property. */
type OutParam<T> = { value?: T };

/** Enable interfaces to inherit from enums: pick variants as optional. */
type Enums<enums> = Partial<Pick<enums, keyof enums>>;

/** Callable accepts either form of a [function] interface. */
type Callable<iface> = iface | Extract<iface[keyof iface], Function>


// @ts-nocheck
/**
 * NOTE: Do not modify this file by hand.
 * Content was generated from source XPCOM .idl files.
 * If you're updating some of the sources, see README for instructions.
 */

declare global {

// https://searchfox.org/mozilla-central/source/toolkit/components/bitsdownload/nsIBits.idl

interface nsIBits extends nsISupports {
  readonly ERROR_TYPE_SUCCESS?: 0;
  readonly ERROR_TYPE_UNKNOWN?: 1;
  readonly ERROR_TYPE_METHOD_THREW?: 2;
  readonly ERROR_TYPE_METHOD_TIMEOUT?: 3;
  readonly ERROR_TYPE_NULL_ARGUMENT?: 4;
  readonly ERROR_TYPE_INVALID_ARGUMENT?: 5;
  readonly ERROR_TYPE_NOT_INITIALIZED?: 6;
  readonly ERROR_TYPE_NO_UTF8_CONVERSION?: 7;
  readonly ERROR_TYPE_INVALID_GUID?: 8;
  readonly ERROR_TYPE_PIPE_NOT_CONNECTED?: 9;
  readonly ERROR_TYPE_PIPE_TIMEOUT?: 10;
  readonly ERROR_TYPE_PIPE_BAD_WRITE_COUNT?: 11;
  readonly ERROR_TYPE_PIPE_API_ERROR?: 12;
  readonly ERROR_TYPE_FAILED_TO_CREATE_BITS_JOB?: 13;
  readonly ERROR_TYPE_FAILED_TO_ADD_FILE_TO_JOB?: 14;
  readonly ERROR_TYPE_FAILED_TO_APPLY_BITS_JOB_SETTINGS?: 15;
  readonly ERROR_TYPE_FAILED_TO_RESUME_BITS_JOB?: 16;
  readonly ERROR_TYPE_OTHER_BITS_ERROR?: 17;
  readonly ERROR_TYPE_OTHER_BITS_CLIENT_ERROR?: 18;
  readonly ERROR_TYPE_BITS_JOB_NOT_FOUND?: 19;
  readonly ERROR_TYPE_FAILED_TO_GET_BITS_JOB?: 20;
  readonly ERROR_TYPE_FAILED_TO_SUSPEND_BITS_JOB?: 21;
  readonly ERROR_TYPE_FAILED_TO_COMPLETE_BITS_JOB?: 22;
  readonly ERROR_TYPE_PARTIALLY_COMPLETED_BITS_JOB?: 23;
  readonly ERROR_TYPE_FAILED_TO_CANCEL_BITS_JOB?: 24;
  readonly ERROR_TYPE_MISSING_RESULT_DATA?: 25;
  readonly ERROR_TYPE_MISSING_CALLBACK?: 26;
  readonly ERROR_TYPE_CALLBACK_ON_WRONG_THREAD?: 27;
  readonly ERROR_TYPE_MISSING_BITS_SERVICE?: 28;
  readonly ERROR_TYPE_BITS_SERVICE_ON_WRONG_THREAD?: 29;
  readonly ERROR_TYPE_MISSING_BITS_REQUEST?: 30;
  readonly ERROR_TYPE_BITS_REQUEST_ON_WRONG_THREAD?: 31;
  readonly ERROR_TYPE_MISSING_OBSERVER?: 32;
  readonly ERROR_TYPE_OBSERVER_ON_WRONG_THREAD?: 33;
  readonly ERROR_TYPE_MISSING_CONTEXT?: 34;
  readonly ERROR_TYPE_CONTEXT_ON_WRONG_THREAD?: 35;
  readonly ERROR_TYPE_FAILED_TO_START_THREAD?: 36;
  readonly ERROR_TYPE_FAILED_TO_CONSTRUCT_TASK_RUNNABLE?: 37;
  readonly ERROR_TYPE_FAILED_TO_DISPATCH_RUNNABLE?: 38;
  readonly ERROR_TYPE_TRANSFER_ALREADY_COMPLETE?: 39;
  readonly ERROR_TYPE_OPERATION_ALREADY_IN_PROGRESS?: 40;
  readonly ERROR_TYPE_MISSING_BITS_CLIENT?: 41;
  readonly ERROR_TYPE_FAILED_TO_GET_JOB_STATUS?: 42;
  readonly ERROR_TYPE_BITS_STATE_ERROR?: 43;
  readonly ERROR_TYPE_BITS_STATE_TRANSIENT_ERROR?: 44;
  readonly ERROR_TYPE_BITS_STATE_CANCELLED?: 45;
  readonly ERROR_TYPE_BITS_STATE_UNEXPECTED?: 46;
  readonly ERROR_TYPE_VERIFICATION_FAILURE?: 47;
  readonly ERROR_TYPE_ACCESS_DENIED_EXPECTED?: 48;
  readonly ERROR_TYPE_FAILED_TO_CONNECT_TO_BCM?: 49;
  readonly ERROR_TYPE_USE_AFTER_REQUEST_SHUTDOWN?: 50;
  readonly ERROR_TYPE_BROWSER_SHUTTING_DOWN?: 51;
  readonly ERROR_ACTION_UNKNOWN?: 1;
  readonly ERROR_ACTION_NONE?: 2;
  readonly ERROR_ACTION_START_DOWNLOAD?: 3;
  readonly ERROR_ACTION_MONITOR_DOWNLOAD?: 4;
  readonly ERROR_ACTION_CHANGE_MONITOR_INTERVAL?: 5;
  readonly ERROR_ACTION_CANCEL?: 6;
  readonly ERROR_ACTION_SET_PRIORITY?: 7;
  readonly ERROR_ACTION_COMPLETE?: 8;
  readonly ERROR_ACTION_SUSPEND?: 9;
  readonly ERROR_ACTION_RESUME?: 10;
  readonly ERROR_ACTION_SET_NO_PROGRESS_TIMEOUT?: 11;
  readonly ERROR_STAGE_UNKNOWN?: 1;
  readonly ERROR_STAGE_PRETASK?: 2;
  readonly ERROR_STAGE_COMMAND_THREAD?: 3;
  readonly ERROR_STAGE_AGENT_COMMUNICATION?: 4;
  readonly ERROR_STAGE_BITS_CLIENT?: 5;
  readonly ERROR_STAGE_MAIN_THREAD?: 6;
  readonly ERROR_STAGE_MONITOR?: 7;
  readonly ERROR_STAGE_VERIFICATION?: 8;
  readonly ERROR_CODE_TYPE_NONE?: 1;
  readonly ERROR_CODE_TYPE_NSRESULT?: 2;
  readonly ERROR_CODE_TYPE_HRESULT?: 3;
  readonly ERROR_CODE_TYPE_STRING?: 4;
  readonly ERROR_CODE_TYPE_EXCEPTION?: 5;
  readonly PROXY_NONE?: 1;
  readonly PROXY_PRECONFIG?: 2;
  readonly PROXY_AUTODETECT?: 3;

  readonly initialized: boolean;
  init(jobName: string, savePathPrefix: string, monitorTimeoutMs: u32): void;
  startDownload(downloadURL: string, saveRelativePath: string, proxy: nsProxyUsage, noProgressTimeoutSecs: u32, monitorIntervalMs: u32, customHeaders: string, observer: nsIRequestObserver, context: nsISupports, callback: nsIBitsNewRequestCallback): void;
  monitorDownload(id: string, monitorIntervalMs: u32, observer: nsIRequestObserver, context: nsISupports, callback: nsIBitsNewRequestCallback): void;
}

interface nsIBitsNewRequestCallback extends nsISupports {
  success(request: nsIBitsRequest): void;
  failure(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage): void;
  failureNsresult(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage, errorCode: nsresult): void;
  failureHresult(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage, errorCode: i32): void;
  failureString(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage, errorMessage: string): void;
}

interface nsIBitsRequest extends nsIRequest {
  readonly bitsId: string;
  readonly transferError: nsBitsErrorType;
  changeMonitorInterval(monitorIntervalMs: u32, callback: nsIBitsCallback): void;
  cancelAsync(status: nsresult, callback: nsIBitsCallback): void;
  setPriorityHigh(callback: nsIBitsCallback): void;
  setPriorityLow(callback: nsIBitsCallback): void;
  setNoProgressTimeout(timeoutSecs: u32, callback: nsIBitsCallback): void;
  complete(callback: nsIBitsCallback): void;
  suspendAsync(callback: nsIBitsCallback): void;
  resumeAsync(callback: nsIBitsCallback): void;
}

interface nsIBitsCallback extends nsISupports {
  success(): void;
  failure(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage): void;
  failureNsresult(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage, errorCode: nsresult): void;
  failureHresult(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage, errorCode: i32): void;
  failureString(errorType: nsBitsErrorType, errorAction: nsBitsErrorAction, errorStage: nsBitsErrorStage, errorMessage: string): void;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibilityService.idl

interface nsIAccessibilityService extends nsISupports {
  getApplicationAccessible(): nsIAccessible;
  getAccessibleFor(aNode: Node): nsIAccessible;
  getAccessibleDescendantFor(aNode: Node): nsIAccessible;
  getStringRole(aRole: u32): string;
  getStringStates(aStates: u32, aExtraStates: u32): nsISupports;
  getStringEventType(aEventType: u32): string;
  getStringRelationType(aRelationType: u32): string;
  getAccessibleFromCache(aNode: Node): nsIAccessible;
  setCacheDomains(aCacheDomains: u64): void;
  createAccessiblePivot(aRoot: nsIAccessible): nsIAccessiblePivot;
  createTextLeafPoint(aAccessible: nsIAccessible, aOffset: i32): nsIAccessibleTextLeafPoint;
  setLogging(aModules: string): void;
  isLogged(aModule: string): boolean;
  getConsumers(): string;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessible.idl

interface nsIAccessible extends nsISupports {
  readonly parent: nsIAccessible;
  readonly nextSibling: nsIAccessible;
  readonly previousSibling: nsIAccessible;
  readonly firstChild: nsIAccessible;
  readonly lastChild: nsIAccessible;
  readonly children: nsIArray;
  readonly childCount: i32;
  readonly indexInParent: i32;
  readonly uniqueID: i64;
  readonly DOMNode: Node;
  readonly id: string;
  readonly document: nsIAccessibleDocument;
  readonly rootDocument: nsIAccessibleDocument;
  readonly language: string;
  readonly name: string;
  readonly value: string;
  readonly description: string;
  readonly accessKey: string;
  readonly keyboardShortcut: string;
  readonly role: u32;
  getState(aState: OutParam<u32>, aExtraState: OutParam<u32>): void;
  readonly focusedChild: nsIAccessible;
  readonly attributes: nsIPersistentProperties;
  readonly cache: nsIPersistentProperties;
  readonly nativeInterface: nsISupports;
  groupPosition(aGroupLevel: OutParam<i32>, aSimilarItemsInGroup: OutParam<i32>, aPositionInGroup: OutParam<i32>): void;
  getChildAtPoint(x: i32, y: i32): nsIAccessible;
  getDeepestChildAtPoint(x: i32, y: i32): nsIAccessible;
  getDeepestChildAtPointInProcess(x: i32, y: i32): nsIAccessible;
  getChildAt(aChildIndex: i32): nsIAccessible;
  getRelationByType(aRelationType: u32): nsIAccessibleRelation;
  getRelations(): nsIArray;
  getBounds(x: OutParam<i32>, y: OutParam<i32>, width: OutParam<i32>, height: OutParam<i32>): void;
  getBoundsInCSSPixels(aX: OutParam<i32>, aY: OutParam<i32>, aWidth: OutParam<i32>, aHeight: OutParam<i32>): void;
  setSelected(isSelected: boolean): void;
  takeSelection(): void;
  takeFocus(): void;
  readonly actionCount: u8;
  getActionName(index: u8): string;
  getActionDescription(aIndex: u8): string;
  doAction(index: u8): void;
  scrollTo(aScrollType: u32): void;
  scrollToPoint(coordinateType: u32, x: i32, y: i32): void;
  announce(announcement: string, priority: u16): void;
  readonly computedARIARole: string;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleAnnouncementEvent.idl

interface nsIAccessibleAnnouncementEvent extends nsIAccessibleEvent {
  readonly POLITE?: 0;
  readonly ASSERTIVE?: 1;

  readonly announcement: string;
  readonly priority: u16;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleApplication.idl

interface nsIAccessibleApplication extends nsISupports {
  readonly appName: string;
  readonly appVersion: string;
  readonly platformName: string;
  readonly platformVersion: string;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleCaretMoveEvent.idl

interface nsIAccessibleCaretMoveEvent extends nsIAccessibleEvent {
  readonly caretOffset: i32;
  readonly isSelectionCollapsed: boolean;
  readonly isAtEndOfLine: boolean;
  readonly granularity: i32;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleDocument.idl

interface nsIAccessibleDocument extends nsISupports {
  readonly URL: string;
  readonly title: string;
  readonly mimeType: string;
  readonly docType: string;
  readonly DOMDocument: Document;
  readonly window: mozIDOMWindowProxy;
  readonly parentDocument: nsIAccessibleDocument;
  readonly childDocumentCount: u32;
  getChildDocumentAt(index: u32): nsIAccessibleDocument;
  readonly browsingContext: BrowsingContext;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleEditableText.idl

interface nsIAccessibleEditableText extends nsISupports {
  setTextContents(text: string): void;
  insertText(text: string, position: i32): void;
  copyText(startPos: i32, endPos: i32): void;
  cutText(startPos: i32, endPos: i32): void;
  deleteText(startPos: i32, endPos: i32): void;
  pasteText(position: i32): void;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleEvent.idl

interface nsIAccessibleEvent extends nsISupports {
  readonly EVENT_SHOW?: 1;
  readonly EVENT_HIDE?: 2;
  readonly EVENT_REORDER?: 3;
  readonly EVENT_FOCUS?: 4;
  readonly EVENT_STATE_CHANGE?: 5;
  readonly EVENT_NAME_CHANGE?: 6;
  readonly EVENT_DESCRIPTION_CHANGE?: 7;
  readonly EVENT_VALUE_CHANGE?: 8;
  readonly EVENT_SELECTION?: 9;
  readonly EVENT_SELECTION_ADD?: 10;
  readonly EVENT_SELECTION_REMOVE?: 11;
  readonly EVENT_SELECTION_WITHIN?: 12;
  readonly EVENT_ALERT?: 13;
  readonly EVENT_MENU_START?: 14;
  readonly EVENT_MENU_END?: 15;
  readonly EVENT_MENUPOPUP_START?: 16;
  readonly EVENT_MENUPOPUP_END?: 17;
  readonly EVENT_DRAGDROP_START?: 18;
  readonly EVENT_SCROLLING_START?: 19;
  readonly EVENT_SCROLLING_END?: 20;
  readonly EVENT_DOCUMENT_LOAD_COMPLETE?: 21;
  readonly EVENT_DOCUMENT_RELOAD?: 22;
  readonly EVENT_DOCUMENT_LOAD_STOPPED?: 23;
  readonly EVENT_TEXT_ATTRIBUTE_CHANGED?: 24;
  readonly EVENT_TEXT_CARET_MOVED?: 25;
  readonly EVENT_TEXT_INSERTED?: 26;
  readonly EVENT_TEXT_REMOVED?: 27;
  readonly EVENT_TEXT_SELECTION_CHANGED?: 28;
  readonly EVENT_WINDOW_ACTIVATE?: 29;
  readonly EVENT_WINDOW_DEACTIVATE?: 30;
  readonly EVENT_WINDOW_MAXIMIZE?: 31;
  readonly EVENT_WINDOW_MINIMIZE?: 32;
  readonly EVENT_WINDOW_RESTORE?: 33;
  readonly EVENT_OBJECT_ATTRIBUTE_CHANGED?: 34;
  readonly EVENT_TEXT_VALUE_CHANGE?: 35;
  readonly EVENT_SCROLLING?: 36;
  readonly EVENT_ANNOUNCEMENT?: 37;
  readonly EVENT_LIVE_REGION_ADDED?: 38;
  readonly EVENT_LIVE_REGION_REMOVED?: 39;
  readonly EVENT_INNER_REORDER?: 40;
  readonly EVENT_LIVE_REGION_CHANGED?: 41;
  readonly EVENT_ERRORMESSAGE_CHANGED?: 42;
  readonly EVENT_LAST_ENTRY?: 43;

  readonly eventType: u32;
  readonly accessible: nsIAccessible;
  readonly accessibleDocument: nsIAccessibleDocument;
  readonly DOMNode: Node;
  readonly isFromUserInput: boolean;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleHideEvent.idl

interface nsIAccessibleHideEvent extends nsIAccessibleEvent {
  readonly targetParent: nsIAccessible;
  readonly targetNextSibling: nsIAccessible;
  readonly targetPrevSibling: nsIAccessible;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleHyperLink.idl

interface nsIAccessibleHyperLink extends nsISupports {
  readonly startIndex: i32;
  readonly endIndex: i32;
  readonly valid: boolean;
  readonly anchorCount: i32;
  getURI(index: i32): nsIURI;
  getAnchor(index: i32): nsIAccessible;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleHyperText.idl

interface nsIAccessibleHyperText extends nsISupports {
  readonly linkCount: i32;
  getLinkAt(index: i32): nsIAccessibleHyperLink;
  getLinkIndex(link: nsIAccessibleHyperLink): i32;
  getLinkIndexAtOffset(offset: i32): i32;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleImage.idl

interface nsIAccessibleImage extends nsISupports {
  getImagePosition(coordType: u32, x: OutParam<i32>, y: OutParam<i32>): void;
  getImageSize(width: OutParam<i32>, height: OutParam<i32>): void;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleObjectAttributeChangedEvent.idl

interface nsIAccessibleObjectAttributeChangedEvent extends nsIAccessibleEvent {
  readonly changedAttribute: string;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessiblePivot.idl

interface nsIAccessiblePivot extends nsISupports {
  next(aAnchor: nsIAccessible, aRule: nsIAccessibleTraversalRule, aIncludeStart?: boolean): nsIAccessible;
  prev(aAnchor: nsIAccessible, aRule: nsIAccessibleTraversalRule, aIncludeStart?: boolean): nsIAccessible;
  first(aRule: nsIAccessibleTraversalRule): nsIAccessible;
  last(aRule: nsIAccessibleTraversalRule): nsIAccessible;
  atPoint(aX: i32, aY: i32, aRule: nsIAccessibleTraversalRule): nsIAccessible;
}

interface nsIAccessibleTraversalRule extends nsISupports {
  readonly FILTER_IGNORE?: 0;
  readonly FILTER_MATCH?: 1;
  readonly FILTER_IGNORE_SUBTREE?: 2;

  match(aAccessible: nsIAccessible): u16;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleRelation.idl

interface nsIAccessibleRelation extends nsISupports {
  readonly RELATION_LABELLED_BY?: 0;
  readonly RELATION_LABEL_FOR?: 1;
  readonly RELATION_DESCRIBED_BY?: 2;
  readonly RELATION_DESCRIPTION_FOR?: 3;
  readonly RELATION_NODE_CHILD_OF?: 4;
  readonly RELATION_NODE_PARENT_OF?: 5;
  readonly RELATION_CONTROLLED_BY?: 6;
  readonly RELATION_CONTROLLER_FOR?: 7;
  readonly RELATION_FLOWS_TO?: 8;
  readonly RELATION_FLOWS_FROM?: 9;
  readonly RELATION_MEMBER_OF?: 10;
  readonly RELATION_SUBWINDOW_OF?: 11;
  readonly RELATION_EMBEDS?: 12;
  readonly RELATION_EMBEDDED_BY?: 13;
  readonly RELATION_POPUP_FOR?: 14;
  readonly RELATION_PARENT_WINDOW_OF?: 15;
  readonly RELATION_DEFAULT_BUTTON?: 16;
  readonly RELATION_CONTAINING_DOCUMENT?: 17;
  readonly RELATION_CONTAINING_TAB_PANE?: 18;
  readonly RELATION_CONTAINING_WINDOW?: 19;
  readonly RELATION_CONTAINING_APPLICATION?: 20;
  readonly RELATION_DETAILS?: 21;
  readonly RELATION_DETAILS_FOR?: 22;
  readonly RELATION_ERRORMSG?: 23;
  readonly RELATION_ERRORMSG_FOR?: 24;
  readonly RELATION_LINKS_TO?: 25;

  readonly relationType: u32;
  readonly targetsCount: u32;
  getTarget(index: u32): nsIAccessible;
  getTargets(): nsIArray;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleRole.idl

interface nsIAccessibleRole extends nsISupports {
  readonly ROLE_NOTHING?: 0;
  readonly ROLE_MENUBAR?: 1;
  readonly ROLE_SCROLLBAR?: 2;
  readonly ROLE_ALERT?: 3;
  readonly ROLE_INTERNAL_FRAME?: 4;
  readonly ROLE_MENUPOPUP?: 5;
  readonly ROLE_MENUITEM?: 6;
  readonly ROLE_TOOLTIP?: 7;
  readonly ROLE_APPLICATION?: 8;
  readonly ROLE_DOCUMENT?: 9;
  readonly ROLE_PANE?: 10;
  readonly ROLE_DIALOG?: 11;
  readonly ROLE_GROUPING?: 12;
  readonly ROLE_SEPARATOR?: 13;
  readonly ROLE_TOOLBAR?: 14;
  readonly ROLE_STATUSBAR?: 15;
  readonly ROLE_TABLE?: 16;
  readonly ROLE_COLUMNHEADER?: 17;
  readonly ROLE_ROWHEADER?: 18;
  readonly ROLE_ROW?: 19;
  readonly ROLE_CELL?: 20;
  readonly ROLE_LINK?: 21;
  readonly ROLE_LIST?: 22;
  readonly ROLE_LISTITEM?: 23;
  readonly ROLE_OUTLINE?: 24;
  readonly ROLE_OUTLINEITEM?: 25;
  readonly ROLE_PAGETAB?: 26;
  readonly ROLE_PROPERTYPAGE?: 27;
  readonly ROLE_GRAPHIC?: 28;
  readonly ROLE_STATICTEXT?: 29;
  readonly ROLE_TEXT_LEAF?: 30;
  readonly ROLE_PUSHBUTTON?: 31;
  readonly ROLE_CHECKBUTTON?: 32;
  readonly ROLE_RADIOBUTTON?: 33;
  readonly ROLE_COMBOBOX?: 34;
  readonly ROLE_PROGRESSBAR?: 35;
  readonly ROLE_SLIDER?: 36;
  readonly ROLE_SPINBUTTON?: 37;
  readonly ROLE_DIAGRAM?: 38;
  readonly ROLE_ANIMATION?: 39;
  readonly ROLE_BUTTONDROPDOWN?: 40;
  readonly ROLE_BUTTONMENU?: 41;
  readonly ROLE_WHITESPACE?: 42;
  readonly ROLE_PAGETABLIST?: 43;
  readonly ROLE_CANVAS?: 44;
  readonly ROLE_CHECK_MENU_ITEM?: 45;
  readonly ROLE_DATE_EDITOR?: 46;
  readonly ROLE_CHROME_WINDOW?: 47;
  readonly ROLE_LABEL?: 48;
  readonly ROLE_PASSWORD_TEXT?: 49;
  readonly ROLE_RADIO_MENU_ITEM?: 50;
  readonly ROLE_TEXT_CONTAINER?: 51;
  readonly ROLE_TOGGLE_BUTTON?: 52;
  readonly ROLE_TREE_TABLE?: 53;
  readonly ROLE_PARAGRAPH?: 54;
  readonly ROLE_ENTRY?: 55;
  readonly ROLE_CAPTION?: 56;
  readonly ROLE_NON_NATIVE_DOCUMENT?: 57;
  readonly ROLE_HEADING?: 58;
  readonly ROLE_SECTION?: 59;
  readonly ROLE_FORM?: 60;
  readonly ROLE_APP_ROOT?: 61;
  readonly ROLE_PARENT_MENUITEM?: 62;
  readonly ROLE_COMBOBOX_LIST?: 63;
  readonly ROLE_COMBOBOX_OPTION?: 64;
  readonly ROLE_IMAGE_MAP?: 65;
  readonly ROLE_OPTION?: 66;
  readonly ROLE_RICH_OPTION?: 67;
  readonly ROLE_LISTBOX?: 68;
  readonly ROLE_FLAT_EQUATION?: 69;
  readonly ROLE_GRID_CELL?: 70;
  readonly ROLE_NOTE?: 71;
  readonly ROLE_FIGURE?: 72;
  readonly ROLE_CHECK_RICH_OPTION?: 73;
  readonly ROLE_DEFINITION_LIST?: 74;
  readonly ROLE_TERM?: 75;
  readonly ROLE_DEFINITION?: 76;
  readonly ROLE_KEY?: 77;
  readonly ROLE_SWITCH?: 78;
  readonly ROLE_MATHML_MATH?: 79;
  readonly ROLE_MATHML_IDENTIFIER?: 80;
  readonly ROLE_MATHML_NUMBER?: 81;
  readonly ROLE_MATHML_OPERATOR?: 82;
  readonly ROLE_MATHML_TEXT?: 83;
  readonly ROLE_MATHML_STRING_LITERAL?: 84;
  readonly ROLE_MATHML_GLYPH?: 85;
  readonly ROLE_MATHML_ROW?: 86;
  readonly ROLE_MATHML_FRACTION?: 87;
  readonly ROLE_MATHML_SQUARE_ROOT?: 88;
  readonly ROLE_MATHML_ROOT?: 89;
  readonly ROLE_MATHML_ENCLOSED?: 90;
  readonly ROLE_MATHML_STYLE?: 91;
  readonly ROLE_MATHML_SUB?: 92;
  readonly ROLE_MATHML_SUP?: 93;
  readonly ROLE_MATHML_SUB_SUP?: 94;
  readonly ROLE_MATHML_UNDER?: 95;
  readonly ROLE_MATHML_OVER?: 96;
  readonly ROLE_MATHML_UNDER_OVER?: 97;
  readonly ROLE_MATHML_MULTISCRIPTS?: 98;
  readonly ROLE_MATHML_TABLE?: 99;
  readonly ROLE_MATHML_LABELED_ROW?: 100;
  readonly ROLE_MATHML_TABLE_ROW?: 101;
  readonly ROLE_MATHML_CELL?: 102;
  readonly ROLE_MATHML_ACTION?: 103;
  readonly ROLE_MATHML_ERROR?: 104;
  readonly ROLE_MATHML_STACK?: 105;
  readonly ROLE_MATHML_LONG_DIVISION?: 106;
  readonly ROLE_MATHML_STACK_GROUP?: 107;
  readonly ROLE_MATHML_STACK_ROW?: 108;
  readonly ROLE_MATHML_STACK_CARRIES?: 109;
  readonly ROLE_MATHML_STACK_CARRY?: 110;
  readonly ROLE_MATHML_STACK_LINE?: 111;
  readonly ROLE_RADIO_GROUP?: 112;
  readonly ROLE_TEXT?: 113;
  readonly ROLE_DETAILS?: 114;
  readonly ROLE_SUMMARY?: 115;
  readonly ROLE_LANDMARK?: 116;
  readonly ROLE_NAVIGATION?: 117;
  readonly ROLE_FOOTNOTE?: 118;
  readonly ROLE_ARTICLE?: 119;
  readonly ROLE_REGION?: 120;
  readonly ROLE_EDITCOMBOBOX?: 121;
  readonly ROLE_BLOCKQUOTE?: 122;
  readonly ROLE_CONTENT_DELETION?: 123;
  readonly ROLE_CONTENT_INSERTION?: 124;
  readonly ROLE_FORM_LANDMARK?: 125;
  readonly ROLE_MARK?: 126;
  readonly ROLE_SUGGESTION?: 127;
  readonly ROLE_COMMENT?: 128;
  readonly ROLE_CODE?: 129;
  readonly ROLE_TIME_EDITOR?: 130;
  readonly ROLE_LISTITEM_MARKER?: 131;
  readonly ROLE_METER?: 132;
  readonly ROLE_SUBSCRIPT?: 133;
  readonly ROLE_SUPERSCRIPT?: 134;
  readonly ROLE_EMPHASIS?: 135;
  readonly ROLE_STRONG?: 136;
  readonly ROLE_TIME?: 137;
  readonly ROLE_GRID?: 138;
  readonly ROLE_ROWGROUP?: 139;
  readonly ROLE_SEARCHBOX?: 140;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleScrollingEvent.idl

interface nsIAccessibleScrollingEvent extends nsIAccessibleEvent {
  readonly scrollX: u32;
  readonly scrollY: u32;
  readonly maxScrollX: u32;
  readonly maxScrollY: u32;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleSelectable.idl

interface nsIAccessibleSelectable extends nsISupports {
  readonly selectedItems: nsIArray;
  readonly selectedItemCount: u32;
  getSelectedItemAt(index: u32): nsIAccessible;
  isItemSelected(index: u32): boolean;
  addItemToSelection(index: u32): void;
  removeItemFromSelection(index: u32): void;
  selectAll(): boolean;
  unselectAll(): void;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleStateChangeEvent.idl

interface nsIAccessibleStateChangeEvent extends nsIAccessibleEvent {
  readonly state: u32;
  readonly isExtraState: boolean;
  readonly isEnabled: boolean;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleStates.idl

interface nsIAccessibleStates extends nsISupports {
  readonly STATE_UNAVAILABLE?: 1;
  readonly STATE_SELECTED?: 2;
  readonly STATE_FOCUSED?: 4;
  readonly STATE_PRESSED?: 8;
  readonly STATE_CHECKED?: 16;
  readonly STATE_MIXED?: 32;
  readonly STATE_READONLY?: 64;
  readonly STATE_HOTTRACKED?: 128;
  readonly STATE_DEFAULT?: 256;
  readonly STATE_EXPANDED?: 512;
  readonly STATE_COLLAPSED?: 1024;
  readonly STATE_BUSY?: 2048;
  readonly STATE_FLOATING?: 4096;
  readonly STATE_MARQUEED?: 8192;
  readonly STATE_ANIMATED?: 16384;
  readonly STATE_INVISIBLE?: 32768;
  readonly STATE_OFFSCREEN?: 65536;
  readonly STATE_SIZEABLE?: 131072;
  readonly STATE_MOVEABLE?: 262144;
  readonly STATE_SELFVOICING?: 524288;
  readonly STATE_FOCUSABLE?: 1048576;
  readonly STATE_SELECTABLE?: 2097152;
  readonly STATE_LINKED?: 4194304;
  readonly STATE_TRAVERSED?: 8388608;
  readonly STATE_MULTISELECTABLE?: 16777216;
  readonly STATE_EXTSELECTABLE?: 33554432;
  readonly STATE_ALERT_LOW?: 67108864;
  readonly STATE_ALERT_MEDIUM?: 134217728;
  readonly STATE_ALERT_HIGH?: 268435456;
  readonly STATE_PROTECTED?: 536870912;
  readonly STATE_HASPOPUP?: 1073741824;
  readonly STATE_REQUIRED?: 67108864;
  readonly STATE_IMPORTANT?: 134217728;
  readonly STATE_INVALID?: 268435456;
  readonly STATE_CHECKABLE?: 8192;
  readonly EXT_STATE_SUPPORTS_AUTOCOMPLETION?: 1;
  readonly EXT_STATE_DEFUNCT?: 2;
  readonly EXT_STATE_SELECTABLE_TEXT?: 4;
  readonly EXT_STATE_EDITABLE?: 8;
  readonly EXT_STATE_ACTIVE?: 16;
  readonly EXT_STATE_MODAL?: 32;
  readonly EXT_STATE_MULTI_LINE?: 64;
  readonly EXT_STATE_HORIZONTAL?: 128;
  readonly EXT_STATE_OPAQUE?: 256;
  readonly EXT_STATE_SINGLE_LINE?: 512;
  readonly EXT_STATE_TRANSIENT?: 1024;
  readonly EXT_STATE_VERTICAL?: 2048;
  readonly EXT_STATE_STALE?: 4096;
  readonly EXT_STATE_ENABLED?: 8192;
  readonly EXT_STATE_SENSITIVE?: 16384;
  readonly EXT_STATE_EXPANDABLE?: 32768;
  readonly EXT_STATE_PINNED?: 65536;
  readonly EXT_STATE_CURRENT?: 131072;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleTable.idl

interface nsIAccessibleTable extends nsISupports {
  readonly caption: nsIAccessible;
  readonly summary: string;
  readonly columnCount: i32;
  readonly rowCount: i32;
  getCellAt(rowIndex: i32, columnIndex: i32): nsIAccessible;
  getCellIndexAt(rowIndex: i32, columnIndex: i32): i32;
  getColumnIndexAt(cellIndex: i32): i32;
  getRowIndexAt(cellIndex: i32): i32;
  getRowAndColumnIndicesAt(cellIndex: i32, rowIndex: OutParam<i32>, columnIndex: OutParam<i32>): void;
  getColumnExtentAt(row: i32, column: i32): i32;
  getRowExtentAt(row: i32, column: i32): i32;
  getColumnDescription(columnIndex: i32): string;
  getRowDescription(rowIndex: i32): string;
  isColumnSelected(columnIndex: i32): boolean;
  isRowSelected(rowIndex: i32): boolean;
  isCellSelected(rowIndex: i32, columnIndex: i32): boolean;
  readonly selectedCellCount: u32;
  readonly selectedColumnCount: u32;
  readonly selectedRowCount: u32;
  readonly selectedCells: nsIArray;
  getSelectedCellIndices(): u32[];
  getSelectedColumnIndices(): u32[];
  getSelectedRowIndices(): u32[];
  isProbablyForLayout(): boolean;
}

interface nsIAccessibleTableCell extends nsISupports {
  readonly table: nsIAccessibleTable;
  readonly columnIndex: i32;
  readonly rowIndex: i32;
  readonly columnExtent: i32;
  readonly rowExtent: i32;
  readonly columnHeaderCells: nsIArray;
  readonly rowHeaderCells: nsIArray;
  isSelected(): boolean;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleTableChangeEvent.idl

interface nsIAccessibleTableChangeEvent extends nsIAccessibleEvent {
  readonly rowOrColIndex: i32;
  readonly RowsOrColsCount: i32;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleText.idl

interface nsIAccessibleText extends nsISupports {
  readonly TEXT_OFFSET_END_OF_TEXT?: -1;
  readonly TEXT_OFFSET_CARET?: -2;
  readonly BOUNDARY_CHAR?: 0;
  readonly BOUNDARY_WORD_START?: 1;
  readonly BOUNDARY_WORD_END?: 2;
  readonly BOUNDARY_SENTENCE_START?: 3;
  readonly BOUNDARY_SENTENCE_END?: 4;
  readonly BOUNDARY_LINE_START?: 5;
  readonly BOUNDARY_LINE_END?: 6;
  readonly BOUNDARY_PARAGRAPH?: 7;
  readonly BOUNDARY_CLUSTER?: 8;

  caretOffset: i32;
  getCaretRect(x: OutParam<i32>, y: OutParam<i32>, width: OutParam<i32>, height: OutParam<i32>): void;
  readonly characterCount: i32;
  readonly selectionCount: i32;
  getText(startOffset: i32, endOffset: i32): string;
  getTextAfterOffset(offset: i32, boundaryType: AccessibleTextBoundary, startOffset: OutParam<i32>, endOffset: OutParam<i32>): string;
  getTextAtOffset(offset: i32, boundaryType: AccessibleTextBoundary, startOffset: OutParam<i32>, endOffset: OutParam<i32>): string;
  getTextBeforeOffset(offset: i32, boundaryType: AccessibleTextBoundary, startOffset: OutParam<i32>, endOffset: OutParam<i32>): string;
  getCharacterAtOffset(offset: i32): string;
  getTextAttributes(includeDefAttrs: boolean, offset: i32, rangeStartOffset: OutParam<i32>, rangeEndOffset: OutParam<i32>): nsIPersistentProperties;
  readonly defaultTextAttributes: nsIPersistentProperties;
  getCharacterExtents(offset: i32, x: OutParam<i32>, y: OutParam<i32>, width: OutParam<i32>, height: OutParam<i32>, coordType: u32): void;
  getRangeExtents(startOffset: i32, endOffset: i32, x: OutParam<i32>, y: OutParam<i32>, width: OutParam<i32>, height: OutParam<i32>, coordType: u32): void;
  getOffsetAtPoint(x: i32, y: i32, coordType: u32): i32;
  getSelectionBounds(selectionNum: i32, startOffset: OutParam<i32>, endOffset: OutParam<i32>): void;
  setSelectionBounds(selectionNum: i32, startOffset: i32, endOffset: i32): void;
  addSelection(startOffset: i32, endOffset: i32): void;
  removeSelection(selectionNum: i32): void;
  scrollSubstringTo(startIndex: i32, endIndex: i32, scrollType: u32): void;
  scrollSubstringToPoint(startIndex: i32, endIndex: i32, coordinateType: u32, x: i32, y: i32): void;
  readonly selectionRanges: nsIArray;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleTextChangeEvent.idl

interface nsIAccessibleTextChangeEvent extends nsIAccessibleEvent {
  readonly start: i32;
  readonly length: u32;
  readonly isInserted: boolean;
  readonly modifiedText: string;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleTextLeafRange.idl

interface nsIAccessibleTextLeafPoint extends nsISupports {
  readonly DIRECTION_NEXT?: 0;
  readonly DIRECTION_PREVIOUS?: 1;
  readonly BOUNDARY_FLAG_DEFAULT?: 0;
  readonly BOUNDARY_FLAG_INCLUDE_ORIGIN?: 1;
  readonly BOUNDARY_FLAG_STOP_IN_EDITABLE?: 2;
  readonly BOUNDARY_FLAG_SKIP_LIST_ITEM_MARKER?: 4;

  accessible: nsIAccessible;
  offset: i32;
  findBoundary(aBoundaryType: AccessibleTextBoundary, aDirection: u32, aFlags: u32): nsIAccessibleTextLeafPoint;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleTextRange.idl

interface nsIAccessibleTextRange extends nsISupports {
  readonly EndPoint_Start?: 1;
  readonly EndPoint_End?: 2;
  readonly AlignToTop?: 0;
  readonly AlignToBottom?: 1;

  readonly startContainer: nsIAccessibleText;
  readonly startOffset: i32;
  readonly endContainer: nsIAccessibleText;
  readonly endOffset: i32;
  readonly container: nsIAccessible;
  compare(aOtherRange: nsIAccessibleTextRange): boolean;
  compareEndPoints(aEndPoint: u32, aOtherRange: nsIAccessibleTextRange, aOtherRangeEndPoint: u32): i32;
  crop(aContainer: nsIAccessible): boolean;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleTextSelectionChangeEvent.idl

interface nsIAccessibleTextSelectionChangeEvent extends nsIAccessibleEvent {
  readonly selectionRanges: nsIArray;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleTypes.idl

interface nsIAccessibleScrollType extends nsISupports {
  readonly SCROLL_TYPE_TOP_LEFT?: 0;
  readonly SCROLL_TYPE_BOTTOM_RIGHT?: 1;
  readonly SCROLL_TYPE_TOP_EDGE?: 2;
  readonly SCROLL_TYPE_BOTTOM_EDGE?: 3;
  readonly SCROLL_TYPE_LEFT_EDGE?: 4;
  readonly SCROLL_TYPE_RIGHT_EDGE?: 5;
  readonly SCROLL_TYPE_ANYWHERE?: 6;
}

interface nsIAccessibleCoordinateType extends nsISupports {
  readonly COORDTYPE_SCREEN_RELATIVE?: 0;
  readonly COORDTYPE_WINDOW_RELATIVE?: 1;
  readonly COORDTYPE_PARENT_RELATIVE?: 2;
}

// https://searchfox.org/mozilla-central/source/accessible/interfaces/nsIAccessibleValue.idl

interface nsIAccessibleValue extends nsISupports {
  readonly maximumValue: double;
  readonly minimumValue: double;
  currentValue: double;
  readonly minimumIncrement: double;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/alerts/nsIAlertsService.idl

interface nsIAlertNotificationImageListener extends nsISupports {
  onImageReady(aUserData: nsISupports, aRequest: imgIRequest): void;
  onImageMissing(aUserData: nsISupports): void;
}

interface nsIAlertAction extends nsISupports {
  readonly action: string;
  readonly title: string;
  readonly iconURL: string;
  readonly windowsSystemActivationType: boolean;
  readonly opaqueRelaunchData: string;
}

interface nsIAlertNotification extends nsISupports {
  init(aName?: string, aImageURL?: string, aTitle?: string, aText?: string, aTextClickable?: boolean, aCookie?: string, aDir?: string, aLang?: string, aData?: string, aPrincipal?: nsIPrincipal, aInPrivateBrowsing?: boolean, aRequireInteraction?: boolean, aSilent?: boolean, aVibrate?: u32[]): void;
  readonly id: string;
  readonly name: string;
  readonly imageURL: string;
  readonly title: string;
  readonly text: string;
  readonly textClickable: boolean;
  readonly cookie: string;
  readonly dir: string;
  readonly lang: string;
  readonly data: string;
  readonly principal: nsIPrincipal;
  readonly URI: nsIURI;
  readonly inPrivateBrowsing: boolean;
  readonly requireInteraction: boolean;
  readonly silent: boolean;
  readonly vibrate: u32[];
  actions: nsIAlertAction[];
  readonly actionable: boolean;
  readonly source: string;
  readonly origin: string;
  opaqueRelaunchData: string;
  loadImage(aTimeout: u32, aListener: nsIAlertNotificationImageListener, aUserData?: nsISupports): nsICancelable;
  getAction(aName: string): nsIAlertAction;
}

interface nsIAlertsService extends nsISupports {
  showAlert(aAlert: nsIAlertNotification, aAlertListener?: nsIObserver): void;
  showAlertNotification(aImageURL: string, aTitle: string, aText: string, aTextClickable?: boolean, aCookie?: string, aAlertListener?: nsIObserver, aName?: string, aDir?: string, aLang?: string, aData?: string, aPrincipal?: nsIPrincipal, aInPrivateBrowsing?: boolean, aRequireInteraction?: boolean): void;
  closeAlert(aName?: string, aContextClosed?: boolean): void;
  teardown(): void;
  pbmTeardown(): void;
}

interface nsIAlertsDoNotDisturb extends nsISupports {
  manualDoNotDisturb: boolean;
  suppressForScreenSharing: boolean;
}

// https://searchfox.org/mozilla-central/source/xpfe/appshell/nsIAppShellService.idl

interface nsIAppShellService extends nsISupports {
  readonly SIZE_TO_CONTENT?: -1;

  createTopLevelWindow(aParent: nsIAppWindow, aUrl: nsIURI, aChromeMask: u32, aInitialWidth: i32, aInitialHeight: i32): nsIAppWindow;
  createWindowlessBrowser(aIsChrome?: boolean, aChromeMask?: u32): nsIWindowlessBrowser;
  readonly hiddenWindow: nsIAppWindow;
  readonly hiddenDOMWindow: mozIDOMWindowProxy;
  registerTopLevelWindow(aWindow: nsIAppWindow): void;
  unregisterTopLevelWindow(aWindow: nsIAppWindow): void;
  readonly hasHiddenWindow: boolean;
}

// https://searchfox.org/mozilla-central/source/xpfe/appshell/nsIAppWindow.idl

interface nsIAppWindow extends nsISupports {
  readonly docShell: nsIDocShell;
  intrinsicallySized: boolean;
  readonly primaryContentShell: nsIDocShellTreeItem;
  readonly primaryRemoteTab: nsIRemoteTab;
  readonly primaryContentBrowsingContext: BrowsingContext;
  remoteTabAdded(aTab: nsIRemoteTab, aPrimary: boolean): void;
  remoteTabRemoved(aTab: nsIRemoteTab): void;
  readonly outerToInnerHeightDifferenceInCSSPixels: u32;
  readonly outerToInnerWidthDifferenceInCSSPixels: u32;
  center(aRelative: nsIAppWindow, aScreen: boolean, aAlert: boolean): void;
  showModal(): void;
  lockAspectRatio(aShouldLock: boolean): void;
  chromeFlags: u32;
  assumeChromeFlagsAreFrozen(): void;
  createNewWindow(aChromeFlags: i32, aOpenWindowInfo: nsIOpenWindowInfo): nsIAppWindow;
  XULBrowserWindow: nsIXULBrowserWindow;
  readonly initialOpenWindowInfo: nsIOpenWindowInfo;
  needFastSnaphot(): void;
  rollupAllPopups(): void;
}

// https://searchfox.org/mozilla-central/source/xpfe/appshell/nsIWindowMediator.idl

interface nsIWindowMediator extends nsISupports {
  getEnumerator(aWindowType: string): nsISimpleEnumerator;
  getAppWindowEnumerator(aWindowType: string): nsISimpleEnumerator;
  getZOrderAppWindowEnumerator(aWindowType: string, aFrontToBack: boolean): nsISimpleEnumerator;
  getMostRecentWindow(aWindowType: string): mozIDOMWindowProxy;
  getMostRecentBrowserWindow(): mozIDOMWindowProxy;
  getMostRecentNonPBWindow(aWindowType: string): mozIDOMWindowProxy;
  getOuterWindowWithId(aOuterWindowID: u64): mozIDOMWindowProxy;
  getCurrentInnerWindowWithId(aInnerWindowID: u64): mozIDOMWindow;
  addListener(aListener: nsIWindowMediatorListener): void;
  removeListener(aListener: nsIWindowMediatorListener): void;
}

// https://searchfox.org/mozilla-central/source/xpfe/appshell/nsIWindowMediatorListener.idl

interface nsIWindowMediatorListener extends nsISupports {
  onOpenWindow(window: nsIAppWindow): void;
  onCloseWindow(window: nsIAppWindow): void;
}

// https://searchfox.org/mozilla-central/source/xpfe/appshell/nsIWindowlessBrowser.idl

interface nsIWindowlessBrowser extends nsIWebNavigation {
  close(): void;
  readonly docShell: nsIDocShell;
  readonly browsingContext: BrowsingContext;
}

// https://searchfox.org/mozilla-central/source/xpfe/appshell/nsIXULBrowserWindow.idl

interface nsIXULBrowserWindow extends nsISupports {
  setOverLink(link: string): void;
  showTooltip(x: i32, y: i32, tooltip: string, direction: string, browser: Element): void;
  hideTooltip(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/startup/public/nsIAppStartup.idl

}  // global

declare enum nsIAppStartup_IDLShutdownPhase {
  SHUTDOWN_PHASE_NOTINSHUTDOWN = 0,
  SHUTDOWN_PHASE_APPSHUTDOWNCONFIRMED = 1,
  SHUTDOWN_PHASE_APPSHUTDOWNNETTEARDOWN = 2,
  SHUTDOWN_PHASE_APPSHUTDOWNTEARDOWN = 3,
  SHUTDOWN_PHASE_APPSHUTDOWN = 4,
  SHUTDOWN_PHASE_APPSHUTDOWNQM = 5,
  SHUTDOWN_PHASE_APPSHUTDOWNRELEMETRY = 6,
  SHUTDOWN_PHASE_XPCOMWILLSHUTDOWN = 7,
  SHUTDOWN_PHASE_XPCOMSHUTDOWN = 8,
}

declare global {

namespace nsIAppStartup {
  type IDLShutdownPhase = nsIAppStartup_IDLShutdownPhase;
}

interface nsIAppStartup extends nsISupports, Enums<typeof nsIAppStartup_IDLShutdownPhase> {
  readonly eConsiderQuit?: 1;
  readonly eAttemptQuit?: 2;
  readonly eForceQuit?: 3;
  readonly eRestart?: 16;
  readonly eSilently?: 256;

  run(): void;
  enterLastWindowClosingSurvivalArea(): void;
  exitLastWindowClosingSurvivalArea(): void;
  readonly automaticSafeModeNecessary: boolean;
  restartInSafeMode(aQuitMode: u32): void;
  createInstanceWithProfile(aProfile: nsIToolkitProfile): void;
  trackStartupCrashBegin(): boolean;
  trackStartupCrashEnd(): void;
  quit(aMode: u32, aExitCode?: i32): boolean;
  advanceShutdownPhase(aPhase: nsIAppStartup.IDLShutdownPhase): void;
  isInOrBeyondShutdownPhase(aPhase: nsIAppStartup.IDLShutdownPhase): boolean;
  readonly shuttingDown: boolean;
  readonly startingUp: boolean;
  readonly restarting: boolean;
  readonly wasRestarted: boolean;
  readonly wasSilentlyStarted: boolean;
  readonly secondsSinceLastOSRestart: i64;
  readonly showedPreXULSkeletonUI: boolean;
  getStartupInfo(): any;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/autocomplete/nsIAutoCompleteController.idl

interface nsIAutoCompleteController extends nsISupports {
  readonly STATUS_NONE?: 1;
  readonly STATUS_SEARCHING?: 2;
  readonly STATUS_COMPLETE_NO_MATCH?: 3;
  readonly STATUS_COMPLETE_MATCH?: 4;

  input: nsIAutoCompleteInput;
  readonly searchStatus: u16;
  readonly matchCount: u32;
  startSearch(searchString: string): void;
  stopSearch(): void;
  handleText(): boolean;
  handleEnter(aIsPopupSelection: boolean, aEvent?: Event): boolean;
  handleEscape(): boolean;
  handleStartComposition(): void;
  handleEndComposition(): void;
  handleTab(): void;
  handleKeyNavigation(key: u32): boolean;
  handleDelete(): boolean;
  getValueAt(index: i32): string;
  getLabelAt(index: i32): string;
  getCommentAt(index: i32): string;
  getStyleAt(index: i32): string;
  getImageAt(index: i32): string;
  getFinalCompleteValueAt(index: i32): string;
  searchString: string;
  setInitiallySelectedIndex(index: i32): void;
  resetInternalState(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/autocomplete/nsIAutoCompleteInput.idl

interface nsIAutoCompleteInput extends nsISupports {
  readonly popupElement: Element;
  readonly popup: nsIAutoCompletePopup;
  readonly controller: nsIAutoCompleteController;
  popupOpen: boolean;
  disableAutoComplete: boolean;
  completeDefaultIndex: boolean;
  completeSelectedIndex: boolean;
  forceComplete: boolean;
  minResultsForPopup: u32;
  maxRows: u32;
  timeout: u32;
  searchParam: string;
  readonly searchCount: u32;
  getSearchAt(index: u32): string;
  textValue: string;
  readonly selectionStart: i32;
  readonly selectionEnd: i32;
  selectTextRange(startIndex: i32, endIndex: i32): void;
  onSearchBegin(): void;
  onSearchComplete(): void;
  onTextEntered(aEvent?: Event): void;
  onTextReverted(): boolean;
  readonly consumeRollupEvent: boolean;
  readonly inPrivateContext: boolean;
  readonly noRollupOnCaretMove: boolean;
  readonly noRollupOnEmptySearch: boolean;
  readonly userContextId: u32;
  readonly invalidatePreviousResult: boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/autocomplete/nsIAutoCompletePopup.idl

interface nsIAutoCompletePopup extends nsISupports {
  readonly INVALIDATE_REASON_NEW_RESULT?: 0;
  readonly INVALIDATE_REASON_DELETE?: 1;

  readonly input: nsIAutoCompleteInput;
  readonly overrideValue: string;
  selectedIndex: i32;
  readonly popupOpen: boolean;
  getNoRollupOnEmptySearch(element: Element): boolean;
  openAutocompletePopup(input: nsIAutoCompleteInput, element: Element): void;
  closePopup(): void;
  invalidate(reason: u16): void;
  selectBy(reverse: boolean, page: boolean): void;
  startSearch(searchString: string, element: Element, listener: nsIFormFillCompleteObserver): void;
  stopSearch(): void;
  selectEntry(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/autocomplete/nsIAutoCompleteResult.idl

interface nsIAutoCompleteResult extends nsISupports {
  readonly RESULT_IGNORED?: 1;
  readonly RESULT_FAILURE?: 2;
  readonly RESULT_NOMATCH?: 3;
  readonly RESULT_SUCCESS?: 4;
  readonly RESULT_NOMATCH_ONGOING?: 5;
  readonly RESULT_SUCCESS_ONGOING?: 6;

  readonly searchString: string;
  readonly searchResult: u16;
  readonly defaultIndex: i32;
  readonly errorDescription: string;
  readonly matchCount: u32;
  getValueAt(index: i32): string;
  getLabelAt(index: i32): string;
  getCommentAt(index: i32): string;
  getStyleAt(index: i32): string;
  getImageAt(index: i32): string;
  getFinalCompleteValueAt(index: i32): string;
  isRemovableAt(rowIndex: i32): boolean;
  removeValueAt(rowIndex: i32): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/autocomplete/nsIAutoCompleteSearch.idl

interface nsIAutoCompleteSearch extends nsISupports {
  startSearch(searchString: string, searchParam: string, previousResult: nsIAutoCompleteResult, listener: nsIAutoCompleteObserver): void;
  stopSearch(): void;
}

interface nsIAutoCompleteObserver extends nsISupports {
  onSearchResult(search: nsIAutoCompleteSearch, result: nsIAutoCompleteResult): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/autocomplete/nsIAutoCompleteSimpleResult.idl

interface nsIAutoCompleteSimpleResult extends nsIAutoCompleteResult {
  setSearchString(aSearchString: string): void;
  setErrorDescription(aErrorDescription: string): void;
  setDefaultIndex(aDefaultIndex: i32): void;
  setSearchResult(aSearchResult: u16): void;
  insertMatchAt(aIndex: i32, aValue: string, aComment: string, aImage?: string, aStyle?: string, aFinalCompleteValue?: string, aLabel?: string): void;
  appendMatch(aValue: string, aComment: string, aImage?: string, aStyle?: string, aFinalCompleteValue?: string, aLabel?: string): void;
  removeMatchAt(aIndex: i32): void;
  getListener(): nsIAutoCompleteSimpleResultListener;
  setListener(aListener: nsIAutoCompleteSimpleResultListener): void;
}

interface nsIAutoCompleteSimpleResultListener extends nsISupports {
  onValueRemoved(aResult: nsIAutoCompleteSimpleResult, aValue: string): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/autocomplete/nsIAutoCompleteSimpleSearch.idl

interface nsIAutoCompleteSimpleSearch extends nsIAutoCompleteSearch {
  overrideNextResult(values: nsIAutoCompleteResult): void;
}

// https://searchfox.org/mozilla-central/source/dom/media/autoplay/nsIAutoplay.idl

interface nsIAutoplay extends nsISupports {
  readonly ALLOWED?: 0;
  readonly BLOCKED?: 1;
  readonly BLOCKED_ALL?: 5;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/backgroundhangmonitor/nsIHangDetails.idl

interface nsIHangDetails extends nsISupports {
  readonly wasPersisted: boolean;
  readonly duration: double;
  readonly thread: string;
  readonly runnableName: string;
  readonly process: string;
  readonly remoteType: string;
  readonly stack: any;
  readonly modules: any;
  readonly annotations: any;
}

// https://searchfox.org/mozilla-central/source/browser/components/nsIBrowserHandler.idl

interface nsIBrowserHandler extends nsISupports {
  startPage: string;
  defaultArgs: string;
  getFirstWindowArgs(): string;
  kiosk: boolean;
  majorUpgrade: boolean;
  firstRunProfile: boolean;
  getFeatures(aCmdLine: nsICommandLine): string;
}

// https://searchfox.org/mozilla-central/source/caps/nsIAddonPolicyService.idl

interface nsIAddonPolicyService extends nsISupports {
  readonly defaultCSP: string;
  readonly defaultCSPV3: string;
  getBaseCSP(aAddonId: string): string;
  getExtensionPageCSP(aAddonId: string): string;
  getGeneratedBackgroundPageUrl(aAddonId: string): string;
  addonHasPermission(aAddonId: string, aPerm: string): boolean;
  addonMayLoadURI(aAddonId: string, aURI: nsIURI, aExplicit?: boolean): boolean;
  getExtensionName(aAddonId: string): string;
  sourceMayLoadExtensionURI(aSourceURI: nsIURI, aExtensionURI: nsIURI, aFromPrivateWindow?: boolean): boolean;
  extensionURIToAddonId(aURI: nsIURI): string;
}

interface nsIAddonContentPolicy extends nsISupports {
  readonly CSP_ALLOW_ANY?: 65535;
  readonly CSP_ALLOW_LOCALHOST?: 1;
  readonly CSP_ALLOW_EVAL?: 2;
  readonly CSP_ALLOW_REMOTE?: 4;
  readonly CSP_ALLOW_WASM?: 8;

  validateAddonCSP(aPolicyString: string, aPermittedPolicy: u32): string;
}

// https://searchfox.org/mozilla-central/source/caps/nsIDomainPolicy.idl

interface nsIDomainPolicy extends nsISupports {
  readonly blocklist: nsIDomainSet;
  readonly superBlocklist: nsIDomainSet;
  readonly allowlist: nsIDomainSet;
  readonly superAllowlist: nsIDomainSet;
  deactivate(): void;
}

interface nsIDomainSet extends nsISupports {
  add(aDomain: nsIURI): void;
  remove(aDomain: nsIURI): void;
  clear(): void;
  contains(aDomain: nsIURI): boolean;
  containsSuperDomain(aDomain: nsIURI): boolean;
}

// https://searchfox.org/mozilla-central/source/caps/nsIPrincipal.idl

interface nsIPrincipal extends nsISupports {
  equals(other: nsIPrincipal): boolean;
  equalsForPermission(other: nsIPrincipal, aExactHost: boolean): boolean;
  equalsConsideringDomain(other: nsIPrincipal): boolean;
  equalsURI(aOtherURI: nsIURI): boolean;
  readonly URI: nsIURI;
  subsumes(other: nsIPrincipal): boolean;
  subsumesConsideringDomain(other: nsIPrincipal): boolean;
  subsumesConsideringDomainIgnoringFPD(other: nsIPrincipal): boolean;
  checkMayLoad(uri: nsIURI, allowIfInheritsPrincipal: boolean): void;
  checkMayLoadWithReporting(uri: nsIURI, allowIfInheritsPrincipal: boolean, innerWindowID: u64): void;
  isThirdPartyURI(uri: nsIURI): boolean;
  isThirdPartyPrincipal(principal: nsIPrincipal): boolean;
  isThirdPartyChannel(channel: nsIChannel): boolean;
  readonly originAttributes: any;
  readonly origin: string;
  readonly hostPort: string;
  readonly asciiHost: string;
  readonly host: string;
  readonly prePath: string;
  readonly filePath: string;
  readonly asciiSpec: string;
  readonly spec: string;
  readonly exposablePrePath: string;
  readonly exposableSpec: string;
  readonly scheme: string;
  schemeIs(scheme: string): boolean;
  isURIInPrefList(pref: string): boolean;
  isURIInList(list: string): boolean;
  isContentAccessibleAboutURI(): boolean;
  isSameOrigin(otherURI: nsIURI): boolean;
  hasFirstpartyStorageAccess(aWindow: mozIDOMWindow, rejectedReason: OutParam<u32>): boolean;
  readonly localStorageQuotaKey: string;
  readonly isOriginPotentiallyTrustworthy: boolean;
  readonly isLoopbackHost: boolean;
  getAboutModuleFlags(): u32;
  readonly storageOriginKey: string;
  readonly originNoSuffix: string;
  readonly originSuffix: string;
  readonly siteOrigin: string;
  readonly siteOriginNoSuffix: string;
  readonly baseDomain: string;
  readonly addonId: string;
  readonly addonPolicy: WebExtensionPolicy;
  readonly contentScriptAddonPolicy: WebExtensionPolicy;
  readonly userContextId: u32;
  readonly privateBrowsingId: u32;
  readonly isInPrivateBrowsing: boolean;
  readonly isNullPrincipal: boolean;
  readonly isContentPrincipal: boolean;
  readonly isExpandedPrincipal: boolean;
  readonly isSystemPrincipal: boolean;
  readonly isAddonOrExpandedAddonPrincipal: boolean;
  readonly isOnion: boolean;
  readonly isScriptAllowedByPolicy: boolean;
  isL10nAllowed(aDocumentURI: nsIURI): boolean;
  readonly nextSubDomainPrincipal: nsIPrincipal;
  readonly isIpAddress: boolean;
  readonly isLocalIpAddress: boolean;
  readonly precursorPrincipal: nsIPrincipal;
}

// https://searchfox.org/mozilla-central/source/caps/nsIScriptSecurityManager.idl

interface nsIScriptSecurityManager extends nsISupports {
  readonly STANDARD?: 0;
  readonly LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT?: 1;
  readonly ALLOW_CHROME?: 2;
  readonly DISALLOW_INHERIT_PRINCIPAL?: 4;
  readonly DISALLOW_SCRIPT_OR_DATA?: 4;
  readonly DISALLOW_SCRIPT?: 8;
  readonly DONT_REPORT_ERRORS?: 16;
  readonly DEFAULT_USER_CONTEXT_ID?: 0;
  readonly DEFAULT_PRIVATE_BROWSING_ID?: 0;

  checkLoadURIWithPrincipalXPCOM(aPrincipal: nsIPrincipal, uri: nsIURI, flags: u32, innerWindowID?: u64): void;
  checkLoadURIWithPrincipal(aPrincipal: nsIPrincipal, uri: nsIURI, flags?: u32, innerWindowID?: u64): void;
  checkLoadURIStrWithPrincipalXPCOM(aPrincipal: nsIPrincipal, uri: string, flags: u32): void;
  checkLoadURIStrWithPrincipal(aPrincipal: nsIPrincipal, uri: string, flags?: u32): void;
  inFileURIAllowlist(aUri: nsIURI): boolean;
  getSystemPrincipal(): nsIPrincipal;
  getLoadContextContentPrincipal(uri: nsIURI, loadContext: nsILoadContext): nsIPrincipal;
  getDocShellContentPrincipal(uri: nsIURI, docShell: nsIDocShell): nsIPrincipal;
  principalWithOA(principal: nsIPrincipal, originAttributes: any): nsIPrincipal;
  createContentPrincipal(uri: nsIURI, originAttributes: any): nsIPrincipal;
  createContentPrincipalFromOrigin(origin: string): nsIPrincipal;
  principalToJSON(principal: nsIPrincipal): string;
  JSONToPrincipal(json: string): nsIPrincipal;
  createNullPrincipal(originAttributes: any): nsIPrincipal;
  checkSameOriginURI(aSourceURI: nsIURI, aTargetURI: nsIURI, reportError: boolean, fromPrivateWindow: boolean): void;
  getChannelResultPrincipal(aChannel: nsIChannel): nsIPrincipal;
  getChannelResultStoragePrincipal(aChannel: nsIChannel): nsIPrincipal;
  getChannelResultPrincipals(aChannel: nsIChannel, aPrincipal: OutParam<nsIPrincipal>, aPartitionedPrincipal: OutParam<nsIPrincipal>): void;
  getChannelURIPrincipal(aChannel: nsIChannel): nsIPrincipal;
  activateDomainPolicy(): nsIDomainPolicy;
  readonly domainPolicyActive: boolean;
  policyAllowsScript(aDomain: nsIURI): boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/captivedetect/nsICaptivePortalDetector.idl

interface nsICaptivePortalCallback extends nsISupports {
  prepare(): void;
  complete(success: boolean): void;
}

interface nsICaptivePortalDetector extends nsISupports {
  checkCaptivePortal(ifname: string, callback: nsICaptivePortalCallback): void;
  abort(ifname: string): void;
  cancelLogin(eventId: string): void;
  finishPreparation(ifname: string): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/cascade_bloom_filter/nsICascadeFilter.idl

interface nsICascadeFilter extends nsISupports {
  setFilterData(data: u8[]): void;
  has(key: string): boolean;
}

// https://searchfox.org/mozilla-central/source/chrome/nsIChromeRegistry.idl

interface nsIChromeRegistry extends nsISupports {
  readonly NONE?: 0;
  readonly PARTIAL?: 1;
  readonly FULL?: 2;

  convertChromeURL(aChromeURL: nsIURI): nsIURI;
  checkForNewChrome(): void;
}

interface nsIXULChromeRegistry extends nsIChromeRegistry {
  isLocaleRTL(package: string): boolean;
  allowScriptsForPackage(url: nsIURI): boolean;
  allowContentToAccess(url: nsIURI): boolean;
  canLoadURLRemotely(url: nsIURI): boolean;
  mustLoadURLRemotely(url: nsIURI): boolean;
}

// https://searchfox.org/mozilla-central/source/chrome/nsIToolkitChromeRegistry.idl

interface nsIToolkitChromeRegistry extends nsIXULChromeRegistry {
  getLocalesForPackage(aPackage: string): nsIUTF8StringEnumerator;
}

// https://searchfox.org/mozilla-central/source/dom/commandhandler/nsICommandManager.idl

interface nsICommandManager extends nsISupports {
  addCommandObserver(aCommandObserver: nsIObserver, aCommandToObserve: string): void;
  removeCommandObserver(aCommandObserver: nsIObserver, aCommandObserved: string): void;
  isCommandSupported(aCommandName: string, aTargetWindow: mozIDOMWindowProxy): boolean;
  isCommandEnabled(aCommandName: string, aTargetWindow: mozIDOMWindowProxy): boolean;
  getCommandState(aCommandName: string, aTargetWindow: mozIDOMWindowProxy, aCommandParams: nsICommandParams): void;
  doCommand(aCommandName: string, aCommandParams: nsICommandParams, aTargetWindow: mozIDOMWindowProxy): void;
}

// https://searchfox.org/mozilla-central/source/dom/commandhandler/nsICommandParams.idl

interface nsICommandParams extends nsISupports {
  readonly eNoType?: 0;
  readonly eBooleanType?: 1;
  readonly eLongType?: 2;
  readonly eDoubleType?: 3;
  readonly eWStringType?: 4;
  readonly eISupportsType?: 5;
  readonly eStringType?: 6;

  getValueType(name: string): i16;
  getBooleanValue(name: string): boolean;
  getLongValue(name: string): i32;
  getDoubleValue(name: string): double;
  getStringValue(name: string): string;
  getCStringValue(name: string): string;
  getISupportsValue(name: string): nsISupports;
  setBooleanValue(name: string, value: boolean): void;
  setLongValue(name: string, value: i32): void;
  setDoubleValue(name: string, value: double): void;
  setStringValue(name: string, value: string): void;
  setCStringValue(name: string, value: string): void;
  setISupportsValue(name: string, value: nsISupports): void;
  removeValue(name: string): void;
}

// https://searchfox.org/mozilla-central/source/dom/commandhandler/nsIControllerCommand.idl

interface nsIControllerCommand extends nsISupports {
  isCommandEnabled(aCommandName: string, aCommandContext: nsISupports): boolean;
  getCommandStateParams(aCommandName: string, aParams: nsICommandParams, aCommandContext: nsISupports): void;
  doCommand(aCommandName: string, aCommandContext: nsISupports): void;
  doCommandParams(aCommandName: string, aParams: nsICommandParams, aCommandContext: nsISupports): void;
}

// https://searchfox.org/mozilla-central/source/dom/commandhandler/nsIControllerCommandTable.idl

interface nsIControllerCommandTable extends nsISupports {
  makeImmutable(): void;
  registerCommand(aCommandName: string, aCommand: nsIControllerCommand): void;
  unregisterCommand(aCommandName: string, aCommand: nsIControllerCommand): void;
  findCommandHandler(aCommandName: string): nsIControllerCommand;
  isCommandEnabled(aCommandName: string, aCommandRefCon: nsISupports): boolean;
  updateCommandState(aCommandName: string, aCommandRefCon: nsISupports): void;
  supportsCommand(aCommandName: string, aCommandRefCon: nsISupports): boolean;
  doCommand(aCommandName: string, aCommandRefCon: nsISupports): void;
  doCommandParams(aCommandName: string, aParam: nsICommandParams, aCommandRefCon: nsISupports): void;
  getCommandState(aCommandName: string, aParam: nsICommandParams, aCommandRefCon: nsISupports): void;
  getSupportedCommands(): string[];
}

// https://searchfox.org/mozilla-central/source/dom/commandhandler/nsIControllerContext.idl

interface nsIControllerContext extends nsISupports {
  setCommandContext(aCommandContext: nsISupports): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/commandlines/nsICommandLine.idl

interface nsICommandLine extends nsISupports {
  readonly STATE_INITIAL_LAUNCH?: 0;
  readonly STATE_REMOTE_AUTO?: 1;
  readonly STATE_REMOTE_EXPLICIT?: 2;

  readonly length: i32;
  getArgument(aIndex: i32): string;
  findFlag(aFlag: string, aCaseSensitive: boolean): i32;
  removeArguments(aStart: i32, aEnd: i32): void;
  handleFlag(aFlag: string, aCaseSensitive: boolean): boolean;
  handleFlagWithParam(aFlag: string, aCaseSensitive: boolean): string;
  readonly state: u32;
  preventDefault: boolean;
  readonly workingDirectory: nsIFile;
  resolveFile(aArgument: string): nsIFile;
  resolveURI(aArgument: string): nsIURI;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/commandlines/nsICommandLineHandler.idl

interface nsICommandLineHandler extends nsISupports {
  handle(aCommandLine: nsICommandLine): void;
  readonly helpInfo: string;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/commandlines/nsICommandLineRunner.idl

// https://searchfox.org/mozilla-central/source/toolkit/components/commandlines/nsICommandLineValidator.idl

interface nsICommandLineValidator extends nsISupports {
  validate(aCommandLine: nsICommandLine): void;
}

// https://searchfox.org/mozilla-central/source/editor/composer/nsIEditingSession.idl

interface nsIEditingSession extends nsISupports {
  readonly eEditorOK?: 0;
  readonly eEditorCreationInProgress?: 1;
  readonly eEditorErrorCantEditMimeType?: 2;
  readonly eEditorErrorFileNotFound?: 3;
  readonly eEditorErrorCantEditFramesets?: 8;
  readonly eEditorErrorUnknown?: 9;

  readonly editorStatus: u32;
  makeWindowEditable(window: mozIDOMWindowProxy, aEditorType: string, doAfterUriLoad: boolean, aMakeWholeDocumentEditable: boolean, aInteractive: boolean): void;
  windowIsEditable(window: mozIDOMWindowProxy): boolean;
  getEditorForWindow(window: mozIDOMWindowProxy): nsIEditor;
}

// https://searchfox.org/mozilla-central/source/dom/events/nsIEventListenerService.idl

interface nsIEventListenerChange extends nsISupports {
  readonly target: EventTarget;
}

type nsIListenerChangeListener = Callable<{
  listenersChanged(aEventListenerChanges: nsIArray): void;
}>

interface nsIEventListenerInfo extends nsISupports {
  readonly type: string;
  readonly capturing: boolean;
  readonly allowsUntrusted: boolean;
  readonly inSystemEventGroup: boolean;
  enabled: boolean;
  readonly listenerObject: any;
  toSource(): string;
}

interface nsIEventListenerService extends nsISupports {
  getListenerInfoFor(aEventTarget: EventTarget): nsIEventListenerInfo[];
  hasListenersFor(aEventTarget: EventTarget, aType: string): boolean;
  addListenerForAllEvents(target: EventTarget, listener: any, aUseCapture?: boolean, aWantsUntrusted?: boolean, aSystemEventGroup?: boolean): void;
  removeListenerForAllEvents(target: EventTarget, listener: any, aUseCapture?: boolean, aSystemEventGroup?: boolean): void;
  addListenerChangeListener(aListener: nsIListenerChangeListener): void;
  removeListenerChangeListener(aListener: nsIListenerChangeListener): void;
}

// https://searchfox.org/mozilla-central/source/dom/media/gmp/mozIGeckoMediaPluginChromeService.idl

interface mozIGeckoMediaPluginChromeService extends nsISupports {
  addPluginDirectory(directory: string): void;
  removePluginDirectory(directory: string): void;
  removeAndDeletePluginDirectory(directory: string, defer?: boolean): void;
  forgetThisSite(site: string, aPattern: string): void;
  forgetThisBaseDomain(baseDomain: string): void;
  isPersistentStorageAllowed(nodeId: string): boolean;
  getStorageDir(): nsIFile;
}

// https://searchfox.org/mozilla-central/source/dom/media/gmp/mozIGeckoMediaPluginService.idl

interface mozIGeckoMediaPluginService extends nsISupports {
  readonly thread: nsIThread;
  RunPluginCrashCallbacks(pluginId: u32, pluginName: string): void;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsIDocShell.idl

}  // global

declare enum nsIDocShell_DocShellEnumeratorDirection {
  ENUMERATE_FORWARDS = 0,
  ENUMERATE_BACKWARDS = 1,
}

declare enum nsIDocShell_AppType {
  APP_TYPE_UNKNOWN = 0,
  APP_TYPE_MAIL = 1,
  APP_TYPE_EDITOR = 2,
}

declare enum nsIDocShell_BusyFlags {
  BUSY_FLAGS_NONE = 0,
  BUSY_FLAGS_BUSY = 1,
  BUSY_FLAGS_BEFORE_PAGE_LOAD = 2,
  BUSY_FLAGS_PAGE_LOADING = 4,
}

declare enum nsIDocShell_LoadCommand {
  LOAD_CMD_NORMAL = 1,
  LOAD_CMD_RELOAD = 2,
  LOAD_CMD_HISTORY = 4,
  LOAD_CMD_PUSHSTATE = 8,
}

declare global {

namespace nsIDocShell {
  type DocShellEnumeratorDirection = nsIDocShell_DocShellEnumeratorDirection;
  type AppType = nsIDocShell_AppType;
  type BusyFlags = nsIDocShell_BusyFlags;
  type LoadCommand = nsIDocShell_LoadCommand;
}

interface nsIDocShell extends nsIDocShellTreeItem, Enums<typeof nsIDocShell_DocShellEnumeratorDirection & typeof nsIDocShell_AppType & typeof nsIDocShell_BusyFlags & typeof nsIDocShell_LoadCommand> {
  setCancelContentJSEpoch(aEpoch: i32): void;
  addState(aData: any, aTitle: string, aURL: string, aReplace: boolean): void;
  prepareForNewContentModel(): void;
  setCurrentURIForSessionStore(aURI: nsIURI): void;
  readonly docViewer: nsIDocumentViewer;
  readonly outerWindowID: u64;
  chromeEventHandler: EventTarget;
  customUserAgent: string;
  cssErrorReportingEnabled: boolean;
  allowMetaRedirects: boolean;
  allowSubframes: boolean;
  allowImages: boolean;
  allowMedia: boolean;
  allowDNSPrefetch: boolean;
  allowWindowControl: boolean;
  allowContentRetargeting: boolean;
  allowContentRetargetingOnChildren: boolean;
  getAllDocShellsInSubtree(aItemType: i32, aDirection: nsIDocShell.DocShellEnumeratorDirection): nsIDocShell[];
  appType: nsIDocShell.AppType;
  allowAuth: boolean;
  zoom: float;
  readonly busyFlags: nsIDocShell.BusyFlags;
  loadType: u32;
  defaultLoadFlags: nsLoadFlags;
  isBeingDestroyed(): boolean;
  readonly isExecutingOnLoadHandler: boolean;
  layoutHistoryState: nsILayoutHistoryState;
  readonly loadURIDelegate: nsILoadURIDelegate;
  suspendRefreshURIs(): void;
  resumeRefreshURIs(): void;
  beginRestore(viewer: nsIDocumentViewer, top: boolean): void;
  finishRestore(): void;
  clearCachedUserAgent(): void;
  clearCachedPlatform(): void;
  readonly restoringDocument: boolean;
  useErrorPages: boolean;
  displayLoadError(aError: nsresult, aURI: nsIURI, aURL: string, aFailedChannel?: nsIChannel): boolean;
  readonly failedChannel: nsIChannel;
  readonly previousEntryIndex: i32;
  readonly loadedEntryIndex: i32;
  historyPurged(numEntries: i32): void;
  readonly currentDocumentChannel: nsIChannel;
  readonly isInUnload: boolean;
  exitPrintPreview(): void;
  readonly historyID: nsID;
  createAboutBlankDocumentViewer(aPrincipal: nsIPrincipal, aPartitionedPrincipal: nsIPrincipal, aCSP?: nsIContentSecurityPolicy): void;
  readonly charset: string;
  forceEncodingDetection(): void;
  now(): DOMHighResTimeStamp;
  addWeakPrivacyTransitionObserver(obs: nsIPrivacyTransitionObserver): void;
  addWeakReflowObserver(obs: nsIReflowObserver): void;
  removeWeakReflowObserver(obs: nsIReflowObserver): void;
  readonly isTopLevelContentDocShell: boolean;
  readonly asyncPanZoomEnabled: boolean;
  readonly mayEnableCharacterEncodingMenu: boolean;
  editor: nsIEditor;
  readonly editable: boolean;
  readonly hasEditingSession: boolean;
  makeEditable(inWaitForUriLoad: boolean): void;
  getCurrentSHEntry(aEntry: OutParam<nsISHEntry>): boolean;
  isCommandEnabled(command: string): boolean;
  doCommand(command: string): void;
  doCommandWithParams(command: string, aParams: nsICommandParams): void;
  readonly hasLoadedNonBlankURI: boolean;
  windowDraggingAllowed: boolean;
  currentScrollRestorationIsManual: boolean;
  getOriginAttributes(): any;
  setOriginAttributes(aAttrs: any): void;
  readonly editingSession: nsIEditingSession;
  readonly browserChild: nsIBrowserChild;
  useTrackingProtection: boolean;
  setColorMatrix(aMatrix: float[]): void;
  readonly isForceReloading: boolean;
  getColorMatrix(): float[];
  readonly messageManager: ContentFrameMessageManager;
  getHasTrackingContentBlocked(): Promise<any>;
  readonly isNavigating: boolean;
  synchronizeLayoutHistoryState(): void;
  persistLayoutHistoryState(): void;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsIDocShellTreeItem.idl

interface nsIDocShellTreeItem extends nsISupports {
  readonly typeChrome?: 0;
  readonly typeContent?: 1;
  readonly typeContentWrapper?: 2;
  readonly typeChromeWrapper?: 3;
  readonly typeAll?: 2147483647;

  name: string;
  nameEquals(name: string): boolean;
  readonly itemType: i32;
  readonly parent: nsIDocShellTreeItem;
  readonly sameTypeParent: nsIDocShellTreeItem;
  readonly rootTreeItem: nsIDocShellTreeItem;
  readonly sameTypeRootTreeItem: nsIDocShellTreeItem;
  readonly treeOwner: nsIDocShellTreeOwner;
  readonly childCount: i32;
  getChildAt(index: i32): nsIDocShellTreeItem;
  readonly browsingContext: BrowsingContext;
  readonly domWindow: mozIDOMWindowProxy;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsIDocShellTreeOwner.idl

interface nsIDocShellTreeOwner extends nsISupports {
  contentShellAdded(aContentShell: nsIDocShellTreeItem, aPrimary: boolean): void;
  contentShellRemoved(aContentShell: nsIDocShellTreeItem): void;
  readonly primaryContentShell: nsIDocShellTreeItem;
  remoteTabAdded(aTab: nsIRemoteTab, aPrimary: boolean): void;
  remoteTabRemoved(aTab: nsIRemoteTab): void;
  readonly primaryRemoteTab: nsIRemoteTab;
  readonly primaryContentBrowsingContext: BrowsingContext;
  sizeShellTo(shell: nsIDocShellTreeItem, cx: i32, cy: i32): void;
  getPrimaryContentSize(width: OutParam<i32>, height: OutParam<i32>): void;
  setPrimaryContentSize(width: i32, height: i32): void;
  getRootShellSize(width: OutParam<i32>, height: OutParam<i32>): void;
  setRootShellSize(width: i32, height: i32): void;
  setPersistence(aPersistPosition: boolean, aPersistSize: boolean, aPersistSizeMode: boolean): void;
  getPersistence(aPersistPosition: OutParam<boolean>, aPersistSize: OutParam<boolean>, aPersistSizeMode: OutParam<boolean>): void;
  readonly hasPrimaryContent: boolean;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsIDocumentLoaderFactory.idl

interface nsIDocumentLoaderFactory extends nsISupports {
  createInstance(aCommand: string, aChannel: nsIChannel, aLoadGroup: nsILoadGroup, aContentType: string, aContainer: nsIDocShell, aExtraInfo: nsISupports, aDocListenerResult: OutParam<nsIStreamListener>): nsIDocumentViewer;
  createInstanceForDocument(aContainer: nsISupports, aDocument: Document, aCommand: string): nsIDocumentViewer;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsIDocumentViewer.idl

}  // global

declare enum nsIDocumentViewer_PermitUnloadAction {
  ePrompt = 0,
  eDontPromptAndDontUnload = 1,
  eDontPromptAndUnload = 2,
}

declare enum nsIDocumentViewer_PermitUnloadResult {
  eAllowNavigation = 0,
  eRequestBlockNavigation = 1,
}

declare global {

namespace nsIDocumentViewer {
  type PermitUnloadAction = nsIDocumentViewer_PermitUnloadAction;
  type PermitUnloadResult = nsIDocumentViewer_PermitUnloadResult;
}

interface nsIDocumentViewer extends nsISupports, Enums<typeof nsIDocumentViewer_PermitUnloadAction & typeof nsIDocumentViewer_PermitUnloadResult> {
  readonly eDelayResize?: 1;

  container: nsIDocShell;
  loadComplete(aStatus: nsresult): void;
  permitUnload(aAction?: nsIDocumentViewer.PermitUnloadAction): boolean;
  readonly inPermitUnload: boolean;
  readonly beforeUnloadFiring: boolean;
  pageHide(isUnload: boolean): void;
  close(historyEntry: nsISHEntry): void;
  destroy(): void;
  stop(): void;
  readonly DOMDocument: Document;
  move(aX: i32, aY: i32): void;
  show(): void;
  hide(): void;
  sticky: boolean;
  open(aState: nsISupports, aSHEntry: nsISHEntry): void;
  clearHistoryEntry(): void;
  setPageModeForTesting(aPageMode: boolean, aPrintSettings: nsIPrintSettings): void;
  readonly historyEntry: nsISHEntry;
  readonly isTabModalPromptAllowed: boolean;
  isHidden: boolean;
  readonly deviceFullZoomForTest: float;
  authorStyleDisabled: boolean;
  getContentSize(maxWidth: i32, maxHeight: i32, prefWidth: i32, width: OutParam<i32>, height: OutParam<i32>): void;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsIDocumentViewerEdit.idl

interface nsIDocumentViewerEdit extends nsISupports {
  readonly COPY_IMAGE_TEXT?: 1;
  readonly COPY_IMAGE_HTML?: 2;
  readonly COPY_IMAGE_DATA?: 4;
  readonly COPY_IMAGE_ALL?: -1;

  clearSelection(): void;
  selectAll(): void;
  copySelection(): void;
  readonly copyable: boolean;
  copyLinkLocation(): void;
  readonly inLink: boolean;
  copyImage(aCopyFlags: i32): void;
  readonly inImage: boolean;
  getContents(aMimeType: string, aSelectionOnly: boolean): string;
  readonly canGetContents: boolean;
  setCommandNode(aNode: Node): void;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsILoadContext.idl

interface nsILoadContext extends nsISupports {
  readonly associatedWindow: mozIDOMWindowProxy;
  readonly topWindow: mozIDOMWindowProxy;
  readonly topFrameElement: Element;
  readonly isContent: boolean;
  usePrivateBrowsing: boolean;
  readonly useRemoteTabs: boolean;
  readonly useRemoteSubframes: boolean;
  useTrackingProtection: boolean;
  readonly originAttributes: any;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsILoadURIDelegate.idl

interface nsILoadURIDelegate extends nsISupports {
  handleLoadError(aURI: nsIURI, aError: nsresult, aErrorModule: i16): nsIURI;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsIPrivacyTransitionObserver.idl

type nsIPrivacyTransitionObserver = Callable<{
  privateModeChanged(enabled: boolean): void;
}>

// https://searchfox.org/mozilla-central/source/docshell/base/nsIReflowObserver.idl

interface nsIReflowObserver extends nsISupports {
  reflow(start: DOMHighResTimeStamp, end: DOMHighResTimeStamp): void;
  reflowInterruptible(start: DOMHighResTimeStamp, end: DOMHighResTimeStamp): void;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsIRefreshURI.idl

interface nsIRefreshURI extends nsISupports {
  refreshURI(aURI: nsIURI, aPrincipal: nsIPrincipal, aMillis: u32): void;
  forceRefreshURI(aURI: nsIURI, aPrincipal: nsIPrincipal, aMillis: u32): void;
  cancelRefreshURITimers(): void;
  readonly refreshPending: boolean;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsITooltipListener.idl

interface nsITooltipListener extends nsISupports {
  onShowTooltip(aXCoords: i32, aYCoords: i32, aTipText: string, aTipDir: string): void;
  onHideTooltip(): void;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsITooltipTextProvider.idl

interface nsITooltipTextProvider extends nsISupports {
  getNodeText(aNode: Node, aText: OutParam<string>, aDirection: OutParam<string>): boolean;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsIURIFixup.idl

interface nsIURIFixupInfo extends nsISupports {
  consumer: BrowsingContext;
  preferredURI: nsIURI;
  fixedURI: nsIURI;
  keywordProviderName: string;
  keywordAsSent: string;
  schemelessInput: nsILoadInfo.SchemelessInputType;
  fixupChangedProtocol: boolean;
  fixupCreatedAlternateURI: boolean;
  originalInput: string;
  postData: nsIInputStream;
}

interface nsIURIFixup extends nsISupports {
  readonly FIXUP_FLAG_NONE?: 0;
  readonly FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP?: 1;
  readonly FIXUP_FLAGS_MAKE_ALTERNATE_URI?: 2;
  readonly FIXUP_FLAG_PRIVATE_CONTEXT?: 4;
  readonly FIXUP_FLAG_FIX_SCHEME_TYPOS?: 8;

  getFixupURIInfo(aURIText: string, aFixupFlags?: u32): nsIURIFixupInfo;
  webNavigationFlagsToFixupFlags(aURIText: string, aDocShellFlags: u32): u32;
  keywordToURI(aKeyword: string, aIsPrivateContext?: boolean): nsIURIFixupInfo;
  forceHttpFixup(aUriString: string): nsIURIFixupInfo;
  checkHost(aURI: nsIURI, aListener: nsIDNSListener, aOriginAttributes?: any): void;
  isDomainKnown(aDomain: string): boolean;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsIWebNavigation.idl

interface nsIWebNavigation extends nsISupports {
  readonly LOAD_FLAGS_MASK?: 65535;
  readonly LOAD_FLAGS_NONE?: 0;
  readonly LOAD_FLAGS_IS_REFRESH?: 16;
  readonly LOAD_FLAGS_IS_LINK?: 32;
  readonly LOAD_FLAGS_BYPASS_HISTORY?: 64;
  readonly LOAD_FLAGS_REPLACE_HISTORY?: 128;
  readonly LOAD_FLAGS_BYPASS_CACHE?: 256;
  readonly LOAD_FLAGS_BYPASS_PROXY?: 512;
  readonly LOAD_FLAGS_CHARSET_CHANGE?: 1024;
  readonly LOAD_FLAGS_STOP_CONTENT?: 2048;
  readonly LOAD_FLAGS_FROM_EXTERNAL?: 4096;
  readonly LOAD_FLAGS_FIRST_LOAD?: 16384;
  readonly LOAD_FLAGS_ALLOW_POPUPS?: 32768;
  readonly LOAD_FLAGS_BYPASS_CLASSIFIER?: 65536;
  readonly LOAD_FLAGS_FORCE_ALLOW_COOKIES?: 131072;
  readonly LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL?: 262144;
  readonly LOAD_FLAGS_ERROR_LOAD_CHANGES_RV?: 524288;
  readonly LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP?: 1048576;
  readonly LOAD_FLAGS_FIXUP_SCHEME_TYPOS?: 2097152;
  readonly LOAD_FLAGS_FORCE_ALLOW_DATA_URI?: 4194304;
  readonly LOAD_FLAGS_IS_REDIRECT?: 8388608;
  readonly LOAD_FLAGS_DISABLE_TRR?: 16777216;
  readonly LOAD_FLAGS_FORCE_TRR?: 33554432;
  readonly LOAD_FLAGS_BYPASS_LOAD_URI_DELEGATE?: 67108864;
  readonly LOAD_FLAGS_USER_ACTIVATION?: 134217728;
  readonly STOP_NETWORK?: 1;
  readonly STOP_CONTENT?: 2;
  readonly STOP_ALL?: 3;

  readonly canGoBack: boolean;
  readonly canGoBackIgnoringUserInteraction: boolean;
  readonly canGoForward: boolean;
  goBack(aRequireUserInteraction?: boolean, aUserActivation?: boolean): void;
  goForward(aRequireUserInteraction?: boolean, aUserActivation?: boolean): void;
  gotoIndex(index: i32, aUserActivation?: boolean): void;
  loadURI(aURI: nsIURI, aLoadURIOptions: any): void;
  fixupAndLoadURIString(aURIString: string, aLoadURIOptions: any): void;
  reload(aReloadFlags: u32): void;
  stop(aStopFlags: u32): void;
  readonly document: Document;
  readonly currentURI: nsIURI;
  readonly sessionHistory: nsISupports;
  resumeRedirectedLoad(aLoadIdentifier: u64, aHistoryIndex: i32): void;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsIWebNavigationInfo.idl

interface nsIWebNavigationInfo extends nsISupports {
  readonly UNSUPPORTED?: 0;
  readonly IMAGE?: 1;
  readonly FALLBACK?: 2;
  readonly OTHER?: 32768;

  isTypeSupported(aType: string): u32;
}

// https://searchfox.org/mozilla-central/source/docshell/base/nsIWebPageDescriptor.idl

interface nsIWebPageDescriptor extends nsISupports {
  loadPageAsViewSource(otherDocShell: nsIDocShell, aURL: string): void;
  readonly currentDescriptor: nsISupports;
}

// https://searchfox.org/mozilla-central/source/dom/base/mozIDOMWindow.idl

interface mozIDOMWindow extends nsISupports {
}

interface mozIDOMWindowProxy extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/dom/base/nsIContentPolicy.idl

}  // global

declare enum nsIContentPolicy_nsContentPolicyType {
  TYPE_INVALID = 0,
  TYPE_OTHER = 1,
  TYPE_SCRIPT = 2,
  TYPE_IMAGE = 3,
  TYPE_STYLESHEET = 4,
  TYPE_OBJECT = 5,
  TYPE_DOCUMENT = 6,
  TYPE_SUBDOCUMENT = 7,
  TYPE_PING = 10,
  TYPE_XMLHTTPREQUEST = 11,
  TYPE_DTD = 13,
  TYPE_FONT = 14,
  TYPE_MEDIA = 15,
  TYPE_WEBSOCKET = 16,
  TYPE_CSP_REPORT = 17,
  TYPE_XSLT = 18,
  TYPE_BEACON = 19,
  TYPE_FETCH = 20,
  TYPE_IMAGESET = 21,
  TYPE_WEB_MANIFEST = 22,
  TYPE_INTERNAL_SCRIPT = 23,
  TYPE_INTERNAL_WORKER = 24,
  TYPE_INTERNAL_SHARED_WORKER = 25,
  TYPE_INTERNAL_EMBED = 26,
  TYPE_INTERNAL_OBJECT = 27,
  TYPE_INTERNAL_FRAME = 28,
  TYPE_INTERNAL_IFRAME = 29,
  TYPE_INTERNAL_AUDIO = 30,
  TYPE_INTERNAL_VIDEO = 31,
  TYPE_INTERNAL_TRACK = 32,
  TYPE_INTERNAL_XMLHTTPREQUEST_ASYNC = 33,
  TYPE_INTERNAL_EVENTSOURCE = 34,
  TYPE_INTERNAL_SERVICE_WORKER = 35,
  TYPE_INTERNAL_SCRIPT_PRELOAD = 36,
  TYPE_INTERNAL_IMAGE = 37,
  TYPE_INTERNAL_IMAGE_PRELOAD = 38,
  TYPE_INTERNAL_STYLESHEET = 39,
  TYPE_INTERNAL_STYLESHEET_PRELOAD = 40,
  TYPE_INTERNAL_IMAGE_FAVICON = 41,
  TYPE_INTERNAL_WORKER_IMPORT_SCRIPTS = 42,
  TYPE_SAVEAS_DOWNLOAD = 43,
  TYPE_SPECULATIVE = 44,
  TYPE_INTERNAL_MODULE = 45,
  TYPE_INTERNAL_MODULE_PRELOAD = 46,
  TYPE_INTERNAL_DTD = 47,
  TYPE_INTERNAL_FORCE_ALLOWED_DTD = 48,
  TYPE_INTERNAL_AUDIOWORKLET = 49,
  TYPE_INTERNAL_PAINTWORKLET = 50,
  TYPE_INTERNAL_FONT_PRELOAD = 51,
  TYPE_INTERNAL_CHROMEUTILS_COMPILED_SCRIPT = 52,
  TYPE_INTERNAL_FRAME_MESSAGEMANAGER_SCRIPT = 53,
  TYPE_INTERNAL_FETCH_PRELOAD = 54,
  TYPE_UA_FONT = 55,
  TYPE_PROXIED_WEBRTC_MEDIA = 56,
  TYPE_WEB_IDENTITY = 57,
  TYPE_INTERNAL_WORKER_STATIC_MODULE = 58,
  TYPE_WEB_TRANSPORT = 59,
  TYPE_INTERNAL_XMLHTTPREQUEST_SYNC = 60,
  TYPE_INTERNAL_EXTERNAL_RESOURCE = 61,
  TYPE_JSON = 62,
  TYPE_INTERNAL_JSON_PRELOAD = 63,
  TYPE_END = 64,
}

declare global {

namespace nsIContentPolicy {
  type nsContentPolicyType = nsIContentPolicy_nsContentPolicyType;
}

interface nsIContentPolicy extends nsISupports, Enums<typeof nsIContentPolicy_nsContentPolicyType> {
  readonly REJECT_REQUEST?: -1;
  readonly REJECT_TYPE?: -2;
  readonly REJECT_SERVER?: -3;
  readonly REJECT_OTHER?: -4;
  readonly REJECT_POLICY?: -5;
  readonly ACCEPT?: 1;

  shouldLoad(aContentLocation: nsIURI, aLoadInfo: nsILoadInfo): i16;
  shouldProcess(aContentLocation: nsIURI, aLoadInfo: nsILoadInfo): i16;
}

// https://searchfox.org/mozilla-central/source/dom/base/nsIDroppedLinkHandler.idl

interface nsIDroppedLinkItem extends nsISupports {
  readonly url: string;
  readonly name: string;
  readonly type: string;
}

interface nsIDroppedLinkHandler extends nsISupports {
  canDropLink(aEvent: DragEvent, aAllowSameDocument: boolean): boolean;
  dropLinks(aEvent: DragEvent, aDisallowInherit?: boolean): nsIDroppedLinkItem[];
  validateURIsForDrop(aEvent: DragEvent, aURIs: string[], aDisallowInherit?: boolean): void;
  queryLinks(aDataTransfer: DataTransfer): nsIDroppedLinkItem[];
  getTriggeringPrincipal(aEvent: DragEvent): nsIPrincipal;
  getCsp(aEvent: DragEvent): nsIContentSecurityPolicy;
}

// https://searchfox.org/mozilla-central/source/dom/base/nsIEventSourceEventService.idl

interface nsIEventSourceEventListener extends nsISupports {
  eventSourceConnectionOpened(aHttpChannelId: u64): void;
  eventSourceConnectionClosed(aHttpChannelId: u64): void;
  eventReceived(aHttpChannelId: u64, aEventName: string, aLastEventID: string, aData: string, aRetry: u32, aTimeStamp: DOMHighResTimeStamp): void;
}

interface nsIEventSourceEventService extends nsISupports {
  addListener(aInnerWindowID: u64, aListener: nsIEventSourceEventListener): void;
  removeListener(aInnerWindowID: u64, aListener: nsIEventSourceEventListener): void;
  hasListenerFor(aInnerWindowID: u64): boolean;
}

// https://searchfox.org/mozilla-central/source/dom/base/nsIImageLoadingContent.idl

interface nsIImageLoadingContent extends imgINotificationObserver {
  readonly UNKNOWN_REQUEST?: -1;
  readonly CURRENT_REQUEST?: 0;
  readonly PENDING_REQUEST?: 1;
}

// https://searchfox.org/mozilla-central/source/dom/base/nsIMessageManager.idl

interface nsIMessageSender extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/dom/base/nsIObjectLoadingContent.idl

interface nsIObjectLoadingContent extends nsISupports {
  readonly TYPE_LOADING?: 0;
  readonly TYPE_DOCUMENT?: 1;
  readonly TYPE_FALLBACK?: 2;

  readonly actualType: string;
  readonly displayedType: u32;
  readonly srcURI: nsIURI;
}

// https://searchfox.org/mozilla-central/source/dom/base/nsIScriptChannel.idl

// https://searchfox.org/mozilla-central/source/dom/base/nsIScriptableContentIterator.idl

}  // global

declare enum nsIScriptableContentIterator_IteratorType {
  NOT_INITIALIZED = 0,
  POST_ORDER_ITERATOR = 1,
  PRE_ORDER_ITERATOR = 2,
  SUBTREE_ITERATOR = 3,
}

declare global {

namespace nsIScriptableContentIterator {
  type IteratorType = nsIScriptableContentIterator_IteratorType;
}

interface nsIScriptableContentIterator extends nsISupports, Enums<typeof nsIScriptableContentIterator_IteratorType> {
  initWithRootNode(aType: nsIScriptableContentIterator.IteratorType, aRoot: Node): void;
  initWithRange(aType: nsIScriptableContentIterator.IteratorType, aRange: Range): void;
  initWithRangeAllowCrossShadowBoundary(aType: nsIScriptableContentIterator.IteratorType, aRange: Range): void;
  initWithPositions(aType: nsIScriptableContentIterator.IteratorType, aStartContainer: Node, aStartOffset: u32, aEndContainer: Node, aEndOffset: u32): void;
  first(): void;
  last(): void;
  next(): void;
  prev(): void;
  readonly currentNode: Node;
  readonly isDone: boolean;
  positionAt(aNode: Node): void;
}

// https://searchfox.org/mozilla-central/source/dom/base/nsISelectionController.idl

}  // global

declare enum nsISelectionController_ControllerScrollFlags {
  SCROLL_SYNCHRONOUS = 2,
  SCROLL_FIRST_ANCESTOR_ONLY = 4,
  SCROLL_OVERFLOW_HIDDEN = 8,
  SCROLL_VERTICAL_NEAREST = 0,
  SCROLL_VERTICAL_START = 16,
  SCROLL_VERTICAL_CENTER = 32,
  SCROLL_VERTICAL_END = 64,
}

declare global {

namespace nsISelectionController {
  type ControllerScrollFlags = nsISelectionController_ControllerScrollFlags;
}

interface nsISelectionController extends nsISelectionDisplay, Enums<typeof nsISelectionController_ControllerScrollFlags> {
  readonly SELECTION_NONE?: 0;
  readonly SELECTION_NORMAL?: 1;
  readonly SELECTION_SPELLCHECK?: 2;
  readonly SELECTION_IME_RAWINPUT?: 3;
  readonly SELECTION_IME_SELECTEDRAWTEXT?: 4;
  readonly SELECTION_IME_CONVERTEDTEXT?: 5;
  readonly SELECTION_IME_SELECTEDCONVERTEDTEXT?: 6;
  readonly SELECTION_ACCESSIBILITY?: 7;
  readonly SELECTION_FIND?: 8;
  readonly SELECTION_URLSECONDARY?: 9;
  readonly SELECTION_URLSTRIKEOUT?: 10;
  readonly SELECTION_TARGET_TEXT?: 11;
  readonly SELECTION_HIGHLIGHT?: 12;
  readonly NUM_SELECTIONTYPES?: 13;
  readonly SELECTION_ANCHOR_REGION?: 0;
  readonly SELECTION_FOCUS_REGION?: 1;
  readonly SELECTION_WHOLE_SELECTION?: 2;
  readonly NUM_SELECTION_REGIONS?: 3;
  readonly SELECTION_OFF?: 0;
  readonly SELECTION_HIDDEN?: 1;
  readonly SELECTION_ON?: 2;
  readonly SELECTION_DISABLED?: 3;
  readonly SELECTION_ATTENTION?: 4;
  readonly MOVE_LEFT?: 0;
  readonly MOVE_RIGHT?: 1;
  readonly MOVE_UP?: 2;
  readonly MOVE_DOWN?: 3;

  setDisplaySelection(toggle: i16): void;
  getDisplaySelection(): i16;
  getSelection(type: i16): Selection;
  scrollSelectionIntoView(type: i16, region: i16, flags: nsISelectionController.ControllerScrollFlags): void;
  repaintSelection(type: i16): void;
  setCaretEnabled(enabled: boolean): void;
  setCaretReadOnly(readOnly: boolean): void;
  getCaretEnabled(): boolean;
  readonly caretVisible: boolean;
  setCaretVisibilityDuringSelection(visibility: boolean): void;
  characterMove(forward: boolean, extend: boolean): void;
  physicalMove(direction: i16, amount: i16, extend: boolean): void;
  wordMove(forward: boolean, extend: boolean): void;
  lineMove(forward: boolean, extend: boolean): void;
  intraLineMove(forward: boolean, extend: boolean): void;
  pageMove(forward: boolean, extend: boolean): void;
  completeScroll(forward: boolean): void;
  completeMove(forward: boolean, extend: boolean): void;
  scrollPage(forward: boolean): void;
  scrollLine(forward: boolean): void;
  scrollCharacter(right: boolean): void;
}

// https://searchfox.org/mozilla-central/source/dom/base/nsISelectionDisplay.idl

interface nsISelectionDisplay extends nsISupports {
  readonly DISPLAY_TEXT?: 1;
  readonly DISPLAY_IMAGES?: 2;
  readonly DISPLAY_FRAMES?: 4;
  readonly DISPLAY_ALL?: 7;

  setSelectionFlags(toggle: i16): void;
  getSelectionFlags(): i16;
}

// https://searchfox.org/mozilla-central/source/dom/base/nsISelectionListener.idl

interface nsISelectionListener extends nsISupports {
  readonly NO_REASON?: 0;
  readonly DRAG_REASON?: 1;
  readonly MOUSEDOWN_REASON?: 2;
  readonly MOUSEUP_REASON?: 4;
  readonly KEYPRESS_REASON?: 8;
  readonly SELECTALL_REASON?: 16;
  readonly COLLAPSETOSTART_REASON?: 32;
  readonly COLLAPSETOEND_REASON?: 64;
  readonly IME_REASON?: 128;
  readonly JS_REASON?: 256;
  readonly CHARACTER_AMOUNT?: 0;
  readonly CLUSTER_AMOUNT?: 1;
  readonly WORD_AMOUNT?: 2;
  readonly WORDNOSPACE_AMOUNT?: 3;
  readonly LINE_AMOUNT?: 4;
  readonly BEGINLINE_AMOUNT?: 5;
  readonly ENDLINE_AMOUNT?: 6;
  readonly NO_AMOUNT?: 7;
  readonly PARAGRAPH_AMOUNT?: 8;

  notifySelectionChanged(doc: Document, sel: Selection, reason: i16, amount: i32): void;
}

// https://searchfox.org/mozilla-central/source/dom/base/nsISlowScriptDebug.idl

type nsISlowScriptDebugCallback = Callable<{
  handleSlowScriptDebug(aWindow: nsIDOMWindow): void;
}>

type nsISlowScriptDebuggerStartupCallback = Callable<{
  finishDebuggerStartup(): void;
}>

type nsISlowScriptDebugRemoteCallback = Callable<{
  handleSlowScriptDebug(aBrowser: EventTarget, aCallback: nsISlowScriptDebuggerStartupCallback): void;
}>

interface nsISlowScriptDebug extends nsISupports {
  activationHandler: nsISlowScriptDebugCallback;
  remoteActivationHandler: nsISlowScriptDebugRemoteCallback;
}

// https://searchfox.org/mozilla-central/source/dom/console/nsIConsoleAPIStorage.idl

interface nsIConsoleAPIStorage extends nsISupports {
  getEvents(aId?: string): any;
  addLogEventListener(aListener: any, aPrincipal: nsIPrincipal): void;
  removeLogEventListener(aListener: any): void;
  recordEvent(aId: string, aEvent: any): void;
  clearEvents(aId?: string): void;
}

// https://searchfox.org/mozilla-central/source/dom/file/ipc/mozIRemoteLazyInputStream.idl

interface mozIRemoteLazyInputStream extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/dom/ipc/nsIDOMProcessChild.idl

interface nsIDOMProcessChild extends nsISupports {
  readonly childID: u64;
  getActor(name: string): JSProcessActorChild;
  getExistingActor(name: string): JSProcessActorChild;
  readonly canSend: boolean;
}

// https://searchfox.org/mozilla-central/source/dom/ipc/nsIDOMProcessParent.idl

interface nsIDOMProcessParent extends nsISupports {
  readonly childID: u64;
  readonly osPid: i32;
  getActor(name: string): JSProcessActorParent;
  getExistingActor(name: string): JSProcessActorParent;
  readonly canSend: boolean;
  readonly remoteType: string;
}

interface nsIContentParentKeepAlive extends nsISupports {
  readonly domProcess: nsIDOMProcessParent;
  invalidateKeepAlive(): void;
}

// https://searchfox.org/mozilla-central/source/dom/ipc/nsIHangReport.idl

interface nsIHangReport extends nsISupports {
  readonly scriptBrowser: Element;
  readonly scriptFileName: string;
  readonly hangDuration: double;
  readonly addonId: string;
  readonly childID: u64;
  userCanceled(): void;
  terminateScript(): void;
  beginStartingDebugger(): void;
  endStartingDebugger(): void;
  isReportForBrowserOrChildren(aFrameLoader: FrameLoader): boolean;
}

// https://searchfox.org/mozilla-central/source/dom/ipc/nsILoginDetectionService.idl

interface nsILoginDetectionService extends nsISupports {
  init(): void;
  isLoginsLoaded(): boolean;
}

// https://searchfox.org/mozilla-central/source/dom/audiochannel/nsIAudioChannelAgent.idl

interface nsISuspendedTypes extends nsISupports {
  readonly NONE_SUSPENDED?: 0;
  readonly SUSPENDED_BLOCK?: 1;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/domstubs.idl

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIBrowser.idl

interface nsIBrowser extends nsISupports {
  dropLinks(links: string[], triggeringPrincipal: nsIPrincipal): void;
  swapBrowsers(aOtherBrowser: nsIBrowser): void;
  closeBrowser(): void;
  readonly isRemoteBrowser: boolean;
  readonly permanentKey: any;
  readonly contentPrincipal: nsIPrincipal;
  readonly contentPartitionedPrincipal: nsIPrincipal;
  readonly csp: nsIContentSecurityPolicy;
  readonly referrerInfo: nsIReferrerInfo;
  isNavigating: boolean;
  mayEnableCharacterEncodingMenu: boolean;
  updateForStateChange(aCharset: string, aDocumentURI: nsIURI, aContentType: string): void;
  updateWebNavigationForLocationChange(aCanGoBack: boolean, aCanGoBackIgnoringUserInteraction: boolean, aCanGoForward: boolean): void;
  updateForLocationChange(aLocation: nsIURI, aCharset: string, aMayEnableCharacterEncodingMenu: boolean, aDocumentURI: nsIURI, aTitle: string, aContentPrincipal: nsIPrincipal, aContentPartitionedPrincipal: nsIPrincipal, aCSP: nsIContentSecurityPolicy, aReferrerInfo: nsIReferrerInfo, aIsSynthetic: boolean, aHasRequestContextID: boolean, aRequestContextID: u64, aContentType: string): void;
  prepareToChangeRemoteness(): Promise<any>;
  beforeChangeRemoteness(): void;
  finishChangeRemoteness(aPendingSwitchId: u64): boolean;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIBrowserChild.idl

interface nsIBrowserChild extends nsISupports {
  readonly messageManager: ContentFrameMessageManager;
  remoteDropLinks(links: nsIDroppedLinkItem[]): void;
  contentTransformsReceived(): Promise<any>;
  readonly tabId: u64;
  notifyNavigationFinished(): void;
  readonly chromeOuterWindowID: u64;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIBrowserDOMWindow.idl

interface nsIOpenURIInFrameParams extends nsISupports {
  readonly openWindowInfo: nsIOpenWindowInfo;
  referrerInfo: nsIReferrerInfo;
  readonly isPrivate: boolean;
  triggeringPrincipal: nsIPrincipal;
  csp: nsIContentSecurityPolicy;
  readonly openerBrowser: Element;
  readonly openerOriginAttributes: any;
}

interface nsIBrowserDOMWindow extends nsISupports {
  readonly OPEN_DEFAULTWINDOW?: 0;
  readonly OPEN_CURRENTWINDOW?: 1;
  readonly OPEN_NEWWINDOW?: 2;
  readonly OPEN_NEWTAB?: 3;
  readonly OPEN_PRINT_BROWSER?: 4;
  readonly OPEN_NEWTAB_BACKGROUND?: 5;
  readonly OPEN_NEWTAB_FOREGROUND?: 6;
  readonly OPEN_NEW?: 0;
  readonly OPEN_EXTERNAL?: 1;
  readonly OPEN_NO_OPENER?: 4;
  readonly OPEN_NO_REFERRER?: 8;

  createContentWindow(aURI: nsIURI, aOpenWindowInfo: nsIOpenWindowInfo, aWhere: i16, aFlags: i32, aTriggeringPrincipal: nsIPrincipal, aCsp?: nsIContentSecurityPolicy): BrowsingContext;
  createContentWindowInFrame(aURI: nsIURI, params: nsIOpenURIInFrameParams, aWhere: i16, aFlags: i32, aName: string): Element;
  openURI(aURI: nsIURI, aOpenWindowInfo: nsIOpenWindowInfo, aWhere: i16, aFlags: i32, aTriggeringPrincipal: nsIPrincipal, aCsp?: nsIContentSecurityPolicy): BrowsingContext;
  openURIInFrame(aURI: nsIURI, params: nsIOpenURIInFrameParams, aWhere: i16, aFlags: i32, aName: string): Element;
  canClose(): boolean;
  readonly tabCount: u32;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIBrowserUsage.idl

interface nsIBrowserUsage extends nsISupports {
  getUniqueDomainsVisitedInPast24Hours(): u32;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIContentPermissionPrompt.idl

interface nsIContentPermissionType extends nsISupports {
  readonly type: string;
  readonly options: nsIArray;
}

interface nsIContentPermissionRequest extends nsISupports {
  readonly types: nsIArray;
  readonly principal: nsIPrincipal;
  readonly topLevelPrincipal: nsIPrincipal;
  readonly window: mozIDOMWindow;
  readonly element: Element;
  readonly hasValidTransientUserGestureActivation: boolean;
  readonly isRequestDelegatedToUnsafeThirdParty: boolean;
  getDelegatePrincipal(aType: string): nsIPrincipal;
  cancel(): void;
  allow(choices?: any): void;
}

type nsIContentPermissionPrompt = Callable<{
  prompt(request: nsIContentPermissionRequest): void;
}>

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIContentPrefService2.idl

interface nsIContentPrefObserver extends nsISupports {
  onContentPrefSet(aGroup: string, aName: string, aValue: nsIVariant, aIsPrivate?: boolean): void;
  onContentPrefRemoved(aGroup: string, aName: string, aIsPrivate?: boolean): void;
}

interface nsIContentPrefService2 extends nsISupports {
  readonly GROUP_NAME_MAX_LENGTH?: 2000;

  getByName(name: string, context: nsILoadContext, callback: nsIContentPrefCallback2): void;
  getByDomainAndName(domain: string, name: string, context: nsILoadContext, callback: nsIContentPrefCallback2): void;
  getBySubdomainAndName(domain: string, name: string, context: nsILoadContext, callback: nsIContentPrefCallback2): void;
  getGlobal(name: string, context: nsILoadContext, callback: nsIContentPrefCallback2): void;
  getCachedByDomainAndName(domain: string, name: string, context: nsILoadContext): nsIContentPref;
  getCachedBySubdomainAndName(domain: string, name: string, context: nsILoadContext): nsIContentPref[];
  getCachedGlobal(name: string, context: nsILoadContext): nsIContentPref;
  set(domain: string, name: string, value: nsIVariant, context: nsILoadContext, callback?: nsIContentPrefCallback2): void;
  setGlobal(name: string, value: nsIVariant, context: nsILoadContext, callback?: nsIContentPrefCallback2): void;
  removeByDomainAndName(domain: string, name: string, context: nsILoadContext, callback?: nsIContentPrefCallback2): void;
  removeBySubdomainAndName(domain: string, name: string, context: nsILoadContext, callback?: nsIContentPrefCallback2): void;
  removeGlobal(name: string, context: nsILoadContext, callback?: nsIContentPrefCallback2): void;
  removeByDomain(domain: string, context: nsILoadContext, callback?: nsIContentPrefCallback2): void;
  removeBySubdomain(domain: string, context: nsILoadContext, callback?: nsIContentPrefCallback2): void;
  removeByName(name: string, context: nsILoadContext, callback?: nsIContentPrefCallback2): void;
  removeAllDomains(context: nsILoadContext, callback?: nsIContentPrefCallback2): void;
  removeAllDomainsSince(since: u64, context: nsILoadContext, callback?: nsIContentPrefCallback2): void;
  removeAllGlobals(context: nsILoadContext, callback?: nsIContentPrefCallback2): void;
  addObserverForName(name: string, observer: nsIContentPrefObserver): void;
  removeObserverForName(name: string, observer: nsIContentPrefObserver): void;
  extractDomain(str: string): string;
}

interface nsIContentPrefCallback2 extends nsISupports {
  readonly COMPLETE_OK?: 0;
  readonly COMPLETE_ERROR?: 1;

  handleResult(pref: nsIContentPref): void;
  handleError(error: nsresult): void;
  handleCompletion(reason: u16): void;
}

interface nsIContentPref extends nsISupports {
  readonly domain: string;
  readonly name: string;
  readonly value: nsIVariant;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIDOMGlobalPropertyInitializer.idl

interface nsIDOMGlobalPropertyInitializer extends nsISupports {
  init(window: mozIDOMWindow): any;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIDOMWindow.idl

interface nsIDOMWindow extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIDOMWindowUtils.idl

interface nsIDOMWindowUtils extends nsISupports {
  readonly MODIFIER_ALT?: 1;
  readonly MODIFIER_CONTROL?: 2;
  readonly MODIFIER_SHIFT?: 4;
  readonly MODIFIER_META?: 8;
  readonly MODIFIER_ALTGRAPH?: 16;
  readonly MODIFIER_CAPSLOCK?: 32;
  readonly MODIFIER_FN?: 64;
  readonly MODIFIER_FNLOCK?: 128;
  readonly MODIFIER_NUMLOCK?: 256;
  readonly MODIFIER_SCROLLLOCK?: 512;
  readonly MODIFIER_SYMBOL?: 1024;
  readonly MODIFIER_SYMBOLLOCK?: 2048;
  readonly WHEEL_EVENT_CAUSED_BY_NO_LINE_OR_PAGE_DELTA_DEVICE?: 1;
  readonly WHEEL_EVENT_CAUSED_BY_MOMENTUM?: 2;
  readonly WHEEL_EVENT_CUSTOMIZED_BY_USER_PREFS?: 4;
  readonly WHEEL_EVENT_ASYNC_ENABLED?: 8;
  readonly WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_ZERO?: 16;
  readonly WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_POSITIVE?: 32;
  readonly WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_NEGATIVE?: 64;
  readonly WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_ZERO?: 256;
  readonly WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_POSITIVE?: 512;
  readonly WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_NEGATIVE?: 1024;
  readonly NATIVE_MODIFIER_CAPS_LOCK?: 1;
  readonly NATIVE_MODIFIER_NUM_LOCK?: 2;
  readonly NATIVE_MODIFIER_SHIFT_LEFT?: 256;
  readonly NATIVE_MODIFIER_SHIFT_RIGHT?: 512;
  readonly NATIVE_MODIFIER_CONTROL_LEFT?: 1024;
  readonly NATIVE_MODIFIER_CONTROL_RIGHT?: 2048;
  readonly NATIVE_MODIFIER_ALT_LEFT?: 4096;
  readonly NATIVE_MODIFIER_ALT_RIGHT?: 8192;
  readonly NATIVE_MODIFIER_COMMAND_LEFT?: 16384;
  readonly NATIVE_MODIFIER_COMMAND_RIGHT?: 32768;
  readonly NATIVE_MODIFIER_HELP?: 65536;
  readonly NATIVE_MODIFIER_ALT_GRAPH?: 131072;
  readonly NATIVE_MODIFIER_FUNCTION?: 1048576;
  readonly NATIVE_MODIFIER_NUMERIC_KEY_PAD?: 16777216;
  readonly NATIVE_MOUSE_MESSAGE_BUTTON_DOWN?: 1;
  readonly NATIVE_MOUSE_MESSAGE_BUTTON_UP?: 2;
  readonly NATIVE_MOUSE_MESSAGE_MOVE?: 3;
  readonly NATIVE_MOUSE_MESSAGE_ENTER_WINDOW?: 4;
  readonly NATIVE_MOUSE_MESSAGE_LEAVE_WINDOW?: 5;
  readonly MOUSESCROLL_PREFER_WIDGET_AT_POINT?: 1;
  readonly MOUSESCROLL_SCROLL_LINES?: 2;
  readonly MOUSESCROLL_WIN_SCROLL_LPARAM_NOT_NULL?: 65536;
  readonly TOUCH_HOVER?: 1;
  readonly TOUCH_CONTACT?: 2;
  readonly TOUCH_REMOVE?: 4;
  readonly TOUCH_CANCEL?: 8;
  readonly PHASE_BEGIN?: 0;
  readonly PHASE_UPDATE?: 1;
  readonly PHASE_END?: 2;
  readonly UPDATE_TYPE_RESTORE?: 0;
  readonly UPDATE_TYPE_MAIN_THREAD?: 1;
  readonly SCROLL_MODE_INSTANT?: 0;
  readonly SCROLL_MODE_SMOOTH?: 1;
  readonly FLUSH_NONE?: -1;
  readonly FLUSH_STYLE?: 0;
  readonly FLUSH_LAYOUT?: 1;
  readonly IME_STATUS_DISABLED?: 0;
  readonly IME_STATUS_ENABLED?: 1;
  readonly IME_STATUS_PASSWORD?: 2;
  readonly INPUT_CONTEXT_ORIGIN_MAIN?: 0;
  readonly INPUT_CONTEXT_ORIGIN_CONTENT?: 1;
  readonly CONTENT_COMMAND_FLAG_PREVENT_SET_SELECTION?: 2;
  readonly QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK?: 0;
  readonly QUERY_CONTENT_FLAG_USE_XP_LINE_BREAK?: 1;
  readonly QUERY_CONTENT_FLAG_SELECTION_SPELLCHECK?: 2;
  readonly QUERY_CONTENT_FLAG_SELECTION_IME_RAWINPUT?: 4;
  readonly QUERY_CONTENT_FLAG_SELECTION_IME_SELECTEDRAWTEXT?: 8;
  readonly QUERY_CONTENT_FLAG_SELECTION_IME_CONVERTEDTEXT?: 16;
  readonly QUERY_CONTENT_FLAG_SELECTION_IME_SELECTEDCONVERTEDTEXT?: 32;
  readonly QUERY_CONTENT_FLAG_SELECTION_ACCESSIBILITY?: 64;
  readonly QUERY_CONTENT_FLAG_SELECTION_FIND?: 128;
  readonly QUERY_CONTENT_FLAG_SELECTION_URLSECONDARY?: 256;
  readonly QUERY_CONTENT_FLAG_SELECTION_URLSTRIKEOUT?: 512;
  readonly QUERY_CONTENT_FLAG_OFFSET_RELATIVE_TO_INSERTION_POINT?: 1024;
  readonly QUERY_SELECTED_TEXT?: 3200;
  readonly QUERY_TEXT_CONTENT?: 3201;
  readonly QUERY_CARET_RECT?: 3203;
  readonly QUERY_TEXT_RECT?: 3204;
  readonly QUERY_EDITOR_RECT?: 3205;
  readonly QUERY_CHARACTER_AT_POINT?: 3208;
  readonly QUERY_TEXT_RECT_ARRAY?: 3209;
  readonly SELECTION_SET_FLAG_USE_NATIVE_LINE_BREAK?: 0;
  readonly SELECTION_SET_FLAG_USE_XP_LINE_BREAK?: 1;
  readonly SELECTION_SET_FLAG_REVERSE?: 2;
  readonly SELECT_CHARACTER?: 0;
  readonly SELECT_CLUSTER?: 1;
  readonly SELECT_WORD?: 2;
  readonly SELECT_LINE?: 3;
  readonly SELECT_BEGINLINE?: 4;
  readonly SELECT_ENDLINE?: 5;
  readonly SELECT_PARAGRAPH?: 6;
  readonly SELECT_WORDNOSPACE?: 7;
  readonly AUDIO_INPUT?: 0;
  readonly AUDIO_OUTPUT?: 1;
  readonly AGENT_SHEET?: 0;
  readonly USER_SHEET?: 1;
  readonly AUTHOR_SHEET?: 2;
  readonly WR_CAPTURE_SCENE?: 1;
  readonly WR_CAPTURE_FRAME?: 2;
  readonly WR_CAPTURE_TILE_CACHE?: 4;
  readonly WR_CAPTURE_EXTERNAL_RESOURCES?: 8;
  readonly DEFAULT_MOUSE_POINTER_ID?: 0;
  readonly DEFAULT_PEN_POINTER_ID?: 1;
  readonly DEFAULT_TOUCH_POINTER_ID?: 2;
  readonly MOUSE_BUTTON_LEFT_BUTTON?: 0;
  readonly MOUSE_BUTTON_MIDDLE_BUTTON?: 1;
  readonly MOUSE_BUTTON_RIGHT_BUTTON?: 2;
  readonly MOUSE_BUTTONS_NO_BUTTON?: 0;
  readonly MOUSE_BUTTONS_LEFT_BUTTON?: 1;
  readonly MOUSE_BUTTONS_RIGHT_BUTTON?: 2;
  readonly MOUSE_BUTTONS_MIDDLE_BUTTON?: 4;
  readonly MOUSE_BUTTONS_4TH_BUTTON?: 8;
  readonly MOUSE_BUTTONS_5TH_BUTTON?: 16;
  readonly MOUSE_BUTTONS_NOT_SPECIFIED?: -1;
  readonly DIRECTION_LTR?: 0;
  readonly DIRECTION_RTL?: 1;
  readonly DIRECTION_NOT_SET?: 2;

  imageAnimationMode: u16;
  readonly docCharsetIsForced: boolean;
  readonly physicalMillimeterInCSSPixels: float;
  getDocumentMetadata(aName: string): string;
  getLastOverWindowPointerLocationInCSSPixels(aX: OutParam<float>, aY: OutParam<float>): void;
  updateLayerTree(): void;
  readonly lastTransactionId: u64;
  getViewportInfo(aDisplayWidth: u32, aDisplayHeight: u32, aDefaultZoom: OutParam<double>, aAllowZoom: OutParam<boolean>, aMinZoom: OutParam<double>, aMaxZoom: OutParam<double>, aWidth: OutParam<u32>, aHeight: OutParam<u32>, aAutoSize: OutParam<boolean>): void;
  getViewportFitInfo(): string;
  getDocumentViewerSize(aDisplayWidth: OutParam<u32>, aDisplayHeight: OutParam<u32>): void;
  setMousewheelAutodir(aElement: Element, aEnabled: boolean, aHonourRoot: boolean): void;
  setDisplayPortForElement(aXPx: float, aYPx: float, aWidthPx: float, aHeightPx: float, aElement: Element, aPriority: u32): void;
  setDisplayPortMarginsForElement(aLeftMargin: float, aTopMargin: float, aRightMargin: float, aBottomMargin: float, aElement: Element, aPriority: u32): void;
  setDisplayPortBaseForElement(aX: i32, aY: i32, aWidth: i32, aHeight: i32, aElement: Element): void;
  getScrollbarSizes(aElement: Element, aVerticalScrollbarWidth: OutParam<u32>, aHorizontalScrollbarHeight: OutParam<u32>): void;
  setResolutionAndScaleTo(aResolution: float): void;
  getResolution(): float;
  setRestoreResolution(aResolution: float, aDisplayWidth: u32, aDisplayHeight: u32): void;
  isFirstPaint: boolean;
  getPresShellId(): u32;
  isCORSSafelistedRequestHeader(name: string, value: string): boolean;
  sendMouseEvent(aType: string, aX: float, aY: float, aButton: i32, aClickCount: i32, aModifiers: i32, aIgnoreRootScrollFrame?: boolean, aPressure?: float, aInputSourceArg?: u16, aIsDOMEventSynthesized?: boolean, aIsWidgetEventSynthesized?: boolean, aButtons?: i32, aIdentifier?: u32): boolean;
  sendTouchEvent(aType: string, aIdentifiers: u32[], aXs: i32[], aYs: i32[], aRxs: u32[], aRys: u32[], aRotationAngles: float[], aForces: float[], aTiltXs: i32[], aTiltYs: i32[], aTwists: i32[], aModifiers: i32, aIgnoreRootScrollFrame?: boolean): boolean;
  sendTouchEventAsPen(aType: string, aIdentifier: u32, aX: i32, aY: i32, aRx: u32, aRy: u32, aRotationAngle: float, aForce: float, aTiltX: i32, aTiltY: i32, aTwist: i32, aModifier: i32, aIgnoreRootScrollFrame?: boolean): boolean;
  sendMouseEventToWindow(aType: string, aX: float, aY: float, aButton: i32, aClickCount: i32, aModifiers: i32, aIgnoreRootScrollFrame?: boolean, aPressure?: float, aInputSourceArg?: u16, aIsDOMEventSynthesized?: boolean, aIsWidgetEventSynthesized?: boolean, aButtons?: i32, aIdentifier?: u32): void;
  sendTouchEventToWindow(aType: string, aIdentifiers: u32[], aXs: i32[], aYs: i32[], aRxs: u32[], aRys: u32[], aRotationAngles: float[], aForces: float[], aTiltXs: i32[], aTiltYs: i32[], aTwists: i32[], aModifiers: i32, aIgnoreRootScrollFrame?: boolean): boolean;
  sendWheelEvent(aX: float, aY: float, aDeltaX: double, aDeltaY: double, aDeltaZ: double, aDeltaMode: u32, aModifiers: i32, aLineOrPageDeltaX: i32, aLineOrPageDeltaY: i32, aOptions: u32): void;
  sendNativeKeyEvent(aNativeKeyboardLayout: i32, aNativeKeyCode: i32, aModifierFlags: u32, aCharacters: string, aUnmodifiedCharacters: string, aObserver?: nsIObserver): void;
  sendNativeMouseEvent(aScreenX: i32, aScreenY: i32, aNativeMessage: u32, aButton: i16, aModifierFlags: u32, aElementOnWidget: Element, aObserver?: nsIObserver): void;
  suppressAnimation(aSuppress: boolean): void;
  sendNativeMouseScrollEvent(aScreenX: i32, aScreenY: i32, aNativeMessage: u32, aDeltaX: double, aDeltaY: double, aDeltaZ: double, aModifierFlags: u32, aAdditionalFlags: u32, aElement: Element, aObserver?: nsIObserver): void;
  sendNativeTouchPoint(aPointerId: u32, aTouchState: u32, aScreenX: i32, aScreenY: i32, aPressure: double, aOrientation: u32, aObserver?: nsIObserver, aElement?: Element): void;
  sendNativeTouchpadPinch(aEventPhase: u32, aScale: float, aScreenX: i32, aScreenY: i32, aModifierFlags: i32): void;
  sendNativeTouchTap(aScreenX: i32, aScreenY: i32, aLongTap: boolean, aObserver?: nsIObserver): void;
  sendNativePenInput(aPointerId: u32, aPointerState: u32, aScreenX: i32, aScreenY: i32, aPressure: double, aRotation: u32, aTiltX: i32, aTiltY: i32, aButton: i32, aObserver?: nsIObserver, aElement?: Element): void;
  clearNativeTouchSequence(aObserver?: nsIObserver): void;
  sendNativeTouchpadDoubleTap(aScreenX: i32, aScreenY: i32, aModifierFlags: i32): void;
  sendNativeTouchpadPan(aEventPhase: u32, aScreenX: i32, aScreenY: i32, aDeltaX: double, aDeltaY: double, aModifierFlags: i32, aObserver?: nsIObserver): void;
  readonly parsedStyleSheets: u32;
  activateNativeMenuItemAt(indexString: string): void;
  forceUpdateNativeMenuAt(indexString: string): void;
  GetSelectionAsPlaintext(): string;
  garbageCollect(aListener?: nsICycleCollectorListener): void;
  cycleCollect(aListener?: nsICycleCollectorListener): void;
  runNextCollectorTimer(aReason?: string): void;
  pokeGC(aReason?: string): void;
  sendSimpleGestureEvent(aType: string, aX: float, aY: float, aDirection: u32, aDelta: double, aModifiers: i32, aClickCount?: u32): void;
  elementFromPoint(aX: float, aY: float, aIgnoreRootScrollFrame: boolean, aFlushLayout: boolean): Element;
  nodesFromRect(aX: float, aY: float, aTopSize: float, aRightSize: float, aBottomSize: float, aLeftSize: float, aIgnoreRootScrollFrame: boolean, aFlushLayout: boolean, aOnlyVisible: boolean, aTransparencyThreshold?: float): NodeList;
  getTranslationNodes(aRoot: Node): nsITranslationNodeList;
  compareCanvases(aCanvas1: nsISupports, aCanvas2: nsISupports, aMaxDifference: OutParam<u32>): u32;
  readonly isMozAfterPaintPending: boolean;
  readonly isWindowFullyOccluded: boolean;
  readonly isCompositorPaused: boolean;
  readonly isInputTaskManagerSuspended: boolean;
  suppressEventHandling(aSuppress: boolean): void;
  disableNonTestMouseEvents(aDisable: boolean): void;
  getScrollXY(aFlushLayout: boolean, aScrollX: OutParam<i32>, aScrollY: OutParam<i32>): void;
  getScrollXYFloat(aFlushLayout: boolean, aScrollX: OutParam<float>, aScrollY: OutParam<float>): void;
  getScrollbarSize(aFlushLayout: boolean, aWidth: OutParam<i32>, aHeight: OutParam<i32>): void;
  getBoundsWithoutFlushing(aElement: Element): DOMRect;
  getWidgetOpaqueRegion(): DOMRect[];
  scrollToVisual(aOffsetX: float, aOffsetY: float, aUpdateType: i32, aScrollMode: i32): void;
  getVisualViewportOffsetRelativeToLayoutViewport(aOffsetX: OutParam<float>, aOffsetY: OutParam<float>): void;
  getVisualViewportOffset(aOffsetX: OutParam<i32>, aOffsetY: OutParam<i32>): void;
  transformRectLayoutToVisual(aX: float, aY: float, aWidth: float, aHeight: float): DOMRect;
  toScreenRectInCSSUnits(aX: float, aY: float, aWidth: float, aHeight: float): DOMRect;
  toScreenRect(aX: float, aY: float, aWidth: float, aHeight: float): DOMRect;
  toTopLevelWidgetRect(aX: float, aY: float, aWidth: float, aHeight: float): DOMRect;
  convertFromParentProcessWidgetToLocal(aX: float, aY: float, aWidth: float, aHeight: float): DOMRect;
  setDynamicToolbarMaxHeight(aHeightInScreen: u32): void;
  needsFlush(aFlushtype: i32): boolean;
  flushLayoutWithoutThrottledAnimations(): void;
  getRootBounds(): DOMRect;
  readonly IMEIsOpen: boolean;
  readonly IMEStatus: u32;
  readonly inputContextURI: nsIURI;
  readonly inputContextOrigin: u32;
  readonly nodeObservedByIMEContentObserver: Node;
  dispatchDOMEventViaPresShellForTesting(aTarget: Node, aEvent: Event): boolean;
  dispatchEventToChromeOnly(aTarget: EventTarget, aEvent: Event): boolean;
  getClassName(aObject: any): string;
  sendContentCommandEvent(aType: string, aTransferable?: nsITransferable, aString?: string, aOffset?: u32, aReplaceSrcString?: string, aAdditionalFlags?: u32): void;
  sendQueryContentEvent(aType: u32, aOffset: i64, aLength: u32, aX: i32, aY: i32, aAdditionalFlags?: u32): nsIQueryContentEventResult;
  remoteFrameFullscreenChanged(aFrameElement: Element): void;
  remoteFrameFullscreenReverted(): void;
  handleFullscreenRequests(): boolean;
  exitFullscreen(aDontRestoreViewSize?: boolean): void;
  sendSelectionSetEvent(aOffset: u32, aLength: u32, aAdditionalFlags?: u32): boolean;
  selectAtPoint(aX: float, aY: float, aSelectBehavior: u32): boolean;
  getVisitedDependentComputedStyle(aElement: Element, aPseudoElement: string, aPropertyName: string): string;
  enterModalState(): void;
  leaveModalState(): void;
  isInModalState(): boolean;
  suspendTimeouts(): void;
  resumeTimeouts(): void;
  readonly layerManagerType: string;
  readonly layerManagerRemote: boolean;
  readonly isWebRenderRequested: boolean;
  readonly currentAudioBackend: string;
  readonly currentMaxAudioChannels: u32;
  defaultDevicesRoundTripLatency(): Promise<any>;
  readonly currentPreferredSampleRate: u32;
  audioDevices(aSide: u16): nsIArray;
  startFrameTimeRecording(): u32;
  stopFrameTimeRecording(startIndex: u32): float[];
  readonly displayDPI: float;
  advanceTimeAndRefresh(aMilliseconds: i64): void;
  restoreNormalRefresh(): void;
  readonly isTestControllingRefreshes: boolean;
  readonly asyncPanZoomEnabled: boolean;
  setAsyncScrollOffset(aElement: Element, aX: float, aY: float): void;
  setAsyncZoom(aRootElement: Element, aValue: float): void;
  flushApzRepaints(aElement?: Element): boolean;
  disableApzForElement(aElement: Element): void;
  zoomToFocusedInput(): void;
  computeAnimationDistance(element: Element, property: string, value1: string, value2: string): double;
  getUnanimatedComputedStyle(aElement: Element, aPseudoElement: string, aProperty: string, aFlushType: i32): string;
  readonly canvasBackgroundColor: string;
  readonly focusedInputType: string;
  readonly focusedActionHint: string;
  readonly focusedInputMode: string;
  readonly focusedAutocapitalize: string;
  readonly focusedAutocorrect: boolean;
  getViewId(aElement: Element): nsViewID;
  checkAndClearPaintedState(aElement: Element): boolean;
  checkAndClearDisplayListState(aElement: Element): boolean;
  getFileId(aFile: any): i64;
  getFilePath(aFile: any): string;
  getFileReferences(aDatabaseName: string, aId: i64, aRefCnt?: OutParam<i32>, aDBRefCnt?: OutParam<i32>): boolean;
  flushPendingFileDeletions(): void;
  startPCCountProfiling(): void;
  stopPCCountProfiling(): void;
  purgePCCounts(): void;
  getPCCountScriptCount(): i32;
  getPCCountScriptSummary(script: i32): string;
  getPCCountScriptContents(script: i32): string;
  readonly paintingSuppressed: boolean;
  setVisualViewportSize(aWidth: float, aHeight: float): void;
  disableDialogs(): void;
  enableDialogs(): void;
  areDialogsEnabled(): boolean;
  resetDialogAbuseState(): void;
  loadSheet(sheetURI: nsIURI, type: u32): void;
  loadSheetUsingURIString(sheetURI: string, type: u32): void;
  addSheet(sheet: nsIPreloadedStyleSheet, type: u32): void;
  removeSheet(sheetURI: nsIURI, type: u32): void;
  removeSheetUsingURIString(sheetURI: string, type: u32): void;
  readonly isHandlingUserInput: boolean;
  readonly millisSinceLastUserInput: double;
  allowScriptsToClose(): void;
  readonly isParentWindowMainWidgetVisible: boolean;
  isNodeDisabledForEvents(aNode: Node): boolean;
  getOMTAStyle(aElement: Element, aProperty: string, aPseudoElement?: string): string;
  setHandlingUserInput(aHandlingInput: boolean): nsIJSRAIIHelper;
  isKeyboardEventUserActivity(aKeyboardEvent: Event): boolean;
  getContentAPZTestData(aElement?: Element): any;
  getCompositorAPZTestData(aElement?: Element): any;
  sendMozMouseHitTestEvent(aX: float, aY: float, aElement?: Element): void;
  postRestyleSelfEvent(aElement: Element): void;
  xpconnectArgument(aObj: nsISupports): void;
  askPermission(aRequest: nsIContentPermissionRequest): void;
  readonly restyleGeneration: u64;
  readonly framesConstructed: u64;
  readonly framesReflowed: u64;
  readonly animationTriggeredRestyles: u64;
  readonly refreshDriverHasPendingTick: boolean;
  setCustomTitlebar(aCustomTitlebar: boolean): void;
  setResizeMargin(aResizeMargin: i32): void;
  getFrameUniformityTestData(): any;
  enterChaosMode(): void;
  leaveChaosMode(): void;
  triggerDeviceReset(): void;
  hasRuleProcessorUsedByMultipleStyleSets(aSheetType: u32): boolean;
  respectDisplayPortSuppression(aEnabled: boolean): void;
  forceReflowInterrupt(): void;
  terminateGPUProcess(): void;
  readonly gpuProcessPid: i32;
  readonly rddProcessPid: i32;
  getStorageUsage(aStorage: Storage): i64;
  getDirectionFromText(aString: string): i32;
  ensureDirtyRootFrame(): void;
  wrCapture(): void;
  wrStartCaptureSequence(aPath: string, aFlags: u32): void;
  wrStopCaptureSequence(): void;
  setCompositionRecording(aValue: boolean): Promise<any>;
  startCompositionRecording(): Promise<any>;
  stopCompositionRecording(aWriteToDisk: boolean): Promise<any>;
  isCssPropertyRecordedInUseCounter(aProperty: string): boolean;
  resetMobileViewportManager(): void;
  isCoepCredentialless(): boolean;
  setHiDPIMode(aHiDPI: boolean): void;
  restoreHiDPIMode(): void;
  systemFont: string;
  readonly paintCount: u64;
  syncFlushCompositor(): void;
  getLayersId(aElement?: Element): u64;
  readonly effectivelyThrottlesFrameRequests: boolean;
  readonly webrtcRawDeviceId: string;
  readonly suspendedByBrowsingContextGroup: boolean;
  readonly hasScrollLinkedEffect: boolean;
  readonly orientationLock: u32;
  getWheelScrollTarget(): Element;
  readonly dragSession: nsIDragSession;
  microTaskLevel: u32;
}

interface nsITranslationNodeList extends nsISupports {
  readonly length: u32;
  item(index: u32): Node;
  isTranslationRootAtIndex(index: u32): boolean;
}

interface nsIJSRAIIHelper extends nsISupports {
  destruct(): void;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIFocusManager.idl

interface nsIFocusManager extends nsISupports {
  readonly FLAG_RAISE?: 1;
  readonly FLAG_NOSCROLL?: 2;
  readonly FLAG_NOSWITCHFRAME?: 4;
  readonly FLAG_NOPARENTFRAME?: 8;
  readonly FLAG_NONSYSTEMCALLER?: 16;
  readonly FLAG_BYMOUSE?: 4096;
  readonly FLAG_BYKEY?: 8192;
  readonly FLAG_BYMOVEFOCUS?: 16384;
  readonly FLAG_NOSHOWRING?: 32768;
  readonly FLAG_SHOWRING?: 65536;
  readonly FLAG_BYTOUCH?: 131072;
  readonly FLAG_BYJS?: 262144;
  readonly FLAG_BYLONGPRESS?: 524288;
  readonly METHOD_MASK?: 946176;
  readonly METHODANDRING_MASK?: 1044480;
  readonly MOVEFOCUS_FORWARD?: 1;
  readonly MOVEFOCUS_BACKWARD?: 2;
  readonly MOVEFOCUS_FORWARDDOC?: 3;
  readonly MOVEFOCUS_BACKWARDDOC?: 4;
  readonly MOVEFOCUS_FIRST?: 5;
  readonly MOVEFOCUS_LAST?: 6;
  readonly MOVEFOCUS_ROOT?: 7;
  readonly MOVEFOCUS_CARET?: 8;
  readonly MOVEFOCUS_FIRSTDOC?: 9;
  readonly MOVEFOCUS_LASTDOC?: 10;

  readonly activeWindow: mozIDOMWindowProxy;
  readonly activeBrowsingContext: BrowsingContext;
  readonly activeContentBrowsingContext: BrowsingContext;
  focusedWindow: mozIDOMWindowProxy;
  readonly focusedContentBrowsingContext: BrowsingContext;
  readonly focusedElement: Element;
  getLastFocusMethod(window: mozIDOMWindowProxy): u32;
  setFocus(aElement: Element, aFlags: u32): void;
  moveFocus(aWindow: mozIDOMWindowProxy, aStartElement: Element, aType: u32, aFlags: u32): Element;
  clearFocus(aWindow: mozIDOMWindowProxy): void;
  getFocusedElementForWindow(aWindow: mozIDOMWindowProxy, aDeep: boolean, aFocusedWindow: OutParam<mozIDOMWindowProxy>): Element;
  moveCaretToFocus(aWindow: mozIDOMWindowProxy): void;
  elementIsFocusable(aElement: Element, aFlags: u32): boolean;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIGeckoViewServiceWorker.idl

interface nsIGeckoViewServiceWorker extends nsISupports {
  openWindow(uri: nsIURI, aOpenWindowInfo: nsIOpenWindowInfo): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIPermissionDelegateHandler.idl

interface nsIPermissionDelegateHandler extends nsISupports {
  maybeUnsafePermissionDelegate(aTypes: string[]): boolean;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIQueryContentEventResult.idl

interface nsIQueryContentEventResult extends nsISupports {
  readonly offset: u32;
  readonly tentativeCaretOffset: u32;
  readonly reversed: boolean;
  readonly left: i32;
  readonly top: i32;
  readonly width: i32;
  readonly height: i32;
  readonly text: string;
  getCharacterRect(offset: i32, left: OutParam<i32>, top: OutParam<i32>, width: OutParam<i32>, height: OutParam<i32>): void;
  readonly succeeded: boolean;
  readonly notFound: boolean;
  readonly tentativeCaretOffsetNotFound: boolean;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIRemoteTab.idl

}  // global

declare enum nsIRemoteTab_NavigationType {
  NAVIGATE_BACK = 0,
  NAVIGATE_FORWARD = 1,
  NAVIGATE_INDEX = 2,
  NAVIGATE_URL = 3,
}

declare global {

namespace nsIRemoteTab {
  type NavigationType = nsIRemoteTab_NavigationType;
}

interface nsIRemoteTab extends nsISupports, Enums<typeof nsIRemoteTab_NavigationType> {
  renderLayers: boolean;
  readonly hasLayers: boolean;
  priorityHint: boolean;
  deprioritize(): void;
  preserveLayers(aPreserveLayers: boolean): void;
  readonly tabId: u64;
  readonly contentProcessId: u64;
  readonly osPid: i32;
  readonly browsingContext: BrowsingContext;
  readonly hasPresented: boolean;
  transmitPermissionsForPrincipal(aPrincipal: nsIPrincipal): void;
  createAboutBlankDocumentViewer(aPrincipal: nsIPrincipal, aPartitionedPrincipal: nsIPrincipal): void;
  maybeCancelContentJSExecution(aNavigationType: nsIRemoteTab.NavigationType, aCancelContentJSOptions?: any): void;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIServiceWorkerManager.idl

interface nsIServiceWorkerUnregisterCallback extends nsISupports {
  unregisterSucceeded(aState: boolean): void;
  unregisterFailed(): void;
}

interface nsIServiceWorkerInfo extends nsISupports {
  readonly STATE_PARSED?: 0;
  readonly STATE_INSTALLING?: 1;
  readonly STATE_INSTALLED?: 2;
  readonly STATE_ACTIVATING?: 3;
  readonly STATE_ACTIVATED?: 4;
  readonly STATE_REDUNDANT?: 5;
  readonly STATE_UNKNOWN?: 6;

  readonly id: string;
  readonly scriptSpec: string;
  readonly cacheName: string;
  readonly launchCount: u32;
  readonly state: u16;
  readonly debugger: nsIWorkerDebugger;
  readonly handlesFetchEvents: boolean;
  readonly installedTime: PRTime;
  readonly activatedTime: PRTime;
  readonly redundantTime: PRTime;
  readonly lifetimeDeadline: double;
  readonly navigationFaultCount: u32;
  testingInjectCancellation: nsresult;
  attachDebugger(): void;
  detachDebugger(): void;
  terminateWorker(): Promise<any>;
}

interface nsIServiceWorkerRegistrationInfoListener extends nsISupports {
  onChange(): void;
}

interface nsIServiceWorkerRegistrationInfo extends nsISupports {
  readonly UPDATE_VIA_CACHE_IMPORTS?: 0;
  readonly UPDATE_VIA_CACHE_ALL?: 1;
  readonly UPDATE_VIA_CACHE_NONE?: 2;

  readonly principal: nsIPrincipal;
  readonly unregistered: boolean;
  readonly scope: string;
  readonly scriptSpec: string;
  readonly updateViaCache: u16;
  readonly lastUpdateTime: PRTime;
  readonly evaluatingWorker: nsIServiceWorkerInfo;
  readonly installingWorker: nsIServiceWorkerInfo;
  readonly waitingWorker: nsIServiceWorkerInfo;
  readonly activeWorker: nsIServiceWorkerInfo;
  readonly quotaUsageCheckCount: i32;
  getWorkerByID(aID: u64): nsIServiceWorkerInfo;
  addListener(listener: nsIServiceWorkerRegistrationInfoListener): void;
  removeListener(listener: nsIServiceWorkerRegistrationInfoListener): void;
  forceShutdown(): void;
}

interface nsIServiceWorkerManagerListener extends nsISupports {
  onRegister(aInfo: nsIServiceWorkerRegistrationInfo): void;
  onUnregister(aInfo: nsIServiceWorkerRegistrationInfo): void;
  onQuotaUsageCheckFinish(aInfo: nsIServiceWorkerRegistrationInfo): void;
}

interface nsIServiceWorkerManager extends nsISupports {
  reloadRegistrationsForTest(): void;
  registerForTest(aPrincipal: nsIPrincipal, aScope: string, aScriptURL: string): Promise<any>;
  registerForAddonPrincipal(aPrincipal: nsIPrincipal): Promise<any>;
  getRegistrationForAddonPrincipal(aPrincipal: nsIPrincipal): nsIServiceWorkerRegistrationInfo;
  wakeForExtensionAPIEvent(aExtensionBaseURL: string, aAPINamespace: string, aAPIEventName: string): Promise<any>;
  unregister(aPrincipal: nsIPrincipal, aCallback: nsIServiceWorkerUnregisterCallback, aScope: string): void;
  getRegistrationByPrincipal(aPrincipal: nsIPrincipal, aScope: string): nsIServiceWorkerRegistrationInfo;
  getScopeForUrl(aPrincipal: nsIPrincipal, aPath: string): string;
  getAllRegistrations(): nsIArray;
  removeRegistrationsByOriginAttributes(aOriginAttributes: string): void;
  propagateUnregister(aPrincipal: nsIPrincipal, aCallback: nsIServiceWorkerUnregisterCallback, aScope: string): void;
  sendPushEvent(aOriginAttributes: string, aScope: string, aDataBytes?: u8[]): void;
  sendPushSubscriptionChangeEvent(aOriginAttributes: string, scope: string, aOldSubscription?: nsIPushSubscription): void;
  addListener(aListener: nsIServiceWorkerManagerListener): void;
  removeListener(aListener: nsIServiceWorkerManagerListener): void;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsIStructuredCloneContainer.idl

interface nsIStructuredCloneContainer extends nsISupports {
  initFromBase64(aData: string, aFormatVersion: u32): void;
  deserializeToJsval(): any;
  getDataAsBase64(): string;
  readonly serializedNBytes: u64;
  readonly formatVersion: u32;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsITextInputProcessor.idl

interface nsITextInputProcessor extends nsISupports {
  readonly ATTR_RAW_CLAUSE?: 2;
  readonly ATTR_SELECTED_RAW_CLAUSE?: 3;
  readonly ATTR_CONVERTED_CLAUSE?: 4;
  readonly ATTR_SELECTED_CLAUSE?: 5;
  readonly KEY_DEFAULT_PREVENTED?: 1;
  readonly KEY_NON_PRINTABLE_KEY?: 2;
  readonly KEY_FORCE_PRINTABLE_KEY?: 4;
  readonly KEY_KEEP_KEY_LOCATION_STANDARD?: 8;
  readonly KEY_KEEP_KEYCODE_ZERO?: 16;
  readonly KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT?: 32;
  readonly KEY_DONT_MARK_KEYDOWN_AS_PROCESSED?: 64;
  readonly KEY_MARK_KEYUP_AS_PROCESSED?: 128;
  readonly KEYEVENT_NOT_CONSUMED?: 0;
  readonly KEYDOWN_IS_CONSUMED?: 1;
  readonly KEYPRESS_IS_CONSUMED?: 2;

  readonly hasComposition: boolean;
  beginInputTransaction(aWindow: mozIDOMWindow, aCallback: nsITextInputProcessorCallback): boolean;
  beginInputTransactionForTests(aWindow: mozIDOMWindow, aCallback?: nsITextInputProcessorCallback): boolean;
  startComposition(aKeyboardEvent?: Event, aKeyFlags?: u32): boolean;
  setPendingCompositionString(aString: string): void;
  appendClauseToPendingComposition(aLength: u32, aAttribute: u32): void;
  setCaretInPendingComposition(aOffset: u32): void;
  flushPendingComposition(aKeyboardEvent?: Event, aKeyFlags?: u32): boolean;
  commitComposition(aKeyboardEvent?: Event, aKeyFlags?: u32): void;
  commitCompositionWith(aCommitString: string, aKeyboardEvent?: Event, aKeyFlags?: u32): boolean;
  cancelComposition(aKeyboardEvent?: Event, aKeyFlags?: u32): void;
  keydown(aKeyboardEvent: Event, aKeyFlags?: u32): u32;
  keyup(aKeyboardEvent: Event, aKeyFlags?: u32): boolean;
  insertTextWithKeyPress(aString: string, aKeyboardEvent?: Event, aKeyFlags?: u32): boolean;
  getModifierState(aModifierKey: string): boolean;
  shareModifierStateOf(aOther: nsITextInputProcessor): void;
  computeCodeValueOfNonPrintableKey(aKeyValue: string, aLocation?: any): string;
  guessCodeValueOfPrintableKeyInUSEnglishKeyboardLayout(aKeyValue: string, aLocation?: any): string;
  guessKeyCodeValueOfPrintableKeyInUSEnglishKeyboardLayout(aKeyValue: string, aLocation?: any): u32;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/base/nsITextInputProcessorCallback.idl

interface nsITextInputProcessorNotification extends nsISupports {
  readonly type: string;
  readonly hasRange: boolean;
  readonly offset: u32;
  readonly text: string;
  readonly collapsed: boolean;
  readonly length: u32;
  readonly reversed: boolean;
  readonly writingMode: string;
  readonly causedByComposition: boolean;
  readonly causedBySelectionEvent: boolean;
  readonly occurredDuringComposition: boolean;
  readonly removedLength: u32;
  readonly addedLength: u32;
  readonly causedOnlyByComposition: boolean;
  readonly includingChangesDuringComposition: boolean;
  readonly includingChangesWithoutComposition: boolean;
}

type nsITextInputProcessorCallback = Callable<{
  onNotify(aTextInputProcessor: nsITextInputProcessor, aNotification: nsITextInputProcessorNotification): boolean;
}>

// https://searchfox.org/mozilla-central/source/dom/bindings/nsIScriptError.idl

interface nsIScriptErrorNote extends nsISupports {
  readonly errorMessage: string;
  readonly sourceName: string;
  readonly sourceId: u32;
  readonly lineNumber: u32;
  readonly columnNumber: u32;
  toString(): string;
}

interface nsIScriptError extends nsIConsoleMessage {
  readonly errorFlag?: 0;
  readonly warningFlag?: 1;
  readonly infoFlag?: 8;

  readonly errorMessage: string;
  readonly sourceName: string;
  readonly sourceId: u32;
  readonly lineNumber: u32;
  readonly columnNumber: u32;
  readonly flags: u32;
  readonly category: string;
  readonly outerWindowID: u64;
  readonly innerWindowID: u64;
  readonly isFromPrivateWindow: boolean;
  readonly isFromChromeContext: boolean;
  readonly isPromiseRejection: boolean;
  exception: any;
  readonly hasException: boolean;
  stack: any;
  errorMessageName: string;
  readonly notes: nsIArray;
  cssSelectors: string;
  init(message: string, sourceName: string, lineNumber: u32, columnNumber: u32, flags: u32, category: string, fromPrivateWindow?: boolean, fromChromeContext?: boolean): void;
  initWithWindowID(message: string, sourceName: string, lineNumber: u32, columnNumber: u32, flags: u32, category: string, innerWindowID: u64, fromChromeContext?: boolean): void;
  initWithSanitizedSource(message: string, sourceName: string, lineNumber: u32, columnNumber: u32, flags: u32, category: string, innerWindowID: u64, fromChromeContext?: boolean): void;
  initWithSourceURI(message: string, sourceURI: nsIURI, lineNumber: u32, columnNumber: u32, flags: u32, category: string, innerWindowID: u64, fromChromeContext?: boolean): void;
  initSourceId(sourceId: u32): void;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/events/nsIDOMEventListener.idl

// https://searchfox.org/mozilla-central/source/dom/interfaces/geolocation/nsIDOMGeoPosition.idl

interface nsIDOMGeoPosition extends nsISupports {
  readonly timestamp: EpochTimeStamp;
  readonly coords: nsIDOMGeoPositionCoords;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/geolocation/nsIDOMGeoPositionCallback.idl

type nsIDOMGeoPositionCallback = Callable<{
  handleEvent(position: nsIDOMGeoPosition): void;
}>

// https://searchfox.org/mozilla-central/source/dom/interfaces/geolocation/nsIDOMGeoPositionCoords.idl

interface nsIDOMGeoPositionCoords extends nsISupports {
  readonly latitude: double;
  readonly longitude: double;
  readonly altitude: double;
  readonly accuracy: double;
  readonly altitudeAccuracy: double;
  readonly heading: double;
  readonly speed: double;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/geolocation/nsIDOMGeoPositionErrorCallback.idl

type nsIDOMGeoPositionErrorCallback = Callable<{
  handleEvent(positionError: GeolocationPositionError): void;
}>

// https://searchfox.org/mozilla-central/source/toolkit/components/credentialmanagement/nsICredentialChooserService.idl

interface nsICredentialChooserService extends nsISupports {
  showCredentialChooser(browsingContext: BrowsingContext, credentials: any[], callback: nsICredentialChosenCallback): void;
  cancelCredentialChooser(browsingContext: BrowsingContext): void;
  fetchImageToDataURI(window: mozIDOMWindow, uri: nsIURI): Promise<any>;
  fetchWellKnown(uri: nsIURI, triggeringPrincipal: nsIPrincipal): Promise<any>;
  fetchConfig(uri: nsIURI, triggeringPrincipal: nsIPrincipal): Promise<any>;
  fetchAccounts(uri: nsIURI, triggeringPrincipal: nsIPrincipal): Promise<any>;
  fetchToken(uri: nsIURI, body: string, triggeringPrincipal: nsIPrincipal): Promise<any>;
  fetchDisconnect(uri: nsIURI, body: string, triggeringPrincipal: nsIPrincipal): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/credentialmanagement/nsICredentialChosenCallback.idl

type nsICredentialChosenCallback = Callable<{
  notify(aChosenID: string): void;
}>

// https://searchfox.org/mozilla-central/source/toolkit/components/credentialmanagement/nsIIdentityCredentialPromptService.idl

interface nsIIdentityCredentialPromptService extends nsISupports {
  showProviderPrompt(browsingContext: BrowsingContext, identityProviders: any, identityManifests: any): Promise<any>;
  showAccountListPrompt(browsingContext: BrowsingContext, accountList: any, identityProvider: any, identityManifest: any): Promise<any>;
  close(browsingContext: BrowsingContext): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/credentialmanagement/nsIIdentityCredentialStorageService.idl

interface nsIIdentityCredentialStorageService extends nsISupports {
  setState(rpPrincipal: nsIPrincipal, idpPrincipal: nsIPrincipal, credentialID: string, registered: boolean, allowLogout: boolean): void;
  getState(rpPrincipal: nsIPrincipal, idpPrincipal: nsIPrincipal, credentialID: string, registered: OutParam<boolean>, allowLogout: OutParam<boolean>): void;
  delete(rpPrincipal: nsIPrincipal, idpPrincipal: nsIPrincipal, credentialID: string): void;
  connected(rpPrincipal: nsIPrincipal, idpPrincipal: nsIPrincipal, connected: OutParam<boolean>): void;
  disconnect(rpPrincipal: nsIPrincipal, idpPrincipal: nsIPrincipal): void;
  clear(): void;
  deleteFromBaseDomain(baseDomain: string): void;
  deleteFromPrincipal(rpPrincipal: nsIPrincipal): void;
  deleteFromTimeRange(aFrom: PRTime, aTo: PRTime): void;
  deleteFromOriginAttributesPattern(aPattern: string): void;
}

// https://searchfox.org/mozilla-central/source/dom/indexedDB/nsIIDBPermissionsRequest.idl

interface nsIIDBPermissionsRequest extends nsISupports {
  readonly browserElement: Element;
  readonly responseObserver: nsIObserver;
}

// https://searchfox.org/mozilla-central/source/dom/indexedDB/nsIIndexedDatabaseManager.idl

interface nsIIndexedDatabaseManager extends nsISupports {
  doMaintenance(): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/dom/localstorage/nsILocalStorageManager.idl

interface nsILocalStorageManager extends nsISupports {
  readonly nextGenLocalStorageEnabled: boolean;
  preload(aPrincipal: nsIPrincipal): Promise<any>;
  isPreloaded(aPrincipal: nsIPrincipal): Promise<any>;
  getState(aPrincipal: nsIPrincipal): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/dom/media/nsIAudioDeviceInfo.idl

interface nsIAudioDeviceInfo extends nsISupports {
  readonly TYPE_UNKNOWN?: 0;
  readonly TYPE_INPUT?: 1;
  readonly TYPE_OUTPUT?: 2;
  readonly STATE_DISABLED?: 0;
  readonly STATE_UNPLUGGED?: 1;
  readonly STATE_ENABLED?: 2;
  readonly PREF_NONE?: 0;
  readonly PREF_MULTIMEDIA?: 1;
  readonly PREF_VOICE?: 2;
  readonly PREF_NOTIFICATION?: 4;
  readonly PREF_ALL?: 15;
  readonly FMT_S16LE?: 16;
  readonly FMT_S16BE?: 32;
  readonly FMT_F32LE?: 4096;
  readonly FMT_F32BE?: 8192;

  readonly name: string;
  readonly groupId: string;
  readonly vendor: string;
  readonly type: u16;
  readonly state: u16;
  readonly preferred: u16;
  readonly supportedFormat: u16;
  readonly defaultFormat: u16;
  readonly maxChannels: u32;
  readonly defaultRate: u32;
  readonly maxRate: u32;
  readonly minRate: u32;
  readonly maxLatency: u32;
  readonly minLatency: u32;
}

// https://searchfox.org/mozilla-central/source/dom/media/nsIMediaDevice.idl

interface nsIMediaDevice extends nsISupports {
  readonly type: string;
  readonly mediaSource: string;
  readonly rawId: string;
  readonly id: string;
  readonly scary: boolean;
  readonly canRequestOsLevelPrompt: boolean;
  readonly rawName: string;
}

// https://searchfox.org/mozilla-central/source/dom/media/nsIMediaManager.idl

interface nsIMediaManagerService extends nsISupports {
  readonly STATE_NOCAPTURE?: 0;
  readonly STATE_CAPTURE_ENABLED?: 1;
  readonly STATE_CAPTURE_DISABLED?: 2;

  readonly activeMediaCaptureWindows: nsIArray;
  mediaCaptureWindowState(aWindow: nsIDOMWindow, aCamera: OutParam<u16>, aMicrophone: OutParam<u16>, aScreenShare: OutParam<u16>, aWindowShare: OutParam<u16>, aBrowserShare: OutParam<u16>, devices: OutParam<nsIMediaDevice[]>): void;
  sanitizeDeviceIds(sinceWhen: i64): void;
}

// https://searchfox.org/mozilla-central/source/dom/network/interfaces/nsITCPSocketCallback.idl

interface nsITCPSocketCallback extends nsISupports {
  readonly BUFFER_SIZE?: 65536;

  fireErrorEvent(name: string, type: string, errorCode: nsresult): void;
  fireDataStringEvent(type: string, data: string): void;
  fireDataArrayEvent(type: string, data: u8[]): void;
  fireEvent(type: string): void;
  updateReadyState(readystate: u32): void;
  updateBufferedAmount(bufferedAmount: u32, trackingNumber: u32): void;
}

// https://searchfox.org/mozilla-central/source/dom/network/interfaces/nsIUDPSocketChild.idl

interface nsIUDPSocketInternal extends nsISupports {
  callListenerOpened(): void;
  callListenerConnected(): void;
  callListenerClosed(): void;
  callListenerReceivedData(host: string, port: u16, data: u8[]): void;
  callListenerError(message: string, filename: string, lineNumber: u32): void;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/notification/nsINotificationStorage.idl

interface nsINotificationActionStorageEntry extends nsISupports {
  readonly name: string;
  readonly title: string;
}

interface nsINotificationStorageEntry extends nsISupports {
  readonly id: string;
  readonly title: string;
  readonly dir: string;
  readonly lang: string;
  readonly body: string;
  readonly tag: string;
  readonly icon: string;
  readonly requireInteraction: boolean;
  readonly silent: boolean;
  readonly dataSerialized: string;
  readonly actions: nsINotificationActionStorageEntry[];
}

type nsINotificationStorageCallback = Callable<{
  done(aEntries: nsINotificationStorageEntry[]): void;
}>

interface nsINotificationStorage extends nsISupports {
  put(aOrigin: string, aEntry: nsINotificationStorageEntry, aScope: string): void;
  get(origin: string, scope: string, tag: string, aCallback: nsINotificationStorageCallback): void;
  delete(origin: string, id: string): void;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/payments/nsIPaymentActionResponse.idl

interface nsIPaymentResponseData extends nsISupports {
  readonly GENERAL_RESPONSE?: 0;
  readonly BASICCARD_RESPONSE?: 1;

  readonly type: u32;
  init(aType: u32): void;
}

interface nsIGeneralResponseData extends nsIPaymentResponseData {
  readonly data: string;
  initData(aData: any): void;
}

interface nsIBasicCardResponseData extends nsIPaymentResponseData {
  readonly cardholderName: string;
  readonly cardNumber: string;
  readonly expiryMonth: string;
  readonly expiryYear: string;
  readonly cardSecurityCode: string;
  readonly billingAddress: nsIPaymentAddress;
  initData(aCardholderName: string, aCardNumber: string, aExpiryMonth: string, aExpiryYear: string, aCardSecurityCode: string, billingAddress: nsIPaymentAddress): void;
}

interface nsIPaymentActionResponse extends nsISupports {
  readonly NO_TYPE?: 0;
  readonly CANMAKE_ACTION?: 2;
  readonly SHOW_ACTION?: 3;
  readonly ABORT_ACTION?: 4;
  readonly COMPLETE_ACTION?: 5;
  readonly ABORT_SUCCEEDED?: 1;
  readonly ABORT_FAILED?: 0;
  readonly PAYMENT_REJECTED?: 0;
  readonly PAYMENT_ACCEPTED?: 1;
  readonly PAYMENT_NOTSUPPORTED?: 2;
  readonly COMPLETE_SUCCEEDED?: 1;
  readonly COMPLETE_FAILED?: 0;

  readonly requestId: string;
  readonly type: u32;
}

interface nsIPaymentCanMakeActionResponse extends nsIPaymentActionResponse {
  readonly result: boolean;
  init(aRequestId: string, aResult: boolean): void;
}

interface nsIPaymentShowActionResponse extends nsIPaymentActionResponse {
  readonly acceptStatus: u32;
  readonly methodName: string;
  readonly data: nsIPaymentResponseData;
  readonly payerName: string;
  readonly payerEmail: string;
  readonly payerPhone: string;
  init(aRequestId: string, aAcceptStatus: u32, aMethodName: string, aData: nsIPaymentResponseData, aPayerName: string, aPayerEmail: string, aPayerPhone: string): void;
}

interface nsIPaymentAbortActionResponse extends nsIPaymentActionResponse {
  readonly abortStatus: u32;
  init(aRequestId: string, aAbortStatus: u32): void;
  isSucceeded(): boolean;
}

interface nsIPaymentCompleteActionResponse extends nsIPaymentActionResponse {
  readonly completeStatus: u32;
  init(aRequestId: string, aCompleteStatus: u32): void;
  isCompleted(): boolean;
}

interface nsIMethodChangeDetails extends nsISupports {
  readonly GENERAL_DETAILS?: 0;
  readonly BASICCARD_DETAILS?: 1;

  readonly type: u32;
  init(aType: u32): void;
}

interface nsIGeneralChangeDetails extends nsIMethodChangeDetails {
  readonly details: string;
  initData(aDetails: any): void;
}

interface nsIBasicCardChangeDetails extends nsIMethodChangeDetails {
  readonly billingAddress: nsIPaymentAddress;
  initData(billingAddress: nsIPaymentAddress): void;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/payments/nsIPaymentAddress.idl

interface nsIPaymentAddress extends nsISupports {
  readonly country: string;
  readonly addressLine: nsIArray;
  readonly region: string;
  readonly regionCode: string;
  readonly city: string;
  readonly dependentLocality: string;
  readonly postalCode: string;
  readonly sortingCode: string;
  readonly organization: string;
  readonly recipient: string;
  readonly phone: string;
  init(aCountry: string, aAddressLine: nsIArray, aRegion: string, aRegionCode: string, aCity: string, aDependentLocality: string, aPostalCode: string, aSortingCode: string, aOrganization: string, aRecipient: string, aPhone: string): void;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/payments/nsIPaymentRequest.idl

interface nsIPaymentMethodData extends nsISupports {
  readonly supportedMethods: string;
  readonly data: any;
}

interface nsIPaymentCurrencyAmount extends nsISupports {
  readonly currency: string;
  readonly value: string;
}

interface nsIPaymentItem extends nsISupports {
  readonly label: string;
  readonly amount: nsIPaymentCurrencyAmount;
  readonly pending: boolean;
}

interface nsIPaymentDetailsModifier extends nsISupports {
  readonly supportedMethods: string;
  readonly total: nsIPaymentItem;
  readonly additionalDisplayItems: nsIArray;
  readonly data: any;
}

interface nsIPaymentShippingOption extends nsISupports {
  readonly id: string;
  readonly label: string;
  readonly amount: nsIPaymentCurrencyAmount;
  selected: boolean;
}

interface nsIPaymentDetails extends nsISupports {
  readonly id: string;
  readonly totalItem: nsIPaymentItem;
  readonly displayItems: nsIArray;
  readonly shippingOptions: nsIArray;
  readonly modifiers: nsIArray;
  readonly error: string;
  readonly shippingAddressErrors: any;
  readonly payerErrors: any;
  readonly paymentMethodErrors: any;
}

interface nsIPaymentOptions extends nsISupports {
  readonly requestPayerName: boolean;
  readonly requestPayerEmail: boolean;
  readonly requestPayerPhone: boolean;
  readonly requestShipping: boolean;
  readonly requestBillingAddress: boolean;
  readonly shippingType: string;
}

interface nsIPaymentRequest extends nsISupports {
  readonly topOuterWindowId: u64;
  readonly topLevelPrincipal: nsIPrincipal;
  readonly requestId: string;
  readonly completeStatus: string;
  readonly paymentMethods: nsIArray;
  readonly paymentDetails: nsIPaymentDetails;
  readonly paymentOptions: nsIPaymentOptions;
  readonly shippingOption: string;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/payments/nsIPaymentRequestService.idl

interface nsIPaymentRequestService extends nsISupports {
  getPaymentRequestById(aRequestId: string): nsIPaymentRequest;
  enumerate(): nsISimpleEnumerator;
  respondPayment(aResponse: nsIPaymentActionResponse): void;
  changeShippingAddress(requestId: string, aAddress: nsIPaymentAddress): void;
  changeShippingOption(requestId: string, option: string): void;
  changePayerDetail(requestId: string, aPayerName: string, aPayerEmail: string, aPayerPhone: string): void;
  changePaymentMethod(requestId: string, aMethodName: string, aMethodDetails: nsIMethodChangeDetails): void;
  cleanup(): void;
  setTestingUIService(aUIService: nsIPaymentUIService): void;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/payments/nsIPaymentUIService.idl

interface nsIPaymentUIService extends nsISupports {
  showPayment(requestId: string): void;
  abortPayment(requestId: string): void;
  completePayment(requestId: string): void;
  updatePayment(requestId: string): void;
  closePayment(requestId: string): void;
}

// https://searchfox.org/mozilla-central/source/dom/power/nsIDOMWakeLockListener.idl

type nsIDOMMozWakeLockListener = Callable<{
  callback(aTopic: string, aState: string): void;
}>

// https://searchfox.org/mozilla-central/source/dom/power/nsIPowerManagerService.idl

interface nsIPowerManagerService extends nsISupports {
  addWakeLockListener(aListener: nsIDOMMozWakeLockListener): void;
  removeWakeLockListener(aListener: nsIDOMMozWakeLockListener): void;
  getWakeLockState(aTopic: string): string;
  newWakeLock(aTopic: string, aWindow?: mozIDOMWindow): nsIWakeLock;
}

// https://searchfox.org/mozilla-central/source/dom/power/nsIWakeLock.idl

interface nsIWakeLock extends nsISupports {
  unlock(): void;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/push/nsIPushErrorReporter.idl

interface nsIPushErrorReporter extends nsISupports {
  readonly ACK_DELIVERED?: 0;
  readonly ACK_DECRYPTION_ERROR?: 1;
  readonly ACK_NOT_DELIVERED?: 2;
  readonly UNSUBSCRIBE_MANUAL?: 3;
  readonly UNSUBSCRIBE_QUOTA_EXCEEDED?: 4;
  readonly UNSUBSCRIBE_PERMISSION_REVOKED?: 5;
  readonly DELIVERY_UNCAUGHT_EXCEPTION?: 6;
  readonly DELIVERY_UNHANDLED_REJECTION?: 7;
  readonly DELIVERY_INTERNAL_ERROR?: 8;

  reportDeliveryError(messageId: string, reason?: u16): void;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/push/nsIPushNotifier.idl

interface nsIPushNotifier extends nsISupports {
  notifyPush(scope: string, principal: nsIPrincipal, messageId: string): void;
  notifyPushWithData(scope: string, principal: nsIPrincipal, messageId: string, data: u8[]): void;
  notifySubscriptionChange(scope: string, principal: nsIPrincipal, oldSubscription?: nsIPushSubscription): void;
  notifySubscriptionModified(scope: string, principal: nsIPrincipal): void;
  notifyError(scope: string, principal: nsIPrincipal, message: string, flags: u32): void;
}

interface nsIPushData extends nsISupports {
  text(): string;
  json(): any;
  binary(): u8[];
}

interface nsIPushMessage extends nsISupports {
  readonly principal: nsIPrincipal;
  readonly data: nsIPushData;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/push/nsIPushService.idl

interface nsIPushSubscription extends nsISupports {
  readonly endpoint: string;
  readonly pushCount: i64;
  readonly lastPush: i64;
  readonly quota: i32;
  readonly isSystemSubscription: boolean;
  readonly p256dhPrivateKey: any;
  quotaApplies(): boolean;
  isExpired(): boolean;
  getKey(name: string): u8[];
}

type nsIPushSubscriptionCallback = Callable<{
  onPushSubscription(status: nsresult, subscription: nsIPushSubscription): void;
}>

type nsIUnsubscribeResultCallback = Callable<{
  onUnsubscribe(status: nsresult, success: boolean): void;
}>

type nsIPushClearResultCallback = Callable<{
  onClear(status: nsresult): void;
}>

interface nsIPushService extends nsISupports {
  readonly pushTopic: string;
  readonly subscriptionChangeTopic: string;
  readonly subscriptionModifiedTopic: string;
  subscribe(scope: string, principal: nsIPrincipal, callback: nsIPushSubscriptionCallback): void;
  subscribeWithKey(scope: string, principal: nsIPrincipal, key: u8[], callback: nsIPushSubscriptionCallback): void;
  unsubscribe(scope: string, principal: nsIPrincipal, callback: nsIUnsubscribeResultCallback): void;
  getSubscription(scope: string, principal: nsIPrincipal, callback: nsIPushSubscriptionCallback): void;
  clearForDomain(domain: string, originAttributesPattern: any, callback: nsIPushClearResultCallback): void;
  clearForPrincipal(principal: nsIPrincipal, callback: nsIPushClearResultCallback): void;
}

interface nsIPushQuotaManager extends nsISupports {
  notificationForOriginShown(origin: string): void;
  notificationForOriginClosed(origin: string): void;
}

// https://searchfox.org/mozilla-central/source/dom/quota/nsIQuotaArtificialFailure.idl

}  // global

declare enum nsIQuotaArtificialFailure_Category {
  CATEGORY_NONE = 0,
  CATEGORY_INITIALIZE_ORIGIN = 1,
  CATEGORY_OPEN_CLIENT_DIRECTORY = 2,
  CATEGORY_CREATE_DIRECTORY_METADATA2 = 4,
}

declare global {

namespace nsIQuotaArtificialFailure {
  type Category = nsIQuotaArtificialFailure_Category;
}

interface nsIQuotaArtificialFailure extends nsISupports, Enums<typeof nsIQuotaArtificialFailure_Category> {
}

// https://searchfox.org/mozilla-central/source/dom/quota/nsIQuotaCallbacks.idl

type nsIQuotaUsageCallback = Callable<{
  onUsageResult(aRequest: nsIQuotaUsageRequest): void;
}>

type nsIQuotaCallback = Callable<{
  onComplete(aRequest: nsIQuotaRequest): void;
}>

// https://searchfox.org/mozilla-central/source/dom/quota/nsIQuotaManagerService.idl

interface nsIQuotaManagerService extends nsISupports {
  storageName(): nsIQuotaRequest;
  storageInitialized(): nsIQuotaRequest;
  persistentStorageInitialized(): nsIQuotaRequest;
  temporaryStorageInitialized(): nsIQuotaRequest;
  temporaryGroupInitialized(aPrincipal: nsIPrincipal): nsIQuotaRequest;
  persistentOriginInitialized(aPrincipal: nsIPrincipal): nsIQuotaRequest;
  temporaryOriginInitialized(aPersistenceType: string, aPrincipal: nsIPrincipal): nsIQuotaRequest;
  init(): nsIQuotaRequest;
  initializePersistentStorage(): nsIQuotaRequest;
  initTemporaryStorage(): nsIQuotaRequest;
  initializeAllTemporaryOrigins(): nsIQuotaRequest;
  initializeTemporaryGroup(aPrincipal: nsIPrincipal): nsIQuotaRequest;
  initializePersistentOrigin(aPrincipal: nsIPrincipal): nsIQuotaRequest;
  initializeTemporaryOrigin(aPersistenceType: string, aPrincipal: nsIPrincipal, aCreateIfNonExistent?: boolean): nsIQuotaRequest;
  initializePersistentClient(aPrincipal: nsIPrincipal, aClientType: string): nsIQuotaRequest;
  initializeTemporaryClient(aPersistenceType: string, aPrincipal: nsIPrincipal, aClientType: string, aCreateIfNonExistent?: boolean): nsIQuotaRequest;
  getFullOriginMetadata(aPersistenceType: string, aPrincipal: nsIPrincipal): nsIQuotaRequest;
  getUsage(aCallback: nsIQuotaUsageCallback, aGetAll?: boolean): nsIQuotaUsageRequest;
  getUsageForPrincipal(aPrincipal: nsIPrincipal, aCallback: nsIQuotaUsageCallback): nsIQuotaUsageRequest;
  getCachedUsageForPrincipal(aPrincipal: nsIPrincipal): nsIQuotaRequest;
  listOrigins(): nsIQuotaRequest;
  listCachedOrigins(): nsIQuotaRequest;
  clear(): nsIQuotaRequest;
  clearStoragesForPrivateBrowsing(): nsIQuotaRequest;
  clearStoragesForOriginAttributesPattern(aPattern: string): nsIQuotaRequest;
  clearStoragesForPrincipal(aPrincipal: nsIPrincipal, aPersistenceType?: string): nsIQuotaRequest;
  clearStoragesForClient(aPrincipal: nsIPrincipal, aClientType: string, aPersistenceType?: string): nsIQuotaRequest;
  clearStoragesForOriginPrefix(aPrincipal: nsIPrincipal, aPersistenceType?: string): nsIQuotaRequest;
  reset(): nsIQuotaRequest;
  resetStoragesForPrincipal(aPrincipal: nsIPrincipal, aPersistenceType?: string): nsIQuotaRequest;
  resetStoragesForClient(aPrincipal: nsIPrincipal, aClientType: string, aPersistenceType?: string): nsIQuotaRequest;
  persisted(aPrincipal: nsIPrincipal): nsIQuotaRequest;
  persist(aPrincipal: nsIPrincipal): nsIQuotaRequest;
  estimate(aPrincipal: nsIPrincipal): nsIQuotaRequest;
}

// https://searchfox.org/mozilla-central/source/dom/quota/nsIQuotaManagerServiceInternal.idl

interface nsIQuotaManagerServiceInternal extends nsISupports {
  setThumbnailPrivateIdentityId(aThumbnailPrivateIdentityId: u32): void;
}

// https://searchfox.org/mozilla-central/source/dom/quota/nsIQuotaRequests.idl

interface nsIQuotaRequestBase extends nsISupports {
  readonly principal: nsIPrincipal;
  readonly resultCode: nsresult;
  readonly resultName: string;
}

interface nsIQuotaUsageRequest extends nsIQuotaRequestBase {
  readonly result: nsIVariant;
  callback: nsIQuotaUsageCallback;
  cancel(): void;
}

interface nsIQuotaRequest extends nsIQuotaRequestBase {
  readonly result: nsIVariant;
  callback: nsIQuotaCallback;
}

// https://searchfox.org/mozilla-central/source/dom/quota/nsIQuotaResults.idl

interface nsIQuotaFullOriginMetadataResult extends nsISupports {
  readonly suffix: string;
  readonly group: string;
  readonly origin: string;
  readonly storageOrigin: string;
  readonly persistenceType: string;
  readonly persisted: boolean;
  readonly lastAccessTime: i64;
}

interface nsIQuotaUsageResult extends nsISupports {
  readonly origin: string;
  readonly persisted: boolean;
  readonly usage: u64;
  readonly lastAccessed: u64;
}

interface nsIQuotaOriginUsageResult extends nsISupports {
  readonly databaseUsage: u64;
  readonly fileUsage: u64;
  readonly usage: u64;
  readonly databaseUsageIsExplicit: boolean;
  readonly fileUsageIsExplicit: boolean;
  readonly totalUsageIsExplicit: boolean;
}

interface nsIQuotaEstimateResult extends nsISupports {
  readonly usage: u64;
  readonly limit: u64;
}

// https://searchfox.org/mozilla-central/source/dom/quota/nsIQuotaUtilsService.idl

interface nsIQuotaUtilsService extends nsISupports {
  getPrivateIdentityId(aName: string): u32;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/security/nsIContentSecurityManager.idl

interface nsIContentSecurityManager extends nsISupports {
  performSecurityCheck(aChannel: nsIChannel, aStreamListener: nsIStreamListener): nsIStreamListener;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/security/nsIContentSecurityPolicy.idl

}  // global

declare enum nsIContentSecurityPolicy_CSPDirective {
  NO_DIRECTIVE = 0,
  DEFAULT_SRC_DIRECTIVE = 1,
  SCRIPT_SRC_DIRECTIVE = 2,
  OBJECT_SRC_DIRECTIVE = 3,
  STYLE_SRC_DIRECTIVE = 4,
  IMG_SRC_DIRECTIVE = 5,
  MEDIA_SRC_DIRECTIVE = 6,
  FRAME_SRC_DIRECTIVE = 7,
  FONT_SRC_DIRECTIVE = 8,
  CONNECT_SRC_DIRECTIVE = 9,
  REPORT_URI_DIRECTIVE = 10,
  FRAME_ANCESTORS_DIRECTIVE = 11,
  REFLECTED_XSS_DIRECTIVE = 12,
  BASE_URI_DIRECTIVE = 13,
  FORM_ACTION_DIRECTIVE = 14,
  WEB_MANIFEST_SRC_DIRECTIVE = 15,
  UPGRADE_IF_INSECURE_DIRECTIVE = 16,
  CHILD_SRC_DIRECTIVE = 17,
  BLOCK_ALL_MIXED_CONTENT = 18,
  SANDBOX_DIRECTIVE = 19,
  WORKER_SRC_DIRECTIVE = 20,
  SCRIPT_SRC_ELEM_DIRECTIVE = 21,
  SCRIPT_SRC_ATTR_DIRECTIVE = 22,
  STYLE_SRC_ELEM_DIRECTIVE = 23,
  STYLE_SRC_ATTR_DIRECTIVE = 24,
  REQUIRE_TRUSTED_TYPES_FOR_DIRECTIVE = 25,
  TRUSTED_TYPES_DIRECTIVE = 26,
  REPORT_TO_DIRECTIVE = 27,
}

declare enum nsIContentSecurityPolicy_RequireTrustedTypesForDirectiveState {
  NONE = 0,
  REPORT_ONLY = 1,
  ENFORCE = 2,
}

declare global {

namespace nsIContentSecurityPolicy {
  type CSPDirective = nsIContentSecurityPolicy_CSPDirective;
  type RequireTrustedTypesForDirectiveState = nsIContentSecurityPolicy_RequireTrustedTypesForDirectiveState;
}

interface nsIContentSecurityPolicy extends nsISerializable, Enums<typeof nsIContentSecurityPolicy_CSPDirective & typeof nsIContentSecurityPolicy_RequireTrustedTypesForDirectiveState> {
  readonly VIOLATION_TYPE_EVAL?: 1;
  readonly VIOLATION_TYPE_WASM_EVAL?: 2;

  getPolicy(index: u32): string;
  readonly policyCount: u32;
  readonly upgradeInsecureRequests: boolean;
  readonly blockAllMixedContent: boolean;
  readonly enforcesFrameAncestors: boolean;
  appendPolicy(policyString: string, reportOnly: boolean, deliveredViaMetaTag: boolean): void;
  readonly requireTrustedTypesForDirectiveState: nsIContentSecurityPolicy.RequireTrustedTypesForDirectiveState;
  getAllowsInline(aDirective: nsIContentSecurityPolicy.CSPDirective, aHasUnsafeHash: boolean, aNonce: string, aParserCreated: boolean, aTriggeringElement: Element, aCSPEventListener: nsICSPEventListener, aContentOfPseudoScript: string, aLineNumber: u32, aColumnNumber: u32): boolean;
  getAllowsEval(shouldReportViolations: OutParam<boolean>): boolean;
  getAllowsWasmEval(shouldReportViolations: OutParam<boolean>): boolean;
  getCSPSandboxFlags(): u32;
  logViolationDetails(violationType: u16, triggeringElement: Element, aCSPEventListener: nsICSPEventListener, sourceFile: string, scriptSample: string, lineNum: i32, columnNum: i32, nonce?: string, content?: string): void;
  setRequestContextWithDocument(aDocument: Document): void;
  setRequestContextWithPrincipal(aRequestPrincipal: nsIPrincipal, aSelfURI: nsIURI, aReferrer: string, aInnerWindowId: u64): void;
  permitsAncestry(aLoadInfo: nsILoadInfo): boolean;
  permits(aTriggeringElement: Element, aCSPEventListener: nsICSPEventListener, aURI: nsIURI, aDir: nsIContentSecurityPolicy.CSPDirective, aSpecific: boolean, aSendViolationReports: boolean): boolean;
  shouldLoad(aContentType: nsContentPolicyType, aCSPEventListener: nsICSPEventListener, aLoadInfo: nsILoadInfo, aContentLocation: nsIURI, aOriginalURIIfRedirect: nsIURI, aSendViolationReports: boolean): i16;
  toJSON(): string;
}

type nsICSPEventListener = Callable<{
  onCSPViolationEvent(aJSON: string): void;
}>

// https://searchfox.org/mozilla-central/source/dom/interfaces/security/nsIReferrerInfo.idl

}  // global

declare enum nsIReferrerInfo_ReferrerPolicyIDL {
  EMPTY = 0,
  NO_REFERRER_WHEN_DOWNGRADE = 1,
  NO_REFERRER = 2,
  ORIGIN = 3,
  ORIGIN_WHEN_CROSS_ORIGIN = 4,
  UNSAFE_URL = 5,
  SAME_ORIGIN = 6,
  STRICT_ORIGIN = 7,
  STRICT_ORIGIN_WHEN_CROSS_ORIGIN = 8,
}

declare global {

namespace nsIReferrerInfo {
  type ReferrerPolicyIDL = nsIReferrerInfo_ReferrerPolicyIDL;
}

interface nsIReferrerInfo extends nsISerializable, Enums<typeof nsIReferrerInfo_ReferrerPolicyIDL> {
  readonly originalReferrer: nsIURI;
  readonly referrerPolicy: nsIReferrerInfo.ReferrerPolicyIDL;
  getReferrerPolicyString(): string;
  readonly sendReferrer: boolean;
  readonly computedReferrerSpec: string;
  equals(other: nsIReferrerInfo): boolean;
  init(aReferrerPolicy: nsIReferrerInfo.ReferrerPolicyIDL, aSendReferrer?: boolean, aOriginalReferrer?: nsIURI): void;
  initWithDocument(aDocument: Document): void;
  initWithElement(aNode: Element): void;
}

// https://searchfox.org/mozilla-central/source/dom/security/nsIHttpsOnlyModePermission.idl

interface nsIHttpsOnlyModePermission extends nsISupports {
  readonly LOAD_INSECURE_DEFAULT?: 0;
  readonly LOAD_INSECURE_ALLOW?: 1;
  readonly LOAD_INSECURE_BLOCK?: 2;
  readonly LOAD_INSECURE_ALLOW_SESSION?: 9;
  readonly HTTPSFIRST_LOAD_INSECURE_ALLOW?: 10;
}

// https://searchfox.org/mozilla-central/source/dom/serializers/nsIDocumentEncoder.idl

interface nsIDocumentEncoderNodeFixup extends nsISupports {
  fixupNode(aNode: Node, aSerializeCloneKids: OutParam<boolean>): Node;
}

interface nsIDocumentEncoder extends nsISupports {
  readonly OutputSelectionOnly?: 1;
  readonly OutputFormatted?: 2;
  readonly OutputRaw?: 4;
  readonly OutputBodyOnly?: 8;
  readonly OutputPreformatted?: 16;
  readonly OutputWrap?: 32;
  readonly OutputFormatFlowed?: 64;
  readonly OutputAbsoluteLinks?: 128;
  readonly OutputCRLineBreak?: 512;
  readonly OutputLFLineBreak?: 1024;
  readonly OutputNoScriptContent?: 2048;
  readonly OutputNoFramesContent?: 4096;
  readonly OutputNoFormattingInPre?: 8192;
  readonly OutputEncodeBasicEntities?: 16384;
  readonly OutputPersistNBSP?: 131072;
  readonly OutputDontRewriteEncodingDeclaration?: 262144;
  readonly SkipInvisibleContent?: 524288;
  readonly OutputFormatDelSp?: 1048576;
  readonly OutputDropInvisibleBreak?: 2097152;
  readonly OutputIgnoreMozDirty?: 4194304;
  readonly OutputForPlainTextClipboardCopy?: 33554432;
  readonly OutputRubyAnnotation?: 67108864;
  readonly OutputDisallowLineBreaking?: 134217728;
  readonly RequiresReinitAfterOutput?: 268435456;
  readonly AllowCrossShadowBoundary?: 536870912;
  readonly MimicChromeToStringBehaviour?: 1073741824;

  init(aDocument: Document, aMimeType: string, aFlags: u32): void;
  setSelection(aSelection: Selection): void;
  setRange(aRange: Range): void;
  setNode(aNode: Node): void;
  setContainerNode(aContainer: Node): void;
  setCharset(aCharset: string): void;
  setWrapColumn(aWrapColumn: u32): void;
  readonly mimeType: string;
  encodeToStream(aStream: nsIOutputStream): void;
  encodeToString(): string;
  encodeToStringWithContext(aContextString: OutParam<string>, aInfoString: OutParam<string>): string;
  encodeToStringWithMaxLength(aMaxLength: u32): string;
  setNodeFixup(aFixup: nsIDocumentEncoderNodeFixup): void;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/sidebar/nsIWebProtocolHandlerRegistrar.idl

interface nsIWebProtocolHandlerRegistrar extends nsISupports {
  registerProtocolHandler(protocol: string, uri: nsIURI, title: string, documentURI: nsIURI, windowOrBrowser: nsISupports): void;
  removeProtocolHandler(protocol: string, uri: string): void;
}

// https://searchfox.org/mozilla-central/source/dom/simpledb/nsISDBCallbacks.idl

type nsISDBCallback = Callable<{
  onComplete(aRequest: nsISDBRequest): void;
}>

type nsISDBCloseCallback = Callable<{
  onClose(aConnection: nsISDBConnection): void;
}>

// https://searchfox.org/mozilla-central/source/dom/simpledb/nsISDBConnection.idl

interface nsISDBConnection extends nsISupports {
  init(aPrincipal: nsIPrincipal, aPersistenceType?: string): void;
  open(aName: string): nsISDBRequest;
  seek(offset: u64): nsISDBRequest;
  read(size: u64): nsISDBRequest;
  write(value: any): nsISDBRequest;
  close(): nsISDBRequest;
  closeCallback: nsISDBCloseCallback;
}

// https://searchfox.org/mozilla-central/source/dom/simpledb/nsISDBRequest.idl

interface nsISDBRequest extends nsISupports {
  readonly result: nsIVariant;
  readonly resultCode: nsresult;
  readonly resultName: string;
  callback: nsISDBCallback;
}

// https://searchfox.org/mozilla-central/source/dom/simpledb/nsISDBResults.idl

interface nsISDBResult extends nsISupports {
  getAsArray(): u8[];
  getAsArrayBuffer(): any;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/storage/nsIDOMStorageManager.idl

interface nsIDOMStorageManager extends nsISupports {
  precacheStorage(aPrincipal: nsIPrincipal, aStoragePrincipal: nsIPrincipal): Storage;
  createStorage(aWindow: mozIDOMWindow, aPrincipal: nsIPrincipal, aStoragePrincipal: nsIPrincipal, aDocumentURI: string, aPrivate?: boolean): Storage;
  getStorage(aWindow: mozIDOMWindow, aPrincipal: nsIPrincipal, aStoragePrincipal: nsIPrincipal, aPrivate?: boolean): Storage;
  cloneStorage(aStorageToCloneFrom: Storage): void;
  checkStorage(aPrincipal: nsIPrincipal, aStorage: Storage): boolean;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/storage/nsIStorageActivityService.idl

interface nsIStorageActivityService extends nsISupports {
  getActiveOrigins(from: PRTime, to: PRTime): nsIArray;
  moveOriginInTime(origin: nsIPrincipal, when: PRTime): void;
  testOnlyReset(): void;
}

// https://searchfox.org/mozilla-central/source/dom/storage/nsISessionStorageService.idl

interface nsISessionStorageService extends nsISupports {
  clearStoragesForOrigin(aPrincipal: nsIPrincipal): void;
}

// https://searchfox.org/mozilla-central/source/dom/system/nsIOSPermissionRequest.idl

interface nsIOSPermissionRequest extends nsISupports {
  readonly PERMISSION_STATE_NOTDETERMINED?: 0;
  readonly PERMISSION_STATE_RESTRICTED?: 1;
  readonly PERMISSION_STATE_DENIED?: 2;
  readonly PERMISSION_STATE_AUTHORIZED?: 3;

  getMediaCapturePermissionState(aVideo: OutParam<u16>, aAudio: OutParam<u16>): void;
  getAudioCapturePermissionState(aAudio: OutParam<u16>): void;
  getVideoCapturePermissionState(aVideo: OutParam<u16>): void;
  getScreenCapturePermissionState(aScreen: OutParam<u16>): void;
  requestVideoCapturePermission(): Promise<any>;
  requestAudioCapturePermission(): Promise<any>;
  maybeRequestScreenCapturePermission(): void;
}

// https://searchfox.org/mozilla-central/source/dom/webauthn/nsIWebAuthnArgs.idl

// https://searchfox.org/mozilla-central/source/dom/webauthn/nsIWebAuthnAttObj.idl

// https://searchfox.org/mozilla-central/source/dom/webauthn/nsIWebAuthnPromise.idl

// https://searchfox.org/mozilla-central/source/dom/webauthn/nsIWebAuthnResult.idl

// https://searchfox.org/mozilla-central/source/dom/webauthn/nsIWebAuthnService.idl

interface nsICredentialParameters extends nsISupports {
  readonly credentialId: string;
  readonly isResidentCredential: boolean;
  readonly rpId: string;
  readonly privateKey: string;
  readonly userHandle: string;
  readonly signCount: u32;
}

interface nsIWebAuthnAutoFillEntry extends nsISupports {
  readonly PROVIDER_UNKNOWN?: 0;
  readonly PROVIDER_TEST_TOKEN?: 1;
  readonly PROVIDER_PLATFORM_WINDOWS?: 2;
  readonly PROVIDER_PLATFORM_MACOS?: 3;
  readonly PROVIDER_PLATFORM_ANDROID?: 4;

  readonly provider: u8;
  readonly userName: string;
  readonly rpId: string;
  readonly credentialId: u8[];
}

interface nsIWebAuthnService extends nsISupports {
  readonly isUVPAA: boolean;
  cancel(aTransactionId: u64): void;
  hasPendingConditionalGet(aBrowsingContextId: u64, aOrigin: string): u64;
  getAutoFillEntries(aTransactionId: u64): nsIWebAuthnAutoFillEntry[];
  selectAutoFillEntry(aTransactionId: u64, aCredentialId: u8[]): void;
  resumeConditionalGet(aTransactionId: u64): void;
  pinCallback(aTransactionId: u64, aPin: string): void;
  setHasAttestationConsent(aTransactionId: u64, aHasConsent: boolean): void;
  selectionCallback(aTransactionId: u64, aIndex: u64): void;
  addVirtualAuthenticator(protocol: string, transport: string, hasResidentKey: boolean, hasUserVerification: boolean, isUserConsenting: boolean, isUserVerified: boolean): string;
  removeVirtualAuthenticator(authenticatorId: string): void;
  addCredential(authenticatorId: string, credentialId: string, isResidentCredential: boolean, rpId: string, privateKey: string, userHandle: string, signCount: u32): void;
  getCredentials(authenticatorId: string): nsICredentialParameters[];
  removeCredential(authenticatorId: string, credentialId: string): void;
  removeAllCredentials(authenticatorId: string): void;
  setUserVerified(authenticatorId: string, isUserVerified: boolean): void;
  listen(): void;
  runCommand(aCommand: string): void;
}

// https://searchfox.org/mozilla-central/source/dom/media/webspeech/recognition/nsISpeechRecognitionService.idl

// https://searchfox.org/mozilla-central/source/dom/media/webspeech/synth/nsISpeechService.idl

interface nsISpeechTaskCallback extends nsISupports {
  onPause(): void;
  onResume(): void;
  onCancel(): void;
  onVolumeChanged(aVolume: float): void;
}

interface nsISpeechTask extends nsISupports {
  setup(aCallback: nsISpeechTaskCallback): void;
  dispatchStart(): void;
  dispatchEnd(aElapsedTime: float, aCharIndex: u32): void;
  dispatchPause(aElapsedTime: float, aCharIndex: u32): void;
  dispatchResume(aElapsedTime: float, aCharIndex: u32): void;
  dispatchError(aElapsedTime: float, aCharIndex: u32): void;
  dispatchBoundary(aName: string, aElapsedTime: float, aCharIndex: u32, aCharLength?: u32): void;
  dispatchMark(aName: string, aElapsedTime: float, aCharIndex: u32): void;
}

interface nsISpeechService extends nsISupports {
  speak(aText: string, aUri: string, aVolume: float, aRate: float, aPitch: float, aTask: nsISpeechTask): void;
}

// https://searchfox.org/mozilla-central/source/dom/media/webspeech/synth/nsISynthVoiceRegistry.idl

interface nsISynthVoiceRegistry extends nsISupports {
  addVoice(aService: nsISpeechService, aUri: string, aName: string, aLang: string, aLocalService: boolean, aQueuesUtterances: boolean): void;
  removeVoice(aService: nsISpeechService, aUri: string): void;
  notifyVoicesChanged(): void;
  notifyVoicesError(aError: string): void;
  setDefaultVoice(aUri: string, aIsDefault: boolean): void;
  readonly voiceCount: u32;
  getVoice(aIndex: u32): string;
  isDefaultVoice(aUri: string): boolean;
  isLocalVoice(aUri: string): boolean;
  getVoiceLang(aUri: string): string;
  getVoiceName(aUri: string): string;
}

// https://searchfox.org/mozilla-central/source/dom/workers/nsIWorkerChannelInfo.idl

interface nsIWorkerChannelLoadInfo extends nsISupports {
  workerAssociatedBrowsingContextID: u64;
  readonly workerAssociatedBrowsingContext: BrowsingContext;
}

interface nsIWorkerChannelInfo extends nsISupports {
  loadInfo: nsIWorkerChannelLoadInfo;
  readonly channelId: u64;
}

// https://searchfox.org/mozilla-central/source/dom/workers/nsIWorkerDebugger.idl

interface nsIWorkerDebuggerListener extends nsISupports {
  onClose(): void;
  onError(filename: string, lineno: u32, message: string): void;
  onMessage(message: string): void;
}

interface nsIWorkerDebugger extends nsISupports {
  readonly TYPE_DEDICATED?: 0;
  readonly TYPE_SHARED?: 1;
  readonly TYPE_SERVICE?: 2;

  readonly isClosed: boolean;
  readonly isChrome: boolean;
  readonly isRemote: boolean;
  readonly isInitialized: boolean;
  readonly parent: nsIWorkerDebugger;
  readonly type: u32;
  readonly url: string;
  readonly window: mozIDOMWindow;
  readonly windowIDs: u64[];
  readonly principal: nsIPrincipal;
  readonly serviceWorkerID: u32;
  readonly id: string;
  readonly name: string;
  initialize(url: string): void;
  postMessage(message: string): void;
  addListener(listener: nsIWorkerDebuggerListener): void;
  removeListener(listener: nsIWorkerDebuggerListener): void;
  setDebuggerReady(ready: boolean): void;
}

// https://searchfox.org/mozilla-central/source/dom/workers/nsIWorkerDebuggerManager.idl

interface nsIWorkerDebuggerManagerListener extends nsISupports {
  onRegister(aDebugger: nsIWorkerDebugger): void;
  onUnregister(aDebugger: nsIWorkerDebugger): void;
}

interface nsIWorkerDebuggerManager extends nsISupports {
  getWorkerDebuggerEnumerator(): nsISimpleEnumerator;
  addListener(listener: nsIWorkerDebuggerManagerListener): void;
  removeListener(listener: nsIWorkerDebuggerManagerListener): void;
}

// https://searchfox.org/mozilla-central/source/dom/xslt/xslt/txIEXSLTFunctions.idl

interface txIEXSLTFunctions extends nsISupports {
  match(str: string, regex: string, flags: string, doc: Document): DocumentFragment;
  replace(str: string, regex: string, flags: string, replace: string): string;
  test(str: string, regex: string, flags: string): boolean;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/xul/nsIDOMXULButtonElement.idl

interface nsIDOMXULButtonElement extends nsIDOMXULControlElement {
  type: string;
  open: boolean;
  checked: boolean;
  group: string;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/xul/nsIDOMXULCommandDispatcher.idl

interface nsIDOMXULCommandDispatcher extends nsISupports {
  focusedElement: Element;
  focusedWindow: mozIDOMWindowProxy;
  addCommandUpdater(updater: Element, events: string, targets: string): void;
  removeCommandUpdater(updater: Element): void;
  updateCommands(eventName: string): void;
  getControllerForCommand(command: string): nsIController;
  getControllers(): nsIControllers;
  advanceFocus(): void;
  rewindFocus(): void;
  advanceFocusIntoSubtree(elt: Element): void;
  lock(): void;
  unlock(): void;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/xul/nsIDOMXULContainerElement.idl

interface nsIDOMXULContainerItemElement extends nsISupports {
  readonly parentContainer: Element;
}

interface nsIDOMXULContainerElement extends nsIDOMXULContainerItemElement {
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/xul/nsIDOMXULControlElement.idl

interface nsIDOMXULControlElement extends nsISupports {
  disabled: boolean;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/xul/nsIDOMXULMenuListElement.idl

interface nsIDOMXULMenuListElement extends nsIDOMXULSelectControlElement {
  editable: boolean;
  open: boolean;
  readonly label: string;
  image: string;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/xul/nsIDOMXULMultSelectCntrlEl.idl

interface nsIDOMXULMultiSelectControlElement extends nsIDOMXULSelectControlElement {
  selType: string;
  currentItem: Element;
  currentIndex: i32;
  readonly selectedItems: NodeList;
  addItemToSelection(item: nsIDOMXULSelectControlItemElement): void;
  removeItemFromSelection(item: nsIDOMXULSelectControlItemElement): void;
  toggleItemSelection(item: nsIDOMXULSelectControlItemElement): void;
  selectItem(item: nsIDOMXULSelectControlItemElement): void;
  selectItemRange(startItem: nsIDOMXULSelectControlItemElement, item: nsIDOMXULSelectControlItemElement): void;
  selectAll(): void;
  clearSelection(): void;
  readonly selectedCount: i32;
  getSelectedItem(index: i32): Element;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/xul/nsIDOMXULRadioGroupElement.idl

interface nsIDOMXULRadioGroupElement extends nsISupports {
  focusedItem: Element;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/xul/nsIDOMXULRelatedElement.idl

interface nsIDOMXULRelatedElement extends nsISupports {
  getRelatedElement(aElement: Node): Element;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/xul/nsIDOMXULSelectCntrlEl.idl

interface nsIDOMXULSelectControlElement extends nsIDOMXULControlElement {
  selectedItem: Element;
  selectedIndex: i32;
  value: string;
  readonly itemCount: u32;
  getIndexOfItem(item: nsIDOMXULSelectControlItemElement): i32;
  getItemAtIndex(index: i32): Element;
}

// https://searchfox.org/mozilla-central/source/dom/interfaces/xul/nsIDOMXULSelectCntrlItemEl.idl

interface nsIDOMXULSelectControlItemElement extends nsISupports {
  disabled: boolean;
  image: string;
  label: string;
  accessKey: string;
  command: string;
  value: string;
  readonly selected: boolean;
  readonly control: Element;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/downloads/mozIDownloadPlatform.idl

interface mozIDownloadPlatform extends nsISupports {
  readonly ZONE_MY_COMPUTER?: 0;
  readonly ZONE_INTRANET?: 1;
  readonly ZONE_TRUSTED?: 2;
  readonly ZONE_INTERNET?: 3;
  readonly ZONE_RESTRICTED?: 4;

  downloadDone(aSource: nsIURI, aReferrer: nsIURI, aTarget: nsIFile, aContentType: string, aIsPrivate: boolean): Promise<any>;
  mapUrlToZone(aURL: string): u32;
}

// https://searchfox.org/mozilla-central/source/editor/nsIDocumentStateListener.idl

interface nsIDocumentStateListener extends nsISupports {
  NotifyDocumentWillBeDestroyed(): void;
  NotifyDocumentStateChanged(aNowDirty: boolean): void;
}

// https://searchfox.org/mozilla-central/source/editor/nsIEditActionListener.idl

interface nsIEditActionListener extends nsISupports {
  DidDeleteNode(aChild: Node, aResult: nsresult): void;
  DidInsertText(aTextNode: CharacterData, aOffset: i32, aString: string, aResult: nsresult): void;
  WillDeleteText(aTextNode: CharacterData, aOffset: i32, aLength: i32): void;
  WillDeleteRanges(aRangesToDelete: Range[]): void;
}

// https://searchfox.org/mozilla-central/source/editor/nsIEditor.idl

interface nsIEditor extends nsISupports {
  readonly eNone?: 0;
  readonly eNext?: 1;
  readonly ePrevious?: 2;
  readonly eNextWord?: 3;
  readonly ePreviousWord?: 4;
  readonly eToBeginningOfLine?: 5;
  readonly eToEndOfLine?: 6;
  readonly eStrip?: 0;
  readonly eNoStrip?: 1;
  readonly eEditorPlaintextMask?: 1;
  readonly eEditorSingleLineMask?: 2;
  readonly eEditorPasswordMask?: 4;
  readonly eEditorReadonlyMask?: 8;
  readonly eEditorMailMask?: 32;
  readonly eEditorEnableWrapHackMask?: 64;
  readonly eEditorAllowInteraction?: 512;
  readonly eEditorRightToLeft?: 2048;
  readonly eEditorLeftToRight?: 4096;
  readonly eEditorSkipSpellCheck?: 8192;
  readonly eNewlinesPasteIntact?: 0;
  readonly eNewlinesPasteToFirst?: 1;
  readonly eNewlinesReplaceWithSpaces?: 2;
  readonly eNewlinesStrip?: 3;
  readonly eNewlinesReplaceWithCommas?: 4;
  readonly eNewlinesStripSurroundingWhitespace?: 5;

  readonly selection: Selection;
  setAttributeOrEquivalent(element: Element, sourceAttrName: string, sourceAttrValue: string, aSuppressTransaction: boolean): void;
  removeAttributeOrEquivalent(element: Element, sourceAttrName: string, aSuppressTransaction: boolean): void;
  flags: u32;
  contentsMIMEType: string;
  readonly isDocumentEditable: boolean;
  readonly isSelectionEditable: boolean;
  readonly document: Document;
  readonly rootElement: Element;
  readonly selectionController: nsISelectionController;
  deleteSelection(action: i16, stripWrappers: i16): void;
  readonly documentIsEmpty: boolean;
  readonly documentModified: boolean;
  documentCharacterSet: string;
  resetModificationCount(): void;
  getModificationCount(): i32;
  incrementModificationCount(aModCount: i32): void;
  enableUndo(enable: boolean): void;
  readonly undoRedoEnabled: boolean;
  readonly canUndo: boolean;
  readonly canRedo: boolean;
  clearUndoRedo(): void;
  undo(): void;
  undoAll(): void;
  redo(): void;
  beginTransaction(): void;
  endTransaction(): void;
  getInlineSpellChecker(autoCreate: boolean): nsIInlineSpellChecker;
  setSpellcheckUserOverride(enable: boolean): void;
  cut(): void;
  canCut(): boolean;
  copy(): void;
  canCopy(): boolean;
  paste(aClipboardType: nsIClipboard.ClipboardType): void;
  pasteTransferable(aTransferable: nsITransferable): void;
  canPaste(aClipboardType: nsIClipboard.ClipboardType): boolean;
  selectAll(): void;
  beginningOfDocument(): void;
  endOfDocument(): void;
  setAttribute(aElement: Element, attributestr: string, attvalue: string): void;
  removeAttribute(aElement: Element, aAttribute: string): void;
  cloneAttributes(aDestElement: Element, aSourceElement: Element): void;
  insertNode(node: Node, parent: Node, aPosition: u32, aPreserveSelection?: boolean): void;
  deleteNode(child: Node, aPreserveSelection?: boolean): void;
  outputToString(formatType: string, flags: u32): string;
  addEditActionListener(listener: nsIEditActionListener): void;
  removeEditActionListener(listener: nsIEditActionListener): void;
  addDocumentStateListener(listener: nsIDocumentStateListener): void;
  removeDocumentStateListener(listener: nsIDocumentStateListener): void;
  forceCompositionEnd(): void;
  readonly composing: boolean;
  unmask(aStart?: u32, aEnd?: i64, aTimeout?: u32): void;
  mask(): void;
  readonly unmaskedStart: u32;
  readonly unmaskedEnd: u32;
  readonly autoMaskingEnabled: boolean;
  readonly passwordMask: string;
  readonly textLength: u32;
  newlineHandling: i32;
  insertText(aStringToInsert: string): void;
  insertLineBreak(): void;
}

// https://searchfox.org/mozilla-central/source/editor/nsIEditorMailSupport.idl

interface nsIEditorMailSupport extends nsISupports {
  insertAsCitedQuotation(aQuotedText: string, aCitation: string, aInsertHTML: boolean): Node;
  rewrap(aRespectNewlines: boolean): void;
  insertTextWithQuotations(aStringToInsert: string): void;
  wrapWidth: i32;
}

// https://searchfox.org/mozilla-central/source/editor/nsIEditorSpellCheck.idl

interface nsIEditorSpellCheck extends nsISupports {
  readonly FILTERTYPE_NORMAL?: 1;
  readonly FILTERTYPE_MAIL?: 2;

  canSpellCheck(): boolean;
  InitSpellChecker(editor: nsIEditor, enableSelectionChecking: boolean, callback?: nsIEditorSpellCheckCallback): void;
  GetNextMisspelledWord(): string;
  GetSuggestedWord(): string;
  CheckCurrentWord(suggestedWord: string): boolean;
  suggest(aCheckingWorkd: string, aMaxCount: u32): Promise<any>;
  ReplaceWord(misspelledWord: string, replaceWord: string, allOccurrences: boolean): void;
  IgnoreWordAllOccurrences(word: string): void;
  AddWordToDictionary(word: string): void;
  RemoveWordFromDictionary(word: string): void;
  GetDictionaryList(): string[];
  getCurrentDictionaries(): string[];
  setCurrentDictionaries(dictionaries: string[]): Promise<any>;
  UninitSpellChecker(): void;
  setFilterType(filterType: u32): void;
  UpdateCurrentDictionary(callback?: nsIEditorSpellCheckCallback): void;
}

type nsIEditorSpellCheckCallback = Callable<{
  editorSpellCheckDone(): void;
}>

// https://searchfox.org/mozilla-central/source/editor/nsIHTMLAbsPosEditor.idl

interface nsIHTMLAbsPosEditor extends nsISupports {
  absolutePositioningEnabled: boolean;
  readonly isAbsolutePositioningActive: boolean;
  snapToGridEnabled: boolean;
  gridSize: u32;
}

// https://searchfox.org/mozilla-central/source/editor/nsIHTMLEditor.idl

interface nsIHTMLEditor extends nsISupports {
  readonly eLeft?: 0;
  readonly eCenter?: 1;
  readonly eRight?: 2;
  readonly eJustify?: 3;

  setInlineProperty(aProperty: string, aAttribute: string, aValue: string): void;
  getInlinePropertyWithAttrValue(aProperty: string, aAttribute: string, aValue: string, aFirst: OutParam<boolean>, aAny: OutParam<boolean>, aAll: OutParam<boolean>): string;
  removeInlineProperty(aProperty: string, aAttribute: string): void;
  nodeIsBlock(aNode: Node): boolean;
  insertHTML(aInputString: string): void;
  rebuildDocumentFromSource(aSourceString: string): void;
  insertElementAtSelection(aElement: Element, aDeleteSelection: boolean): void;
  updateBaseURL(): void;
  selectElement(aElement: Element): void;
  getParagraphState(aMixed: OutParam<boolean>): string;
  getFontFaceState(aMixed: OutParam<boolean>): string;
  getHighlightColorState(aMixed: OutParam<boolean>): string;
  getListState(aMixed: OutParam<boolean>, aOL: OutParam<boolean>, aUL: OutParam<boolean>, aDL: OutParam<boolean>): void;
  getListItemState(aMixed: OutParam<boolean>, aLI: OutParam<boolean>, aDT: OutParam<boolean>, aDD: OutParam<boolean>): void;
  getAlignment(aMixed: OutParam<boolean>, aAlign: OutParam<i16>): void;
  makeOrChangeList(aListType: string, entireList: boolean, aBulletType: string): void;
  removeList(aListType: string): void;
  getElementOrParentByTagName(aTagName: string, aNode: Node): Element;
  getSelectedElement(aTagName: string): nsISupports;
  createElementWithDefaults(aTagName: string): Element;
  insertLinkAroundSelection(aAnchorElement: Element): void;
  setBackgroundColor(aColor: string): void;
  isCSSEnabled: boolean;
  checkSelectionStateForAnonymousButtons(): void;
  isAnonymousElement(aElement: Element): boolean;
  returnInParagraphCreatesNewParagraph: boolean;
}

// https://searchfox.org/mozilla-central/source/editor/nsIHTMLInlineTableEditor.idl

interface nsIHTMLInlineTableEditor extends nsISupports {
  inlineTableEditingEnabled: boolean;
  readonly isInlineTableEditingActive: boolean;
}

// https://searchfox.org/mozilla-central/source/editor/nsIHTMLObjectResizer.idl

interface nsIHTMLObjectResizer extends nsISupports {
  readonly eTopLeft?: 0;
  readonly eTop?: 1;
  readonly eTopRight?: 2;
  readonly eLeft?: 3;
  readonly eRight?: 4;
  readonly eBottomLeft?: 5;
  readonly eBottom?: 6;
  readonly eBottomRight?: 7;

  objectResizingEnabled: boolean;
  readonly isObjectResizingActive: boolean;
  hideResizers(): void;
}

// https://searchfox.org/mozilla-central/source/editor/nsITableEditor.idl

interface nsITableEditor extends nsISupports {
  readonly eNoSearch?: 0;
  readonly ePreviousColumn?: 1;
  readonly ePreviousRow?: 2;

  insertTableCell(aNumberOfColumnsToInsert: i32, aInsertAfterSelectedCell: boolean): void;
  insertTableColumn(aNumberOfColumnsToInsert: i32, aInsertAfterSelectedCell: boolean): void;
  insertTableRow(aNumberOfRowsToInsert: i32, aInsertAfterSelectedCell: boolean): void;
  deleteTable(): void;
  deleteTableCellContents(): void;
  deleteTableCell(aNumberOfCellsToDelete: i32): void;
  deleteTableColumn(aNumberOfColumnsToDelete: i32): void;
  deleteTableRow(aNumberOfRowsToDelete: i32): void;
  selectTableCell(): void;
  selectTableRow(): void;
  selectTableColumn(): void;
  selectTable(): void;
  selectAllTableCells(): void;
  switchTableCellHeaderType(aSourceCell: Element): Element;
  joinTableCells(aMergeNonContiguousContents: boolean): void;
  splitTableCell(): void;
  normalizeTable(aTable: Element): void;
  getCellIndexes(aCellElement: Element, aRowIndex: OutParam<i32>, aColumnIndex: OutParam<i32>): void;
  getTableSize(aTableOrElementInTable: Element, aRowCount: OutParam<i32>, aColCount: OutParam<i32>): void;
  getCellAt(aTableElement: Element, aRowIndex: i32, aColumnIndex: i32): Element;
  getCellDataAt(aTableElement: Element, aRowIndex: i32, aColumnIndex: i32, aCellElement: OutParam<Element>, aStartRowIndex: OutParam<i32>, aStartColumnIndex: OutParam<i32>, aRowSpan: OutParam<i32>, aColSpan: OutParam<i32>, aEffectiveRowSpan: OutParam<i32>, aEffectiveColSpan: OutParam<i32>, aIsSelected: OutParam<boolean>): void;
  getFirstRow(aTableElement: Element): Element;
  getSelectedOrParentTableElement(aTagName: OutParam<string>, aCount: OutParam<i32>): Element;
  getSelectedCellsType(aElement: Element): u32;
  getFirstSelectedCellInTable(aRowIndex: OutParam<i32>, aColIndex: OutParam<i32>): Element;
  getSelectedCells(): Element[];
}

// https://searchfox.org/mozilla-central/source/toolkit/components/enterprisepolicies/nsIEnterprisePolicies.idl

interface nsIEnterprisePolicies extends nsISupports {
  readonly UNINITIALIZED?: -1;
  readonly INACTIVE?: 0;
  readonly ACTIVE?: 1;
  readonly FAILED?: 2;

  readonly status: i16;
  readonly isEnterprise: boolean;
  isAllowed(feature: string): boolean;
  getActivePolicies(): any;
  getSupportMenu(): any;
  getExtensionPolicy(extensionID: string): any;
  getExtensionSettings(extensionID: string): any;
  mayInstallAddon(addon: any): boolean;
  allowedInstallSource(uri: nsIURI): boolean;
  isExemptExecutableExtension(url: string, extension: string): boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/mozapps/extensions/amIAddonManagerStartup.idl

interface amIAddonManagerStartup extends nsISupports {
  readStartupData(): any;
  registerChrome(manifestURI: nsIURI, entries: any): nsIJSRAIIHelper;
  encodeBlob(value: any): any;
  decodeBlob(value: any): any;
  enumerateJAR(uri: nsIURI, pattern: string): string[];
  enumerateJARSubtree(uri: nsIURI): string[];
  initializeURLPreloader(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/mozapps/extensions/amIWebInstallPrompt.idl

interface amIWebInstallPrompt extends nsISupports {
  confirm(aBrowser: Element, aUri: nsIURI, aInstalls: nsIVariant[]): void;
}

// https://searchfox.org/mozilla-central/source/uriloader/exthandler/nsCExternalHandlerService.idl

// https://searchfox.org/mozilla-central/source/uriloader/exthandler/nsIContentDispatchChooser.idl

interface nsIContentDispatchChooser extends nsISupports {
  handleURI(aHandler: nsIHandlerInfo, aURI: nsIURI, aTriggeringPrincipal: nsIPrincipal, aBrowsingContext: BrowsingContext, aWasTriggeredExternally?: boolean): void;
}

// https://searchfox.org/mozilla-central/source/uriloader/exthandler/nsIExternalHelperAppService.idl

interface nsIExternalHelperAppService extends nsISupports {
  doContent(aMimeContentType: string, aChannel: nsIChannel, aContentContext: nsIInterfaceRequestor, aForceSave: boolean, aWindowContext?: nsIInterfaceRequestor): nsIStreamListener;
  createListener(aMimeContentType: string, aChannel: nsIChannel, aContentContext: BrowsingContext, aForceSave: boolean, aWindowContext?: nsIInterfaceRequestor): nsIStreamListener;
  applyDecodingForExtension(aExtension: string, aEncodingType: string): boolean;
  getPreferredDownloadsDirectory(): nsIFile;
}

interface nsPIExternalAppLauncher extends nsISupports {
  deleteTemporaryFileOnExit(aTemporaryFile: nsIFile): void;
  deleteTemporaryPrivateFileWhenPossible(aTemporaryFile: nsIFile): void;
}

interface nsIHelperAppLauncher extends nsICancelable {
  readonly MIMEInfo: nsIMIMEInfo;
  readonly source: nsIURI;
  readonly suggestedFileName: string;
  promptForSaveDestination(): void;
  setDownloadToLaunch(aHandleInternally: boolean, aFile: nsIFile): void;
  launchLocalFile(): void;
  saveDestinationAvailable(aFile: nsIFile, aDialogWasShown?: boolean): void;
  setWebProgressListener(aWebProgressListener: nsIWebProgressListener2): void;
  readonly targetFile: nsIFile;
  readonly targetFileIsExecutable: boolean;
  readonly timeDownloadStarted: PRTime;
  readonly contentLength: i64;
  readonly browsingContextId: u64;
}

// https://searchfox.org/mozilla-central/source/uriloader/exthandler/nsIExternalProtocolService.idl

interface nsIExternalProtocolService extends nsISupports {
  externalProtocolHandlerExists(aProtocolScheme: string): boolean;
  isExposedProtocol(aProtocolScheme: string): boolean;
  getProtocolHandlerInfo(aProtocolScheme: string): nsIHandlerInfo;
  getProtocolHandlerInfoFromOS(aProtocolScheme: string, aFound: OutParam<boolean>): nsIHandlerInfo;
  setProtocolHandlerDefaults(aHandlerInfo: nsIHandlerInfo, aOSHandlerExists: boolean): void;
  loadURI(aURI: nsIURI, aTriggeringPrincipal?: nsIPrincipal, aRedirectPrincipal?: nsIPrincipal, aBrowsingContext?: BrowsingContext, aWasTriggeredExternally?: boolean, aHasValidUserGestureActivation?: boolean, aNewWindowTarget?: boolean): void;
  getApplicationDescription(aScheme: string): string;
  isCurrentAppOSDefaultForProtocol(aScheme: string): boolean;
}

// https://searchfox.org/mozilla-central/source/uriloader/exthandler/nsIHandlerService.idl

interface nsIHandlerService extends nsISupports {
  asyncInit(): void;
  enumerate(): nsISimpleEnumerator;
  fillHandlerInfo(aHandlerInfo: nsIHandlerInfo, aOverrideType: string): void;
  store(aHandlerInfo: nsIHandlerInfo): void;
  exists(aHandlerInfo: nsIHandlerInfo): boolean;
  remove(aHandlerInfo: nsIHandlerInfo): void;
  getTypeFromExtension(aFileExtension: string): string;
  existsForProtocolOS(aProtocolScheme: string): boolean;
  existsForProtocol(aProtocolScheme: string): boolean;
  getApplicationDescription(aProtocolScheme: string): string;
}

// https://searchfox.org/mozilla-central/source/uriloader/exthandler/nsIHelperAppLauncherDialog.idl

interface nsIHelperAppLauncherDialog extends nsISupports {
  readonly REASON_CANTHANDLE?: 0;
  readonly REASON_SERVERREQUEST?: 1;
  readonly REASON_TYPESNIFFED?: 2;

  show(aLauncher: nsIHelperAppLauncher, aWindowContext: nsIInterfaceRequestor, aReason: u32): void;
  promptForSaveToFileAsync(aLauncher: nsIHelperAppLauncher, aWindowContext: nsIInterfaceRequestor, aDefaultFileName: string, aSuggestedFileExtension: string, aForcePrompt: boolean): void;
}

// https://searchfox.org/mozilla-central/source/uriloader/exthandler/nsISharingHandlerApp.idl

interface nsISharingHandlerApp extends nsIHandlerApp {
  share(data: string, title?: string): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/typeaheadfind/nsITypeAheadFind.idl

interface nsITypeAheadFind extends nsISupports {
  readonly FIND_INITIAL?: 0;
  readonly FIND_NEXT?: 1;
  readonly FIND_PREVIOUS?: 2;
  readonly FIND_FIRST?: 3;
  readonly FIND_LAST?: 4;
  readonly FIND_FOUND?: 0;
  readonly FIND_NOTFOUND?: 1;
  readonly FIND_WRAPPED?: 2;
  readonly FIND_PENDING?: 3;

  init(aDocShell: nsIDocShell): void;
  find(aSearchString: string, aLinksOnly: boolean, aMode: u32, aDontIterateFrames: boolean): u16;
  getFoundRange(): Range;
  setDocShell(aDocShell: nsIDocShell): void;
  setSelectionModeAndRepaint(toggle: i16): void;
  collapseSelection(): void;
  isRangeVisible(aRange: Range, aMustBeInViewPort: boolean): boolean;
  isRangeRendered(aRange: Range): boolean;
  readonly searchString: string;
  caseSensitive: boolean;
  matchDiacritics: boolean;
  entireWord: boolean;
  readonly foundLink: Element;
  readonly foundEditable: Element;
  readonly currentWindow: mozIDOMWindow;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/glean/xpcom/nsIFOG.idl

interface nsIFOG extends nsISupports {
  initializeFOG(aDataPathOverride?: string, aAppIdOverride?: string, aDisableInternalPings?: boolean): void;
  registerCustomPings(): void;
  setLogPings(aEnableLogPings: boolean): void;
  setTagPings(aDebugTag: string): void;
  sendPing(aPingName: string): void;
  setExperimentActive(aExperimentId: string, aBranch: string, aExtra?: any): void;
  setExperimentInactive(aExperimentId: string): void;
  testGetExperimentData(aExperimentId: string): any;
  applyServerKnobsConfig(aJsonConfig: string): void;
  testFlushAllChildren(): Promise<any>;
  testResetFOG(aDataPathOverride?: string, aAppIdOverride?: string): void;
  testTriggerMetrics(aProcessType: u32): Promise<any>;
  testRegisterRuntimeMetric(aType: string, aCategory: string, aName: string, aPings: string[], aLifetime: string, aDisabled: boolean, aExtraArgs?: string): u32;
  testRegisterRuntimePing(aName: string, aIncludeClientId: boolean, aSendIfEmpty: boolean, aPreciseTimestamps: boolean, aIncludeInfoSections: boolean, aEnabled: boolean, aSchedulesPings: string[], aReasonCodes: string[], aFollowsCollectionEnabled: boolean, aUploaderCapabilities: string[]): u32;
  updateAttribution(aSource: string, aMedium: string, aCampaign: string, aTerm: string, aContent: string): void;
  testGetAttribution(): any;
  updateDistribution(aName: string): void;
  testGetDistribution(): any;
  registerRuntimeMetric(aType: string, aCategory: string, aName: string, aPings: string[], aLifetime: string, aDisabled: boolean, aExtraArgs?: string): void;
  registerRuntimePing(aName: string, aIncludeClientId: boolean, aSendIfEmpty: boolean, aPreciseTimestamps: boolean, aIncludeInfoSections: boolean, aEnabled: boolean, aSchedulesPings: string[], aReasonCodes: string[], aFollowsCollectionEnabled: boolean, aUploaderCapabilities: string[]): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/glean/xpcom/nsIGleanPing.idl

type nsIGleanPingTestCallback = Callable<{
  call(aReason: string): void;
}>

type nsIGleanPingSubmitCallback = Callable<{
  call(): Promise<any>;
}>

interface nsIGleanPing extends nsISupports {
  submit(aReason?: string): void;
  testBeforeNextSubmit(aCallback: nsIGleanPingTestCallback): void;
  setEnabled(aValue: boolean): void;
  testSubmission(aTestCallback: nsIGleanPingTestCallback, aSubmitCallback: nsIGleanPingSubmitCallback, aSubmitTimeoutMs?: u32): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/gfx/src/nsIFontEnumerator.idl

interface nsIFontEnumerator extends nsISupports {
  EnumerateAllFonts(): string[];
  EnumerateFonts(aLangGroup: string, aGeneric: string): string[];
  EnumerateAllFontsAsync(): any;
  EnumerateFontsAsync(aLangGroup: string, aGeneric: string): any;
  HaveFontFor(aLangGroup: string): boolean;
  getDefaultFont(aLangGroup: string, aGeneric: string): string;
  getStandardFamilyName(aName: string): string;
}

// https://searchfox.org/mozilla-central/source/gfx/thebes/nsIFontLoadCompleteCallback.idl

// https://searchfox.org/mozilla-central/source/parser/html/nsIParserUtils.idl

interface nsIParserUtils extends nsISupports {
  readonly SanitizerAllowComments?: 1;
  readonly SanitizerAllowStyle?: 2;
  readonly SanitizerCidEmbedsOnly?: 4;
  readonly SanitizerDropNonCSSPresentation?: 8;
  readonly SanitizerDropForms?: 16;
  readonly SanitizerDropMedia?: 32;
  readonly SanitizerLogRemovals?: 64;

  sanitize(src: string, flags: u32): string;
  removeConditionalCSS(src: string): string;
  convertToPlainText(src: string, flags: u32, wrapCol: u32): string;
  parseFragment(fragment: string, flags: u32, isXML: boolean, baseURI: nsIURI, element: Element): DocumentFragment;
}

// https://searchfox.org/mozilla-central/source/parser/htmlparser/nsIExpatSink.idl

interface nsIExpatSink extends nsISupports {
  HandleStartElement(aName: string, aAtts: string[], aAttsCount: u32, aLineNumber: u32, aColumnNumber: u32): void;
  HandleEndElement(aName: string): void;
  HandleComment(aCommentText: string): void;
  HandleCDataSection(aData: string, aLength: u32): void;
  HandleDoctypeDecl(aSubset: string, aName: string, aSystemId: string, aPublicId: string, aCatalogData: nsISupports): void;
  HandleCharacterData(aData: string, aLength: u32): void;
  HandleProcessingInstruction(aTarget: string, aData: string): void;
  HandleXMLDeclaration(aVersion: string, aEncoding: string, aStandalone: i32): void;
  ReportError(aErrorText: string, aSourceText: string, aError: nsIScriptError): boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/http-sfv/nsIStructuredFieldValues.idl

interface nsISFVBareItem extends nsISupports {
  readonly BOOL?: 1;
  readonly STRING?: 2;
  readonly DECIMAL?: 3;
  readonly INTEGER?: 4;
  readonly TOKEN?: 5;
  readonly BYTE_SEQUENCE?: 6;

  readonly type: i32;
}

interface nsISFVInteger extends nsISFVBareItem {
  value: i64;
}

interface nsISFVString extends nsISFVBareItem {
  value: string;
}

interface nsISFVBool extends nsISFVBareItem {
  value: boolean;
}

interface nsISFVDecimal extends nsISFVBareItem {
  value: double;
}

interface nsISFVToken extends nsISFVBareItem {
  value: string;
}

interface nsISFVByteSeq extends nsISFVBareItem {
  value: string;
}

interface nsISFVParams extends nsISupports {
  get(key: string): nsISFVBareItem;
  set(key: string, item: nsISFVBareItem): void;
  delete(key: string): void;
  keys(): string[];
}

interface nsISFVParametrizable extends nsISupports {
  readonly params: nsISFVParams;
}

interface nsISFVItemOrInnerList extends nsISFVParametrizable {
}

interface nsISFVSerialize extends nsISupports {
  serialize(): string;
}

interface nsISFVItem extends nsISFVItemOrInnerList {
  readonly value: nsISFVBareItem;
  serialize(): string;
}

interface nsISFVInnerList extends nsISFVItemOrInnerList {
  items: nsISFVItem[];
}

interface nsISFVList extends nsISFVSerialize {
  members: nsISFVItemOrInnerList[];
  parseMore(header: string): void;
}

interface nsISFVDictionary extends nsISFVSerialize {
  get(key: string): nsISFVItemOrInnerList;
  set(key: string, member_value: nsISFVItemOrInnerList): void;
  delete(key: string): void;
  keys(): string[];
  parseMore(header: string): void;
}

interface nsISFVService extends nsISupports {
  parseDictionary(header: string): nsISFVDictionary;
  parseList(header: string): nsISFVList;
  parseItem(header: string): nsISFVItem;
  newInteger(value: i64): nsISFVInteger;
  newBool(value: boolean): nsISFVBool;
  newDecimal(value: double): nsISFVDecimal;
  newString(value: string): nsISFVString;
  newByteSequence(value: string): nsISFVByteSeq;
  newToken(value: string): nsISFVToken;
  newParameters(): nsISFVParams;
  newInnerList(items: nsISFVItem[], params: nsISFVParams): nsISFVInnerList;
  newItem(value: nsISFVBareItem, params: nsISFVParams): nsISFVItem;
  newList(members: nsISFVItemOrInnerList[]): nsISFVList;
  newDictionary(): nsISFVDictionary;
}

// https://searchfox.org/mozilla-central/source/image/imgICache.idl

interface imgICache extends nsISupports {
  clearCache(chrome?: any): void;
  removeEntriesFromPrincipalInAllProcesses(aPrincipal: nsIPrincipal): void;
  removeEntriesFromSiteInAllProcesses(aBaseDomain: string, OriginAttributesPattern: any): void;
  findEntryProperties(uri: nsIURI, doc?: Document): nsIProperties;
  respectPrivacyNotifications(): void;
}

// https://searchfox.org/mozilla-central/source/image/imgIContainer.idl

}  // global

declare enum imgIContainer_DecodeResult {
  DECODE_SURFACE_AVAILABLE = 0,
  DECODE_REQUESTED = 1,
  DECODE_REQUEST_FAILED = 2,
}

declare global {

namespace imgIContainer {
  type DecodeResult = imgIContainer_DecodeResult;
}

interface imgIContainer extends nsISupports, Enums<typeof imgIContainer_DecodeResult> {
  readonly TYPE_RASTER?: 0;
  readonly TYPE_VECTOR?: 1;
  readonly TYPE_REQUEST?: 2;
  readonly FLAG_NONE?: 0;
  readonly FLAG_SYNC_DECODE?: 1;
  readonly FLAG_SYNC_DECODE_IF_FAST?: 2;
  readonly FLAG_ASYNC_NOTIFY?: 4;
  readonly FLAG_DECODE_NO_PREMULTIPLY_ALPHA?: 8;
  readonly FLAG_DECODE_NO_COLORSPACE_CONVERSION?: 16;
  readonly FLAG_CLAMP?: 32;
  readonly FLAG_HIGH_QUALITY_SCALING?: 64;
  readonly FLAG_BYPASS_SURFACE_CACHE?: 128;
  readonly FLAG_FORCE_PRESERVEASPECTRATIO_NONE?: 256;
  readonly FLAG_FORCE_UNIFORM_SCALING?: 512;
  readonly FLAG_AVOID_REDECODE_FOR_SIZE?: 1024;
  readonly FLAG_DECODE_TO_SRGB_COLORSPACE?: 2048;
  readonly FLAG_RECORD_BLOB?: 4096;
  readonly DECODE_FLAGS_DEFAULT?: 0;
  readonly DECODE_FLAGS_FOR_REENCODE?: 2056;
  readonly FRAME_FIRST?: 0;
  readonly FRAME_CURRENT?: 1;
  readonly FRAME_MAX_VALUE?: 1;
  readonly kNormalAnimMode?: 0;
  readonly kDontAnimMode?: 1;
  readonly kLoopOnceAnimMode?: 2;

  readonly width: i32;
  readonly height: i32;
  readonly hotspotX: i32;
  readonly hotspotY: i32;
  readonly type: u16;
  readonly animated: boolean;
  readonly providerId: u32;
  lockImage(): void;
  unlockImage(): void;
  requestDiscard(): void;
  animationMode: u16;
  resetAnimation(): void;
}

// https://searchfox.org/mozilla-central/source/image/imgIContainerDebug.idl

interface imgIContainerDebug extends nsISupports {
  readonly framesNotified: u32;
}

// https://searchfox.org/mozilla-central/source/image/imgIEncoder.idl

interface imgIEncoder extends nsIAsyncInputStream {
  readonly INPUT_FORMAT_RGB?: 0;
  readonly INPUT_FORMAT_RGBA?: 1;
  readonly INPUT_FORMAT_HOSTARGB?: 2;

  initFromData(data: u8[], length: u32, width: u32, height: u32, stride: u32, inputFormat: u32, outputOptions: string): void;
  startImageEncode(width: u32, height: u32, inputFormat: u32, outputOptions: string): void;
  addImageFrame(data: u8[], length: u32, width: u32, height: u32, stride: u32, frameFormat: u32, frameOptions: string): void;
  endImageEncode(): void;
}

// https://searchfox.org/mozilla-central/source/image/imgILoader.idl

interface imgILoader extends nsISupports {
  readonly LOAD_CORS_ANONYMOUS?: 65536;
  readonly LOAD_CORS_USE_CREDENTIALS?: 131072;

  loadImageXPCOM(aURI: nsIURI, aInitialDocumentURL: nsIURI, aReferrerInfo: nsIReferrerInfo, aLoadingPrincipal: nsIPrincipal, aLoadGroup: nsILoadGroup, aObserver: imgINotificationObserver, aLoadingDocument: Document, aLoadFlags: nsLoadFlags, cacheKey: nsISupports, aContentPolicyType?: nsContentPolicyType): imgIRequest;
  loadImageWithChannelXPCOM(aChannel: nsIChannel, aObserver: imgINotificationObserver, aLoadingDocument: Document, aListener: OutParam<nsIStreamListener>): imgIRequest;
}

// https://searchfox.org/mozilla-central/source/image/imgINotificationObserver.idl

interface imgINotificationObserver extends nsISupports {
  readonly SIZE_AVAILABLE?: 1;
  readonly FRAME_UPDATE?: 2;
  readonly FRAME_COMPLETE?: 3;
  readonly LOAD_COMPLETE?: 4;
  readonly DECODE_COMPLETE?: 5;
  readonly DISCARD?: 6;
  readonly UNLOCKED_DRAW?: 7;
  readonly IS_ANIMATED?: 8;
  readonly HAS_TRANSPARENCY?: 9;
}

// https://searchfox.org/mozilla-central/source/image/imgIRequest.idl

interface imgIRequest extends nsIRequest {
  readonly STATUS_NONE?: 0;
  readonly STATUS_SIZE_AVAILABLE?: 1;
  readonly STATUS_LOAD_COMPLETE?: 2;
  readonly STATUS_ERROR?: 4;
  readonly STATUS_FRAME_COMPLETE?: 8;
  readonly STATUS_DECODE_COMPLETE?: 16;
  readonly STATUS_IS_ANIMATED?: 32;
  readonly STATUS_HAS_TRANSPARENCY?: 64;
  readonly CATEGORY_FRAME_INIT?: 1;
  readonly CATEGORY_FRAME_STYLE?: 2;
  readonly CATEGORY_SIZE_QUERY?: 4;
  readonly CATEGORY_DISPLAY?: 8;

  readonly image: imgIContainer;
  readonly providerId: u32;
  readonly triggeringPrincipal: nsIPrincipal;
  readonly imageStatus: u32;
  readonly URI: nsIURI;
  readonly finalURI: nsIURI;
  readonly notificationObserver: imgINotificationObserver;
  readonly mimeType: string;
  readonly fileName: string;
  clone(aObserver: imgINotificationObserver): imgIRequest;
  readonly imagePrincipal: nsIPrincipal;
  readonly hadCrossOriginRedirects: boolean;
  readonly multipart: boolean;
  readonly CORSMode: i32;
  readonly referrerInfo: nsIReferrerInfo;
  cancelAndForgetObserver(aStatus: nsresult): void;
  startDecoding(aFlags: u32): void;
  lockImage(): void;
  unlockImage(): void;
  requestDiscard(): void;
  getStaticRequest(): imgIRequest;
  incrementAnimationConsumers(): void;
  decrementAnimationConsumers(): void;
  boostPriority(aCategory: u32): void;
}

// https://searchfox.org/mozilla-central/source/image/imgIScriptedNotificationObserver.idl

interface imgIScriptedNotificationObserver extends nsISupports {
  sizeAvailable(aRequest: imgIRequest): void;
  frameUpdate(aRequest: imgIRequest): void;
  frameComplete(aRequest: imgIRequest): void;
  loadComplete(aRequest: imgIRequest): void;
  decodeComplete(aRequest: imgIRequest): void;
  discard(aRequest: imgIRequest): void;
  isAnimated(aRequest: imgIRequest): void;
  hasTransparency(aRequest: imgIRequest): void;
}

// https://searchfox.org/mozilla-central/source/image/imgITools.idl

interface imgITools extends nsISupports {
  decodeImageFromBuffer(aBuffer: string, aSize: u32, aMimeType: string): imgIContainer;
  decodeImageFromArrayBuffer(aArrayBuffer: any, aMimeType: string): imgIContainer;
  decodeImageFromChannelAsync(aURI: nsIURI, aChannel: nsIChannel, aCallback: imgIContainerCallback, aObserver: imgINotificationObserver): void;
  decodeImageAsync(aStream: nsIInputStream, aMimeType: string, aCallback: imgIContainerCallback, aEventTarget: nsIEventTarget): void;
  encodeImage(aContainer: imgIContainer, aMimeType: string, outputOptions?: string): nsIInputStream;
  encodeScaledImage(aContainer: imgIContainer, aMimeType: string, aWidth: i32, aHeight: i32, outputOptions?: string): nsIInputStream;
  getImgLoaderForDocument(doc: Document): imgILoader;
  getImgCacheForDocument(doc: Document): imgICache;
  encodeCroppedImage(aContainer: imgIContainer, aMimeType: string, aOffsetX: i32, aOffsetY: i32, aWidth: i32, aHeight: i32, outputOptions?: string): nsIInputStream;
  createScriptedObserver(aObserver: imgIScriptedNotificationObserver): imgINotificationObserver;
}

type imgIContainerCallback = Callable<{
  onImageReady(aImage: imgIContainer, aStatus: nsresult): void;
}>

// https://searchfox.org/mozilla-central/source/image/nsIIconURI.idl

interface nsIMozIconURI extends nsIURI {
  readonly iconURL: nsIURL;
  readonly imageSize: u32;
  readonly imageScale: u32;
  readonly imageDark: boolean;
  readonly stockIcon: string;
  readonly contentType: string;
  readonly fileExtension: string;
}

// https://searchfox.org/mozilla-central/source/layout/inspector/inIDeepTreeWalker.idl

interface inIDeepTreeWalker extends nsISupports {
  showAnonymousContent: boolean;
  showSubDocuments: boolean;
  showDocumentsAsNodes: boolean;
  init(aRoot: Node): void;
  readonly root: Node;
  currentNode: Node;
  parentNode(): Node;
  firstChild(): Node;
  lastChild(): Node;
  previousSibling(): Node;
  nextSibling(): Node;
  previousNode(): Node;
  nextNode(): Node;
}

// https://searchfox.org/mozilla-central/source/intl/strres/nsIStringBundle.idl

interface nsIStringBundle extends nsISupports {
  GetStringFromID(aID: i32): string;
  GetStringFromName(aName: string): string;
  formatStringFromID(aID: i32, params: string[]): string;
  formatStringFromName(aName: string, params: string[]): string;
  getSimpleEnumeration(): nsISimpleEnumerator;
  asyncPreload(): void;
}

interface nsIStringBundleService extends nsISupports {
  createBundle(aURLSpec: string): nsIStringBundle;
  flushBundles(): void;
}

// https://searchfox.org/mozilla-central/source/modules/libjar/nsIJARChannel.idl

interface nsIJARChannel extends nsIChannel {
  jarFile: nsIFile;
  readonly zipEntry: nsIZipEntry;
  ensureCached(): boolean;
}

// https://searchfox.org/mozilla-central/source/modules/libjar/nsIJARURI.idl

interface nsIJARURI extends nsIURL {
  readonly JARFile: nsIURI;
  readonly JAREntry: string;
}

// https://searchfox.org/mozilla-central/source/modules/libjar/nsIZipReader.idl

interface nsIZipEntry extends nsISupports {
  readonly compression: u16;
  readonly size: u32;
  readonly realSize: u32;
  readonly CRC32: u32;
  readonly isDirectory: boolean;
  readonly lastModifiedTime: PRTime;
  readonly isSynthetic: boolean;
  readonly permissions: u32;
}

interface nsIZipReader extends nsISupports {
  open(zipFile: nsIFile): void;
  openInner(zipReader: nsIZipReader, zipEntry: string): void;
  readonly file: nsIFile;
  close(): void;
  test(aEntryName: string): void;
  extract(zipEntry: string, outFile: nsIFile): void;
  getEntry(zipEntry: string): nsIZipEntry;
  hasEntry(zipEntry: string): boolean;
  findEntries(aPattern: string): nsIUTF8StringEnumerator;
  getInputStream(zipEntry: string): nsIInputStream;
}

interface nsIZipReaderCache extends nsISupports {
  init(cacheSize: u32): void;
  getZip(zipFile: nsIFile): nsIZipReader;
  getZipIfCached(zipFile: nsIFile): nsIZipReader;
  isCached(zipFile: nsIFile): boolean;
  getInnerZip(zipFile: nsIFile, zipEntry: string): nsIZipReader;
}

// https://searchfox.org/mozilla-central/source/devtools/platform/IJSDebugger.idl

interface IJSDebugger extends nsISupports {
  addClass(global: any): void;
}

// https://searchfox.org/mozilla-central/source/devtools/platform/nsIJSInspector.idl

interface nsIJSInspector extends nsISupports {
  enterNestedEventLoop(requestor: any): u32;
  exitNestedEventLoop(): u32;
  readonly eventLoopNestLevel: u32;
  readonly lastNestRequestor: any;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/kvstore/nsIKeyValue.idl

}  // global

declare enum nsIKeyValueService_RecoveryStrategy {
  ERROR = 0,
  DISCARD = 1,
  RENAME = 2,
}

declare global {

namespace nsIKeyValueService {
  type RecoveryStrategy = nsIKeyValueService_RecoveryStrategy;
}

interface nsIKeyValueService extends nsISupports, Enums<typeof nsIKeyValueService_RecoveryStrategy> {
  getOrCreate(callback: nsIKeyValueDatabaseCallback, path: string, name: string): void;
  getOrCreateWithOptions(callback: nsIKeyValueDatabaseCallback, path: string, name: string, recoveryStrategy?: nsIKeyValueService.RecoveryStrategy): void;
  createImporter(type: string, path: string): nsIKeyValueImporter;
}

interface nsIKeyValueImportSourceSpec extends nsISupports {
  readonly path: string;
  addDatabase(name: string): nsIKeyValueDatabaseImportOptions;
  addAllDatabases(): nsIKeyValueDatabaseImportOptions;
}

}  // global

declare enum nsIKeyValueImporter_ConflictPolicy {
  ERROR_ON_CONFLICT = 0,
  IGNORE_ON_CONFLICT = 1,
  REPLACE_ON_CONFLICT = 2,
}

declare enum nsIKeyValueImporter_CleanupPolicy {
  KEEP_AFTER_IMPORT = 0,
  DELETE_AFTER_IMPORT = 1,
}

declare global {

namespace nsIKeyValueImporter {
  type ConflictPolicy = nsIKeyValueImporter_ConflictPolicy;
  type CleanupPolicy = nsIKeyValueImporter_CleanupPolicy;
}

interface nsIKeyValueImporter extends nsIKeyValueImportSourceSpec, Enums<typeof nsIKeyValueImporter_ConflictPolicy & typeof nsIKeyValueImporter_CleanupPolicy> {
  readonly type: string;
  addPath(path: string): nsIKeyValueImportSourceSpec;
  import(callback: nsIKeyValueVoidCallback): void;
}

interface nsIKeyValueDatabaseImportOptions extends nsISupports {
  setConflictPolicy(conflictPolicy: nsIKeyValueImporter.ConflictPolicy): nsIKeyValueDatabaseImportOptions;
  setCleanupPolicy(cleanupPolicy: nsIKeyValueImporter.CleanupPolicy): nsIKeyValueDatabaseImportOptions;
}

interface nsIKeyValueDatabase extends nsISupports {
  isEmpty(callback: nsIKeyValueVariantCallback): void;
  count(callback: nsIKeyValueVariantCallback): void;
  size(callback: nsIKeyValueVariantCallback): void;
  put(callback: nsIKeyValueVoidCallback, key: string, value: nsIVariant): void;
  writeMany(callback: nsIKeyValueVoidCallback, pairs: nsIKeyValuePair[]): void;
  get(callback: nsIKeyValueVariantCallback, key: string, defaultValue?: nsIVariant): void;
  has(callback: nsIKeyValueVariantCallback, key: string): void;
  delete(callback: nsIKeyValueVoidCallback, key: string): void;
  deleteRange(callback: nsIKeyValueVoidCallback, fromKey?: string, toKey?: string): void;
  clear(callback: nsIKeyValueVoidCallback): void;
  enumerate(callback: nsIKeyValueEnumeratorCallback, fromKey?: string, toKey?: string): void;
  close(callback: nsIKeyValueVoidCallback): void;
}

interface nsIKeyValuePair extends nsISupports {
  readonly key: string;
  readonly value: nsIVariant;
}

interface nsIKeyValueEnumerator extends nsISupports {
  hasMoreElements(): boolean;
  getNext(): nsIKeyValuePair;
}

interface nsIKeyValueDatabaseCallback extends nsISupports {
  resolve(database: nsIKeyValueDatabase): void;
  reject(message: string): void;
}

interface nsIKeyValueEnumeratorCallback extends nsISupports {
  resolve(enumerator: nsIKeyValueEnumerator): void;
  reject(message: string): void;
}

interface nsIKeyValuePairCallback extends nsISupports {
  resolve(pair: nsIKeyValuePair): void;
  reject(message: string): void;
}

interface nsIKeyValueVariantCallback extends nsISupports {
  resolve(result: nsIVariant): void;
  reject(message: string): void;
}

interface nsIKeyValueVoidCallback extends nsISupports {
  resolve(): void;
  reject(message: string): void;
}

// https://searchfox.org/mozilla-central/source/layout/base/nsILayoutHistoryState.idl

interface nsILayoutHistoryState extends nsISupports {
  readonly hasStates: boolean;
  getKeys(): string[];
  getPresState(aKey: string, aScrollX: OutParam<float>, aScrollY: OutParam<float>, aAllowScrollOriginDowngrade: OutParam<boolean>, aRes: OutParam<float>): void;
  addNewPresState(aKey: string, aScrollX: float, aScrollY: float, aAllowScrollOriginDowngrade: boolean, aRes: float): void;
}

// https://searchfox.org/mozilla-central/source/layout/base/nsIPreloadedStyleSheet.idl

interface nsIPreloadedStyleSheet extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/layout/base/nsISVGPaintContext.idl

interface nsISVGPaintContext extends nsISupports {
  readonly fillColor: string;
  readonly strokeColor: string;
  readonly fillOpacity: float;
  readonly strokeOpacity: float;
}

// https://searchfox.org/mozilla-central/source/layout/base/nsIStyleSheetService.idl

interface nsIStyleSheetService extends nsISupports {
  readonly AGENT_SHEET?: 0;
  readonly USER_SHEET?: 1;
  readonly AUTHOR_SHEET?: 2;

  loadAndRegisterSheet(sheetURI: nsIURI, type: u32): void;
  sheetRegistered(sheetURI: nsIURI, type: u32): boolean;
  preloadSheet(sheetURI: nsIURI, type: u32): nsIPreloadedStyleSheet;
  preloadSheetAsync(sheetURI: nsIURI, type: u32): any;
  unregisterSheet(sheetURI: nsIURI, type: u32): void;
}

// https://searchfox.org/mozilla-central/source/layout/xul/tree/nsITreeSelection.idl

interface nsITreeSelection extends nsISupports {
  tree: XULTreeElement;
  readonly single: boolean;
  readonly count: i32;
  isSelected(index: i32): boolean;
  select(index: i32): void;
  timedSelect(index: i32, delay: i32): void;
  toggleSelect(index: i32): void;
  rangedSelect(startIndex: i32, endIndex: i32, augment: boolean): void;
  clearRange(startIndex: i32, endIndex: i32): void;
  clearSelection(): void;
  selectAll(): void;
  getRangeCount(): i32;
  getRangeAt(i: i32, min: OutParam<i32>, max: OutParam<i32>): void;
  invalidateSelection(): void;
  adjustSelection(index: i32, count: i32): void;
  selectEventsSuppressed: boolean;
  currentIndex: i32;
  readonly shiftSelectPivot: i32;
}

// https://searchfox.org/mozilla-central/source/layout/xul/tree/nsITreeView.idl

interface nsITreeView extends nsISupports {
  readonly DROP_BEFORE?: -1;
  readonly DROP_ON?: 0;
  readonly DROP_AFTER?: 1;

  readonly rowCount: i32;
  selection: nsITreeSelection;
  getRowProperties(index: i32): string;
  getCellProperties(row: i32, col: TreeColumn): string;
  getColumnProperties(col: TreeColumn): string;
  isContainer(index: i32): boolean;
  isContainerOpen(index: i32): boolean;
  isContainerEmpty(index: i32): boolean;
  isSeparator(index: i32): boolean;
  isSorted(): boolean;
  canDrop(index: i32, orientation: i32, dataTransfer: DataTransfer): boolean;
  drop(row: i32, orientation: i32, dataTransfer: DataTransfer): void;
  getParentIndex(rowIndex: i32): i32;
  hasNextSibling(rowIndex: i32, afterIndex: i32): boolean;
  getLevel(index: i32): i32;
  getImageSrc(row: i32, col: TreeColumn): string;
  getCellValue(row: i32, col: TreeColumn): string;
  getCellText(row: i32, col: TreeColumn): string;
  setTree(tree: XULTreeElement): void;
  toggleOpenState(index: i32): void;
  cycleHeader(col: TreeColumn): void;
  selectionChanged(): void;
  cycleCell(row: i32, col: TreeColumn): void;
  isEditable(row: i32, col: TreeColumn): boolean;
  setCellValue(row: i32, col: TreeColumn, value: string): void;
  setCellText(row: i32, col: TreeColumn, value: string): void;
}

// https://searchfox.org/mozilla-central/source/intl/locale/mozILocaleService.idl

interface mozILocaleService extends nsISupports {
  readonly langNegStrategyFiltering?: 0;
  readonly langNegStrategyMatching?: 1;
  readonly langNegStrategyLookup?: 2;

  readonly defaultLocale: string;
  readonly lastFallbackLocale: string;
  readonly appLocalesAsLangTags: string[];
  readonly appLocalesAsBCP47: string[];
  readonly regionalPrefsLocales: string[];
  readonly webExposedLocales: string[];
  negotiateLanguages(aRequested: string[], aAvailable: string[], aDefaultLocale?: string, langNegStrategy?: i32): string[];
  readonly appLocaleAsLangTag: string;
  readonly appLocaleAsBCP47: string;
  requestedLocales: string[];
  readonly requestedLocale: string;
  availableLocales: string[];
  readonly isAppLocaleRTL: boolean;
  readonly packagedLocales: string[];
}

// https://searchfox.org/mozilla-central/source/intl/locale/mozIOSPreferences.idl

interface mozIOSPreferences extends nsISupports {
  readonly dateTimeFormatStyleNone?: 0;
  readonly dateTimeFormatStyleShort?: 1;
  readonly dateTimeFormatStyleMedium?: 2;
  readonly dateTimeFormatStyleLong?: 3;
  readonly dateTimeFormatStyleFull?: 4;

  readonly systemLocales: string[];
  readonly regionalPrefsLocales: string[];
  readonly systemLocale: string;
  getDateTimePattern(timeFormatStyle: i32, dateFormatStyle: i32, locale?: string): string;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/passwordmgr/nsILoginInfo.idl

interface nsILoginInfo extends nsISupports {
  readonly displayOrigin: string;
  origin: string;
  hostname: string;
  formActionOrigin: string;
  formSubmitURL: string;
  httpRealm: string;
  username: string;
  usernameField: string;
  password: string;
  passwordField: string;
  unknownFields: string;
  everSynced: boolean;
  syncCounter: i32;
  init(aOrigin: string, aFormActionOrigin: string, aHttpRealm: string, aUsername: string, aPassword: string, aUsernameField?: string, aPasswordField?: string): void;
  equals(aLoginInfo: nsILoginInfo): boolean;
  matches(aLoginInfo: nsILoginInfo, ignorePassword: boolean): boolean;
  clone(): nsILoginInfo;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/passwordmgr/nsILoginManager.idl

interface nsILoginSearchCallback extends nsISupports {
  onSearchComplete(aLogins: nsILoginInfo[]): void;
}

interface nsILoginManager extends nsISupports {
  readonly initializationPromise: Promise<any>;
  addLogin(aLogin: nsILoginInfo): nsILoginInfo;
  addLoginAsync(aLogin: nsILoginInfo): Promise<any>;
  addLogins(aLogins: any): Promise<any>;
  removeLogin(aLogin: nsILoginInfo): void;
  modifyLogin(oldLogin: nsILoginInfo, newLoginData: nsISupports): void;
  recordPasswordUse(aLogin: nsILoginInfo, aPrivateContextWithoutExplicitConsent: boolean, aLoginType: string, aFilled: boolean): void;
  removeAllUserFacingLogins(): void;
  removeAllLogins(): void;
  getAllLogins(): Promise<any>;
  getAllLoginsWithCallback(aCallback: nsILoginSearchCallback): void;
  getAllDisabledHosts(): string[];
  getLoginSavingEnabled(aHost: string): boolean;
  setLoginSavingEnabled(aHost: string, isEnabled: boolean): void;
  findLogins(aOrigin: string, aActionOrigin: string, aHttpRealm: string): nsILoginInfo[];
  countLogins(aOrigin: string, aActionOrigin: string, aHttpRealm: string): u32;
  searchLoginsAsync(matchData: any): Promise<any>;
  searchLogins(matchData: nsIPropertyBag): nsILoginInfo[];
  getSyncID(): Promise<any>;
  setSyncID(syncID: string): Promise<any>;
  getLastSync(): Promise<any>;
  setLastSync(timestamp: double): Promise<any>;
  ensureCurrentSyncID(newSyncID: string): Promise<any>;
  readonly uiBusy: boolean;
  readonly isLoggedIn: boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/passwordmgr/nsILoginManagerAuthPrompter.idl

interface nsILoginManagerAuthPrompter extends nsISupports {
  init(aWindow: nsIDOMWindow): void;
  browser: Element;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/passwordmgr/nsILoginManagerCrypto.idl

interface nsILoginManagerCrypto extends nsISupports {
  readonly ENCTYPE_BASE64?: 0;
  readonly ENCTYPE_SDR?: 1;

  encrypt(plainText: string): string;
  encryptMany(plainTexts: any): Promise<any>;
  decrypt(cipherText: string): string;
  decryptMany(cipherTexts: any): Promise<any>;
  readonly uiBusy: boolean;
  readonly isLoggedIn: boolean;
  readonly defaultEncType: u32;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/passwordmgr/nsILoginManagerPrompter.idl

interface nsILoginManagerPrompter extends nsISupports {
  promptToSavePassword(aBrowser: Element, aLogin: nsILoginInfo, dismissed?: boolean, notifySaved?: boolean, autoFilledLoginGuid?: string, possibleValues?: any): nsIPromptInstance;
  promptToChangePassword(aBrowser: Element, aOldLogin: nsILoginInfo, aNewLogin: nsILoginInfo, dismissed?: boolean, notifySaved?: boolean, autoSavedLoginGuid?: string, autoFilledLoginGuid?: string, possibleValues?: any): nsIPromptInstance;
  promptToChangePasswordWithUsernames(aBrowser: Element, logins: nsILoginInfo[], aNewLogin: nsILoginInfo): nsIPromptInstance;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/passwordmgr/nsILoginMetaInfo.idl

interface nsILoginMetaInfo extends nsISupports {
  guid: string;
  timeCreated: u64;
  timeLastUsed: u64;
  timePasswordChanged: u64;
  timesUsed: u32;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/passwordmgr/nsIPromptInstance.idl

interface nsIPromptInstance extends nsISupports {
  dismiss(): void;
}

// https://searchfox.org/mozilla-central/source/browser/components/migration/nsIEdgeMigrationUtils.idl

interface nsIEdgeMigrationUtils extends nsISupports {
  isDbLocked(aFile: nsIFile): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/netwerk/mime/nsIMIMEHeaderParam.idl

interface nsIMIMEHeaderParam extends nsISupports {
  getParameter(aHeaderVal: string, aParamName: string, aFallbackCharset: string, aTryLocaleCharset: boolean, aLang: OutParam<string>): string;
  getParameterHTTP(aHeaderVal: string, aParamName: string, aFallbackCharset: string, aTryLocaleCharset: boolean, aLang: OutParam<string>): string;
  decodeRFC5987Param(aParamVal: string, aLang: OutParam<string>): string;
}

// https://searchfox.org/mozilla-central/source/netwerk/mime/nsIMIMEInfo.idl

interface nsIHandlerInfo extends nsISupports {
  readonly saveToDisk?: 0;
  readonly alwaysAsk?: 1;
  readonly useHelperApp?: 2;
  readonly handleInternally?: 3;
  readonly useSystemDefault?: 4;

  readonly type: string;
  description: string;
  preferredApplicationHandler: nsIHandlerApp;
  readonly possibleApplicationHandlers: nsIMutableArray;
  readonly hasDefaultHandler: boolean;
  readonly defaultDescription: string;
  readonly defaultExecutable: nsIFile;
  launchWithURI(aURI: nsIURI, aBrowsingContext?: BrowsingContext): void;
  preferredAction: nsHandlerInfoAction;
  alwaysAskBeforeHandling: boolean;
}

interface nsIMIMEInfo extends nsIHandlerInfo {
  getFileExtensions(): nsIUTF8StringEnumerator;
  setFileExtensions(aExtensions: string): void;
  extensionExists(aExtension: string): boolean;
  appendExtension(aExtension: string): void;
  primaryExtension: string;
  readonly MIMEType: string;
  equals(aMIMEInfo: nsIMIMEInfo): boolean;
  readonly possibleLocalHandlers: nsIArray;
  launchWithFile(aFile: nsIFile): void;
  isCurrentAppOSDefault(): boolean;
}

interface nsIHandlerApp extends nsISupports {
  name: string;
  detailedDescription: string;
  equals(aHandlerApp: nsIHandlerApp): boolean;
  launchWithURI(aURI: nsIURI, aBrowsingContext?: BrowsingContext): void;
}

interface nsILocalHandlerApp extends nsIHandlerApp {
  executable: nsIFile;
  readonly parameterCount: u32;
  prettyNameAsync(): Promise<any>;
  clearParameters(): void;
  appendParameter(param: string): void;
  getParameter(parameterIndex: u32): string;
  parameterExists(param: string): boolean;
}

interface nsIWebHandlerApp extends nsIHandlerApp {
  uriTemplate: string;
}

interface nsIDBusHandlerApp extends nsIHandlerApp {
  service: string;
  objectPath: string;
  dBusInterface: string;
  method: string;
}

// https://searchfox.org/mozilla-central/source/netwerk/mime/nsIMIMEService.idl

interface nsIMIMEService extends nsISupports {
  readonly VALIDATE_DEFAULT?: 0;
  readonly VALIDATE_SANITIZE_ONLY?: 1;
  readonly VALIDATE_DONT_COLLAPSE_WHITESPACE?: 2;
  readonly VALIDATE_DONT_TRUNCATE?: 4;
  readonly VALIDATE_GUESS_FROM_EXTENSION?: 8;
  readonly VALIDATE_ALLOW_EMPTY?: 16;
  readonly VALIDATE_NO_DEFAULT_FILENAME?: 32;
  readonly VALIDATE_FORCE_APPEND_EXTENSION?: 64;
  readonly VALIDATE_ALLOW_INVALID_FILENAMES?: 128;
  readonly VALIDATE_ALLOW_DIRECTORY_NAMES?: 256;

  getFromTypeAndExtension(aMIMEType: string, aFileExt: string): nsIMIMEInfo;
  getTypeFromExtension(aFileExt: string): string;
  getTypeFromURI(aURI: nsIURI): string;
  getDefaultTypeFromURI(aURI: nsIURI): string;
  getTypeFromFile(aFile: nsIFile): string;
  getPrimaryExtension(aMIMEType: string, aFileExt: string): string;
  getMIMEInfoFromOS(aType: string, aFileExtension: string, aFound: OutParam<boolean>): nsIMIMEInfo;
  updateDefaultAppInfo(aMIMEInfo: nsIMIMEInfo): void;
  getValidFileName(aChannel: nsIChannel, aType: string, aOriginalURI: nsIURI, aFlags: u32): string;
  validateFileNameForSaving(aFileName: string, aType: string, aFlags: u32): string;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/ml/nsIMLUtils.idl

interface nsIMLUtils extends nsISupports {
  readonly totalPhysicalMemory: u64;
  readonly availablePhysicalMemory: u64;
  getOptimalCPUConcurrency(): u8;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/find/nsIFind.idl

interface nsIFind extends nsISupports {
  findBackwards: boolean;
  caseSensitive: boolean;
  entireWord: boolean;
  matchDiacritics: boolean;
  Find(aPatText: string, aSearchRange: Range, aStartPoint: Range, aEndPoint: Range): Range;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/find/nsIFindService.idl

interface nsIFindService extends nsISupports {
  searchString: string;
  replaceString: string;
  findBackwards: boolean;
  wrapFind: boolean;
  entireWord: boolean;
  matchCase: boolean;
  matchDiacritics: boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/find/nsIWebBrowserFind.idl

interface nsIWebBrowserFind extends nsISupports {
  findNext(): boolean;
  searchString: string;
  findBackwards: boolean;
  wrapFind: boolean;
  entireWord: boolean;
  matchCase: boolean;
  matchDiacritics: boolean;
  searchFrames: boolean;
}

interface nsIWebBrowserFindInFrames extends nsISupports {
  currentSearchFrame: mozIDOMWindowProxy;
  rootSearchFrame: mozIDOMWindowProxy;
  searchSubframes: boolean;
  searchParentFrames: boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/mozintl/mozIMozIntl.idl

interface mozIMozIntl extends nsISupports {
  getCalendarInfo(locales?: any): any;
  getDisplayNamesDeprecated(locales?: any, options?: any): any;
  getAvailableLocaleDisplayNames(type: any): any;
  getLanguageDisplayNames(locales: any, langCodes: any): any;
  getRegionDisplayNames(locales: any, regionCodes: any): any;
  getLocaleDisplayNames(locales: any, localeCodes: any, options?: any): any;
  getScriptDirection(locale: any): any;
  stringHasRTLChars(str: any): boolean;
  readonly Collator: any;
  readonly DateTimeFormat: any;
  readonly DisplayNames: any;
  readonly ListFormat: any;
  readonly Locale: any;
  readonly NumberFormat: any;
  readonly PluralRules: any;
  readonly RelativeTimeFormat: any;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/mozintl/mozIMozIntlHelper.idl

interface mozIMozIntlHelper extends nsISupports {
  addGetCalendarInfo(intlObject: any): void;
  addDateTimeFormatConstructor(intlObject: any): void;
  addDisplayNamesConstructor(intlObject: any): void;
  stringHasRTLChars(str: any): boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/mozIThirdPartyUtil.idl

interface mozIThirdPartyUtil extends nsISupports {
  isThirdPartyURI(aFirstURI: nsIURI, aSecondURI: nsIURI): boolean;
  isThirdPartyWindow(aWindow: mozIDOMWindowProxy, aURI?: nsIURI): boolean;
  isThirdPartyChannel(aChannel: nsIChannel, aURI?: nsIURI): boolean;
  getBaseDomain(aHostURI: nsIURI): string;
  getURIFromWindow(aWindow: mozIDOMWindowProxy): nsIURI;
  getPrincipalFromWindow(aWindow: mozIDOMWindowProxy): nsIPrincipal;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIAndroidContentInputStream.idl

interface nsIAndroidContentInputStream extends nsIInputStream {
  init(uri: nsIURI): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIArrayBufferInputStream.idl

interface nsIArrayBufferInputStream extends nsIInputStream {
  setData(buffer: any, byteOffset: u64, byteLen: u64): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIAsyncStreamCopier.idl

interface nsIAsyncStreamCopier extends nsIRequest {
  init(aSource: nsIInputStream, aSink: nsIOutputStream, aTarget: nsIEventTarget, aSourceBuffered: boolean, aSinkBuffered: boolean, aChunkSize: u32, aCloseSource: boolean, aCloseSink: boolean): void;
  asyncCopy(aObserver: nsIRequestObserver, aObserverContext: nsISupports): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIAsyncStreamCopier2.idl

interface nsIAsyncStreamCopier2 extends nsIRequest {
  init(aSource: nsIInputStream, aSink: nsIOutputStream, aTarget: nsIEventTarget, aChunkSize: u32, aCloseSource: boolean, aCloseSink: boolean): void;
  asyncCopy(aObserver: nsIRequestObserver, aObserverContext: nsISupports): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIAsyncVerifyRedirectCallback.idl

interface nsIAsyncVerifyRedirectCallback extends nsISupports {
  onRedirectVerifyCallback(result: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIAuthInformation.idl

interface nsIAuthInformation extends nsISupports {
  readonly AUTH_HOST?: 1;
  readonly AUTH_PROXY?: 2;
  readonly NEED_DOMAIN?: 4;
  readonly ONLY_PASSWORD?: 8;
  readonly PREVIOUS_FAILED?: 16;
  readonly CROSS_ORIGIN_SUB_RESOURCE?: 32;

  readonly flags: u32;
  readonly realm: string;
  readonly authenticationScheme: string;
  username: string;
  password: string;
  domain: string;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIAuthModule.idl

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIAuthPrompt.idl

interface nsIAuthPrompt extends nsISupports {
  readonly SAVE_PASSWORD_NEVER?: 0;
  readonly SAVE_PASSWORD_FOR_SESSION?: 1;
  readonly SAVE_PASSWORD_PERMANENTLY?: 2;

  prompt(dialogTitle: string, text: string, passwordRealm: string, savePassword: u32, defaultText: string, result: OutParam<string>): boolean;
  promptUsernameAndPassword(dialogTitle: string, text: string, passwordRealm: string, savePassword: u32, user: InOutParam<string>, pwd: InOutParam<string>): boolean;
  asyncPromptUsernameAndPassword(dialogTitle: string, text: string, passwordRealm: string, savePassword: u32, user: InOutParam<string>, pwd: InOutParam<string>): Promise<any>;
  promptPassword(dialogTitle: string, text: string, passwordRealm: string, savePassword: u32, pwd: InOutParam<string>): boolean;
  asyncPromptPassword(dialogTitle: string, text: string, passwordRealm: string, savePassword: u32, pwd: InOutParam<string>): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIAuthPrompt2.idl

interface nsIAuthPrompt2 extends nsISupports {
  readonly LEVEL_NONE?: 0;
  readonly LEVEL_PW_ENCRYPTED?: 1;
  readonly LEVEL_SECURE?: 2;

  promptAuth(aChannel: nsIChannel, level: u32, authInfo: nsIAuthInformation): boolean;
  asyncPromptAuth(aChannel: nsIChannel, aCallback: nsIAuthPromptCallback, aContext: nsISupports, level: u32, authInfo: nsIAuthInformation): nsICancelable;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIAuthPromptAdapterFactory.idl

interface nsIAuthPromptAdapterFactory extends nsISupports {
  createAdapter(aPrompt: nsIAuthPrompt): nsIAuthPrompt2;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIAuthPromptCallback.idl

interface nsIAuthPromptCallback extends nsISupports {
  onAuthAvailable(aContext: nsISupports, aAuthInfo: nsIAuthInformation): void;
  onAuthCancelled(aContext: nsISupports, userCancel: boolean): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIAuthPromptProvider.idl

interface nsIAuthPromptProvider extends nsISupports {
  readonly PROMPT_NORMAL?: 0;
  readonly PROMPT_PROXY?: 1;

  getAuthPrompt<T extends nsIID>(aPromptReason: u32, iid: T): nsQIResult<T>;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIBackgroundFileSaver.idl

interface nsIBackgroundFileSaver extends nsISupports {
  observer: nsIBackgroundFileSaverObserver;
  readonly signatureInfo: u8[][][];
  readonly sha256Hash: string;
  enableSignatureInfo(): void;
  enableSha256(): void;
  enableAppend(): void;
  setTarget(aTarget: nsIFile, aKeepPartial: boolean): void;
  finish(aStatus: nsresult): void;
}

interface nsIBackgroundFileSaverObserver extends nsISupports {
  onTargetChange(aSaver: nsIBackgroundFileSaver, aTarget: nsIFile): void;
  onSaveComplete(aSaver: nsIBackgroundFileSaver, aStatus: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIBaseChannel.idl

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIBufferedStreams.idl

interface nsIBufferedInputStream extends nsIInputStream {
  init(fillFromStream: nsIInputStream, bufferSize: u32): void;
  readonly data: nsIInputStream;
}

interface nsIBufferedOutputStream extends nsIOutputStream {
  init(sinkToStream: nsIOutputStream, bufferSize: u32): void;
  readonly data: nsIOutputStream;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIByteRangeRequest.idl

interface nsIByteRangeRequest extends nsISupports {
  readonly isByteRangeRequest: boolean;
  readonly startRange: i64;
  readonly endRange: i64;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsICacheInfoChannel.idl

interface nsIInputStreamReceiver extends nsISupports {
  onInputStreamReady(aStream: nsIInputStream): void;
}

}  // global

declare enum nsICacheInfoChannel_PreferredAlternativeDataDeliveryType {
  NONE = 0,
  ASYNC = 1,
  SERIALIZE = 2,
}

declare global {

namespace nsICacheInfoChannel {
  type PreferredAlternativeDataDeliveryType = nsICacheInfoChannel_PreferredAlternativeDataDeliveryType;
}

interface nsICacheInfoChannel extends nsISupports, Enums<typeof nsICacheInfoChannel_PreferredAlternativeDataDeliveryType> {
  readonly cacheTokenFetchCount: u32;
  readonly cacheTokenExpirationTime: u32;
  isFromCache(): boolean;
  isRacing(): boolean;
  getCacheEntryId(): u64;
  cacheKey: u32;
  allowStaleCacheContent: boolean;
  preferCacheLoadOverBypass: boolean;
  forceValidateCacheContent: boolean;
  preferAlternativeDataType(type: string, contentType: string, deliverAltData: nsICacheInfoChannel.PreferredAlternativeDataDeliveryType): void;
  readonly alternativeDataType: string;
  readonly alternativeDataInputStream: nsIInputStream;
  getOriginalInputStream(aReceiver: nsIInputStreamReceiver): void;
  openAlternativeOutputStream(type: string, predictedSize: i64): nsIAsyncOutputStream;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsICachingChannel.idl

interface nsICachingChannel extends nsICacheInfoChannel {
  readonly LOAD_NO_NETWORK_IO?: 67108864;
  readonly LOAD_BYPASS_LOCAL_CACHE?: 268435456;
  readonly LOAD_BYPASS_LOCAL_CACHE_IF_BUSY?: 536870912;
  readonly LOAD_ONLY_FROM_CACHE?: 1073741824;
  readonly LOAD_ONLY_IF_MODIFIED?: 2147483648;

  cacheToken: nsISupports;
  cacheOnlyMetadata: boolean;
  pin: boolean;
  forceCacheEntryValidFor(aSecondsToTheFuture: u32): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsICancelable.idl

interface nsICancelable extends nsISupports {
  cancel(aReason: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsICaptivePortalService.idl

interface nsICaptivePortalServiceCallback extends nsISupports {
  complete(success: boolean, error: nsresult): void;
}

interface nsICaptivePortalService extends nsISupports {
  readonly UNKNOWN?: 0;
  readonly NOT_CAPTIVE?: 1;
  readonly UNLOCKED_PORTAL?: 2;
  readonly LOCKED_PORTAL?: 3;

  recheckCaptivePortal(): void;
  readonly state: i32;
  readonly lastChecked: u64;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIChannel.idl

interface nsIChannel extends nsIRequest {
  readonly LOAD_DOCUMENT_URI?: 65536;
  readonly LOAD_RETARGETED_DOCUMENT_URI?: 131072;
  readonly LOAD_REPLACE?: 262144;
  readonly LOAD_INITIAL_DOCUMENT_URI?: 524288;
  readonly LOAD_TARGETED?: 1048576;
  readonly LOAD_CALL_CONTENT_SNIFFERS?: 2097152;
  readonly LOAD_BYPASS_URL_CLASSIFIER?: 4194304;
  readonly LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE?: 8388608;
  readonly LOAD_EXPLICIT_CREDENTIALS?: 16777216;
  readonly LOAD_BYPASS_SERVICE_WORKER?: 33554432;
  readonly DISPOSITION_INLINE?: 0;
  readonly DISPOSITION_ATTACHMENT?: 1;
  readonly DISPOSITION_FORCE_INLINE?: 2;

  originalURI: nsIURI;
  readonly URI: nsIURI;
  owner: nsISupports;
  notificationCallbacks: nsIInterfaceRequestor;
  readonly securityInfo: nsITransportSecurityInfo;
  contentType: string;
  contentCharset: string;
  contentLength: i64;
  open(): nsIInputStream;
  asyncOpen(aListener: nsIStreamListener): void;
  readonly canceled: boolean;
  contentDisposition: u32;
  contentDispositionFilename: string;
  readonly contentDispositionHeader: string;
  loadInfo: nsILoadInfo;
  readonly isDocument: boolean;
}

interface nsIIdentChannel extends nsIChannel {
  channelId: u64;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIChannelEventSink.idl

interface nsIChannelEventSink extends nsISupports {
  readonly REDIRECT_TEMPORARY?: 1;
  readonly REDIRECT_PERMANENT?: 2;
  readonly REDIRECT_INTERNAL?: 4;
  readonly REDIRECT_STS_UPGRADE?: 8;
  readonly REDIRECT_AUTH_RETRY?: 16;
  readonly REDIRECT_TRANSPARENT?: 32;

  asyncOnChannelRedirect(oldChannel: nsIChannel, newChannel: nsIChannel, flags: u32, callback: nsIAsyncVerifyRedirectCallback): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIChildChannel.idl

interface nsIChildChannel extends nsISupports {
  connectParent(registrarId: u32): void;
  completeRedirectSetup(aListener: nsIStreamListener): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIClassOfService.idl

}  // global

declare enum nsIClassOfService_FetchPriority {
  FETCHPRIORITY_UNSET = 0,
  FETCHPRIORITY_LOW = 1,
  FETCHPRIORITY_AUTO = 2,
  FETCHPRIORITY_HIGH = 3,
}

declare global {

namespace nsIClassOfService {
  type FetchPriority = nsIClassOfService_FetchPriority;
}

interface nsIClassOfService extends nsISupports, Enums<typeof nsIClassOfService_FetchPriority> {
  readonly Leader?: 1;
  readonly Follower?: 2;
  readonly Speculative?: 4;
  readonly Background?: 8;
  readonly Unblocked?: 16;
  readonly Throttleable?: 32;
  readonly UrgentStart?: 64;
  readonly DontThrottle?: 128;
  readonly Tail?: 256;
  readonly TailAllowed?: 512;
  readonly TailForbidden?: 1024;

  classFlags: u32;
  incremental: boolean;
  clearClassFlags(flags: u32): void;
  addClassFlags(flags: u32): void;
  fetchPriority: nsIClassOfService.FetchPriority;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIClassifiedChannel.idl

}  // global

declare enum nsIClassifiedChannel_ClassificationFlags {
  CLASSIFIED_FINGERPRINTING = 1,
  CLASSIFIED_FINGERPRINTING_CONTENT = 128,
  CLASSIFIED_CRYPTOMINING = 2,
  CLASSIFIED_CRYPTOMINING_CONTENT = 256,
  CLASSIFIED_TRACKING = 4,
  CLASSIFIED_TRACKING_AD = 8,
  CLASSIFIED_TRACKING_ANALYTICS = 16,
  CLASSIFIED_TRACKING_SOCIAL = 32,
  CLASSIFIED_TRACKING_CONTENT = 64,
  CLASSIFIED_SOCIALTRACKING = 512,
  CLASSIFIED_SOCIALTRACKING_FACEBOOK = 1024,
  CLASSIFIED_SOCIALTRACKING_LINKEDIN = 2048,
  CLASSIFIED_SOCIALTRACKING_TWITTER = 4096,
  CLASSIFIED_EMAILTRACKING = 8192,
  CLASSIFIED_EMAILTRACKING_CONTENT = 16384,
  CLASSIFIED_CONSENTMANAGER = 32768,
  CLASSIFIED_ANY_BASIC_TRACKING = 61,
  CLASSIFIED_ANY_STRICT_TRACKING = 253,
  CLASSIFIED_ANY_SOCIAL_TRACKING = 7680,
}

declare global {

namespace nsIClassifiedChannel {
  type ClassificationFlags = nsIClassifiedChannel_ClassificationFlags;
}

interface nsIClassifiedChannel extends nsISupports, Enums<typeof nsIClassifiedChannel_ClassificationFlags> {
  setMatchedInfo(aList: string, aProvider: string, aFullHash: string): void;
  readonly matchedList: string;
  readonly matchedProvider: string;
  readonly matchedFullHash: string;
  setMatchedTrackingInfo(aLists: string[], aFullHashes: string[]): void;
  readonly matchedTrackingLists: string[];
  readonly matchedTrackingFullHashes: string[];
  readonly firstPartyClassificationFlags: u32;
  readonly thirdPartyClassificationFlags: u32;
  readonly classificationFlags: u32;
  isThirdPartyTrackingResource(): boolean;
  isThirdPartySocialTrackingResource(): boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIContentSniffer.idl

interface nsIContentSniffer extends nsISupports {
  getMIMETypeFromContent(aRequest: nsIRequest, aData: u8[], aLength: u32): string;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIDHCPClient.idl

interface nsIDHCPClient extends nsISupports {
  getOption(option: u8): string;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIDashboard.idl

type nsINetDashboardCallback = Callable<{
  onDashboardDataAvailable(data: any): void;
}>

interface nsIDashboard extends nsISupports {
  requestSockets(cb: nsINetDashboardCallback): void;
  requestHttpConnections(cb: nsINetDashboardCallback): void;
  requestWebsocketConnections(cb: nsINetDashboardCallback): void;
  requestDNSInfo(cb: nsINetDashboardCallback): void;
  requestConnection(aHost: string, aPort: u32, aProtocol: string, aTimeout: u32, cb: nsINetDashboardCallback): void;
  enableLogging: boolean;
  requestDNSLookup(aHost: string, cb: nsINetDashboardCallback): void;
  requestDNSHTTPSRRLookup(aHost: string, cb: nsINetDashboardCallback): void;
  requestRcwnStats(cb: nsINetDashboardCallback): void;
  getLogPath(): string;
  requestHttp3ConnectionStats(cb: nsINetDashboardCallback): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIDashboardEventNotifier.idl

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIDownloader.idl

interface nsIDownloader extends nsIStreamListener {
  init(observer: nsIDownloadObserver, downloadLocation: nsIFile): void;
}

interface nsIDownloadObserver extends nsISupports {
  onDownloadComplete(downloader: nsIDownloader, request: nsIRequest, status: nsresult, result: nsIFile): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIEncodedChannel.idl

interface nsIEncodedChannel extends nsISupports {
  readonly contentEncodings: nsIUTF8StringEnumerator;
  applyConversion: boolean;
  hasContentDecompressed: boolean;
  doApplyContentConversions(aNextListener: nsIStreamListener, aNewNextListener: OutParam<nsIStreamListener>, aCtxt: nsISupports): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIExternalProtocolHandler.idl

interface nsIExternalProtocolHandler extends nsIProtocolHandler {
  externalAppExistsForScheme(scheme: string): boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIFileStreams.idl

interface nsIFileInputStream extends nsIInputStream {
  readonly CLOSE_ON_EOF?: 4;
  readonly REOPEN_ON_REWIND?: 8;
  readonly DEFER_OPEN?: 16;
  readonly SHARE_DELETE?: 32;

  init(file: nsIFile, ioFlags: i32, perm: i32, behaviorFlags: i32): void;
}

interface nsIFileOutputStream extends nsIOutputStream {
  readonly DEFER_OPEN?: 1;

  init(file: nsIFile, ioFlags: i32, perm: i32, behaviorFlags: i32): void;
}

interface nsIFileRandomAccessStream extends nsIRandomAccessStream {
  readonly DEFER_OPEN?: 1;

  init(file: nsIFile, ioFlags: i32, perm: i32, behaviorFlags: i32): void;
}

interface nsIFileMetadata extends nsISupports {
  readonly size: i64;
  readonly lastModified: i64;
}

interface nsIAsyncFileMetadata extends nsIFileMetadata {
  asyncFileMetadataWait(aCallback: nsIFileMetadataCallback, aEventTarget: nsIEventTarget): void;
}

type nsIFileMetadataCallback = Callable<{
  onFileMetadataReady(aObject: nsIAsyncFileMetadata): void;
}>

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIFileURL.idl

interface nsIFileURL extends nsIURL {
  readonly file: nsIFile;
}

interface nsIFileURLMutator extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIForcePendingChannel.idl

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIFormPOSTActionChannel.idl

interface nsIFormPOSTActionChannel extends nsIUploadChannel {
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIHttpAuthenticatorCallback.idl

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIIOService.idl

interface nsIIOService extends nsISupports {
  getProtocolHandler(aScheme: string): nsIProtocolHandler;
  getProtocolFlags(aScheme: string): u32;
  getDynamicProtocolFlags(aURI: nsIURI): u32;
  getDefaultPort(aScheme: string): i32;
  newURI(aSpec: string, aOriginCharset?: string, aBaseURI?: nsIURI): nsIURI;
  newFileURI(aFile: nsIFile): nsIURI;
  createExposableURI(aURI: nsIURI): nsIURI;
  newChannelFromURI(aURI: nsIURI, aLoadingNode: Node, aLoadingPrincipal: nsIPrincipal, aTriggeringPrincipal: nsIPrincipal, aSecurityFlags: u32, aContentPolicyType: nsContentPolicyType): nsIChannel;
  newChannelFromURIWithLoadInfo(aURI: nsIURI, aLoadInfo: nsILoadInfo): nsIChannel;
  newChannel(aSpec: string, aOriginCharset: string, aBaseURI: nsIURI, aLoadingNode: Node, aLoadingPrincipal: nsIPrincipal, aTriggeringPrincipal: nsIPrincipal, aSecurityFlags: u32, aContentPolicyType: nsContentPolicyType): nsIChannel;
  newSuspendableChannelWrapper(innerChannel: nsIChannel): nsISuspendableChannelWrapper;
  newWebTransport(): nsIWebTransport;
  originAttributesForNetworkState(aChannel: nsIChannel): any;
  offline: boolean;
  readonly connectivity: boolean;
  setConnectivityForTesting(connectivity: boolean): void;
  allowPort(aPort: i32, aScheme: string): boolean;
  extractScheme(urlString: string): string;
  hostnameIsLocalIPAddress(aURI: nsIURI): boolean;
  hostnameIsSharedIPAddress(aURI: nsIURI): boolean;
  hostnameIsIPAddressAny(aURI: nsIURI): boolean;
  isValidHostname(hostname: string): boolean;
  manageOfflineStatus: boolean;
  newChannelFromURIWithProxyFlags(aURI: nsIURI, aProxyURI: nsIURI, aProxyFlags: u32, aLoadingNode: Node, aLoadingPrincipal: nsIPrincipal, aTriggeringPrincipal: nsIPrincipal, aSecurityFlags: u32, aContentPolicyType: nsContentPolicyType): nsIChannel;
  readonly socketProcessLaunched: boolean;
  readonly socketProcessId: u64;
  registerProtocolHandler(aScheme: string, aHandler: nsIProtocolHandler, aProtocolFlags: u32, aDefaultPort: i32): void;
  unregisterProtocolHandler(aScheme: string): void;
  setSimpleURIUnknownRemoteSchemes(aRemoteSchemes: string[]): void;
  addEssentialDomainMapping(aFrom: string, aTo: string): void;
  clearEssentialDomainMapping(): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIIncrementalDownload.idl

interface nsIIncrementalDownload extends nsIRequest {
  init(uri: nsIURI, destination: nsIFile, chunkSize: i32, intervalInSeconds: i32, extraHeaders: string): void;
  readonly URI: nsIURI;
  readonly finalURI: nsIURI;
  readonly destination: nsIFile;
  readonly totalSize: i64;
  readonly currentSize: i64;
  start(observer: nsIRequestObserver, ctxt: nsISupports): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIIncrementalStreamLoader.idl

interface nsIIncrementalStreamLoaderObserver extends nsISupports {
  onStartRequest(aRequest: nsIRequest): void;
  onIncrementalData(loader: nsIIncrementalStreamLoader, ctxt: nsISupports, dataLength: u32, data: u8[], consumedLength: InOutParam<u32>): void;
  onStreamComplete(loader: nsIIncrementalStreamLoader, ctxt: nsISupports, status: nsresult, resultLength: u32, result: u8[]): void;
}

interface nsIIncrementalStreamLoader extends nsIThreadRetargetableStreamListener {
  init(aObserver: nsIIncrementalStreamLoaderObserver): void;
  readonly numBytesRead: u32;
  readonly request: nsIRequest;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIInputStreamChannel.idl

interface nsIInputStreamChannel extends nsISupports {
  setURI(aURI: nsIURI): void;
  contentStream: nsIInputStream;
  srcdocData: string;
  readonly isSrcdocChannel: boolean;
  baseURI: nsIURI;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIInputStreamPump.idl

interface nsIInputStreamPump extends nsIRequest {
  init(aStream: nsIInputStream, aSegmentSize: u32, aSegmentCount: u32, aCloseWhenDone: boolean, aMainThreadTarget?: nsISerialEventTarget): void;
  asyncRead(aListener: nsIStreamListener): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIInterceptionInfo.idl

interface nsIInterceptionInfo extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsILoadContextInfo.idl

interface nsILoadContextInfo extends nsISupports {
  readonly isPrivate: boolean;
  readonly isAnonymous: boolean;
  readonly originAttributes: any;
}

interface nsILoadContextInfoFactory extends nsISupports {
  readonly default: nsILoadContextInfo;
  readonly private: nsILoadContextInfo;
  readonly anonymous: nsILoadContextInfo;
  custom(aAnonymous: boolean, aOriginAttributes: any): nsILoadContextInfo;
  fromLoadContext(aLoadContext: nsILoadContext, aAnonymous: boolean): nsILoadContextInfo;
  fromWindow(aWindow: nsIDOMWindow, aAnonymous: boolean): nsILoadContextInfo;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsILoadGroup.idl

interface nsILoadGroup extends nsIRequest {
  groupObserver: nsIRequestObserver;
  defaultLoadRequest: nsIRequest;
  addRequest(aRequest: nsIRequest, aContext: nsISupports): void;
  removeRequest(aRequest: nsIRequest, aContext: nsISupports, aStatus: nsresult): void;
  readonly requests: nsISimpleEnumerator;
  totalKeepAliveBytes: u64;
  readonly activeCount: u32;
  notificationCallbacks: nsIInterfaceRequestor;
  readonly requestContextID: u64;
  defaultLoadFlags: nsLoadFlags;
  readonly isBrowsingContextDiscarded: boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsILoadGroupChild.idl

interface nsILoadGroupChild extends nsISupports {
  parentLoadGroup: nsILoadGroup;
  readonly childLoadGroup: nsILoadGroup;
  readonly rootLoadGroup: nsILoadGroup;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsILoadInfo.idl

}  // global

declare enum nsILoadInfo_StoragePermissionState {
  NoStoragePermission = 0,
  HasStoragePermission = 1,
  StoragePermissionAllowListed = 2,
}

declare enum nsILoadInfo_IPAddressSpace {
  Unknown = 0,
  Local = 1,
  Private = 2,
  Public = 3,
  Invalid = 4,
}

declare enum nsILoadInfo_CrossOriginOpenerPolicy {
  OPENER_POLICY_UNSAFE_NONE = 0,
  OPENER_POLICY_SAME_ORIGIN = 1,
  OPENER_POLICY_SAME_ORIGIN_ALLOW_POPUPS = 2,
  OPENER_POLICY_EMBEDDER_POLICY_REQUIRE_CORP_FLAG = 16,
  OPENER_POLICY_SAME_ORIGIN_EMBEDDER_POLICY_REQUIRE_CORP = 17,
}

declare enum nsILoadInfo_CrossOriginEmbedderPolicy {
  EMBEDDER_POLICY_NULL = 0,
  EMBEDDER_POLICY_REQUIRE_CORP = 1,
  EMBEDDER_POLICY_CREDENTIALLESS = 2,
}

declare enum nsILoadInfo_SchemelessInputType {
  SchemelessInputTypeUnset = 0,
  SchemelessInputTypeSchemeful = 1,
  SchemelessInputTypeSchemeless = 2,
}

declare enum nsILoadInfo_HTTPSUpgradeTelemetryType {
  NOT_INITIALIZED = 0,
  NO_UPGRADE = 1,
  ALREADY_HTTPS = 2,
  HSTS = 4,
  HTTPS_ONLY_UPGRADE = 8,
  HTTPS_ONLY_UPGRADE_DOWNGRADE = 16,
  HTTPS_FIRST_UPGRADE = 32,
  HTTPS_FIRST_UPGRADE_DOWNGRADE = 64,
  HTTPS_FIRST_SCHEMELESS_UPGRADE = 128,
  HTTPS_FIRST_SCHEMELESS_UPGRADE_DOWNGRADE = 256,
  CSP_UIR = 512,
  HTTPS_RR = 1024,
  WEB_EXTENSION_UPGRADE = 2048,
  UPGRADE_EXCEPTION = 4096,
  SKIP_HTTPS_UPGRADE = 8192,
}

declare global {

namespace nsILoadInfo {
  type StoragePermissionState = nsILoadInfo_StoragePermissionState;
  type IPAddressSpace = nsILoadInfo_IPAddressSpace;
  type CrossOriginOpenerPolicy = nsILoadInfo_CrossOriginOpenerPolicy;
  type CrossOriginEmbedderPolicy = nsILoadInfo_CrossOriginEmbedderPolicy;
  type SchemelessInputType = nsILoadInfo_SchemelessInputType;
  type HTTPSUpgradeTelemetryType = nsILoadInfo_HTTPSUpgradeTelemetryType;
}

interface nsILoadInfo extends nsISupports, Enums<typeof nsILoadInfo_StoragePermissionState & typeof nsILoadInfo_IPAddressSpace & typeof nsILoadInfo_CrossOriginOpenerPolicy & typeof nsILoadInfo_CrossOriginEmbedderPolicy & typeof nsILoadInfo_SchemelessInputType & typeof nsILoadInfo_HTTPSUpgradeTelemetryType> {
  readonly SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK?: 0;
  readonly SEC_REQUIRE_SAME_ORIGIN_INHERITS_SEC_CONTEXT?: 1;
  readonly SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED?: 2;
  readonly SEC_ALLOW_CROSS_ORIGIN_INHERITS_SEC_CONTEXT?: 4;
  readonly SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL?: 8;
  readonly SEC_REQUIRE_CORS_INHERITS_SEC_CONTEXT?: 16;
  readonly SEC_COOKIES_DEFAULT?: 0;
  readonly SEC_COOKIES_INCLUDE?: 32;
  readonly SEC_COOKIES_SAME_ORIGIN?: 64;
  readonly SEC_COOKIES_OMIT?: 96;
  readonly SEC_FORCE_INHERIT_PRINCIPAL?: 128;
  readonly SEC_ABOUT_BLANK_INHERITS?: 512;
  readonly SEC_ALLOW_CHROME?: 1024;
  readonly SEC_DISALLOW_SCRIPT?: 2048;
  readonly SEC_DONT_FOLLOW_REDIRECTS?: 4096;
  readonly SEC_LOAD_ERROR_PAGE?: 8192;
  readonly SEC_FORCE_INHERIT_PRINCIPAL_OVERRULE_OWNER?: 16384;
  readonly HTTPS_ONLY_UNINITIALIZED?: 1;
  readonly HTTPS_ONLY_UPGRADED_LISTENER_NOT_REGISTERED?: 2;
  readonly HTTPS_ONLY_UPGRADED_LISTENER_REGISTERED?: 4;
  readonly HTTPS_ONLY_EXEMPT?: 8;
  readonly HTTPS_ONLY_TOP_LEVEL_LOAD_IN_PROGRESS?: 16;
  readonly HTTPS_ONLY_DOWNLOAD_IN_PROGRESS?: 32;
  readonly HTTPS_ONLY_DO_NOT_LOG_TO_CONSOLE?: 64;
  readonly HTTPS_ONLY_UPGRADED_HTTPS_FIRST?: 128;
  readonly HTTPS_ONLY_BYPASS_ORB?: 256;
  readonly TAINTING_BASIC?: 0;
  readonly TAINTING_CORS?: 1;
  readonly TAINTING_OPAQUE?: 2;
  readonly BLOCKING_REASON_NONE?: 0;
  readonly BLOCKING_REASON_CORSDISABLED?: 1001;
  readonly BLOCKING_REASON_CORSDIDNOTSUCCEED?: 1002;
  readonly BLOCKING_REASON_CORSREQUESTNOTHTTP?: 1003;
  readonly BLOCKING_REASON_CORSMULTIPLEALLOWORIGINNOTALLOWED?: 1004;
  readonly BLOCKING_REASON_CORSMISSINGALLOWORIGIN?: 1005;
  readonly BLOCKING_REASON_CORSNOTSUPPORTINGCREDENTIALS?: 1006;
  readonly BLOCKING_REASON_CORSALLOWORIGINNOTMATCHINGORIGIN?: 1007;
  readonly BLOCKING_REASON_CORSMISSINGALLOWCREDENTIALS?: 1008;
  readonly BLOCKING_REASON_CORSORIGINHEADERNOTADDED?: 1009;
  readonly BLOCKING_REASON_CORSEXTERNALREDIRECTNOTALLOWED?: 1010;
  readonly BLOCKING_REASON_CORSPREFLIGHTDIDNOTSUCCEED?: 1011;
  readonly BLOCKING_REASON_CORSINVALIDALLOWMETHOD?: 1012;
  readonly BLOCKING_REASON_CORSMETHODNOTFOUND?: 1013;
  readonly BLOCKING_REASON_CORSINVALIDALLOWHEADER?: 1014;
  readonly BLOCKING_REASON_CORSMISSINGALLOWHEADERFROMPREFLIGHT?: 1015;
  readonly BLOCKING_REASON_CLASSIFY_MALWARE_URI?: 2001;
  readonly BLOCKING_REASON_CLASSIFY_PHISHING_URI?: 2002;
  readonly BLOCKING_REASON_CLASSIFY_UNWANTED_URI?: 2003;
  readonly BLOCKING_REASON_CLASSIFY_TRACKING_URI?: 2004;
  readonly BLOCKING_REASON_CLASSIFY_BLOCKED_URI?: 2005;
  readonly BLOCKING_REASON_CLASSIFY_HARMFUL_URI?: 2006;
  readonly BLOCKING_REASON_CLASSIFY_CRYPTOMINING_URI?: 2007;
  readonly BLOCKING_REASON_CLASSIFY_FINGERPRINTING_URI?: 2008;
  readonly BLOCKING_REASON_CLASSIFY_SOCIALTRACKING_URI?: 2009;
  readonly BLOCKING_REASON_CLASSIFY_EMAILTRACKING_URI?: 2010;
  readonly BLOCKING_REASON_MIXED_BLOCKED?: 3001;
  readonly BLOCKING_REASON_CONTENT_POLICY_GENERAL?: 4000;
  readonly BLOCKING_REASON_CONTENT_POLICY_NO_DATA_PROTOCOL?: 4001;
  readonly BLOCKING_REASON_CONTENT_POLICY_CONTENT_BLOCKED?: 4003;
  readonly BLOCKING_REASON_CONTENT_POLICY_DATA_DOCUMENT?: 4004;
  readonly BLOCKING_REASON_CONTENT_POLICY_WEB_BROWSER?: 4005;
  readonly BLOCKING_REASON_CONTENT_POLICY_PRELOAD?: 4006;
  readonly BLOCKING_REASON_NOT_SAME_ORIGIN?: 5000;
  readonly BLOCKING_REASON_EXTENSION_WEBREQUEST?: 6000;
  readonly BLOCKING_REASON_WEBDRIVER_BIDI?: 7000;

  readonly loadingPrincipal: nsIPrincipal;
  readonly triggeringPrincipal: nsIPrincipal;
  triggeringRemoteType: string;
  principalToInherit: nsIPrincipal;
  readonly loadingDocument: Document;
  readonly loadingContext: nsISupports;
  readonly securityFlags: nsSecurityFlags;
  readonly sandboxFlags: u32;
  triggeringSandboxFlags: u32;
  triggeringWindowId: u64;
  triggeringStorageAccess: boolean;
  readonly securityMode: u32;
  skipContentSniffing: boolean;
  httpsOnlyStatus: u32;
  hstsStatus: boolean;
  hasValidUserGestureActivation: boolean;
  textDirectiveUserActivation: boolean;
  isSameDocumentNavigation: boolean;
  allowDeprecatedSystemRequests: boolean;
  parserCreatedScript: boolean;
  isUserTriggeredSave: boolean;
  isInDevToolsContext: boolean;
  isInThirdPartyContext: boolean;
  isThirdPartyContextToTopWindow: boolean;
  isOn3PCBExceptionList: boolean;
  readonly cookiePolicy: u32;
  cookieJarSettings: nsICookieJarSettings;
  ipAddressSpace: nsILoadInfo.IPAddressSpace;
  parentIpAddressSpace: nsILoadInfo.IPAddressSpace;
  storagePermission: nsILoadInfo.StoragePermissionState;
  isMetaRefresh: boolean;
  readonly forceInheritPrincipal: boolean;
  readonly forceInheritPrincipalOverruleOwner: boolean;
  readonly loadingSandboxed: boolean;
  readonly aboutBlankInherits: boolean;
  readonly allowChrome: boolean;
  readonly disallowScript: boolean;
  readonly dontFollowRedirects: boolean;
  readonly loadErrorPage: boolean;
  isFormSubmission: boolean;
  isGETRequest: boolean;
  readonly externalContentPolicyType: nsContentPolicyType;
  sendCSPViolationEvents: boolean;
  readonly internalContentPolicyType: nsContentPolicyType;
  readonly fetchDestination: string;
  readonly blockAllMixedContent: boolean;
  readonly upgradeInsecureRequests: boolean;
  readonly browserUpgradeInsecureRequests: boolean;
  browserDidUpgradeInsecureRequests: boolean;
  readonly browserWouldUpgradeInsecureRequests: boolean;
  forceAllowDataURI: boolean;
  allowInsecureRedirectToDataURI: boolean;
  skipContentPolicyCheckForWebRequest: boolean;
  originalFrameSrcLoad: boolean;
  readonly forceInheritPrincipalDropped: boolean;
  readonly innerWindowID: u64;
  readonly browsingContextID: u64;
  readonly browsingContext: BrowsingContext;
  workerAssociatedBrowsingContextID: u64;
  readonly workerAssociatedBrowsingContext: BrowsingContext;
  readonly frameBrowsingContextID: u64;
  readonly frameBrowsingContext: BrowsingContext;
  readonly targetBrowsingContextID: u64;
  readonly targetBrowsingContext: BrowsingContext;
  resetPrincipalToInheritToNullPrincipal(): void;
  originAttributes: any;
  initialSecurityCheckDone: boolean;
  loadTriggeredFromExternal: boolean;
  appendRedirectHistoryEntry(channelToDeriveFrom: nsIChannel, isInternalRedirect: boolean): void;
  readonly redirectChainIncludingInternalRedirects: any;
  readonly redirectChain: any;
  readonly forcePreflight: boolean;
  readonly isPreflight: boolean;
  readonly tainting: u32;
  maybeIncreaseTainting(aTainting: u32): void;
  readonly isTopLevelLoad: boolean;
  resultPrincipalURI: nsIURI;
  channelCreationOriginalURI: nsIURI;
  documentHasUserInteracted: boolean;
  allowListFutureDocumentsCreatedFromThisRedirectChain: boolean;
  needForCheckingAntiTrackingHeuristic: boolean;
  cspNonce: string;
  integrityMetadata: string;
  requestBlockingReason: u32;
  cspEventListener: nsICSPEventListener;
  readonly isFromProcessingFrameAttributes: boolean;
  loadingEmbedderPolicy: nsILoadInfo.CrossOriginEmbedderPolicy;
  isOriginTrialCoepCredentiallessEnabledForTopLevel: boolean;
  isMediaRequest: boolean;
  isMediaInitialRequest: boolean;
  isFromObjectOrEmbed: boolean;
  unstrippedURI: nsIURI;
  hasInjectedCookieForCookieBannerHandling: boolean;
  schemelessInput: nsILoadInfo.SchemelessInputType;
  httpsUpgradeTelemetry: nsILoadInfo.HTTPSUpgradeTelemetryType;
  isNewWindowTarget: boolean;
  skipHTTPSUpgrade: boolean;
  userNavigationInvolvement: u8;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIMIMEInputStream.idl

interface nsIMIMEInputStream extends nsIInputStream {
  addHeader(name: string, value: string): void;
  visitHeaders(visitor: nsIHttpHeaderVisitor): void;
  setData(stream: nsIInputStream): void;
  readonly data: nsIInputStream;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIMockNetworkLayerController.idl

interface nsIMockNetworkLayerController extends nsISupports {
  createScriptableNetAddr(aIP: string, aPort: u16): nsINetAddr;
  addNetAddrOverride(aFrom: nsINetAddr, aTo: nsINetAddr): void;
  clearNetAddrOverrides(): void;
  blockUDPAddrIO(aAddr: nsINetAddr): void;
  clearBlockedUDPAddr(): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIMultiPartChannel.idl

interface nsIMultiPartChannel extends nsISupports {
  readonly baseChannel: nsIChannel;
  readonly partID: u32;
  readonly isLastPart: boolean;
}

interface nsIMultiPartChannelListener extends nsISupports {
  onAfterLastPart(status: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsINestedURI.idl

interface nsINestedURI extends nsISupports {
  readonly innerURI: nsIURI;
  readonly innermostURI: nsIURI;
}

interface nsINestedURIMutator extends nsISupports {
}

interface nsINestedAboutURIMutator extends nsISupports {
}

interface nsIJSURIMutator extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsINetAddr.idl

interface nsINetAddr extends nsISupports {
  readonly FAMILY_INET?: 1;
  readonly FAMILY_INET6?: 2;
  readonly FAMILY_LOCAL?: 3;

  readonly family: u16;
  readonly address: string;
  readonly port: u16;
  readonly flow: u32;
  readonly scope: u32;
  readonly isV4Mapped: boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsINetUtil.idl

interface nsINetUtil extends nsISupports {
  readonly ESCAPE_ALL?: 0;
  readonly ESCAPE_XALPHAS?: 1;
  readonly ESCAPE_XPALPHAS?: 2;
  readonly ESCAPE_URL_PATH?: 4;
  readonly ESCAPE_URL_APPLE_EXTRA?: 8;
  readonly ESCAPE_URL_SCHEME?: 1;
  readonly ESCAPE_URL_USERNAME?: 2;
  readonly ESCAPE_URL_PASSWORD?: 4;
  readonly ESCAPE_URL_HOST?: 8;
  readonly ESCAPE_URL_DIRECTORY?: 16;
  readonly ESCAPE_URL_FILE_BASENAME?: 32;
  readonly ESCAPE_URL_FILE_EXTENSION?: 64;
  readonly ESCAPE_URL_PARAM?: 128;
  readonly ESCAPE_URL_QUERY?: 256;
  readonly ESCAPE_URL_REF?: 512;
  readonly ESCAPE_URL_FILEPATH?: 112;
  readonly ESCAPE_URL_MINIMAL?: 1023;
  readonly ESCAPE_URL_FORCED?: 1024;
  readonly ESCAPE_URL_ONLY_ASCII?: 2048;
  readonly ESCAPE_URL_ONLY_NONASCII?: 4096;
  readonly ESCAPE_URL_COLON?: 16384;
  readonly ESCAPE_URL_SKIP_CONTROL?: 32768;
  readonly ESCAPE_URL_EXT_HANDLER?: 131072;

  parseRequestContentType(aTypeHeader: string, aCharset: OutParam<string>, aHadCharset: OutParam<boolean>): string;
  parseResponseContentType(aTypeHeader: string, aCharset: OutParam<string>, aHadCharset: OutParam<boolean>): string;
  protocolHasFlags(aURI: nsIURI, aFlag: u32): boolean;
  URIChainHasFlags(aURI: nsIURI, aFlags: u32): boolean;
  escapeString(aString: string, aEscapeType: u32): string;
  escapeURL(aStr: string, aFlags: u32): string;
  unescapeString(aStr: string, aFlags: u32): string;
  extractCharsetFromContentType(aTypeHeader: string, aCharset: OutParam<string>, aCharsetStart: OutParam<i32>, aCharsetEnd: OutParam<i32>): boolean;
  socketProcessTelemetryPing(): void;
  notImplemented(): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsINetworkConnectivityService.idl

}  // global

declare enum nsINetworkConnectivityService_ConnectivityState {
  UNKNOWN = 0,
  OK = 1,
  NOT_AVAILABLE = 2,
}

declare global {

namespace nsINetworkConnectivityService {
  type ConnectivityState = nsINetworkConnectivityService_ConnectivityState;
}

interface nsINetworkConnectivityService extends nsISupports, Enums<typeof nsINetworkConnectivityService_ConnectivityState> {
  DNSv4: nsINetworkConnectivityService.ConnectivityState;
  DNSv6: nsINetworkConnectivityService.ConnectivityState;
  DNS_HTTPS: nsINetworkConnectivityService.ConnectivityState;
  IPv4: nsINetworkConnectivityService.ConnectivityState;
  IPv6: nsINetworkConnectivityService.ConnectivityState;
  NAT64: nsINetworkConnectivityService.ConnectivityState;
  recheckDNS(): void;
  recheckIPConnectivity(): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsINetworkInfoService.idl

interface nsIListNetworkAddressesListener extends nsISupports {
  onListedNetworkAddresses(aAddressArray: string[]): void;
  onListNetworkAddressesFailed(): void;
}

interface nsIGetHostnameListener extends nsISupports {
  onGotHostname(aHostname: string): void;
  onGetHostnameFailed(): void;
}

interface nsINetworkInfoService extends nsISupports {
  listNetworkAddresses(aListener: nsIListNetworkAddressesListener): void;
  getHostname(aListener: nsIGetHostnameListener): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsINetworkInterceptController.idl

interface nsIInterceptedBodyCallback extends nsISupports {
  bodyComplete(aRv: nsresult): void;
}

interface nsIInterceptedChannel extends nsISupports {
  resetInterception(bypass: boolean): void;
  synthesizeStatus(status: u16, reason: string): void;
  synthesizeHeader(name: string, value: string): void;
  startSynthesizedResponse(body: nsIInputStream, callback: nsIInterceptedBodyCallback, channel: nsICacheInfoChannel, finalURLSpec: string, responseRedirected: boolean): void;
  finishSynthesizedResponse(): void;
  cancelInterception(status: nsresult): void;
  readonly channel: nsIChannel;
  readonly secureUpgradedChannelURI: nsIURI;
}

interface nsINetworkInterceptController extends nsISupports {
  shouldPrepareForIntercept(aURI: nsIURI, aChannel: nsIChannel): boolean;
  channelIntercepted(aChannel: nsIInterceptedChannel): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsINetworkLinkService.idl

interface nsINetworkLinkService extends nsISupports {
  readonly LINK_TYPE_UNKNOWN?: 0;
  readonly LINK_TYPE_ETHERNET?: 1;
  readonly LINK_TYPE_USB?: 2;
  readonly LINK_TYPE_WIFI?: 3;
  readonly LINK_TYPE_WIMAX?: 4;
  readonly LINK_TYPE_MOBILE?: 9;
  readonly NONE_DETECTED?: 0;
  readonly VPN_DETECTED?: 1;
  readonly PROXY_DETECTED?: 2;
  readonly NRPT_DETECTED?: 4;

  readonly isLinkUp: boolean;
  readonly linkStatusKnown: boolean;
  readonly linkType: u32;
  readonly networkID: string;
  readonly dnsSuffixList: string[];
  readonly resolvers: nsINetAddr[];
  readonly platformDNSIndications: u32;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsINetworkPredictor.idl

interface nsINetworkPredictor extends nsISupports {
  readonly PREDICT_LINK?: 0;
  readonly PREDICT_LOAD?: 1;
  readonly PREDICT_STARTUP?: 2;
  readonly LEARN_LOAD_TOPLEVEL?: 0;
  readonly LEARN_LOAD_SUBRESOURCE?: 1;
  readonly LEARN_LOAD_REDIRECT?: 2;
  readonly LEARN_STARTUP?: 3;

  predict(targetURI: nsIURI, sourceURI: nsIURI, reason: PredictorPredictReason, originAttributes: any, verifier: nsINetworkPredictorVerifier): void;
  learn(targetURI: nsIURI, sourceURI: nsIURI, reason: PredictorLearnReason, originAttributes: any): void;
  reset(): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsINetworkPredictorVerifier.idl

interface nsINetworkPredictorVerifier extends nsISupports {
  onPredictPrefetch(uri: nsIURI, status: u32): void;
  onPredictPreconnect(uri: nsIURI): void;
  onPredictDNS(uri: nsIURI): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsINullChannel.idl

interface nsINullChannel extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIParentChannel.idl

interface nsIParentChannel extends nsIStreamListener {
  delete(): void;
  readonly remoteType: string;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIParentRedirectingChannel.idl

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIPermission.idl

interface nsIPermission extends nsISupports {
  readonly principal: nsIPrincipal;
  readonly type: string;
  readonly capability: u32;
  readonly expireType: u32;
  readonly expireTime: i64;
  readonly modificationTime: i64;
  matches(principal: nsIPrincipal, exactHost: boolean): boolean;
  matchesURI(uri: nsIURI, exactHost: boolean): boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIPermissionManager.idl

interface nsIPermissionManager extends nsISupports {
  readonly UNKNOWN_ACTION?: 0;
  readonly ALLOW_ACTION?: 1;
  readonly DENY_ACTION?: 2;
  readonly PROMPT_ACTION?: 3;
  readonly MAX_VALID_ACTION?: 3;
  readonly EXPIRE_NEVER?: 0;
  readonly EXPIRE_SESSION?: 1;
  readonly EXPIRE_TIME?: 2;
  readonly EXPIRE_POLICY?: 3;

  getAllForPrincipal(principal: nsIPrincipal): nsIPermission[];
  getAllWithTypePrefix(prefix: string): nsIPermission[];
  getAllByTypes(types: string[]): nsIPermission[];
  getAllByTypeSince(type: string, since: i64): nsIPermission[];
  addFromPrincipal(principal: nsIPrincipal, type: string, permission: u32, expireType?: u32, expireTime?: i64): void;
  testAddFromPrincipalByTime(principal: nsIPrincipal, type: string, permission: u32, modificationTime: i64): void;
  addFromPrincipalAndPersistInPrivateBrowsing(principal: nsIPrincipal, type: string, permission: u32): void;
  addDefaultFromPrincipal(principal: nsIPrincipal, type: string, permission: u32): void;
  removeFromPrincipal(principal: nsIPrincipal, type: string): void;
  removePermission(perm: nsIPermission): void;
  removeAll(): void;
  removeAllSince(since: i64): void;
  removeByType(type: string): void;
  removeAllExceptTypes(typeExceptions: string[]): void;
  removeByTypeSince(type: string, since: i64): void;
  removeAllSinceWithTypeExceptions(since: i64, typeExceptions: string[]): void;
  testPermissionFromPrincipal(principal: nsIPrincipal, type: string): u32;
  testExactPermissionFromPrincipal(principal: nsIPrincipal, type: string): u32;
  testExactPermanentPermission(principal: nsIPrincipal, type: string): u32;
  getPermissionObject(principal: nsIPrincipal, type: string, exactHost: boolean): nsIPermission;
  readonly all: nsIPermission[];
  removePermissionsWithAttributes(patternAsJSON: string, typeInclusions: string[], typeExceptions: string[]): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIPrivateBrowsingChannel.idl

interface nsIPrivateBrowsingChannel extends nsISupports {
  setPrivate(aPrivate: boolean): void;
  readonly isChannelPrivate: boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIProgressEventSink.idl

interface nsIProgressEventSink extends nsISupports {
  onProgress(aRequest: nsIRequest, aProgress: i64, aProgressMax: i64): void;
  onStatus(aRequest: nsIRequest, aStatus: nsresult, aStatusArg: string): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIPrompt.idl

interface nsIPrompt extends nsISupports {
  readonly BUTTON_POS_0?: 1;
  readonly BUTTON_POS_1?: 256;
  readonly BUTTON_POS_2?: 65536;
  readonly BUTTON_TITLE_OK?: 1;
  readonly BUTTON_TITLE_CANCEL?: 2;
  readonly BUTTON_TITLE_YES?: 3;
  readonly BUTTON_TITLE_NO?: 4;
  readonly BUTTON_TITLE_SAVE?: 5;
  readonly BUTTON_TITLE_DONT_SAVE?: 6;
  readonly BUTTON_TITLE_REVERT?: 7;
  readonly BUTTON_TITLE_IS_STRING?: 127;
  readonly BUTTON_POS_0_DEFAULT?: 0;
  readonly BUTTON_POS_1_DEFAULT?: 16777216;
  readonly BUTTON_POS_2_DEFAULT?: 33554432;
  readonly BUTTON_DELAY_ENABLE?: 67108864;
  readonly SHOW_SPINNER?: 134217728;
  readonly BUTTON_NONE_ENABLE_BIT?: 268435456;
  readonly BUTTON_NONE?: 268435583;
  readonly BUTTON_POS_1_IS_SECONDARY?: 536870912;
  readonly STD_OK_CANCEL_BUTTONS?: 513;
  readonly STD_YES_NO_BUTTONS?: 1027;
  readonly MODAL_TYPE_CONTENT?: 1;
  readonly MODAL_TYPE_TAB?: 2;
  readonly MODAL_TYPE_WINDOW?: 3;
  readonly MODAL_TYPE_INTERNAL_WINDOW?: 4;

  alert(dialogTitle: string, text: string): void;
  alertCheck(dialogTitle: string, text: string, checkMsg: string, checkValue: InOutParam<boolean>): void;
  confirm(dialogTitle: string, text: string): boolean;
  confirmCheck(dialogTitle: string, text: string, checkMsg: string, checkValue: InOutParam<boolean>): boolean;
  confirmEx(dialogTitle: string, text: string, buttonFlags: u32, button0Title: string, button1Title: string, button2Title: string, checkMsg: string, checkValue: InOutParam<boolean>): i32;
  prompt(dialogTitle: string, text: string, value: InOutParam<string>, checkMsg: string, checkValue: InOutParam<boolean>): boolean;
  promptPassword(dialogTitle: string, text: string, password: InOutParam<string>): boolean;
  promptUsernameAndPassword(dialogTitle: string, text: string, username: InOutParam<string>, password: InOutParam<string>): boolean;
  select(dialogTitle: string, text: string, selectList: string[], outSelection: OutParam<i32>): boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIProtocolHandler.idl

interface nsIProtocolHandlerWithDynamicFlags extends nsISupports {
  getFlagsForURI(aURI: nsIURI): u32;
}

interface nsIProtocolHandler extends nsISupports {
  readonly URI_STD?: 0;
  readonly URI_NORELATIVE?: 1;
  readonly URI_NOAUTH?: 2;
  readonly ALLOWS_PROXY?: 4;
  readonly ALLOWS_PROXY_HTTP?: 8;
  readonly URI_INHERITS_SECURITY_CONTEXT?: 16;
  readonly URI_FORBIDS_AUTOMATIC_DOCUMENT_REPLACEMENT?: 32;
  readonly URI_LOADABLE_BY_ANYONE?: 64;
  readonly URI_DANGEROUS_TO_LOAD?: 128;
  readonly URI_IS_UI_RESOURCE?: 256;
  readonly URI_IS_LOCAL_FILE?: 512;
  readonly URI_LOADABLE_BY_SUBSUMERS?: 1024;
  readonly URI_DOES_NOT_RETURN_DATA?: 2048;
  readonly URI_IS_LOCAL_RESOURCE?: 4096;
  readonly URI_OPENING_EXECUTES_SCRIPT?: 8192;
  readonly URI_NON_PERSISTABLE?: 16384;
  readonly URI_CROSS_ORIGIN_NEEDS_WEBAPPS_PERM?: 32768;
  readonly URI_SYNC_LOAD_IS_OK?: 65536;
  readonly URI_IS_POTENTIALLY_TRUSTWORTHY?: 131072;
  readonly URI_IS_WEBEXTENSION_RESOURCE?: 262144;
  readonly ORIGIN_IS_FULL_SPEC?: 524288;
  readonly URI_SCHEME_NOT_SELF_LINKABLE?: 1048576;
  readonly URI_LOADABLE_BY_EXTENSIONS?: 2097152;
  readonly URI_FORBIDS_COOKIE_ACCESS?: 4194304;
  readonly URI_HAS_WEB_EXPOSED_ORIGIN?: 8388608;
  readonly DYNAMIC_URI_FLAGS?: 2228416;

  readonly scheme: string;
  newChannel(aURI: nsIURI, aLoadinfo: nsILoadInfo): nsIChannel;
  allowPort(port: i32, scheme: string): boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIProtocolProxyCallback.idl

interface nsIProtocolProxyCallback extends nsISupports {
  onProxyAvailable(aRequest: nsICancelable, aChannel: nsIChannel, aProxyInfo: nsIProxyInfo, aStatus: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIProtocolProxyFilter.idl

interface nsIProxyProtocolFilterResult extends nsISupports {
  onProxyFilterResult(aProxy: nsIProxyInfo): void;
}

interface nsIProtocolProxyFilter extends nsISupports {
  applyFilter(aURI: nsIURI, aProxy: nsIProxyInfo, aCallback: nsIProxyProtocolFilterResult): void;
}

interface nsIProtocolProxyChannelFilter extends nsISupports {
  applyFilter(aChannel: nsIChannel, aProxy: nsIProxyInfo, aCallback: nsIProxyProtocolFilterResult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIProtocolProxyService.idl

interface nsIProxyConfigChangedCallback extends nsISupports {
  onProxyConfigChanged(): void;
}

interface nsIProtocolProxyService extends nsISupports {
  readonly RESOLVE_PREFER_SOCKS_PROXY?: 2;
  readonly RESOLVE_IGNORE_URI_SCHEME?: 4;
  readonly RESOLVE_PREFER_HTTPS_PROXY?: 12;
  readonly RESOLVE_ALWAYS_TUNNEL?: 16;
  readonly PROXYCONFIG_DIRECT?: 0;
  readonly PROXYCONFIG_MANUAL?: 1;
  readonly PROXYCONFIG_PAC?: 2;
  readonly PROXYCONFIG_WPAD?: 4;
  readonly PROXYCONFIG_SYSTEM?: 5;

  asyncResolve(aChannelOrURI: nsISupports, aFlags: u32, aCallback: nsIProtocolProxyCallback, aMainThreadTarget?: nsISerialEventTarget): nsICancelable;
  newProxyInfo(aType: string, aHost: string, aPort: i32, aProxyAuthorizationHeader: string, aConnectionIsolationKey: string, aFlags: u32, aFailoverTimeout: u32, aFailoverProxy: nsIProxyInfo): nsIProxyInfo;
  newProxyInfoWithAuth(aType: string, aHost: string, aPort: i32, aUsername: string, aPassword: string, aProxyAuthorizationHeader: string, aConnectionIsolationKey: string, aFlags: u32, aFailoverTimeout: u32, aFailoverProxy: nsIProxyInfo): nsIProxyInfo;
  getFailoverForProxy(aProxyInfo: nsIProxyInfo, aURI: nsIURI, aReason: nsresult): nsIProxyInfo;
  registerFilter(aFilter: nsIProtocolProxyFilter, aPosition: u32): void;
  registerChannelFilter(aFilter: nsIProtocolProxyChannelFilter, aPosition: u32): void;
  unregisterFilter(aFilter: nsIProtocolProxyFilter): void;
  unregisterChannelFilter(aFilter: nsIProtocolProxyChannelFilter): void;
  readonly hasProxyFilterRegistered: boolean;
  addProxyConfigCallback(aCallback: nsIProxyConfigChangedCallback): void;
  removeProxyConfigCallback(aCallback: nsIProxyConfigChangedCallback): void;
  notifyProxyConfigChangedInternal(): void;
  readonly proxyConfigType: u32;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIProtocolProxyService2.idl

interface nsIProtocolProxyService2 extends nsIProtocolProxyService {
  reloadPAC(): void;
  asyncResolve2(aChannel: nsIChannel, aFlags: u32, aCallback: nsIProtocolProxyCallback, aMainThreadTarget?: nsISerialEventTarget): nsICancelable;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIProxiedChannel.idl

interface nsIProxiedChannel extends nsISupports {
  readonly proxyInfo: nsIProxyInfo;
  readonly httpProxyConnectResponseCode: i32;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIProxiedProtocolHandler.idl

interface nsIProxiedProtocolHandler extends nsIProtocolHandler {
  newProxiedChannel(uri: nsIURI, proxyInfo: nsIProxyInfo, proxyResolveFlags: u32, proxyURI: nsIURI, aLoadInfo: nsILoadInfo): nsIChannel;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIProxyInfo.idl

interface nsIProxyInfo extends nsISupports {
  readonly SOCKS_V4?: 4;
  readonly SOCKS_V5?: 5;
  readonly TRANSPARENT_PROXY_RESOLVES_HOST?: 1;

  readonly host: string;
  readonly port: i32;
  readonly type: string;
  readonly flags: u32;
  readonly resolveFlags: u32;
  readonly username: string;
  readonly password: string;
  readonly failoverTimeout: u32;
  failoverProxy: nsIProxyInfo;
  sourceId: string;
  readonly proxyAuthorizationHeader: string;
  readonly connectionIsolationKey: string;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIRandomGenerator.idl

interface nsIRandomGenerator extends nsISupports {
  generateRandomBytes(aLength: u32): u8[];
  generateRandomBytesInto(aBuffer: u8[], aLength: u32): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIRedirectChannelRegistrar.idl

interface nsIRedirectChannelRegistrar extends nsISupports {
  registerChannel(channel: nsIChannel, id: u64): void;
  linkChannels(id: u64, channel: nsIParentChannel): nsIChannel;
  getRegisteredChannel(id: u64): nsIChannel;
  getParentChannel(id: u64): nsIParentChannel;
  deregisterChannels(id: u64): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIRedirectHistoryEntry.idl

interface nsIRedirectHistoryEntry extends nsISupports {
  readonly principal: nsIPrincipal;
  readonly referrerURI: nsIURI;
  readonly remoteAddress: string;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIRedirectResultListener.idl

interface nsIRedirectResultListener extends nsISupports {
  onRedirectResult(status: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIRequest.idl

}  // global

declare enum nsIRequest_TRRMode {
  TRR_DEFAULT_MODE = 0,
  TRR_DISABLED_MODE = 1,
  TRR_FIRST_MODE = 2,
  TRR_ONLY_MODE = 3,
}

declare global {

namespace nsIRequest {
  type TRRMode = nsIRequest_TRRMode;
}

interface nsIRequest extends nsISupports, Enums<typeof nsIRequest_TRRMode> {
  readonly LOAD_REQUESTMASK?: 65535;
  readonly LOAD_NORMAL?: 0;
  readonly LOAD_BACKGROUND?: 1;
  readonly LOAD_HTML_OBJECT_DATA?: 2;
  readonly LOAD_DOCUMENT_NEEDS_COOKIE?: 4;
  readonly LOAD_TRR_MASK?: 24;
  readonly LOAD_TRR_DISABLED_MODE?: 8;
  readonly LOAD_TRR_FIRST_MODE?: 16;
  readonly LOAD_TRR_ONLY_MODE?: 24;
  readonly LOAD_ANONYMOUS_ALLOW_CLIENT_CERT?: 32;
  readonly INHIBIT_CACHING?: 128;
  readonly INHIBIT_PERSISTENT_CACHING?: 256;
  readonly LOAD_BYPASS_CACHE?: 512;
  readonly LOAD_FROM_CACHE?: 1024;
  readonly VALIDATE_ALWAYS?: 2048;
  readonly VALIDATE_NEVER?: 4096;
  readonly VALIDATE_ONCE_PER_SESSION?: 8192;
  readonly LOAD_ANONYMOUS?: 16384;
  readonly LOAD_FRESH_CONNECTION?: 32768;

  readonly name: string;
  isPending(): boolean;
  readonly status: nsresult;
  cancel(aStatus: nsresult): void;
  suspend(): void;
  resume(): void;
  loadGroup: nsILoadGroup;
  loadFlags: nsLoadFlags;
  getTRRMode(): nsIRequest.TRRMode;
  setTRRMode(mode: nsIRequest.TRRMode): void;
  cancelWithReason(aStatus: nsresult, aReason: string): void;
  canceledReason: string;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIRequestContext.idl

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIRequestObserver.idl

interface nsIRequestObserver extends nsISupports {
  onStartRequest(aRequest: nsIRequest): void;
  onStopRequest(aRequest: nsIRequest, aStatusCode: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIRequestObserverProxy.idl

interface nsIRequestObserverProxy extends nsIRequestObserver {
  init(observer: nsIRequestObserver, context: nsISupports): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIResumableChannel.idl

interface nsIResumableChannel extends nsISupports {
  resumeAt(startPos: u64, entityID: string): void;
  readonly entityID: string;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsISecCheckWrapChannel.idl

interface nsISecCheckWrapChannel extends nsISupports {
  readonly innerChannel: nsIChannel;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsISecureBrowserUI.idl

interface nsISecureBrowserUI extends nsISupports {
  readonly state: u32;
  readonly isSecureContext: boolean;
  readonly secInfo: nsITransportSecurityInfo;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsISensitiveInfoHiddenURI.idl

interface nsISensitiveInfoHiddenURI extends nsISupports {
  getSensitiveInfoHiddenSpec(): string;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsISerializationHelper.idl

interface nsISerializationHelper extends nsISupports {
  serializeToString(serializable: nsISerializable): string;
  deserializeObject(input: string): nsISupports;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIServerSocket.idl

interface nsIServerSocket extends nsISupports {
  readonly LoopbackOnly?: 1;
  readonly KeepWhenOffline?: 2;

  init(aPort: i32, aLoopbackOnly: boolean, aBackLog: i32): void;
  initIPv6(aPort: i32, aLoopbackOnly: boolean, aBackLog: i32): void;
  initDualStack(aPort: i32, aBackLog: i32): void;
  initSpecialConnection(aPort: i32, aFlags: nsServerSocketFlag, aBackLog: i32): void;
  initWithFilename(aPath: nsIFile, aPermissions: u32, aBacklog: i32): void;
  initWithAbstractAddress(aName: string, aBacklog: i32): void;
  close(): void;
  asyncListen(aListener: nsIServerSocketListener): void;
  readonly port: i32;
}

interface nsIServerSocketListener extends nsISupports {
  onSocketAccepted(aServ: nsIServerSocket, aTransport: nsISocketTransport): void;
  onStopListening(aServ: nsIServerSocket, aStatus: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsISimpleStreamListener.idl

interface nsISimpleStreamListener extends nsIStreamListener {
  init(aSink: nsIOutputStream, aObserver: nsIRequestObserver): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsISimpleURIMutator.idl

interface nsISimpleURIMutator extends nsISupports {
  setSpecAndFilterWhitespace(aSpec: string): nsIURIMutator;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsISocketFilter.idl

// https://searchfox.org/mozilla-central/source/netwerk/base/nsISocketTransport.idl

interface nsISocketTransport extends nsITransport {
  readonly TIMEOUT_CONNECT?: 0;
  readonly TIMEOUT_READ_WRITE?: 1;
  readonly STATUS_RESOLVING?: 4915203;
  readonly STATUS_RESOLVED?: 4915211;
  readonly STATUS_CONNECTING_TO?: 4915207;
  readonly STATUS_CONNECTED_TO?: 4915204;
  readonly STATUS_SENDING_TO?: 4915205;
  readonly STATUS_WAITING_FOR?: 4915210;
  readonly STATUS_RECEIVING_FROM?: 4915206;
  readonly STATUS_TLS_HANDSHAKE_STARTING?: 4915212;
  readonly STATUS_TLS_HANDSHAKE_ENDED?: 4915213;
  readonly BYPASS_CACHE?: 1;
  readonly ANONYMOUS_CONNECT?: 2;
  readonly DISABLE_IPV6?: 4;
  readonly NO_PERMANENT_STORAGE?: 8;
  readonly DISABLE_IPV4?: 16;
  readonly DISABLE_RFC1918?: 32;
  readonly BE_CONSERVATIVE?: 64;
  readonly DISABLE_TRR?: 128;
  readonly REFRESH_CACHE?: 256;
  readonly RETRY_WITH_DIFFERENT_IP_FAMILY?: 512;
  readonly DONT_TRY_ECH?: 1024;
  readonly TRR_MODE_FLAGS?: 6144;
  readonly USE_IP_HINT_ADDRESS?: 8192;
  readonly ANONYMOUS_CONNECT_ALLOW_CLIENT_CERT?: 16384;
  readonly IS_RETRY?: 32768;
  readonly IS_SPECULATIVE_CONNECTION?: 65536;

  readonly host: string;
  readonly port: i32;
  originAttributes: any;
  getScriptablePeerAddr(): nsINetAddr;
  getScriptableSelfAddr(): nsINetAddr;
  readonly tlsSocketControl: nsITLSSocketControl;
  securityCallbacks: nsIInterfaceRequestor;
  isAlive(): boolean;
  getTimeout(aType: u32): u32;
  setTimeout(aType: u32, aValue: u32): void;
  setLinger(aPolarity: boolean, aTimeout: i16): void;
  setReuseAddrPort(reuseAddrPort: boolean): void;
  connectionFlags: u32;
  tlsFlags: u32;
  QoSBits: u8;
  recvBufferSize: u32;
  sendBufferSize: u32;
  keepaliveEnabled: boolean;
  setKeepaliveVals(keepaliveIdleTime: i32, keepaliveRetryInterval: i32): void;
  readonly resetIPFamilyPreference: boolean;
  readonly echConfigUsed: boolean;
  setEchConfig(echConfig: string): void;
  resolvedByTRR(): boolean;
  readonly effectiveTRRMode: nsIRequest.TRRMode;
  readonly trrSkipReason: nsITRRSkipReason.value;
  readonly retryDnsIfPossible: boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsISocketTransportService.idl

type nsISTSShutdownObserver = Callable<{
  observe(): void;
}>

interface nsISocketTransportService extends nsISupports {
  createTransport(aSocketTypes: string[], aHost: string, aPort: i32, aProxyInfo: nsIProxyInfo, dnsRecord: nsIDNSRecord): nsISocketTransport;
  createUnixDomainTransport(aPath: nsIFile): nsISocketTransport;
  createUnixDomainAbstractAddressTransport(aName: string): nsISocketTransport;
}

interface nsIRoutedSocketTransportService extends nsISocketTransportService {
  createRoutedTransport(aSocketTypes: string[], aHost: string, aPort: i32, aHostRoute: string, aPortRoute: i32, aProxyInfo: nsIProxyInfo, aDnsRecord: nsIDNSRecord): nsISocketTransport;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsISpeculativeConnect.idl

interface nsISpeculativeConnect extends nsISupports {
  speculativeConnect(aURI: nsIURI, aPrincipal: nsIPrincipal, aCallbacks: nsIInterfaceRequestor, aAnonymous: boolean): void;
  speculativeConnectWithOriginAttributes(aURI: nsIURI, originAttributes: any, aCallbacks: nsIInterfaceRequestor, aAnonymous: boolean): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIStandardURL.idl

interface nsIStandardURL extends nsISupports {
  readonly URLTYPE_STANDARD?: 1;
  readonly URLTYPE_AUTHORITY?: 2;
  readonly URLTYPE_NO_AUTHORITY?: 3;
}

interface nsIStandardURLMutator extends nsISupports {
  init(aUrlType: u32, aDefaultPort: i32, aSpec: string, aOriginCharset: string, aBaseURI: nsIURI): nsIURIMutator;
  setDefaultPort(aNewDefaultPort: i32): nsIURIMutator;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIStreamListener.idl

interface nsIStreamListener extends nsIRequestObserver {
  onDataAvailable(aRequest: nsIRequest, aInputStream: nsIInputStream, aOffset: u64, aCount: u32): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIStreamListenerTee.idl

interface nsIStreamListenerTee extends nsIThreadRetargetableStreamListener {
  init(listener: nsIStreamListener, sink: nsIOutputStream, requestObserver?: nsIRequestObserver): void;
  initAsync(listener: nsIStreamListener, eventTarget: nsIEventTarget, sink: nsIOutputStream, requestObserver?: nsIRequestObserver): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIStreamLoader.idl

interface nsIStreamLoaderObserver extends nsISupports {
  onStreamComplete(loader: nsIStreamLoader, ctxt: nsISupports, status: nsresult, resultLength: u32, result: u8[]): void;
}

interface nsIStreamLoader extends nsIThreadRetargetableStreamListener {
  init(aStreamObserver: nsIStreamLoaderObserver, aRequestObserver?: nsIRequestObserver): void;
  readonly numBytesRead: u32;
  readonly request: nsIRequest;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIStreamTransportService.idl

interface nsIStreamTransportService extends nsISupports {
  createInputTransport(aStream: nsIInputStream, aCloseWhenDone: boolean): nsITransport;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsISuspendableChannelWrapper.idl

interface nsISuspendableChannelWrapper extends nsIChannel {
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsISyncStreamListener.idl

interface nsISyncStreamListener extends nsIStreamListener {
  readonly inputStream: nsIInputStream;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsISystemProxySettings.idl

interface nsISystemProxySettings extends nsISupports {
  readonly mainThreadOnly: boolean;
  readonly PACURI: string;
  getProxyForURI(testSpec: string, testScheme: string, testHost: string, testPort: i32): string;
  readonly systemWPADSetting: boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsITLSServerSocket.idl

interface nsITLSServerSocket extends nsIServerSocket {
  readonly REQUEST_NEVER?: 0;
  readonly REQUEST_FIRST_HANDSHAKE?: 1;
  readonly REQUEST_ALWAYS?: 2;
  readonly REQUIRE_FIRST_HANDSHAKE?: 3;
  readonly REQUIRE_ALWAYS?: 4;

  serverCert: nsIX509Cert;
  setSessionTickets(aSessionTickets: boolean): void;
  setRequestClientCertificate(aRequestClientCert: u32): void;
  setVersionRange(aMinVersion: u16, aMaxVersion: u16): void;
}

interface nsITLSClientStatus extends nsISupports {
  readonly SSL_VERSION_3?: 768;
  readonly TLS_VERSION_1?: 769;
  readonly TLS_VERSION_1_1?: 770;
  readonly TLS_VERSION_1_2?: 771;
  readonly TLS_VERSION_1_3?: 772;
  readonly TLS_VERSION_UNKNOWN?: -1;

  readonly peerCert: nsIX509Cert;
  readonly tlsVersionUsed: i16;
  readonly cipherName: string;
  readonly keyLength: u32;
  readonly macLength: u32;
}

interface nsITLSServerConnectionInfo extends nsISupports {
  setSecurityObserver(observer: nsITLSServerSecurityObserver): void;
  readonly serverSocket: nsITLSServerSocket;
  readonly status: nsITLSClientStatus;
}

interface nsITLSServerSecurityObserver extends nsISupports {
  onHandshakeDone(aServer: nsITLSServerSocket, aStatus: nsITLSClientStatus): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIThreadRetargetableRequest.idl

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIThreadRetargetableStreamListener.idl

interface nsIThreadRetargetableStreamListener extends nsIStreamListener {
  checkListenerChain(): void;
  onDataFinished(aStatusCode: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIThrottledInputChannel.idl

interface nsIInputChannelThrottleQueue extends nsISupports {
  init(aMeanBytesPerSecond: u32, aMaxBytesPerSecond: u32): void;
  available(aRemaining: u32): u32;
  recordRead(aBytesRead: u32): void;
  bytesProcessed(): u64;
  wrapStream(aInputStream: nsIInputStream): nsIAsyncInputStream;
}

interface nsIThrottledInputChannel extends nsISupports {
  throttleQueue: nsIInputChannelThrottleQueue;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsITimedChannel.idl

interface nsIServerTiming extends nsISupports {
  readonly name: string;
  readonly duration: double;
  readonly description: string;
}

}  // global

declare enum nsITimedChannel_BodyInfoAccess {
  DISALLOWED = 0,
  ALLOW_SIZES = 1,
  ALLOW_ALL = 2,
}

declare global {

namespace nsITimedChannel {
  type BodyInfoAccess = nsITimedChannel_BodyInfoAccess;
}

interface nsITimedChannel extends nsISupports, Enums<typeof nsITimedChannel_BodyInfoAccess> {
  redirectCount: u8;
  internalRedirectCount: u8;
  initiatorType: string;
  readonly channelCreationTime: PRTime;
  readonly asyncOpenTime: PRTime;
  readonly launchServiceWorkerStartTime: PRTime;
  readonly launchServiceWorkerEndTime: PRTime;
  readonly dispatchFetchEventStartTime: PRTime;
  readonly dispatchFetchEventEndTime: PRTime;
  readonly handleFetchEventStartTime: PRTime;
  readonly handleFetchEventEndTime: PRTime;
  readonly domainLookupStartTime: PRTime;
  readonly domainLookupEndTime: PRTime;
  readonly connectStartTime: PRTime;
  readonly tcpConnectEndTime: PRTime;
  readonly secureConnectionStartTime: PRTime;
  readonly connectEndTime: PRTime;
  readonly requestStartTime: PRTime;
  readonly responseStartTime: PRTime;
  readonly responseEndTime: PRTime;
  readonly cacheReadStartTime: PRTime;
  readonly cacheReadEndTime: PRTime;
  readonly redirectStartTime: PRTime;
  readonly redirectEndTime: PRTime;
  readonly transactionPendingTime: PRTime;
  readonly serverTiming: nsIArray;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsITraceableChannel.idl

interface nsITraceableChannel extends nsISupports {
  setNewListener(aListener: nsIStreamListener, aMustApplyContentConversion?: boolean): nsIStreamListener;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsITransport.idl

interface nsITransport extends nsISupports {
  readonly OPEN_BLOCKING?: 1;
  readonly OPEN_UNBUFFERED?: 2;
  readonly STATUS_READING?: 4915208;
  readonly STATUS_WRITING?: 4915209;

  openInputStream(aFlags: u32, aSegmentSize: u32, aSegmentCount: u32): nsIInputStream;
  openOutputStream(aFlags: u32, aSegmentSize: u32, aSegmentCount: u32): nsIOutputStream;
  close(aReason: nsresult): void;
  setEventSink(aSink: nsITransportEventSink, aEventTarget: nsIEventTarget): void;
}

interface nsITransportEventSink extends nsISupports {
  onTransportStatus(aTransport: nsITransport, aStatus: nsresult, aProgress: i64, aProgressMax: i64): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIUDPSocket.idl

interface nsIUDPSocket extends nsISupports {
  init(aPort: i32, aLoopbackOnly: boolean, aPrincipal: nsIPrincipal, aAddressReuse?: boolean): void;
  init2(aAddr: string, aPort: i32, aPrincipal: nsIPrincipal, aAddressReuse?: boolean): void;
  close(): void;
  asyncListen(aListener: nsIUDPSocketListener): void;
  readonly localAddr: nsINetAddr;
  readonly port: i32;
  send(host: string, port: u16, data: u8[]): u32;
  sendWithAddr(addr: nsINetAddr, data: u8[]): u32;
  sendBinaryStream(host: string, port: u16, stream: nsIInputStream): void;
  joinMulticast(addr: string, iface?: string): void;
  leaveMulticast(addr: string, iface?: string): void;
  multicastLoopback: boolean;
  multicastInterface: string;
}

interface nsIUDPSocketListener extends nsISupports {
  onPacketReceived(aSocket: nsIUDPSocket, aMessage: nsIUDPMessage): void;
  onStopListening(aSocket: nsIUDPSocket, aStatus: nsresult): void;
}

interface nsIUDPMessage extends nsISupports {
  readonly fromAddr: nsINetAddr;
  readonly data: string;
  readonly outputStream: nsIOutputStream;
  readonly rawData: any;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIURI.idl

interface nsIURI extends nsISupports {
  readonly spec: string;
  readonly prePath: string;
  readonly scheme: string;
  readonly userPass: string;
  readonly username: string;
  readonly password: string;
  readonly hostPort: string;
  readonly host: string;
  readonly port: i32;
  readonly pathQueryRef: string;
  equals(other: nsIURI): boolean;
  schemeIs(scheme: string): boolean;
  resolve(relativePath: string): string;
  readonly asciiSpec: string;
  readonly asciiHostPort: string;
  readonly asciiHost: string;
  readonly ref: string;
  equalsExceptRef(other: nsIURI): boolean;
  readonly specIgnoringRef: string;
  readonly hasRef: boolean;
  readonly hasUserPass: boolean;
  readonly filePath: string;
  readonly query: string;
  readonly hasQuery: boolean;
  readonly displayHost: string;
  readonly displayHostPort: string;
  readonly displaySpec: string;
  readonly displayPrePath: string;
  mutate(): nsIURIMutator;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIURIMutator.idl

interface nsIURISetSpec extends nsISupports {
  setSpec(aSpec: string): nsIURIMutator;
}

interface nsIURISetters extends nsIURISetSpec {
  setScheme(aScheme: string): nsIURIMutator;
  setUserPass(aUserPass: string): nsIURIMutator;
  setUsername(aUsername: string): nsIURIMutator;
  setPassword(aPassword: string): nsIURIMutator;
  setHostPort(aHostPort: string): nsIURIMutator;
  setHost(aHost: string): nsIURIMutator;
  setPort(aPort: i32): nsIURIMutator;
  setPathQueryRef(aPathQueryRef: string): nsIURIMutator;
  setRef(aRef: string): nsIURIMutator;
  setFilePath(aFilePath: string): nsIURIMutator;
  setQuery(aQuery: string): nsIURIMutator;
}

interface nsIURIMutator extends nsIURISetters {
  finalize(): nsIURI;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIURIWithSpecialOrigin.idl

interface nsIURIWithSpecialOrigin extends nsISupports {
  readonly origin: nsIURI;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIURL.idl

interface nsIURL extends nsIURI {
  readonly directory: string;
  readonly fileName: string;
  readonly fileBaseName: string;
  readonly fileExtension: string;
  getCommonBaseSpec(aURIToCompare: nsIURI): string;
  getRelativeSpec(aURIToCompare: nsIURI): string;
}

interface nsIURLMutator extends nsISupports {
  setFileName(aFileName: string): nsIURIMutator;
  setFileBaseName(aFileBaseName: string): nsIURIMutator;
  setFileExtension(aFileExtension: string): nsIURIMutator;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIURLParser.idl

interface nsIURLParser extends nsISupports {
  parseURL(spec: string, specLen: i32, schemePos: OutParam<u32>, schemeLen: OutParam<i32>, authorityPos: OutParam<u32>, authorityLen: OutParam<i32>, pathPos: OutParam<u32>, pathLen: OutParam<i32>): void;
  parseAuthority(authority: string, authorityLen: i32, usernamePos: OutParam<u32>, usernameLen: OutParam<i32>, passwordPos: OutParam<u32>, passwordLen: OutParam<i32>, hostnamePos: OutParam<u32>, hostnameLen: OutParam<i32>, port: OutParam<i32>): void;
  parseUserInfo(userinfo: string, userinfoLen: i32, usernamePos: OutParam<u32>, usernameLen: OutParam<i32>, passwordPos: OutParam<u32>, passwordLen: OutParam<i32>): void;
  parseServerInfo(serverinfo: string, serverinfoLen: i32, hostnamePos: OutParam<u32>, hostnameLen: OutParam<i32>, port: OutParam<i32>): void;
  parsePath(path: string, pathLen: i32, filepathPos: OutParam<u32>, filepathLen: OutParam<i32>, queryPos: OutParam<u32>, queryLen: OutParam<i32>, refPos: OutParam<u32>, refLen: OutParam<i32>): void;
  parseFilePath(filepath: string, filepathLen: i32, directoryPos: OutParam<u32>, directoryLen: OutParam<i32>, basenamePos: OutParam<u32>, basenameLen: OutParam<i32>, extensionPos: OutParam<u32>, extensionLen: OutParam<i32>): void;
  parseFileName(filename: string, filenameLen: i32, basenamePos: OutParam<u32>, basenameLen: OutParam<i32>, extensionPos: OutParam<u32>, extensionLen: OutParam<i32>): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIUploadChannel.idl

interface nsIUploadChannel extends nsISupports {
  setUploadStream(aStream: nsIInputStream, aContentType: string, aContentLength: i64): void;
  readonly uploadStream: nsIInputStream;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsIUploadChannel2.idl

interface nsIUploadChannel2 extends nsISupports {
  explicitSetUploadStream(aStream: nsIInputStream, aContentType: string, aContentLength: i64, aMethod: string, aStreamHasHeaders: boolean): void;
  readonly uploadStreamHasHeaders: boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/base/nsPISocketTransportService.idl

interface nsPISocketTransportService extends nsIRoutedSocketTransportService {
  init(): void;
  shutdown(aXpcomShutdown: boolean): void;
  readonly sendBufferSize: i32;
  offline: boolean;
  readonly keepaliveIdleTime: i32;
  readonly keepaliveRetryInterval: i32;
  readonly keepaliveProbeCount: i32;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/about/nsIAboutModule.idl

interface nsIAboutModule extends nsISupports {
  readonly URI_SAFE_FOR_UNTRUSTED_CONTENT?: 1;
  readonly ALLOW_SCRIPT?: 2;
  readonly HIDE_FROM_ABOUTABOUT?: 4;
  readonly ENABLE_INDEXED_DB?: 8;
  readonly URI_CAN_LOAD_IN_CHILD?: 16;
  readonly URI_MUST_LOAD_IN_CHILD?: 32;
  readonly MAKE_UNLINKABLE?: 64;
  readonly MAKE_LINKABLE?: 128;
  readonly URI_CAN_LOAD_IN_PRIVILEGEDABOUT_PROCESS?: 256;
  readonly URI_MUST_LOAD_IN_EXTENSION_PROCESS?: 512;
  readonly IS_SECURE_CHROME_UI?: 1024;

  newChannel(aURI: nsIURI, aLoadInfo: nsILoadInfo): nsIChannel;
  getURIFlags(aURI: nsIURI): u32;
  getChromeURI(aURI: nsIURI): nsIURI;
}

// https://searchfox.org/mozilla-central/source/netwerk/cache2/nsICacheEntry.idl

interface nsICacheEntry extends nsISupports {
  readonly CONTENT_TYPE_UNKNOWN?: 0;
  readonly CONTENT_TYPE_OTHER?: 1;
  readonly CONTENT_TYPE_JAVASCRIPT?: 2;
  readonly CONTENT_TYPE_IMAGE?: 3;
  readonly CONTENT_TYPE_MEDIA?: 4;
  readonly CONTENT_TYPE_STYLESHEET?: 5;
  readonly CONTENT_TYPE_WASM?: 6;
  readonly CONTENT_TYPE_LAST?: 7;
  readonly NO_EXPIRATION_TIME?: 4294967295;

  readonly key: string;
  readonly cacheEntryId: u64;
  readonly persistent: boolean;
  readonly fetchCount: u32;
  readonly lastFetched: u32;
  readonly lastModified: u32;
  readonly expirationTime: u32;
  setExpirationTime(expirationTime: u32): void;
  readonly onStartTime: u64;
  readonly onStopTime: u64;
  setNetworkTimes(onStartTime: u64, onStopTime: u64): void;
  setContentType(contentType: u8): void;
  forceValidFor(aSecondsToTheFuture: u32): void;
  readonly isForcedValid: boolean;
  markForcedValidUse(): void;
  openInputStream(offset: i64): nsIInputStream;
  openOutputStream(offset: i64, predictedSize: i64): nsIOutputStream;
  securityInfo: nsITransportSecurityInfo;
  readonly storageDataSize: u32;
  asyncDoom(listener: nsICacheEntryDoomCallback): void;
  getMetaDataElement(key: string): string;
  setMetaDataElement(key: string, value: string): void;
  visitMetaData(visitor: nsICacheEntryMetaDataVisitor): void;
  metaDataReady(): void;
  setValid(): void;
  dismiss(): void;
  readonly diskStorageSizeInKB: u32;
  recreate(aMemoryOnly?: boolean): nsICacheEntry;
  readonly dataSize: i64;
  readonly altDataSize: i64;
  readonly altDataType: string;
  openAlternativeOutputStream(type: string, predictedSize: i64): nsIAsyncOutputStream;
  openAlternativeInputStream(type: string): nsIInputStream;
  readonly loadContextInfo: nsILoadContextInfo;
}

interface nsICacheEntryMetaDataVisitor extends nsISupports {
  onMetaDataElement(key: string, value: string): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/cache2/nsICacheEntryDoomCallback.idl

interface nsICacheEntryDoomCallback extends nsISupports {
  onCacheEntryDoomed(aResult: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/cache2/nsICacheEntryOpenCallback.idl

interface nsICacheEntryOpenCallback extends nsISupports {
  readonly ENTRY_WANTED?: 0;
  readonly RECHECK_AFTER_WRITE_FINISHED?: 1;
  readonly ENTRY_NEEDS_REVALIDATION?: 2;
  readonly ENTRY_NOT_WANTED?: 3;

  onCacheEntryCheck(aEntry: nsICacheEntry): u32;
  onCacheEntryAvailable(aEntry: nsICacheEntry, aNew: boolean, aResult: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/cache2/nsICachePurgeLock.idl

interface nsICachePurgeLock extends nsISupports {
  lock(profileName: string): void;
  isOtherInstanceRunning(): boolean;
  unlock(): void;
  getLockFile(profileName: string): nsIFile;
}

// https://searchfox.org/mozilla-central/source/netwerk/cache2/nsICacheStorage.idl

interface nsICacheStorage extends nsISupports {
  readonly OPEN_NORMALLY?: 0;
  readonly OPEN_TRUNCATE?: 1;
  readonly OPEN_READONLY?: 2;
  readonly OPEN_PRIORITY?: 4;
  readonly OPEN_BYPASS_IF_BUSY?: 8;
  readonly CHECK_MULTITHREADED?: 16;
  readonly OPEN_SECRETLY?: 32;
  readonly OPEN_INTERCEPTED?: 64;

  asyncOpenURI(aURI: nsIURI, aIdExtension: string, aFlags: u32, aCallback: nsICacheEntryOpenCallback): void;
  openTruncate(aURI: nsIURI, aIdExtension: string): nsICacheEntry;
  exists(aURI: nsIURI, aIdExtension: string): boolean;
  getCacheIndexEntryAttrs(aURI: nsIURI, aIdExtension: string, aHasAltData: OutParam<boolean>, aSizeInKB: OutParam<u32>): void;
  asyncDoomURI(aURI: nsIURI, aIdExtension: string, aCallback: nsICacheEntryDoomCallback): void;
  asyncEvictStorage(aCallback: nsICacheEntryDoomCallback): void;
  asyncVisitStorage(aVisitor: nsICacheStorageVisitor, aVisitEntries: boolean): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/cache2/nsICacheStorageService.idl

interface nsICacheStorageService extends nsISupports {
  readonly PURGE_DISK_DATA_ONLY?: 1;
  readonly PURGE_DISK_ALL?: 2;
  readonly PURGE_EVERYTHING?: 3;

  memoryCacheStorage(aLoadContextInfo: nsILoadContextInfo): nsICacheStorage;
  diskCacheStorage(aLoadContextInfo: nsILoadContextInfo): nsICacheStorage;
  pinningCacheStorage(aLoadContextInfo: nsILoadContextInfo): nsICacheStorage;
  clearOriginsByPrincipal(aPrincipal: nsIPrincipal): void;
  clearBaseDomain(aBaseDomain: string): void;
  clearOriginsByOriginAttributes(aOriginAttributes: string): void;
  clear(): void;
  purgeFromMemory(aWhat: u32): void;
  readonly ioTarget: nsIEventTarget;
  asyncGetDiskConsumption(aObserver: nsICacheStorageConsumptionObserver): void;
  asyncVisitAllStorages(aVisitor: nsICacheStorageVisitor, aVisitEntries: boolean): void;
}

interface nsICacheStorageConsumptionObserver extends nsISupports {
  onNetworkCacheDiskConsumption(aDiskSize: i64): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/cache2/nsICacheStorageVisitor.idl

interface nsICacheStorageVisitor extends nsISupports {
  onCacheStorageInfo(aEntryCount: u32, aConsumption: u64, aCapacity: u64, aDiskDirectory: nsIFile): void;
  onCacheEntryInfo(aURI: nsIURI, aIdEnhance: string, aDataSize: i64, aAltDataSize: i64, aFetchCount: u32, aLastModifiedTime: u32, aExpirationTime: u32, aPinned: boolean, aInfo: nsILoadContextInfo): void;
  onCacheEntryVisitCompleted(): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/cache2/nsICacheTesting.idl

interface nsICacheTesting extends nsISupports {
  suspendCacheIOThread(aLevel: u32): void;
  resumeCacheIOThread(): void;
  flush(aObserver: nsIObserver): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/cookie/nsICookie.idl

}  // global

declare enum nsICookie_schemeType {
  SCHEME_UNSET = 0,
  SCHEME_HTTP = 1,
  SCHEME_HTTPS = 2,
  SCHEME_FILE = 4,
}

declare global {

namespace nsICookie {
  type schemeType = nsICookie_schemeType;
}

interface nsICookie extends nsISupports, Enums<typeof nsICookie_schemeType> {
  readonly SAMESITE_NONE?: 0;
  readonly SAMESITE_LAX?: 1;
  readonly SAMESITE_STRICT?: 2;
  readonly SAMESITE_UNSET?: 256;

  readonly name: string;
  readonly value: string;
  readonly isDomain: boolean;
  readonly host: string;
  readonly rawHost: string;
  readonly path: string;
  readonly isSecure: boolean;
  readonly expires: u64;
  readonly expiry: i64;
  readonly originAttributes: any;
  readonly isSession: boolean;
  readonly isHttpOnly: boolean;
  readonly creationTime: i64;
  readonly lastAccessed: i64;
  readonly sameSite: i32;
  readonly schemeMap: nsICookie.schemeType;
  readonly isPartitioned: boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/cookie/nsICookieJarSettings.idl

interface nsICookieJarSettings extends nsISerializable {
  readonly cookieBehavior: u32;
  readonly isFirstPartyIsolated: boolean;
  readonly shouldResistFingerprinting: boolean;
  readonly rejectThirdPartyContexts: boolean;
  readonly limitForeignContexts: boolean;
  readonly blockingAllThirdPartyContexts: boolean;
  readonly blockingAllContexts: boolean;
  partitionForeign: boolean;
  readonly isOnContentBlockingAllowList: boolean;
  readonly partitionKey: string;
  readonly fingerprintingRandomizationKey: u8[];
  cookiePermission(aPrincipal: nsIPrincipal): u32;
  initWithURI(aURI: nsIURI, aIsPrivate: boolean): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/cookie/nsICookieManager.idl

interface nsICookieManager extends nsISupports {
  removeAll(): void;
  readonly cookies: nsICookie[];
  readonly sessionCookies: nsICookie[];
  getCookieBehavior(aIsPrivate: boolean): u32;
  remove(aHost: string, aName: string, aPath: string, aOriginAttributes: any): void;
  add(aHost: string, aPath: string, aName: string, aValue: string, aIsSecure: boolean, aIsHttpOnly: boolean, aIsSession: boolean, aExpiry: i64, aOriginAttributes: any, aSameSite: i32, aSchemeMap: nsICookie.schemeType, aIsPartitioned?: boolean): void;
  cookieExists(aHost: string, aPath: string, aName: string, aOriginAttributes: any): boolean;
  countCookiesFromHost(aHost: string): u32;
  getCookiesFromHost(aHost: string, aOriginAttributes: any, aSorted?: boolean): nsICookie[];
  getCookiesWithOriginAttributes(aPattern: string, aHost?: string, aSorted?: boolean): nsICookie[];
  removeCookiesWithOriginAttributes(aPattern: string, aHost?: string): void;
  removeCookiesFromExactHost(aHost: string, aPattern: string): void;
  removeAllSince(aSinceWhen: i64): Promise<any>;
  getCookiesSince(aSinceWhen: i64): nsICookie[];
  addThirdPartyCookieBlockingExceptions(aExcpetions: nsIThirdPartyCookieExceptionEntry[]): void;
  removeThirdPartyCookieBlockingExceptions(aExceptions: nsIThirdPartyCookieExceptionEntry[]): void;
  testGet3PCBExceptions(): string[];
}

// https://searchfox.org/mozilla-central/source/netwerk/cookie/nsICookieNotification.idl

}  // global

declare enum nsICookieNotification_Action {
  COOKIE_DELETED = 0,
  COOKIE_ADDED = 1,
  COOKIE_CHANGED = 2,
  ALL_COOKIES_CLEARED = 3,
  COOKIES_BATCH_DELETED = 4,
}

declare global {

namespace nsICookieNotification {
  type Action = nsICookieNotification_Action;
}

interface nsICookieNotification extends nsISupports, Enums<typeof nsICookieNotification_Action> {
  readonly action: nsICookieNotification.Action;
  readonly cookie: nsICookie;
  readonly baseDomain: string;
  readonly isThirdParty: boolean;
  readonly batchDeletedCookies: nsIArray;
  readonly browsingContextId: u64;
  readonly browsingContext: BrowsingContext;
  readonly operationID: nsID;
}

// https://searchfox.org/mozilla-central/source/netwerk/cookie/nsICookiePermission.idl

interface nsICookiePermission extends nsISupports {
  readonly ACCESS_DEFAULT?: 0;
  readonly ACCESS_ALLOW?: 1;
  readonly ACCESS_DENY?: 2;
  readonly ACCESS_SESSION?: 8;
}

// https://searchfox.org/mozilla-central/source/netwerk/cookie/nsICookieService.idl

type nsICookieTransactionCallback = Callable<{
  callback(): void;
}>

interface nsICookieService extends nsISupports {
  readonly BEHAVIOR_ACCEPT?: 0;
  readonly BEHAVIOR_REJECT_FOREIGN?: 1;
  readonly BEHAVIOR_REJECT?: 2;
  readonly BEHAVIOR_LIMIT_FOREIGN?: 3;
  readonly BEHAVIOR_REJECT_TRACKER?: 4;
  readonly BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN?: 5;
  readonly BEHAVIOR_LAST?: 5;

  getCookieStringFromHttp(aURI: nsIURI, aChannel: nsIChannel): string;
  setCookieStringFromHttp(aURI: nsIURI, aCookie: string, aChannel: nsIChannel): void;
  runInTransaction(aCallback: nsICookieTransactionCallback): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/cookie/nsIThirdPartyCookieBlockingExceptionListService.idl

interface nsIThirdPartyCookieBlockingExceptionListService extends nsISupports {
  init(): Promise<any>;
  shutdown(): void;
}

interface nsIThirdPartyCookieExceptionEntry extends nsISupports {
  readonly firstPartySite: string;
  readonly thirdPartySite: string;
  serialize(): string;
}

// https://searchfox.org/mozilla-central/source/netwerk/dns/nsIDNSAdditionalInfo.idl

interface nsIDNSAdditionalInfo extends nsISupports {
  readonly port: i32;
  readonly resolverURL: string;
}

// https://searchfox.org/mozilla-central/source/netwerk/dns/nsIDNSByTypeRecord.idl

interface nsIDNSByTypeRecord extends nsIDNSRecord {
  readonly type: u32;
}

interface nsIDNSTXTRecord extends nsISupports {
  getRecordsAsOneString(): string;
}

interface nsISVCParam extends nsISupports {
  readonly type: u16;
}

interface nsISVCParamAlpn extends nsISupports {
  readonly alpn: string[];
}

interface nsISVCParamNoDefaultAlpn extends nsISupports {
}

interface nsISVCParamPort extends nsISupports {
  readonly port: u16;
}

interface nsISVCParamIPv4Hint extends nsISupports {
  readonly ipv4Hint: nsINetAddr[];
}

interface nsISVCParamEchConfig extends nsISupports {
  readonly echconfig: string;
}

interface nsISVCParamIPv6Hint extends nsISupports {
  readonly ipv6Hint: nsINetAddr[];
}

interface nsISVCParamODoHConfig extends nsISupports {
  readonly ODoHConfig: string;
}

interface nsISVCBRecord extends nsISupports {
  readonly priority: u16;
  readonly name: string;
  readonly selectedAlpn: string;
  readonly echConfig: string;
  readonly ODoHConfig: string;
  readonly hasIPHintAddress: boolean;
  readonly values: nsISVCParam[];
}

interface nsIDNSHTTPSSVCRecord extends nsISupports {
  readonly records: nsISVCBRecord[];
  GetServiceModeRecord(aNoHttp2: boolean, aNoHttp3: boolean): nsISVCBRecord;
  GetServiceModeRecordWithCname(aNoHttp2: boolean, aNoHttp3: boolean, aCName: string): nsISVCBRecord;
  readonly hasIPAddresses: boolean;
  readonly allRecordsExcluded: boolean;
  readonly ttl: u32;
  IsTRR(): boolean;
  GetAllRecordsWithEchConfig(aNoHttp2: boolean, aNoHttp3: boolean, aCName: string, aAllRecordsHaveEchConfig: OutParam<boolean>, aAllRecordsInH3ExcludedList: OutParam<boolean>): nsISVCBRecord[];
  GetAllRecords(aNoHttp2: boolean, aNoHttp3: boolean, aCName: string): nsISVCBRecord[];
}

// https://searchfox.org/mozilla-central/source/netwerk/dns/nsIDNSListener.idl

interface nsIDNSListener extends nsISupports {
  onLookupComplete(aRequest: nsICancelable, aRecord: nsIDNSRecord, aStatus: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/dns/nsIDNSRecord.idl

interface nsIDNSRecord extends nsISupports {
}

interface nsIDNSAddrRecord extends nsIDNSRecord {
  readonly canonicalName: string;
  getScriptableNextAddr(aPort: u16): nsINetAddr;
  getNextAddrAsString(): string;
  hasMore(): boolean;
  rewind(): void;
  reportUnusable(aPort: u16): void;
  IsTRR(): boolean;
  resolvedInSocketProcess(): boolean;
  readonly trrFetchDuration: double;
  readonly trrFetchDurationNetworkOnly: double;
  readonly effectiveTRRMode: nsIRequest.TRRMode;
  readonly trrSkipReason: nsITRRSkipReason.value;
  readonly ttl: u32;
}

// https://searchfox.org/mozilla-central/source/netwerk/dns/nsIDNSService.idl

}  // global

declare enum nsIDNSService_ResolveType {
  RESOLVE_TYPE_DEFAULT = 0,
  RESOLVE_TYPE_TXT = 16,
  RESOLVE_TYPE_HTTPSSVC = 65,
}

declare enum nsIDNSService_ResolverMode {
  MODE_NATIVEONLY = 0,
  MODE_RESERVED1 = 1,
  MODE_TRRFIRST = 2,
  MODE_TRRONLY = 3,
  MODE_RESERVED4 = 4,
  MODE_TRROFF = 5,
}

declare enum nsIDNSService_DNSFlags {
  RESOLVE_DEFAULT_FLAGS = 0,
  RESOLVE_BYPASS_CACHE = 1,
  RESOLVE_CANONICAL_NAME = 2,
  RESOLVE_PRIORITY_MEDIUM = 4,
  RESOLVE_PRIORITY_LOW = 8,
  RESOLVE_SPECULATE = 16,
  RESOLVE_DISABLE_IPV6 = 32,
  RESOLVE_OFFLINE = 64,
  RESOLVE_DISABLE_IPV4 = 128,
  RESOLVE_ALLOW_NAME_COLLISION = 256,
  RESOLVE_DISABLE_TRR = 512,
  RESOLVE_REFRESH_CACHE = 1024,
  RESOLVE_TRR_MODE_MASK = 6144,
  RESOLVE_TRR_DISABLED_MODE = 2048,
  RESOLVE_IGNORE_SOCKS_DNS = 8192,
  RESOLVE_IP_HINT = 16384,
  RESOLVE_WANT_RECORD_ON_ERROR = 65536,
  RESOLVE_DISABLE_NATIVE_HTTPS_QUERY = 131072,
  RESOLVE_CREATE_MOCK_HTTPS_RR = 262144,
  ALL_DNSFLAGS_BITS = 524287,
}

declare enum nsIDNSService_ConfirmationState {
  CONFIRM_OFF = 0,
  CONFIRM_TRYING_OK = 1,
  CONFIRM_OK = 2,
  CONFIRM_FAILED = 3,
  CONFIRM_TRYING_FAILED = 4,
  CONFIRM_DISABLED = 5,
}

declare global {

namespace nsIDNSService {
  type ResolveType = nsIDNSService_ResolveType;
  type ResolverMode = nsIDNSService_ResolverMode;
  type DNSFlags = nsIDNSService_DNSFlags;
  type ConfirmationState = nsIDNSService_ConfirmationState;
}

interface nsIDNSService extends nsISupports, Enums<typeof nsIDNSService_ResolveType & typeof nsIDNSService_ResolverMode & typeof nsIDNSService_DNSFlags & typeof nsIDNSService_ConfirmationState> {
  asyncResolve(aHostName: string, aType: nsIDNSService.ResolveType, aFlags: nsIDNSService.DNSFlags, aInfo: nsIDNSAdditionalInfo, aListener: nsIDNSListener, aListenerTarget: nsIEventTarget, aOriginAttributes?: any): nsICancelable;
  newAdditionalInfo(aTrrURL: string, aPort: i32): nsIDNSAdditionalInfo;
  cancelAsyncResolve(aHostName: string, aType: nsIDNSService.ResolveType, aFlags: nsIDNSService.DNSFlags, aResolver: nsIDNSAdditionalInfo, aListener: nsIDNSListener, aReason: nsresult, aOriginAttributes?: any): void;
  resolve(aHostName: string, aFlags: nsIDNSService.DNSFlags, aOriginAttributes?: any): nsIDNSRecord;
  clearCache(aTrrToo: boolean): void;
  reloadParentalControlEnabled(): void;
  setDetectedTrrURI(aURI: string): void;
  setHeuristicDetectionResult(value: nsITRRSkipReason.value): void;
  readonly heuristicDetectionResult: nsITRRSkipReason.value;
  getTRRSkipReasonName(value: nsITRRSkipReason.value): string;
  readonly lastConfirmationStatus: nsresult;
  readonly lastConfirmationSkipReason: nsITRRSkipReason.value;
  readonly currentTrrURI: string;
  readonly currentTrrMode: nsIDNSService.ResolverMode;
  readonly currentTrrConfirmationState: u32;
  readonly myHostName: string;
  readonly trrDomain: string;
  readonly TRRDomainKey: string;
}

// https://searchfox.org/mozilla-central/source/netwerk/dns/nsIEffectiveTLDService.idl

interface nsIEffectiveTLDService extends nsISupports {
  getPublicSuffix(aURI: nsIURI): string;
  getKnownPublicSuffix(aURI: nsIURI): string;
  getBaseDomain(aURI: nsIURI, aAdditionalParts?: u32): string;
  getSchemelessSite(aURI: nsIURI): string;
  getSchemelessSiteFromHost(aHost: string): string;
  getSite(aURI: nsIURI): string;
  getPublicSuffixFromHost(aHost: string): string;
  getKnownPublicSuffixFromHost(aHost: string): string;
  getBaseDomainFromHost(aHost: string, aAdditionalParts?: u32): string;
  getNextSubDomain(aHost: string): string;
  hasRootDomain(aInput: string, aHost: string): boolean;
  hasKnownPublicSuffix(aURI: nsIURI): boolean;
  hasKnownPublicSuffixFromHost(aHost: string): boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/dns/nsIIDNService.idl

interface nsIIDNService extends nsISupports {
  domainToASCII(input: string): string;
  convertUTF8toACE(input: string): string;
  domainToDisplay(input: string): string;
  convertToDisplayIDN(input: string): string;
  convertACEtoUTF8(input: string): string;
}

// https://searchfox.org/mozilla-central/source/netwerk/dns/nsINativeDNSResolverOverride.idl

interface nsINativeDNSResolverOverride extends nsISupports {
  addIPOverride(aHost: string, aIPLiteral: string): void;
  addHTTPSRecordOverride(aHost: string, aData: u8[], aLength: u32): void;
  setCnameOverride(aHost: string, aCNAME: string): void;
  clearHostOverride(aHost: string): void;
  clearOverrides(): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/dns/nsITRRSkipReason.idl

}  // global

declare enum nsITRRSkipReason_value {
  TRR_UNSET = 0,
  TRR_OK = 1,
  TRR_NO_GSERVICE = 2,
  TRR_PARENTAL_CONTROL = 3,
  TRR_OFF_EXPLICIT = 4,
  TRR_REQ_MODE_DISABLED = 5,
  TRR_MODE_NOT_ENABLED = 6,
  TRR_FAILED = 7,
  TRR_MODE_UNHANDLED_DEFAULT = 8,
  TRR_MODE_UNHANDLED_DISABLED = 9,
  TRR_DISABLED_FLAG = 10,
  TRR_TIMEOUT = 11,
  TRR_CHANNEL_DNS_FAIL = 12,
  TRR_BROWSER_IS_OFFLINE = 13,
  TRR_NOT_CONFIRMED = 14,
  TRR_DID_NOT_MAKE_QUERY = 15,
  TRR_UNKNOWN_CHANNEL_FAILURE = 16,
  TRR_HOST_BLOCKED_TEMPORARY = 17,
  TRR_SEND_FAILED = 18,
  TRR_NET_RESET = 19,
  TRR_NET_TIMEOUT = 20,
  TRR_NET_REFUSED = 21,
  TRR_NET_INTERRUPT = 22,
  TRR_NET_INADEQ_SEQURITY = 23,
  TRR_NO_ANSWERS = 24,
  TRR_DECODE_FAILED = 25,
  TRR_EXCLUDED = 26,
  TRR_SERVER_RESPONSE_ERR = 27,
  TRR_RCODE_FAIL = 28,
  TRR_NO_CONNECTIVITY = 29,
  TRR_NXDOMAIN = 30,
  TRR_REQ_CANCELLED = 31,
  ODOH_KEY_NOT_USABLE = 32,
  ODOH_UPDATE_KEY_FAILED = 33,
  ODOH_KEY_NOT_AVAILABLE = 34,
  ODOH_ENCRYPTION_FAILED = 35,
  ODOH_DECRYPTION_FAILED = 36,
  TRR_HEURISTIC_TRIPPED_GOOGLE_SAFESEARCH = 37,
  TRR_HEURISTIC_TRIPPED_YOUTUBE_SAFESEARCH = 38,
  TRR_HEURISTIC_TRIPPED_ZSCALER_CANARY = 39,
  TRR_HEURISTIC_TRIPPED_CANARY = 40,
  TRR_HEURISTIC_TRIPPED_MODIFIED_ROOTS = 41,
  TRR_HEURISTIC_TRIPPED_PARENTAL_CONTROLS = 42,
  TRR_HEURISTIC_TRIPPED_THIRD_PARTY_ROOTS = 43,
  TRR_HEURISTIC_TRIPPED_ENTERPRISE_POLICY = 44,
  TRR_HEURISTIC_TRIPPED_VPN = 45,
  TRR_HEURISTIC_TRIPPED_PROXY = 46,
  TRR_HEURISTIC_TRIPPED_NRPT = 47,
  TRR_BAD_URL = 48,
  TRR_SYSTEM_SLEEP_MODE = 49,
  eLAST_VALUE = 49,
}

declare global {

namespace nsITRRSkipReason {
  type value = nsITRRSkipReason_value;
}

interface nsITRRSkipReason extends nsISupports, Enums<typeof nsITRRSkipReason_value> {
}

// https://searchfox.org/mozilla-central/source/netwerk/dns/nsPIDNSService.idl

interface nsPIDNSService extends nsIDNSService {
  init(): void;
  shutdown(): void;
  prefetchEnabled: boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/file/nsIFileChannel.idl

interface nsIFileChannel extends nsISupports {
  readonly file: nsIFile;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/file/nsIFileProtocolHandler.idl

interface nsIFileProtocolHandler extends nsIProtocolHandler {
  newFileURI(aFile: nsIFile): nsIURI;
  newFileURIMutator(file: nsIFile): nsIURIMutator;
  getURLSpecFromActualFile(file: nsIFile): string;
  getURLSpecFromDir(file: nsIFile): string;
  getFileFromURLSpec(url: string): nsIFile;
  readURLFile(file: nsIFile): nsIURI;
  readShellLink(file: nsIFile): nsIURI;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/data/nsIDataChannel.idl

interface nsIDataChannel extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIBackgroundChannelRegistrar.idl

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIBinaryHttp.idl

interface nsIBinaryHttpRequest extends nsISupports {
  readonly method: string;
  readonly scheme: string;
  readonly authority: string;
  readonly path: string;
  readonly headerNames: string[];
  readonly headerValues: string[];
  readonly content: u8[];
}

interface nsIBinaryHttpResponse extends nsISupports {
  readonly status: u16;
  readonly headerNames: string[];
  readonly headerValues: string[];
  readonly content: u8[];
}

interface nsIBinaryHttp extends nsISupports {
  encodeRequest(request: nsIBinaryHttpRequest): u8[];
  decodeRequest(request: u8[]): nsIBinaryHttpRequest;
  decodeResponse(response: u8[]): nsIBinaryHttpResponse;
  encodeResponse(response: nsIBinaryHttpResponse): u8[];
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsICORSPreflightCache.idl

interface nsICORSPreflightCache extends nsISupports {
  getEntries(principal: nsIPrincipal): nsICORSPreflightCacheEntry[];
  clearEntry(entry: nsICORSPreflightCacheEntry): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsICORSPreflightCacheEntry.idl

interface nsICORSPreflightCacheEntry extends nsISupports {
  readonly key: string;
  readonly URI: nsIURI;
  readonly originAttributes: any;
  readonly principal: nsIPrincipal;
  readonly privateBrowsing: boolean;
  readonly withCredentials: boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIEarlyHintObserver.idl

interface nsIEarlyHintObserver extends nsISupports {
  earlyHint(linkHeader: string, referrerPolicy: string, cspHeader: string): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIHttpActivityObserver.idl

interface nsIHttpActivityObserver extends nsISupports {
  readonly ACTIVITY_TYPE_SOCKET_TRANSPORT?: 1;
  readonly ACTIVITY_TYPE_HTTP_TRANSACTION?: 2;
  readonly ACTIVITY_TYPE_HTTP_CONNECTION?: 3;
  readonly ACTIVITY_SUBTYPE_REQUEST_HEADER?: 20481;
  readonly ACTIVITY_SUBTYPE_REQUEST_BODY_SENT?: 20482;
  readonly ACTIVITY_SUBTYPE_RESPONSE_START?: 20483;
  readonly ACTIVITY_SUBTYPE_RESPONSE_HEADER?: 20484;
  readonly ACTIVITY_SUBTYPE_RESPONSE_COMPLETE?: 20485;
  readonly ACTIVITY_SUBTYPE_TRANSACTION_CLOSE?: 20486;
  readonly ACTIVITY_SUBTYPE_PROXY_RESPONSE_HEADER?: 20487;
  readonly ACTIVITY_SUBTYPE_DNSANDSOCKET_CREATED?: 20488;
  readonly ACTIVITY_SUBTYPE_SPECULATIVE_DNSANDSOCKET_CREATED?: 20489;
  readonly ACTIVITY_SUBTYPE_ECH_SET?: 20490;
  readonly ACTIVITY_SUBTYPE_CONNECTION_CREATED?: 20491;
  readonly ACTIVITY_SUBTYPE_EARLYHINT_RESPONSE_HEADER?: 20492;

  observeActivity(aHttpChannel: nsISupports, aActivityType: u32, aActivitySubtype: u32, aTimestamp: PRTime, aExtraSizeData: u64, aExtraStringData: string): void;
  readonly isActive: boolean;
  observeConnectionActivity(aHost: string, aPort: i32, aSSL: boolean, aHasECH: boolean, aIsHttp3: boolean, aActivityType: u32, aActivitySubtype: u32, aTimestamp: PRTime, aExtraStringData: string): void;
}

interface nsIHttpActivityDistributor extends nsIHttpActivityObserver {
  addObserver(aObserver: nsIHttpActivityObserver): void;
  removeObserver(aObserver: nsIHttpActivityObserver): void;
  observeProxyResponse: boolean;
  observeConnection: boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIHttpAuthManager.idl

interface nsIHttpAuthManager extends nsISupports {
  getAuthIdentity(aScheme: string, aHost: string, aPort: i32, aAuthType: string, aRealm: string, aPath: string, aUserDomain: OutParam<string>, aUserName: OutParam<string>, aUserPassword: OutParam<string>, aIsPrivate?: boolean, aPrincipal?: nsIPrincipal): void;
  setAuthIdentity(aScheme: string, aHost: string, aPort: i32, aAuthType: string, aRealm: string, aPath: string, aUserDomain: string, aUserName: string, aUserPassword: string, aIsPrivate?: boolean, aPrincipal?: nsIPrincipal): void;
  clearAll(): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIHttpAuthenticableChannel.idl

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIHttpAuthenticator.idl

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIHttpChannel.idl

interface nsIHttpChannel extends nsIIdentChannel {
  requestMethod: string;
  referrerInfo: nsIReferrerInfo;
  readonly protocolVersion: string;
  readonly transferSize: u64;
  readonly requestSize: u64;
  readonly decodedBodySize: u64;
  readonly encodedBodySize: u64;
  getRequestHeader(aHeader: string): string;
  setRequestHeader(aHeader: string, aValue: string, aMerge: boolean): void;
  setNewReferrerInfo(aUrl: string, aPolicy: nsIReferrerInfo.ReferrerPolicyIDL, aSendReferrer: boolean): void;
  setEmptyRequestHeader(aHeader: string): void;
  visitRequestHeaders(aVisitor: nsIHttpHeaderVisitor): void;
  visitNonDefaultRequestHeaders(aVisitor: nsIHttpHeaderVisitor): void;
  ShouldStripRequestBodyHeader(aMethod: string): boolean;
  allowSTS: boolean;
  redirectionLimit: u32;
  readonly responseStatus: u32;
  readonly responseStatusText: string;
  readonly requestSucceeded: boolean;
  isMainDocumentChannel: boolean;
  getResponseHeader(header: string): string;
  setResponseHeader(header: string, value: string, merge: boolean): void;
  visitResponseHeaders(aVisitor: nsIHttpHeaderVisitor): void;
  getOriginalResponseHeader(aHeader: string, aVisitor: nsIHttpHeaderVisitor): void;
  visitOriginalResponseHeaders(aVisitor: nsIHttpHeaderVisitor): void;
  isNoStoreResponse(): boolean;
  isNoCacheResponse(): boolean;
  isPrivateResponse(): boolean;
  redirectTo(aTargetURI: nsIURI): void;
  upgradeToSecure(): void;
  topLevelContentWindowId: u64;
  browserId: u64;
  logBlockedCORSRequest(aMessage: string, aCategory: string, aIsWarning: boolean): void;
  logMimeTypeMismatch(aMessageName: string, aWarning: boolean, aURL: string, aContentType: string): void;
  classicScriptHintCharset: string;
  documentCharacterSet: string;
  requestObserversCalled: boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIHttpChannelAuthProvider.idl

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIHttpChannelChild.idl

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIHttpChannelInternal.idl

interface nsIHttpUpgradeListener extends nsISupports {
  onTransportAvailable(aTransport: nsISocketTransport, aSocketIn: nsIAsyncInputStream, aSocketOut: nsIAsyncOutputStream): void;
  onUpgradeFailed(aErrorCode: nsresult): void;
}

interface nsIHttpChannelInternal extends nsISupports {
  readonly THIRD_PARTY_FORCE_ALLOW?: 1;
  readonly TLS_FLAG_CONFIGURE_AS_RETRY?: 65536;
  readonly REDIRECT_MODE_FOLLOW?: 0;
  readonly REDIRECT_MODE_ERROR?: 1;
  readonly REDIRECT_MODE_MANUAL?: 2;
  readonly FETCH_CACHE_MODE_DEFAULT?: 0;
  readonly FETCH_CACHE_MODE_NO_STORE?: 1;
  readonly FETCH_CACHE_MODE_RELOAD?: 2;
  readonly FETCH_CACHE_MODE_NO_CACHE?: 3;
  readonly FETCH_CACHE_MODE_FORCE_CACHE?: 4;
  readonly FETCH_CACHE_MODE_ONLY_IF_CACHED?: 5;

  documentURI: nsIURI;
  getRequestVersion(major: OutParam<u32>, minor: OutParam<u32>): void;
  getResponseVersion(major: OutParam<u32>, minor: OutParam<u32>): void;
  setCookieHeaders(aCookieHeaders: string[]): void;
  thirdPartyFlags: u32;
  forceAllowThirdPartyCookie: boolean;
  channelIsForDownload: boolean;
  readonly localAddress: string;
  readonly localPort: i32;
  readonly remoteAddress: string;
  readonly remotePort: i32;
  HTTPUpgrade(aProtocolName: string, aListener: nsIHttpUpgradeListener): void;
  setConnectOnly(tlsTunnel: boolean): void;
  readonly onlyConnect: boolean;
  allowSpdy: boolean;
  allowHttp3: boolean;
  responseTimeoutEnabled: boolean;
  initialRwin: u32;
  readonly apiRedirectToURI: nsIURI;
  allowAltSvc: boolean;
  beConservative: boolean;
  bypassProxy: boolean;
  readonly isResolvedByTRR: boolean;
  readonly effectiveTRRMode: nsIRequest.TRRMode;
  readonly trrSkipReason: nsITRRSkipReason.value;
  readonly isLoadedBySocketProcess: boolean;
  isOCSP: boolean;
  tlsFlags: u32;
  readonly lastModifiedTime: PRTime;
  corsIncludeCredentials: boolean;
  redirectMode: u32;
  fetchCacheMode: u32;
  readonly topWindowURI: nsIURI;
  setTopWindowURIIfUnknown(topWindowURI: nsIURI): void;
  readonly proxyURI: nsIURI;
  blockAuthPrompt: boolean;
  integrityMetadata: string;
  readonly connectionInfoHashKey: string;
  setIPv4Disabled(): void;
  setIPv6Disabled(): void;
  readonly crossOriginOpenerPolicy: nsILoadInfo.CrossOriginOpenerPolicy;
  readonly supportsHTTP3: boolean;
  readonly hasHTTPSRR: boolean;
  setEarlyHintObserver(aObserver: nsIEarlyHintObserver): void;
  earlyHintPreloaderId: u64;
  readonly isProxyUsed: boolean;
  setWebTransportSessionEventListener(aListener: WebTransportSessionEventListener): void;
  earlyHintLinkType: u32;
  isUserAgentHeaderModified: boolean;
  setResponseOverride(aReplacedHttpResponse: nsIReplacedHttpResponse): void;
  setResponseStatus(aStatus: u32, aStatusText: string): void;
  readonly lastTransportStatus: nsresult;
  transparentRedirectTo(aTargetURI: nsIURI): void;
  readonly caps: u32;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIHttpHeaderVisitor.idl

type nsIHttpHeaderVisitor = Callable<{
  visitHeader(aHeader: string, aValue: string): void;
}>

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIHttpProtocolHandler.idl

interface nsIHttpProtocolHandler extends nsIProxiedProtocolHandler {
  readonly userAgent: string;
  readonly rfpUserAgent: string;
  readonly appName: string;
  readonly appVersion: string;
  readonly platform: string;
  readonly oscpu: string;
  readonly misc: string;
  readonly altSvcCacheKeys: string[];
  readonly authCacheKeys: string[];
  EnsureHSTSDataReady(): Promise<any>;
  clearCORSPreflightCache(): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsINetworkErrorLogging.idl

interface nsINetworkErrorLogging extends nsISupports {
  registerPolicy(aChannel: nsIHttpChannel): void;
  generateNELReport(aChannel: nsIHttpChannel): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIObliviousHttp.idl

interface nsIObliviousHttpClientResponse extends nsISupports {
  decapsulate(encResponse: u8[]): u8[];
}

interface nsIObliviousHttpClientRequest extends nsISupports {
  readonly encRequest: u8[];
  readonly response: nsIObliviousHttpClientResponse;
}

interface nsIObliviousHttpServerResponse extends nsISupports {
  readonly request: u8[];
  encapsulate(response: u8[]): u8[];
}

interface nsIObliviousHttpServer extends nsISupports {
  readonly encodedConfig: u8[];
  decapsulate(encRequest: u8[]): nsIObliviousHttpServerResponse;
}

interface nsIObliviousHttp extends nsISupports {
  encapsulateRequest(encodedConfig: u8[], request: u8[]): nsIObliviousHttpClientRequest;
  server(): nsIObliviousHttpServer;
  decodeConfigList(encodedConfigList: u8[]): u8[][];
}

interface nsIObliviousHttpService extends nsISupports {
  newChannel(relayURI: nsIURI, targetURI: nsIURI, encodedConfig: u8[]): nsIChannel;
  getTRRSettings(relayURI: OutParam<nsIURI>, encodedConfig: OutParam<u8[]>): void;
  clearTRRConfig(): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIObliviousHttpChannel.idl

interface nsIObliviousHttpChannel extends nsIHttpChannel {
  readonly relayChannel: nsIHttpChannel;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIRaceCacheWithNetwork.idl

interface nsIRaceCacheWithNetwork extends nsISupports {
  allowRacing: boolean;
  test_triggerNetwork(timeout: i32): void;
  test_delayCacheEntryOpeningBy(timeout: i32): void;
  test_triggerDelayedOpenCacheEntry(): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIReplacedHttpResponse.idl

interface nsIReplacedHttpResponse extends nsISupports {
  init(): void;
  responseBody: string;
  responseStatus: u32;
  responseStatusText: string;
  visitResponseHeaders(visitor: nsIHttpHeaderVisitor): void;
  setResponseHeader(header: string, value: string, merge: boolean): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsITlsHandshakeListener.idl

// https://searchfox.org/mozilla-central/source/netwerk/protocol/http/nsIWellKnownOpportunisticUtils.idl

interface nsIWellKnownOpportunisticUtils extends nsISupports {
  verify(aJSON: string, aOrigin: string): void;
  readonly valid: boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/streamconv/converters/nsICompressConvStats.idl

interface nsICompressConvStats extends nsISupports {
  readonly decodedDataLength: u64;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/res/nsIResProtocolHandler.idl

interface nsIResProtocolHandler extends nsISubstitutingProtocolHandler {
  allowContentToAccess(url: nsIURI): boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/res/nsISubstitutingProtocolHandler.idl

interface nsISubstitutingProtocolHandler extends nsIProtocolHandler {
  readonly ALLOW_CONTENT_ACCESS?: 1;
  readonly RESOLVE_JAR_URI?: 2;

  setSubstitution(root: string, baseURI: nsIURI): void;
  setSubstitutionWithFlags(root: string, baseURI: nsIURI, flags: u32): void;
  getSubstitution(root: string): nsIURI;
  hasSubstitution(root: string): boolean;
  resolveURI(resURI: nsIURI): string;
}

// https://searchfox.org/mozilla-central/source/netwerk/socket/nsISocketProvider.idl

interface nsISocketProvider extends nsISupports {
  readonly PROXY_RESOLVES_HOST?: 1;
  readonly ANONYMOUS_CONNECT?: 2;
  readonly NO_PERMANENT_STORAGE?: 4;
  readonly BE_CONSERVATIVE?: 8;
  readonly ANONYMOUS_CONNECT_ALLOW_CLIENT_CERT?: 16;
  readonly IS_SPECULATIVE_CONNECTION?: 32;
  readonly DONT_TRY_ECH?: 1024;
  readonly IS_RETRY?: 2048;
  readonly USED_PRIVATE_DNS?: 4096;
}

// https://searchfox.org/mozilla-central/source/netwerk/socket/nsISocketProviderService.idl

interface nsISocketProviderService extends nsISupports {
  getSocketProvider(socketType: string): nsISocketProvider;
}

// https://searchfox.org/mozilla-central/source/netwerk/streamconv/mozITXTToHTMLConv.idl

interface mozITXTToHTMLConv extends nsIStreamConverter {
  readonly kEntities?: 0;
  readonly kURLs?: 2;
  readonly kGlyphSubstitution?: 4;
  readonly kStructPhrase?: 8;

  scanTXT(text: string, whattodo: u32): string;
  scanHTML(text: string, whattodo: u32): string;
  citeLevelTXT(line: string, logLineStart: OutParam<u32>): u32;
  findURLInPlaintext(text: string, aLength: i32, aPos: i32, aStartPos: OutParam<i32>, aEndPos: OutParam<i32>): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/streamconv/nsIDirIndex.idl

interface nsIDirIndex extends nsISupports {
  readonly TYPE_UNKNOWN?: 0;
  readonly TYPE_DIRECTORY?: 1;
  readonly TYPE_FILE?: 2;
  readonly TYPE_SYMLINK?: 3;

  type: u32;
  location: string;
  size: i64;
  lastModified: PRTime;
}

// https://searchfox.org/mozilla-central/source/netwerk/streamconv/nsIDirIndexListener.idl

interface nsIDirIndexListener extends nsISupports {
  onIndexAvailable(aRequest: nsIRequest, aIndex: nsIDirIndex): void;
}

interface nsIDirIndexParser extends nsIStreamListener {
  listener: nsIDirIndexListener;
}

// https://searchfox.org/mozilla-central/source/netwerk/streamconv/nsIStreamConverter.idl

interface nsIStreamConverter extends nsIThreadRetargetableStreamListener {
  convert(aFromStream: nsIInputStream, aFromType: string, aToType: string, aCtxt: nsISupports): nsIInputStream;
  asyncConvertData(aFromType: string, aToType: string, aListener: nsIStreamListener, aCtxt: nsISupports): void;
  maybeRetarget(request: nsIRequest): void;
  getConvertedType(aFromType: string, aChannel: nsIChannel): string;
}

// https://searchfox.org/mozilla-central/source/netwerk/streamconv/nsIStreamConverterService.idl

interface nsIStreamConverterService extends nsISupports {
  canConvert(aFromType: string, aToType: string): boolean;
  convertedType(aFromType: string, aChannel: nsIChannel): string;
  convert(aFromStream: nsIInputStream, aFromType: string, aToType: string, aContext: nsISupports): nsIInputStream;
  asyncConvertData(aFromType: string, aToType: string, aListener: nsIStreamListener, aContext: nsISupports): nsIStreamListener;
}

// https://searchfox.org/mozilla-central/source/netwerk/streamconv/nsITXTToHTMLConv.idl

interface nsITXTToHTMLConv extends nsIStreamConverter {
  setTitle(text: string): void;
  preFormatHTML(value: boolean): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/viewsource/nsIViewSourceChannel.idl

// https://searchfox.org/mozilla-central/source/netwerk/protocol/websocket/nsITransportProvider.idl

interface nsITransportProvider extends nsISupports {
  setListener(listener: nsIHttpUpgradeListener): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/websocket/nsIWebSocketChannel.idl

interface nsIWebSocketChannel extends nsISupports {
  readonly CLOSE_NORMAL?: 1000;
  readonly CLOSE_GOING_AWAY?: 1001;
  readonly CLOSE_PROTOCOL_ERROR?: 1002;
  readonly CLOSE_UNSUPPORTED_DATATYPE?: 1003;
  readonly CLOSE_NO_STATUS?: 1005;
  readonly CLOSE_ABNORMAL?: 1006;
  readonly CLOSE_INVALID_PAYLOAD?: 1007;
  readonly CLOSE_POLICY_VIOLATION?: 1008;
  readonly CLOSE_TOO_LARGE?: 1009;
  readonly CLOSE_EXTENSION_MISSING?: 1010;
  readonly CLOSE_INTERNAL_ERROR?: 1011;
  readonly CLOSE_TLS_FAILED?: 1015;

  readonly originalURI: nsIURI;
  readonly URI: nsIURI;
  notificationCallbacks: nsIInterfaceRequestor;
  readonly securityInfo: nsITransportSecurityInfo;
  loadGroup: nsILoadGroup;
  loadInfo: nsILoadInfo;
  protocol: string;
  readonly extensions: string;
  readonly httpChannelId: u64;
  initLoadInfo(aLoadingNode: Node, aLoadingPrincipal: nsIPrincipal, aTriggeringPrincipal: nsIPrincipal, aSecurityFlags: u32, aContentPolicyType: nsContentPolicyType): void;
  asyncOpen(aURI: nsIURI, aOrigin: string, aOriginAttributes: any, aInnerWindowID: u64, aListener: nsIWebSocketListener, aContext: nsISupports): void;
  close(aCode: u16, aReason: string): void;
  sendMsg(aMsg: string): void;
  sendBinaryMsg(aMsg: string): void;
  sendBinaryStream(aStream: nsIInputStream, length: u32): void;
  pingInterval: u32;
  pingTimeout: u32;
  serial: u32;
  setServerParameters(aProvider: nsITransportProvider, aNegotiatedExtensions: string): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/websocket/nsIWebSocketEventService.idl

interface nsIWebSocketFrame extends nsISupports {
  readonly OPCODE_CONTINUATION?: 0;
  readonly OPCODE_TEXT?: 1;
  readonly OPCODE_BINARY?: 2;
  readonly OPCODE_CLOSE?: 8;
  readonly OPCODE_PING?: 9;
  readonly OPCODE_PONG?: 10;

  readonly timeStamp: DOMHighResTimeStamp;
  readonly finBit: boolean;
  readonly rsvBit1: boolean;
  readonly rsvBit2: boolean;
  readonly rsvBit3: boolean;
  readonly opCode: u16;
  readonly maskBit: boolean;
  readonly mask: u32;
  readonly payload: string;
}

interface nsIWebSocketEventListener extends nsISupports {
  readonly TYPE_STRING?: 0;
  readonly TYPE_BLOB?: 1;
  readonly TYPE_ARRAYBUFFER?: 2;

  webSocketCreated(aWebSocketSerialID: u32, aURI: string, aProtocols: string): void;
  webSocketOpened(aWebSocketSerialID: u32, aEffectiveURI: string, aProtocols: string, aExtensions: string, aHttpChannelId: u64): void;
  webSocketMessageAvailable(aWebSocketSerialID: u32, aMessage: string, aType: u16): void;
  webSocketClosed(aWebSocketSerialID: u32, aWasClean: boolean, aCode: u16, aReason: string): void;
  frameReceived(aWebSocketSerialID: u32, aFrame: nsIWebSocketFrame): void;
  frameSent(aWebSocketSerialID: u32, aFrame: nsIWebSocketFrame): void;
}

interface nsIWebSocketEventService extends nsISupports {
  sendMessage(aWebSocketSerialID: u32, aMessage: string): void;
  addListener(aInnerWindowID: u64, aListener: nsIWebSocketEventListener): void;
  removeListener(aInnerWindowID: u64, aListener: nsIWebSocketEventListener): void;
  hasListenerFor(aInnerWindowID: u64): boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/websocket/nsIWebSocketImpl.idl

interface nsIWebSocketImpl extends nsISupports {
  sendMessage(aMessage: string): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/websocket/nsIWebSocketListener.idl

interface nsIWebSocketListener extends nsISupports {
  onStart(aContext: nsISupports): void;
  onStop(aContext: nsISupports, aStatusCode: nsresult): void;
  onMessageAvailable(aContext: nsISupports, aMsg: string): void;
  onBinaryMessageAvailable(aContext: nsISupports, aMsg: string): void;
  onAcknowledge(aContext: nsISupports, aSize: u32): void;
  onServerClose(aContext: nsISupports, aCode: u16, aReason: string): void;
  OnError(): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/webtransport/nsIWebTransport.idl

}  // global

declare enum nsIWebTransport_WebTransportError {
  UNKNOWN_ERROR = 0,
  INVALID_STATE_ERROR = 1,
}

declare enum nsIWebTransport_HTTPVersion {
  h3 = 0,
  h2 = 1,
}

declare global {

namespace nsIWebTransport {
  type WebTransportError = nsIWebTransport_WebTransportError;
  type HTTPVersion = nsIWebTransport_HTTPVersion;
}

interface nsIWebTransport extends nsISupports, Enums<typeof nsIWebTransport_WebTransportError & typeof nsIWebTransport_HTTPVersion> {
  asyncConnect(aURI: nsIURI, aDedicated: boolean, aServerCertHashes: nsIWebTransportHash[], aLoadingPrincipal: nsIPrincipal, aSecurityFlags: u32, aListener: WebTransportSessionEventListener, aVersion?: nsIWebTransport.HTTPVersion): void;
  getStats(): void;
  closeSession(aErrorCode: u32, aReason: string): void;
  createOutgoingBidirectionalStream(aListener: nsIWebTransportStreamCallback): void;
  createOutgoingUnidirectionalStream(aListener: nsIWebTransportStreamCallback): void;
  sendDatagram(aData: u8[], aTrackingId: u64): void;
  getMaxDatagramSize(): void;
}

}  // global

declare enum WebTransportSessionEventListener_DatagramOutcome {
  UNKNOWN = 0,
  DROPPED_TOO_MUCH_DATA = 1,
  SENT = 2,
}

declare global {

namespace WebTransportSessionEventListener {
  type DatagramOutcome = WebTransportSessionEventListener_DatagramOutcome;
}

interface WebTransportSessionEventListener extends nsISupports, Enums<typeof WebTransportSessionEventListener_DatagramOutcome> {
  onSessionReady(aSessionId: u64): void;
  onSessionClosed(aCleanly: boolean, aErrorCode: u32, aReason: string): void;
  onIncomingBidirectionalStreamAvailable(aStream: nsIWebTransportBidirectionalStream): void;
  onIncomingUnidirectionalStreamAvailable(aStream: nsIWebTransportReceiveStream): void;
  onStopSending(aStreamId: u64, aError: nsresult): void;
  onResetReceived(aStreamId: u64, aError: nsresult): void;
  onDatagramReceived(aData: u8[]): void;
  onMaxDatagramSize(aSize: u64): void;
  onOutgoingDatagramOutCome(aId: u64, aOutCome: WebTransportSessionEventListener.DatagramOutcome): void;
}

interface nsIWebTransportStreamCallback extends nsISupports {
  onBidirectionalStreamReady(aStream: nsIWebTransportBidirectionalStream): void;
  onUnidirectionalStreamReady(aStream: nsIWebTransportSendStream): void;
  onError(aError: u8): void;
}

interface nsIWebTransportHash extends nsISupports {
  readonly algorithm: string;
  readonly value: u8[];
}

// https://searchfox.org/mozilla-central/source/netwerk/protocol/webtransport/nsIWebTransportStream.idl

interface nsIWebTransportSendStreamStats extends nsISupports {
  readonly bytesSent: u64;
  readonly bytesAcknowledged: u64;
}

interface nsIWebTransportReceiveStreamStats extends nsISupports {
  readonly bytesReceived: u64;
}

interface nsIWebTransportStreamStatsCallback extends nsISupports {
  onSendStatsAvailable(aStats: nsIWebTransportSendStreamStats): void;
  onReceiveStatsAvailable(aStats: nsIWebTransportReceiveStreamStats): void;
}

interface nsIWebTransportReceiveStream extends nsISupports {
  sendStopSending(aError: u8): void;
  getReceiveStreamStats(aCallback: nsIWebTransportStreamStatsCallback): void;
  readonly hasReceivedFIN: boolean;
  readonly inputStream: nsIAsyncInputStream;
  readonly streamId: u64;
}

interface nsIWebTransportSendStream extends nsISupports {
  sendFin(): void;
  reset(aErrorCode: u8): void;
  getSendStreamStats(aCallback: nsIWebTransportStreamStatsCallback): void;
  readonly outputStream: nsIAsyncOutputStream;
  readonly streamId: u64;
}

interface nsIWebTransportBidirectionalStream extends nsISupports {
  sendStopSending(aError: u8): void;
  sendFin(): void;
  reset(aErrorCode: u8): void;
  readonly hasReceivedFIN: boolean;
  readonly inputStream: nsIAsyncInputStream;
  readonly outputStream: nsIAsyncOutputStream;
  readonly streamId: u64;
}

// https://searchfox.org/mozilla-central/source/netwerk/wifi/nsIWifiAccessPoint.idl

interface nsIWifiAccessPoint extends nsISupports {
  readonly mac: string;
  readonly ssid: string;
  readonly rawSSID: string;
  readonly signal: i32;
}

// https://searchfox.org/mozilla-central/source/netwerk/wifi/nsIWifiListener.idl

interface nsIWifiListener extends nsISupports {
  onChange(accessPoints: nsIWifiAccessPoint[]): void;
  onError(error: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/wifi/nsIWifiMonitor.idl

interface nsIWifiMonitor extends nsISupports {
  startWatching(aListener: nsIWifiListener, aForcePolling: boolean): void;
  stopWatching(aListener: nsIWifiListener): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/parentalcontrols/nsIParentalControlsService.idl

interface nsIParentalControlsService extends nsISupports {
  readonly DOWNLOAD?: 1;
  readonly INSTALL_EXTENSION?: 2;
  readonly INSTALL_APP?: 3;
  readonly BROWSE?: 4;
  readonly SHARE?: 5;
  readonly BOOKMARK?: 6;
  readonly ADD_CONTACT?: 7;
  readonly SET_IMAGE?: 8;
  readonly MODIFY_ACCOUNTS?: 9;
  readonly REMOTE_DEBUGGING?: 10;
  readonly IMPORT_SETTINGS?: 11;
  readonly PRIVATE_BROWSING?: 12;
  readonly DATA_CHOICES?: 13;
  readonly CLEAR_HISTORY?: 14;
  readonly MASTER_PASSWORD?: 15;
  readonly GUEST_BROWSING?: 16;
  readonly ADVANCED_SETTINGS?: 17;
  readonly CAMERA_MICROPHONE?: 18;
  readonly BLOCK_LIST?: 19;
  readonly TELEMETRY?: 20;
  readonly HEALTH_REPORT?: 21;
  readonly DEFAULT_THEME?: 22;
  readonly ePCLog_URIVisit?: 1;
  readonly ePCLog_FileDownload?: 2;

  readonly parentalControlsEnabled: boolean;
  readonly blockFileDownloadsEnabled: boolean;
  isAllowed(aAction: i16, aUri?: nsIURI): boolean;
  readonly loggingEnabled: boolean;
  log(aEntryType: i16, aFlag: boolean, aSource: nsIURI, aTarget?: nsIFile): void;
}

// https://searchfox.org/mozilla-central/source/dom/media/bridge/IPeerConnection.idl

interface IPeerConnectionObserver extends nsISupports {
}

interface IPeerConnection extends nsISupports {
  readonly kHintAudio?: 1;
  readonly kHintVideo?: 2;
  readonly kActionNone?: -1;
  readonly kActionOffer?: 0;
  readonly kActionAnswer?: 1;
  readonly kActionPRAnswer?: 2;
  readonly kActionRollback?: 3;
  readonly kIceGathering?: 0;
  readonly kIceWaiting?: 1;
  readonly kIceChecking?: 2;
  readonly kIceConnected?: 3;
  readonly kIceFailed?: 4;
  readonly kNew?: 0;
  readonly kNegotiating?: 1;
  readonly kActive?: 2;
  readonly kClosing?: 3;
  readonly kClosed?: 4;
  readonly kDataChannelReliable?: 0;
  readonly kDataChannelPartialReliableRexmit?: 1;
  readonly kDataChannelPartialReliableTimed?: 2;
  readonly kNoError?: 0;
  readonly kInvalidCandidate?: 2;
  readonly kInvalidMediastreamTrack?: 3;
  readonly kInvalidState?: 4;
  readonly kInvalidSessionDescription?: 5;
  readonly kIncompatibleSessionDescription?: 6;
  readonly kIncompatibleMediaStreamTrack?: 8;
  readonly kInternalError?: 9;
  readonly kTypeError?: 10;
  readonly kOperationError?: 11;
  readonly kMaxErrorType?: 11;
}

// https://searchfox.org/mozilla-central/source/extensions/permissions/nsIRemotePermissionService.idl

interface nsIRemotePermissionService extends nsISupports {
  init(): void;
  readonly isInitialized: Promise<any>;
  testAllowedPermissionValues: any;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsICertOverrideService.idl

interface nsICertOverride extends nsISupports {
  readonly asciiHost: string;
  readonly port: i32;
  readonly hostPort: string;
  readonly fingerprint: string;
  readonly originAttributes: any;
}

interface nsICertOverrideService extends nsISupports {
  rememberValidityOverride(aHostName: string, aPort: i32, aOriginAttributes: any, aCert: nsIX509Cert, aTemporary: boolean): void;
  hasMatchingOverride(aHostName: string, aPort: i32, aOriginAttributes: any, aCert: nsIX509Cert, aIsTemporary: OutParam<boolean>): boolean;
  clearValidityOverride(aHostName: string, aPort: i32, aOriginAttributes: any): void;
  clearAllOverrides(): void;
  getOverrides(): nsICertOverride[];
  setDisableAllSecurityChecksAndLetAttackersInterceptMyData(aDisable: boolean): void;
  setDisableAllSecurityChecksAndLetAttackersInterceptMyDataForUserContext(aUserContextId: u32, aDisable: boolean): void;
  resetDisableAllSecurityChecksAndLetAttackersInterceptMyDataForUserContext(aUserContextId: u32): void;
  readonly securityCheckDisabled: boolean;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsICertStorage.idl

type nsICertStorageCallback = Callable<{
  done(rv: nsresult, result: nsIVariant): void;
}>

interface nsIRevocationState extends nsISupports {
  readonly state: i16;
}

interface nsIIssuerAndSerialRevocationState extends nsIRevocationState {
  readonly issuer: string;
  readonly serial: string;
}

interface nsISubjectAndPubKeyRevocationState extends nsIRevocationState {
  readonly subject: string;
  readonly pubKey: string;
}

interface nsICertInfo extends nsISupports {
  readonly cert: string;
  readonly subject: string;
  readonly trust: i16;
}

interface nsICertStorage extends nsISupports {
  readonly DATA_TYPE_REVOCATION?: 1;
  readonly DATA_TYPE_CERTIFICATE?: 2;
  readonly DATA_TYPE_CRLITE?: 3;
  readonly DATA_TYPE_CRLITE_FILTER_FULL?: 4;
  readonly DATA_TYPE_CRLITE_FILTER_INCREMENTAL?: 5;
  readonly STATE_UNSET?: 0;
  readonly STATE_ENFORCE?: 1;
  readonly STATE_NOT_ENROLLED?: 2;
  readonly STATE_NOT_COVERED?: 3;
  readonly STATE_NO_FILTER?: 4;
  readonly TRUST_INHERIT?: 0;
  readonly TRUST_ANCHOR?: 1;

  hasPriorData(type: u8, callback: nsICertStorageCallback): void;
  setRevocations(revocations: nsIRevocationState[], callback: nsICertStorageCallback): void;
  getRevocationState(issuer: u8[], serial: u8[], subject: u8[], pubkey: u8[]): i16;
  setFullCRLiteFilter(filter: u8[], callback: nsICertStorageCallback): void;
  addCRLiteDelta(delta: u8[], filename: string, callback: nsICertStorageCallback): void;
  testNoteCRLiteUpdateTime(callback: nsICertStorageCallback): void;
  addCerts(certs: nsICertInfo[], callback: nsICertStorageCallback): void;
  removeCertsByHashes(hashes: string[], callback: nsICertStorageCallback): void;
  findCertsBySubject(subject: u8[]): u8[][];
  GetRemainingOperationCount(): i32;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsICertTree.idl

interface nsICertTreeItem extends nsISupports {
  readonly cert: nsIX509Cert;
}

interface nsICertTree extends nsITreeView {
  loadCertsFromCache(cache: nsIX509Cert[], type: u32): void;
  getCert(index: u32): nsIX509Cert;
  getTreeItem(index: u32): nsICertTreeItem;
  deleteEntryObject(index: u32): void;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsICertificateDialogs.idl

interface nsICertificateDialogs extends nsISupports {
  confirmDownloadCACert(ctx: nsIInterfaceRequestor, cert: nsIX509Cert, trust: OutParam<u32>): boolean;
  setPKCS12FilePassword(ctx: nsIInterfaceRequestor, password: OutParam<string>): boolean;
  getPKCS12FilePassword(ctx: nsIInterfaceRequestor, password: OutParam<string>): boolean;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIClientAuthDialogService.idl

type nsIClientAuthDialogCallback = Callable<{
  certificateChosen(cert: nsIX509Cert, rememberDuration: nsIClientAuthRememberService.Duration): void;
}>

interface nsIClientAuthDialogService extends nsISupports {
  chooseCertificate(hostname: string, certArray: nsIX509Cert[], loadContext: nsILoadContext, caNames: u8[][], callback: nsIClientAuthDialogCallback): void;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIClientAuthRememberService.idl

interface nsIClientAuthRememberRecord extends nsISupports {
  readonly asciiHost: string;
  readonly dbKey: string;
  readonly entryKey: string;
}

}  // global

declare enum nsIClientAuthRememberService_Duration {
  Once = 0,
  Permanent = 1,
  Session = 2,
}

declare global {

namespace nsIClientAuthRememberService {
  type Duration = nsIClientAuthRememberService_Duration;
}

interface nsIClientAuthRememberService extends nsISupports, Enums<typeof nsIClientAuthRememberService_Duration> {
  forgetRememberedDecision(key: string): void;
  getDecisions(): nsIClientAuthRememberRecord[];
  rememberDecisionScriptable(aHostName: string, originAttributes: any, aClientCert: nsIX509Cert, aDuration: nsIClientAuthRememberService.Duration): void;
  hasRememberedDecisionScriptable(aHostName: string, originAttributes: any, aCertDBKey: OutParam<string>): boolean;
  clearRememberedDecisions(): void;
  deleteDecisionsByHost(aHostName: string, aOriginAttributes: any): void;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIContentSignatureVerifier.idl

interface nsIContentSignatureVerifier extends nsISupports {
  readonly ContentSignatureProdRoot?: 1;
  readonly ContentSignatureStageRoot?: 2;
  readonly ContentSignatureDevRoot?: 3;
  readonly ContentSignatureLocalRoot?: 4;

  asyncVerifyContentSignature(aData: string, aContentSignatureHeader: string, aCertificateChain: string, aHostname: string, aTrustedRoot: AppTrustedRoot): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsICryptoHash.idl

interface nsICryptoHash extends nsISupports {
  readonly MD5?: 2;
  readonly SHA1?: 3;
  readonly SHA256?: 4;
  readonly SHA384?: 5;
  readonly SHA512?: 6;

  init(aAlgorithm: u32): void;
  initWithString(aAlgorithm: string): void;
  update(aData: u8[], aLen: u32): void;
  updateFromStream(aStream: nsIInputStream, aLen: u32): void;
  finish(aASCII: boolean): string;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIDataStorage.idl

}  // global

declare enum nsIDataStorageManager_DataStorage {
  AlternateServices = 0,
  ClientAuthRememberList = 1,
  SiteSecurityServiceState = 2,
}

declare global {

namespace nsIDataStorageManager {
  type DataStorage = nsIDataStorageManager_DataStorage;
}

interface nsIDataStorageManager extends nsISupports, Enums<typeof nsIDataStorageManager_DataStorage> {
  get(dataStorage: nsIDataStorageManager.DataStorage): nsIDataStorage;
}

}  // global

declare enum nsIDataStorage_DataType {
  Persistent = 0,
  Private = 1,
  Temporary = 2,
}

declare global {

namespace nsIDataStorage {
  type DataType = nsIDataStorage_DataType;
}

interface nsIDataStorage extends nsISupports, Enums<typeof nsIDataStorage_DataType> {
  get(key: string, type: nsIDataStorage.DataType): string;
  put(key: string, value: string, type: nsIDataStorage.DataType): void;
  remove(key: string, type: nsIDataStorage.DataType): void;
  clear(): void;
  isReady(): boolean;
  getAll(): nsIDataStorageItem[];
}

interface nsIDataStorageItem extends nsISupports {
  readonly key: string;
  readonly value: string;
  readonly type: nsIDataStorage.DataType;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsINSSComponent.idl

interface nsINSSComponent extends nsISupports {
  getEnterpriseRoots(): u8[][];
  getEnterpriseRootsPEM(): string;
  getEnterpriseIntermediates(): u8[][];
  getEnterpriseIntermediatesPEM(): string;
  addEnterpriseIntermediate(intermediateBytes: u8[]): void;
  clearSSLExternalAndInternalSessionCache(): void;
  asyncClearSSLExternalAndInternalSessionCache(): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsINSSErrorsService.idl

interface nsINSSErrorsService extends nsISupports {
  readonly ERROR_CLASS_SSL_PROTOCOL?: 1;
  readonly ERROR_CLASS_BAD_CERT?: 2;
  readonly NSS_SEC_ERROR_BASE?: -8192;
  readonly NSS_SEC_ERROR_LIMIT?: -7192;
  readonly NSS_SSL_ERROR_BASE?: -12288;
  readonly NSS_SSL_ERROR_LIMIT?: -11288;
  readonly MOZILLA_PKIX_ERROR_BASE?: -16384;
  readonly MOZILLA_PKIX_ERROR_LIMIT?: -15384;

  isNSSErrorCode(aNSPRCode: i32): boolean;
  getXPCOMFromNSSError(aNSPRCode: i32): nsresult;
  getErrorMessage(aXPCOMErrorCode: nsresult): string;
  getErrorName(aXPCOMErrorCode: nsresult): string;
  getErrorClass(aXPCOMErrorCode: nsresult): u32;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsINSSVersion.idl

interface nsINSSVersion extends nsISupports {
  readonly NSPR_MinVersion: string;
  readonly NSS_MinVersion: string;
  readonly NSSUTIL_MinVersion: string;
  readonly NSSSSL_MinVersion: string;
  readonly NSSSMIME_MinVersion: string;
  readonly NSPR_Version: string;
  readonly NSS_Version: string;
  readonly NSSUTIL_Version: string;
  readonly NSSSSL_Version: string;
  readonly NSSSMIME_Version: string;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIOSKeyStore.idl

interface nsIOSKeyStore extends nsISupports {
  asyncGenerateSecret(label: string): Promise<any>;
  asyncSecretAvailable(label: string): Promise<any>;
  asyncRecoverSecret(label: string, recoveryPhrase: string): Promise<any>;
  asyncDeleteSecret(label: string): Promise<any>;
  asyncEncryptBytes(label: string, inBytes: u8[]): Promise<any>;
  asyncDecryptBytes(label: string, encryptedBase64Text: string): Promise<any>;
  asyncGetRecoveryPhrase(aLabel: string): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIOSReauthenticator.idl

interface nsIOSReauthenticator extends nsISupports {
  asyncReauthenticateUser(prompt: string, caption: string, parentWindow: mozIDOMWindow): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIPK11Token.idl

interface nsIPK11Token extends nsISupports {
  readonly tokenName: string;
  readonly isInternalKeyToken: boolean;
  readonly tokenManID: string;
  readonly tokenHWVersion: string;
  readonly tokenFWVersion: string;
  readonly tokenSerialNumber: string;
  isLoggedIn(): boolean;
  login(force: boolean): void;
  logoutSimple(): void;
  logoutAndDropAuthenticatedResources(): void;
  needsLogin(): boolean;
  readonly needsUserInit: boolean;
  reset(): void;
  checkPassword(password: string): boolean;
  initPassword(initialPassword: string): void;
  changePassword(oldPassword: string, newPassword: string): void;
  readonly hasPassword: boolean;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIPK11TokenDB.idl

interface nsIPK11TokenDB extends nsISupports {
  getInternalKeyToken(): nsIPK11Token;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIPKCS11Module.idl

interface nsIPKCS11Module extends nsISupports {
  readonly name: string;
  readonly libName: string;
  listSlots(): nsISimpleEnumerator;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIPKCS11ModuleDB.idl

interface nsIPKCS11ModuleDB extends nsISupports {
  deleteModule(moduleName: string): void;
  addModule(moduleName: string, libraryFullPath: string, cryptoMechanismFlags: i32, cipherFlags: i32): void;
  listModules(): nsISimpleEnumerator;
  readonly canToggleFIPS: boolean;
  toggleFIPSMode(): void;
  readonly isFIPSEnabled: boolean;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIPKCS11Slot.idl

interface nsIPKCS11Slot extends nsISupports {
  readonly SLOT_DISABLED?: 0;
  readonly SLOT_NOT_PRESENT?: 1;
  readonly SLOT_UNINITIALIZED?: 2;
  readonly SLOT_NOT_LOGGED_IN?: 3;
  readonly SLOT_LOGGED_IN?: 4;
  readonly SLOT_READY?: 5;

  readonly name: string;
  readonly desc: string;
  readonly manID: string;
  readonly HWVersion: string;
  readonly FWVersion: string;
  readonly status: u32;
  getToken(): nsIPK11Token;
  readonly tokenName: string;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIPublicKeyPinningService.idl

interface nsIPublicKeyPinningService extends nsISupports {
  hostHasPins(aURI: nsIURI): boolean;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsISecretDecoderRing.idl

interface nsISecretDecoderRing extends nsISupports {
  encryptString(text: string): string;
  asyncEncryptStrings(plaintexts: string[]): Promise<any>;
  decryptString(encryptedBase64Text: string): string;
  asyncDecryptStrings(encryptedStrings: string[]): Promise<any>;
  changePassword(): void;
  logout(): void;
  logoutAndTeardown(): void;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsISecurityUITelemetry.idl

interface nsISecurityUITelemetry extends nsISupports {
  readonly WARNING_ADDON_ASKING_PREVENTED?: 1;
  readonly WARNING_ADDON_ASKING_PREVENTED_CLICK_THROUGH?: 2;
  readonly WARNING_CONFIRM_ADDON_INSTALL?: 3;
  readonly WARNING_CONFIRM_ADDON_INSTALL_CLICK_THROUGH?: 4;
  readonly WARNING_CONFIRM_POST_TO_INSECURE_FROM_SECURE?: 9;
  readonly WARNING_CONFIRM_POST_TO_INSECURE_FROM_SECURE_CLICK_THROUGH?: 10;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsISiteSecurityService.idl

}  // global

declare enum nsISiteSecurityService_ResetStateBy {
  ExactDomain = 0,
  RootDomain = 1,
  BaseDomain = 2,
}

declare global {

namespace nsISiteSecurityService {
  type ResetStateBy = nsISiteSecurityService_ResetStateBy;
}

interface nsISiteSecurityService extends nsISupports, Enums<typeof nsISiteSecurityService_ResetStateBy> {
  readonly Success?: 0;
  readonly ERROR_UNKNOWN?: 1;
  readonly ERROR_COULD_NOT_PARSE_HEADER?: 3;
  readonly ERROR_NO_MAX_AGE?: 4;
  readonly ERROR_MULTIPLE_MAX_AGES?: 5;
  readonly ERROR_INVALID_MAX_AGE?: 6;
  readonly ERROR_MULTIPLE_INCLUDE_SUBDOMAINS?: 7;
  readonly ERROR_INVALID_INCLUDE_SUBDOMAINS?: 8;
  readonly ERROR_COULD_NOT_SAVE_STATE?: 13;

  processHeader(aSourceURI: nsIURI, aHeader: string, aOriginAttributes?: any, aMaxAge?: OutParam<u64>, aIncludeSubdomains?: OutParam<boolean>, aFailureResult?: OutParam<u32>): void;
  resetState(aURI: nsIURI, aOriginAttributes?: any, aScope?: nsISiteSecurityService.ResetStateBy): void;
  isSecureURI(aURI: nsIURI, aOriginAttributes?: any): boolean;
  clearAll(): void;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsITLSSocketControl.idl

interface nsITLSSocketControl extends nsISupports {
  readonly KEY_EXCHANGE_UNKNOWN?: -1;
  readonly SSL_VERSION_3?: 768;
  readonly TLS_VERSION_1?: 769;
  readonly TLS_VERSION_1_1?: 770;
  readonly TLS_VERSION_1_2?: 771;
  readonly TLS_VERSION_1_3?: 772;
  readonly SSL_VERSION_UNKNOWN?: -1;
  readonly SSL_MAC_UNKNOWN?: -1;
  readonly SSL_MAC_NULL?: 0;
  readonly SSL_MAC_MD5?: 1;
  readonly SSL_MAC_SHA?: 2;
  readonly SSL_HMAC_MD5?: 3;
  readonly SSL_HMAC_SHA?: 4;
  readonly SSL_HMAC_SHA256?: 5;
  readonly SSL_MAC_AEAD?: 6;

  asyncStartTLS(): Promise<any>;
  getAlpnEarlySelection(): string;
  readonly earlyDataAccepted: boolean;
  driveHandshake(): void;
  joinConnection(npnProtocol: string, hostname: string, port: i32): boolean;
  testJoinConnection(npnProtocol: string, hostname: string, port: i32): boolean;
  isAcceptableForHost(hostname: string): boolean;
  readonly KEAUsed: i16;
  readonly KEAKeyBits: u32;
  readonly providerFlags: u32;
  readonly SSLVersionUsed: i16;
  readonly SSLVersionOffered: i16;
  readonly MACAlgorithmUsed: i16;
  readonly clientCertSent: boolean;
  readonly failedVerification: boolean;
  esniTxt: string;
  echConfig: string;
  readonly retryEchConfig: string;
  readonly peerId: string;
  readonly securityInfo: nsITransportSecurityInfo;
  asyncGetSecurityInfo(): Promise<any>;
  claim(): void;
  browserId: u64;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsITokenPasswordDialogs.idl

interface nsITokenPasswordDialogs extends nsISupports {
  setPassword(ctx: nsIInterfaceRequestor, token: nsIPK11Token): boolean;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsITransportSecurityInfo.idl

}  // global

declare enum nsITransportSecurityInfo_OverridableErrorCategory {
  ERROR_UNSET = 0,
  ERROR_TRUST = 1,
  ERROR_DOMAIN = 2,
  ERROR_TIME = 3,
}

declare global {

namespace nsITransportSecurityInfo {
  type OverridableErrorCategory = nsITransportSecurityInfo_OverridableErrorCategory;
}

interface nsITransportSecurityInfo extends nsISupports, Enums<typeof nsITransportSecurityInfo_OverridableErrorCategory> {
  readonly SSL_VERSION_3?: 0;
  readonly TLS_VERSION_1?: 1;
  readonly TLS_VERSION_1_1?: 2;
  readonly TLS_VERSION_1_2?: 3;
  readonly TLS_VERSION_1_3?: 4;
  readonly CERTIFICATE_TRANSPARENCY_NOT_APPLICABLE?: 0;
  readonly CERTIFICATE_TRANSPARENCY_POLICY_COMPLIANT?: 5;
  readonly CERTIFICATE_TRANSPARENCY_POLICY_NOT_ENOUGH_SCTS?: 6;
  readonly CERTIFICATE_TRANSPARENCY_POLICY_NOT_DIVERSE_SCTS?: 7;

  readonly securityState: u32;
  readonly errorCode: i32;
  readonly errorCodeString: string;
  readonly failedCertChain: nsIX509Cert[];
  readonly serverCert: nsIX509Cert;
  readonly succeededCertChain: nsIX509Cert[];
  readonly cipherName: string;
  readonly keyLength: u32;
  readonly secretKeyLength: u32;
  readonly keaGroupName: string;
  readonly signatureSchemeName: string;
  readonly protocolVersion: u16;
  readonly certificateTransparencyStatus: u16;
  readonly isAcceptedEch: boolean;
  readonly isDelegatedCredential: boolean;
  readonly overridableErrorCategory: nsITransportSecurityInfo.OverridableErrorCategory;
  readonly madeOCSPRequests: boolean;
  readonly usedPrivateDNS: boolean;
  readonly isExtendedValidation: boolean;
  toString(): string;
  readonly negotiatedNPN: string;
  readonly resumed: boolean;
  readonly isBuiltCertChainRootBuiltInRoot: boolean;
  readonly peerId: string;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIX509Cert.idl

interface nsIX509Cert extends nsISupports {
  readonly UNKNOWN_CERT?: 0;
  readonly CA_CERT?: 1;
  readonly USER_CERT?: 2;
  readonly EMAIL_CERT?: 4;
  readonly SERVER_CERT?: 8;
  readonly ANY_CERT?: 65535;

  readonly emailAddress: string;
  getEmailAddresses(): string[];
  containsEmailAddress(aEmailAddress: string): boolean;
  readonly subjectName: string;
  readonly commonName: string;
  readonly organization: string;
  readonly organizationalUnit: string;
  readonly sha256Fingerprint: string;
  readonly sha1Fingerprint: string;
  readonly tokenName: string;
  readonly issuerName: string;
  readonly serialNumber: string;
  readonly issuerCommonName: string;
  readonly issuerOrganization: string;
  readonly issuerOrganizationUnit: string;
  readonly validity: nsIX509CertValidity;
  readonly dbKey: string;
  readonly displayName: string;
  readonly certType: u32;
  getRawDER(): u8[];
  getBase64DERString(): string;
  readonly sha256SubjectPublicKeyInfoDigest: string;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIX509CertDB.idl

}  // global

declare enum nsIAppSignatureInfo_SignatureAlgorithm {
  PKCS7_WITH_SHA1 = 0,
  PKCS7_WITH_SHA256 = 1,
  COSE_WITH_SHA256 = 2,
}

declare global {

namespace nsIAppSignatureInfo {
  type SignatureAlgorithm = nsIAppSignatureInfo_SignatureAlgorithm;
}

interface nsIAppSignatureInfo extends nsISupports, Enums<typeof nsIAppSignatureInfo_SignatureAlgorithm> {
  readonly signerCert: nsIX509Cert;
  readonly signatureAlgorithm: nsIAppSignatureInfo.SignatureAlgorithm;
}

type nsIOpenSignedAppFileCallback = Callable<{
  openSignedAppFileFinished(rv: nsresult, aZipReader: nsIZipReader, aSignatureInfos: nsIAppSignatureInfo[]): void;
}>

type nsIAsyncBoolCallback = Callable<{
  onResult(result: boolean): void;
}>

type nsICertVerificationCallback = Callable<{
  verifyCertFinished(aPRErrorCode: i32, aVerifiedChain: nsIX509Cert[], aHasEVPolicy: boolean): void;
}>

}  // global

declare enum nsIX509CertDB_VerifyUsage {
  verifyUsageTLSServer = 1,
  verifyUsageTLSServerCA = 2,
  verifyUsageTLSClient = 3,
  verifyUsageTLSClientCA = 4,
  verifyUsageEmailSigner = 5,
  verifyUsageEmailRecipient = 6,
  verifyUsageEmailCA = 7,
}

declare global {

namespace nsIX509CertDB {
  type VerifyUsage = nsIX509CertDB_VerifyUsage;
}

interface nsIX509CertDB extends nsISupports, Enums<typeof nsIX509CertDB_VerifyUsage> {
  readonly UNTRUSTED?: 0;
  readonly TRUSTED_SSL?: 1;
  readonly TRUSTED_EMAIL?: 2;
  readonly Success?: 0;
  readonly ERROR_UNKNOWN?: 1;
  readonly ERROR_PKCS12_NOSMARTCARD_EXPORT?: 2;
  readonly ERROR_PKCS12_RESTORE_FAILED?: 3;
  readonly ERROR_PKCS12_BACKUP_FAILED?: 4;
  readonly ERROR_PKCS12_CERT_COLLISION?: 5;
  readonly ERROR_BAD_PASSWORD?: 6;
  readonly ERROR_DECODE_ERROR?: 7;
  readonly ERROR_PKCS12_DUPLICATE_DATA?: 8;
  readonly AppXPCShellRoot?: 6;
  readonly AddonsPublicRoot?: 7;
  readonly AddonsStageRoot?: 8;
  readonly FLAG_LOCAL_ONLY?: 1;
  readonly FLAG_MUST_BE_EV?: 2;

  findCertByDBKey(aDBkey: string): nsIX509Cert;
  importCertificates(data: u8[], length: u32, type: u32, ctx: nsIInterfaceRequestor): void;
  importEmailCertificate(data: u8[], length: u32, ctx: nsIInterfaceRequestor): void;
  importUserCertificate(data: u8[], length: u32, ctx: nsIInterfaceRequestor): void;
  deleteCertificate(aCert: nsIX509Cert): void;
  setCertTrust(cert: nsIX509Cert, type: u32, trust: u32): void;
  setCertTrustFromString(cert: nsIX509Cert, trustString: string): void;
  isCertTrusted(cert: nsIX509Cert, certType: u32, trustType: u32): boolean;
  importCertsFromFile(aFile: nsIFile, aType: u32): void;
  importPKCS12File(aFile: nsIFile, aPassword: string): u32;
  exportPKCS12File(aFile: nsIFile, aCerts: nsIX509Cert[], aPassword: string): u32;
  constructX509FromBase64(base64: string): nsIX509Cert;
  constructX509(certDER: u8[]): nsIX509Cert;
  openSignedAppFileAsync(trustedRoot: AppTrustedRoot, aJarFile: nsIFile, callback: nsIOpenSignedAppFileCallback): void;
  addCert(certDER: string, trust: string): nsIX509Cert;
  asyncVerifyCertAtTime(aCert: nsIX509Cert, aUsage: nsIX509CertDB.VerifyUsage, aFlags: u32, aHostname: string, aTime: u64, aCallback: nsICertVerificationCallback): void;
  clearOCSPCache(): void;
  addCertFromBase64(base64: string, trust: string): nsIX509Cert;
  getCerts(): nsIX509Cert[];
  asPKCS7Blob(certList: nsIX509Cert[]): string;
  asyncHasThirdPartyRoots(callback: nsIAsyncBoolCallback): void;
  countTrustObjects(): u32;
  getAndroidCertificateFromAlias(alias: string): nsIX509Cert;
}

// https://searchfox.org/mozilla-central/source/security/manager/ssl/nsIX509CertValidity.idl

interface nsIX509CertValidity extends nsISupports {
  readonly notBefore: PRTime;
  readonly notAfter: PRTime;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/places/mozIAsyncHistory.idl

interface mozIVisitInfo extends nsISupports {
  readonly visitId: i64;
  readonly visitDate: PRTime;
  readonly transitionType: u32;
  readonly referrerURI: nsIURI;
}

interface mozIPlaceInfo extends nsISupports {
  readonly placeId: i64;
  readonly guid: string;
  readonly uri: nsIURI;
  readonly title: string;
  readonly frecency: i64;
  readonly visits: any;
}

interface mozIVisitInfoCallback extends nsISupports {
  handleError(aResultCode: nsresult, aPlaceInfo: mozIPlaceInfo): void;
  handleResult(aPlaceInfo: mozIPlaceInfo): void;
  handleCompletion(aUpdatedItems: u32): void;
  readonly ignoreResults: boolean;
  readonly ignoreErrors: boolean;
}

type mozIVisitedStatusCallback = Callable<{
  isVisited(aURI: nsIURI, aVisitedStatus: boolean): void;
}>

interface mozIAsyncHistory extends nsISupports {
  updatePlaces(aPlaceInfo: any, aCallback?: mozIVisitInfoCallback): void;
  isURIVisited(aURI: nsIURI, aCallback: mozIVisitedStatusCallback): void;
  clearCache(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/places/mozIPlacesAutoComplete.idl

interface mozIPlacesAutoComplete extends nsISupports {
  readonly MATCH_ANYWHERE?: 0;
  readonly MATCH_BOUNDARY_ANYWHERE?: 1;
  readonly MATCH_BOUNDARY?: 2;
  readonly MATCH_BEGINNING?: 3;
  readonly MATCH_ANYWHERE_UNMODIFIED?: 4;
  readonly MATCH_BEGINNING_CASE_SENSITIVE?: 5;
  readonly BEHAVIOR_HISTORY?: 1;
  readonly BEHAVIOR_BOOKMARK?: 2;
  readonly BEHAVIOR_TAG?: 4;
  readonly BEHAVIOR_TITLE?: 8;
  readonly BEHAVIOR_URL?: 16;
  readonly BEHAVIOR_TYPED?: 32;
  readonly BEHAVIOR_JAVASCRIPT?: 64;
  readonly BEHAVIOR_OPENPAGE?: 128;
  readonly BEHAVIOR_RESTRICT?: 256;
  readonly BEHAVIOR_SEARCH?: 512;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/places/mozIPlacesPendingOperation.idl

interface mozIPlacesPendingOperation extends nsISupports {
  cancel(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/places/mozISyncedBookmarksMirror.idl

interface mozISyncedBookmarksMirrorProgressListener extends nsISupports {
  onFetchLocalTree(took: i64, itemCount: i64, deletedCount: i64, problems: nsIPropertyBag): void;
  onFetchRemoteTree(took: i64, itemCount: i64, deletedCount: i64, problems: nsIPropertyBag): void;
  onMerge(took: i64, counts: nsIPropertyBag): void;
  onApply(took: i64): void;
}

interface mozISyncedBookmarksMirrorCallback extends nsISupports {
  handleSuccess(result: boolean): void;
  handleError(code: nsresult, message: string): void;
}

interface mozISyncedBookmarksMirrorLogger extends nsISupports {
  readonly LEVEL_OFF?: 0;
  readonly LEVEL_ERROR?: 1;
  readonly LEVEL_WARN?: 2;
  readonly LEVEL_DEBUG?: 3;
  readonly LEVEL_TRACE?: 4;

  maxLevel: i16;
  error(message: string): void;
  warn(message: string): void;
  debug(message: string): void;
  trace(message: string): void;
}

}  // global

declare enum mozISyncedBookmarksMerger_SyncedItemKinds {
  KIND_BOOKMARK = 1,
  KIND_QUERY = 2,
  KIND_FOLDER = 3,
  KIND_LIVEMARK = 4,
  KIND_SEPARATOR = 5,
}

declare enum mozISyncedBookmarksMerger_SyncedItemValidity {
  VALIDITY_VALID = 1,
  VALIDITY_REUPLOAD = 2,
  VALIDITY_REPLACE = 3,
}

declare global {

namespace mozISyncedBookmarksMerger {
  type SyncedItemKinds = mozISyncedBookmarksMerger_SyncedItemKinds;
  type SyncedItemValidity = mozISyncedBookmarksMerger_SyncedItemValidity;
}

interface mozISyncedBookmarksMerger extends nsISupports, Enums<typeof mozISyncedBookmarksMerger_SyncedItemKinds & typeof mozISyncedBookmarksMerger_SyncedItemValidity> {
  db: mozIStorageConnection;
  logger: mozIServicesLogSink;
  merge(localTimeSeconds: i64, remoteTimeSeconds: i64, callback: mozISyncedBookmarksMirrorCallback): mozIPlacesPendingOperation;
  reset(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/places/nsIFaviconService.idl

interface nsIFaviconService extends nsISupports {
  readonly FAVICON_LOAD_PRIVATE?: 1;
  readonly FAVICON_LOAD_NON_PRIVATE?: 2;
  readonly ICONDATA_FLAGS_RICH?: 1;
  readonly MAX_FAVICON_BUFFER_SIZE?: 65536;

  getFaviconLinkForIcon(aFaviconURI: nsIURI): nsIURI;
  expireAllFavicons(): void;
  setDefaultIconURIPreferredSize(aDefaultSize: u16): void;
  preferredSizeFromURI(aURI: nsIURI): u16;
  readonly defaultFavicon: nsIURI;
  readonly defaultFaviconMimeType: string;
  setFaviconForPage(aPageURI: nsIURI, aFaviconURI: nsIURI, aDataURL: nsIURI, aExpiration?: PRTime, isRichIcon?: boolean): Promise<any>;
  getFaviconForPage(aPageURI: nsIURI, aPreferredWidth?: u16): Promise<any>;
  copyFavicons(aFromPageURI: nsIURI, aToPageURI: nsIURI, aFaviconLoadType: u32, aCallback?: nsIFaviconDataCallback): void;
}

type nsIFaviconDataCallback = Callable<{
  onComplete(aFaviconURI: nsIURI, aDataLen: u32, aData: u8[], aMimeType: string, aWidth: u16): void;
}>

interface nsIFavicon extends nsISupports {
  readonly uri: nsIURI;
  readonly dataURI: nsIURI;
  readonly rawData: u8[];
  readonly mimeType: string;
  readonly width: u16;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/places/nsINavBookmarksService.idl

}  // global

declare enum nsINavBookmarksService_ChangeSource {
  SOURCE_DEFAULT = 0,
  SOURCE_SYNC = 1,
  SOURCE_IMPORT = 2,
  SOURCE_SYNC_REPARENT_REMOVED_FOLDER_CHILDREN = 4,
  SOURCE_RESTORE = 5,
  SOURCE_RESTORE_ON_STARTUP = 6,
}

declare global {

namespace nsINavBookmarksService {
  type ChangeSource = nsINavBookmarksService_ChangeSource;
}

interface nsINavBookmarksService extends nsISupports, Enums<typeof nsINavBookmarksService_ChangeSource> {
  readonly DEFAULT_INDEX?: -1;
  readonly TYPE_BOOKMARK?: 1;
  readonly TYPE_FOLDER?: 2;
  readonly TYPE_SEPARATOR?: 3;
  readonly TYPE_DYNAMIC_CONTAINER?: 4;
  readonly SYNC_STATUS_UNKNOWN?: 0;
  readonly SYNC_STATUS_NEW?: 1;
  readonly SYNC_STATUS_NORMAL?: 2;

  readonly tagsFolder: i64;
  readonly totalSyncChanges: i64;
  insertBookmark(aParentId: i64, aURI: nsIURI, aIndex: i32, aTitle: string, aGuid?: string, aSource?: u16): i64;
  removeItem(aItemId: i64, aSource?: u16): void;
  createFolder(aParentFolder: i64, name: string, index: i32, aGuid?: string, aSource?: u16): i64;
  setItemTitle(aItemId: i64, aTitle: string, aSource?: u16): void;
  getItemTitle(aItemId: i64): string;
  setItemLastModified(aItemId: i64, aLastModified: PRTime, aSource?: u16): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/places/nsINavHistoryService.idl

}  // global

declare enum nsINavHistoryResultNode_ResultType {
  RESULT_TYPE_URI = 0,
  RESULT_TYPE_QUERY = 5,
  RESULT_TYPE_FOLDER = 6,
  RESULT_TYPE_SEPARATOR = 7,
  RESULT_TYPE_FOLDER_SHORTCUT = 9,
}

declare global {

namespace nsINavHistoryResultNode {
  type ResultType = nsINavHistoryResultNode_ResultType;
}

interface nsINavHistoryResultNode extends nsISupports, Enums<typeof nsINavHistoryResultNode_ResultType> {
  readonly parent: nsINavHistoryContainerResultNode;
  readonly parentResult: nsINavHistoryResult;
  readonly uri: string;
  readonly type: u32;
  readonly title: string;
  readonly accessCount: u32;
  readonly time: PRTime;
  readonly icon: string;
  readonly indentLevel: i32;
  readonly bookmarkIndex: i32;
  readonly itemId: i64;
  readonly dateAdded: PRTime;
  readonly lastModified: PRTime;
  readonly tags: string;
  readonly pageGuid: string;
  readonly bookmarkGuid: string;
  readonly visitId: i64;
  readonly visitType: u32;
}

interface nsINavHistoryContainerResultNode extends nsINavHistoryResultNode {
  readonly STATE_CLOSED?: 0;
  readonly STATE_LOADING?: 1;
  readonly STATE_OPENED?: 2;

  containerOpen: boolean;
  readonly state: u16;
  readonly hasChildren: boolean;
  readonly childCount: u32;
  getChild(aIndex: u32): nsINavHistoryResultNode;
  getChildIndex(aNode: nsINavHistoryResultNode): u32;
}

interface nsINavHistoryQueryResultNode extends nsINavHistoryContainerResultNode {
  readonly query: nsINavHistoryQuery;
  readonly queryOptions: nsINavHistoryQueryOptions;
  readonly folderItemId: i64;
  readonly targetFolderGuid: string;
}

interface nsINavHistoryResultObserver extends nsISupports {
  readonly skipHistoryDetailsNotifications: boolean;
  nodeInserted(aParent: nsINavHistoryContainerResultNode, aNode: nsINavHistoryResultNode, aNewIndex: u32): void;
  nodeRemoved(aParent: nsINavHistoryContainerResultNode, aItem: nsINavHistoryResultNode, aOldIndex: u32): void;
  nodeMoved(aNode: nsINavHistoryResultNode, aOldParent: nsINavHistoryContainerResultNode, aOldIndex: u32, aNewParent: nsINavHistoryContainerResultNode, aNewIndex: u32): void;
  nodeTitleChanged(aNode: nsINavHistoryResultNode, aNewTitle: string): void;
  nodeURIChanged(aNode: nsINavHistoryResultNode, aOldURI: string): void;
  nodeIconChanged(aNode: nsINavHistoryResultNode): void;
  nodeHistoryDetailsChanged(aNode: nsINavHistoryResultNode, aOldVisitDate: PRTime, aOldAccessCount: u32): void;
  nodeTagsChanged(aNode: nsINavHistoryResultNode): void;
  nodeKeywordChanged(aNode: nsINavHistoryResultNode, aNewKeyword: string): void;
  nodeDateAddedChanged(aNode: nsINavHistoryResultNode, aNewValue: PRTime): void;
  nodeLastModifiedChanged(aNode: nsINavHistoryResultNode, aNewValue: PRTime): void;
  containerStateChanged(aContainerNode: nsINavHistoryContainerResultNode, aOldState: u32, aNewState: u32): void;
  invalidateContainer(aContainerNode: nsINavHistoryContainerResultNode): void;
  sortingChanged(sortingMode: u16): void;
  batching(aToggleMode: boolean): void;
  result: nsINavHistoryResult;
}

interface nsINavHistoryResult extends nsISupports {
  sortingMode: u16;
  suppressNotifications: boolean;
  addObserver(aObserver: nsINavHistoryResultObserver, aOwnsWeak?: boolean): void;
  removeObserver(aObserver: nsINavHistoryResultObserver): void;
  readonly root: nsINavHistoryContainerResultNode;
  onBeginUpdateBatch(): void;
  onEndUpdateBatch(): void;
}

interface nsINavHistoryQuery extends nsISupports {
  readonly TIME_RELATIVE_EPOCH?: 0;
  readonly TIME_RELATIVE_TODAY?: 1;
  readonly TIME_RELATIVE_NOW?: 2;

  beginTime: PRTime;
  beginTimeReference: u32;
  readonly hasBeginTime: boolean;
  readonly absoluteBeginTime: PRTime;
  endTime: PRTime;
  endTimeReference: u32;
  readonly hasEndTime: boolean;
  readonly absoluteEndTime: PRTime;
  searchTerms: string;
  readonly hasSearchTerms: boolean;
  minVisits: i32;
  maxVisits: i32;
  setTransitions(transitions: u32[]): void;
  getTransitions(): u32[];
  readonly transitionCount: u32;
  domainIsHost: boolean;
  domain: string;
  readonly hasDomain: boolean;
  uri: nsIURI;
  readonly hasUri: boolean;
  tags: nsIVariant;
  tagsAreNot: boolean;
  getParents(): string[];
  readonly parentCount: u32;
  setParents(aGuids: string[]): void;
  clone(): nsINavHistoryQuery;
}

interface nsINavHistoryQueryOptions extends nsISupports {
  readonly SORT_BY_NONE?: 0;
  readonly SORT_BY_TITLE_ASCENDING?: 1;
  readonly SORT_BY_TITLE_DESCENDING?: 2;
  readonly SORT_BY_DATE_ASCENDING?: 3;
  readonly SORT_BY_DATE_DESCENDING?: 4;
  readonly SORT_BY_URI_ASCENDING?: 5;
  readonly SORT_BY_URI_DESCENDING?: 6;
  readonly SORT_BY_VISITCOUNT_ASCENDING?: 7;
  readonly SORT_BY_VISITCOUNT_DESCENDING?: 8;
  readonly SORT_BY_DATEADDED_ASCENDING?: 11;
  readonly SORT_BY_DATEADDED_DESCENDING?: 12;
  readonly SORT_BY_LASTMODIFIED_ASCENDING?: 13;
  readonly SORT_BY_LASTMODIFIED_DESCENDING?: 14;
  readonly SORT_BY_TAGS_ASCENDING?: 17;
  readonly SORT_BY_TAGS_DESCENDING?: 18;
  readonly SORT_BY_FRECENCY_ASCENDING?: 21;
  readonly SORT_BY_FRECENCY_DESCENDING?: 22;
  readonly RESULTS_AS_URI?: 0;
  readonly RESULTS_AS_VISIT?: 1;
  readonly RESULTS_AS_DATE_QUERY?: 3;
  readonly RESULTS_AS_SITE_QUERY?: 4;
  readonly RESULTS_AS_DATE_SITE_QUERY?: 5;
  readonly RESULTS_AS_TAGS_ROOT?: 6;
  readonly RESULTS_AS_TAG_CONTENTS?: 7;
  readonly RESULTS_AS_ROOTS_QUERY?: 8;
  readonly RESULTS_AS_LEFT_PANE_QUERY?: 9;
  readonly QUERY_TYPE_HISTORY?: 0;
  readonly QUERY_TYPE_BOOKMARKS?: 1;

  sortingMode: u16;
  resultType: u16;
  excludeItems: boolean;
  excludeQueries: boolean;
  expandQueries: boolean;
  includeHidden: boolean;
  maxResults: u32;
  queryType: u16;
  asyncEnabled: boolean;
  clone(): nsINavHistoryQueryOptions;
}

}  // global

declare enum nsINavHistoryService_TransitionType {
  TRANSITION_LINK = 1,
  TRANSITION_TYPED = 2,
  TRANSITION_BOOKMARK = 3,
  TRANSITION_EMBED = 4,
  TRANSITION_REDIRECT_PERMANENT = 5,
  TRANSITION_REDIRECT_TEMPORARY = 6,
  TRANSITION_DOWNLOAD = 7,
  TRANSITION_FRAMED_LINK = 8,
  TRANSITION_RELOAD = 9,
}

declare global {

namespace nsINavHistoryService {
  type TransitionType = nsINavHistoryService_TransitionType;
}

interface nsINavHistoryService extends nsISupports, Enums<typeof nsINavHistoryService_TransitionType> {
  readonly DATABASE_SCHEMA_VERSION?: 80;
  readonly DATABASE_STATUS_OK?: 0;
  readonly DATABASE_STATUS_CREATE?: 1;
  readonly DATABASE_STATUS_CORRUPT?: 2;
  readonly DATABASE_STATUS_UPGRADED?: 3;
  readonly DATABASE_STATUS_LOCKED?: 4;
  readonly VISIT_SOURCE_ORGANIC?: 0;
  readonly VISIT_SOURCE_SPONSORED?: 1;
  readonly VISIT_SOURCE_BOOKMARKED?: 2;
  readonly VISIT_SOURCE_SEARCHED?: 3;

  readonly databaseStatus: u16;
  markPageAsFollowedBookmark(aURI: nsIURI): void;
  markPageAsTyped(aURI: nsIURI): void;
  markPageAsFollowedLink(aURI: nsIURI): void;
  canAddURI(aURI: nsIURI): boolean;
  getNewQuery(): nsINavHistoryQuery;
  getNewQueryOptions(): nsINavHistoryQueryOptions;
  executeQuery(aQuery: nsINavHistoryQuery, options: nsINavHistoryQueryOptions): nsINavHistoryResult;
  queryStringToQuery(aQueryString: string, aQuery: OutParam<nsINavHistoryQuery>, options: OutParam<nsINavHistoryQueryOptions>): void;
  queryToQueryString(aQuery: nsINavHistoryQuery, options: nsINavHistoryQueryOptions): string;
  readonly historyDisabled: boolean;
  makeGuid(): string;
  hashURL(aSpec: string, aMode?: string): u64;
  isFrecencyDecaying: boolean;
  readonly isAlternativeFrecencyEnabled: boolean;
  shouldStartFrecencyRecalculation: boolean;
  readonly DBConnection: mozIStorageConnection;
  asyncExecuteLegacyQuery(aQuery: nsINavHistoryQuery, aOptions: nsINavHistoryQueryOptions, aCallback: mozIStorageStatementCallback): mozIStoragePendingStatement;
  readonly shutdownClient: nsIAsyncShutdownClient;
  readonly connectionShutdownClient: nsIAsyncShutdownClient;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/places/nsIPlacesPreviewsHelperService.idl

interface nsIPlacesPreviewsHelperService extends nsISupports {
  getFilePathForURL(aURL: string): string;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/places/nsITaggingService.idl

interface nsITaggingService extends nsISupports {
  tagURI(aURI: nsIURI, aTags: nsIVariant, aSource?: u16): void;
  untagURI(aURI: nsIURI, aTags: nsIVariant, aSource?: u16): void;
  getTagsForURI(aURI: nsIURI): string[];
}

// https://searchfox.org/mozilla-central/source/modules/libpref/nsIPrefBranch.idl

interface nsIPrefBranch extends nsISupports {
  readonly PREF_INVALID?: 0;
  readonly PREF_STRING?: 32;
  readonly PREF_INT?: 64;
  readonly PREF_BOOL?: 128;

  readonly root: string;
  getPrefType(aPrefName: string): i32;
  getBoolPref(aPrefName: string, aDefaultValue?: boolean): boolean;
  setBoolPref(aPrefName: string, aValue: boolean): void;
  getFloatPref(aPrefName: string, aDefaultValue?: float): float;
  getCharPref(aPrefName: string, aDefaultValue?: string): string;
  setCharPref(aPrefName: string, aValue: string): void;
  getStringPref(aPrefName: string, aDefaultValue?: string): string;
  setStringPref(aPrefName: string, aValue: string): void;
  getIntPref(aPrefName: string, aDefaultValue?: i32): i32;
  setIntPref(aPrefName: string, aValue: i32): void;
  getComplexValue<T extends nsIID>(aPrefName: string, aType: T): nsQIResult<T>;
  setComplexValue(aPrefName: string, aType: nsID, aValue: nsISupports): void;
  clearUserPref(aPrefName: string): void;
  lockPref(aPrefName: string): void;
  prefHasUserValue(aPrefName: string): boolean;
  prefHasDefaultValue(aPrefName: string): boolean;
  prefIsLocked(aPrefName: string): boolean;
  prefIsSanitized(aPrefName: string): boolean;
  unlockPref(aPrefName: string): void;
  deleteBranch(aStartingAt: string): void;
  getChildList(aStartingAt: string): string[];
  addObserver(aDomain: string, aObserver: nsIObserver, aHoldWeak?: boolean): void;
  removeObserver(aDomain: string, aObserver: nsIObserver): void;
}

// https://searchfox.org/mozilla-central/source/modules/libpref/nsIPrefLocalizedString.idl

interface nsIPrefLocalizedString extends nsISupportsString {
}

// https://searchfox.org/mozilla-central/source/modules/libpref/nsIPrefService.idl

type nsIPrefStatsCallback = Callable<{
  visit(prefName: string, accessCount: u32): void;
}>

interface nsIPrefObserver extends nsISupports {
  onStringPref(kind: string, name: string, value: string, isSticky: boolean, isLocked: boolean): void;
  onIntPref(kind: string, name: string, value: i32, isSticky: boolean, isLocked: boolean): void;
  onBoolPref(kind: string, name: string, value: boolean, isSticky: boolean, isLocked: boolean): void;
  onError(message: string): void;
}

interface nsIPrefService extends nsISupports {
  resetPrefs(): void;
  savePrefFile(aFile: nsIFile): void;
  backupPrefFile(aFile: nsIFile): Promise<any>;
  getBranch(aPrefRoot: string): nsIPrefBranch;
  getDefaultBranch(aPrefRoot: string): nsIPrefBranch;
  readonly dirty: boolean;
  readDefaultPrefsFromFile(aFile: nsIFile): void;
  readUserPrefsFromFile(aFile: nsIFile): void;
  readStats(callback: nsIPrefStatsCallback): void;
  resetStats(): void;
  parsePrefsFromBuffer(bytes: u8[], observer: nsIPrefObserver, pathLabel?: string): void;
  readonly userPrefsFileLastModifiedAtStartup: PRTime;
}

// https://searchfox.org/mozilla-central/source/modules/libpref/nsIRelativeFilePref.idl

interface nsIRelativeFilePref extends nsISupports {
  file: nsIFile;
  relativeToKey: string;
}

// https://searchfox.org/mozilla-central/source/uriloader/prefetch/nsIPrefetchService.idl

interface nsIPrefetchService extends nsISupports {
  prefetchURI(aURI: nsIURI, aReferrerInfo: nsIReferrerInfo, aSource: Node, aExplicit: boolean): void;
  preloadURI(aURI: nsIURI, aReferrerInfo: nsIReferrerInfo, aSource: Node, aPolicyType: nsContentPolicyType): void;
  hasMoreElements(): boolean;
  cancelPrefetchPreloadURI(aURI: nsIURI, aSource: Node): void;
}

// https://searchfox.org/mozilla-central/source/dom/privateattribution/nsIPrivateAttributionService.idl

interface nsIPrivateAttributionService extends nsISupports {
  onAttributionEvent(sourceHost: string, type: string, index: u32, ad: string, targetHost: string): void;
  onAttributionConversion(targetHost: string, task: string, histogramSize: u32, lookbackDays: u32, impressionType: string, ads: string[], sourceHosts: string[]): void;
}

// https://searchfox.org/mozilla-central/source/tools/profiler/gecko/nsIProfiler.idl

interface nsIProfilerStartParams extends nsISupports {
  readonly entries: u32;
  readonly duration: double;
  readonly interval: double;
  readonly features: u32;
  readonly activeTabID: u64;
}

interface nsIProfiler extends nsISupports {
  StartProfiler(aEntries: u32, aInterval: double, aFeatures: string[], aFilters?: string[], aActiveTabID?: u64, aDuration?: double): Promise<any>;
  StopProfiler(): Promise<any>;
  IsPaused(): boolean;
  Pause(): Promise<any>;
  Resume(): Promise<any>;
  IsSamplingPaused(): boolean;
  PauseSampling(): Promise<any>;
  ResumeSampling(): Promise<any>;
  waitOnePeriodicSampling(): Promise<any>;
  GetProfile(aSinceTime?: double): string;
  getProfileData(aSinceTime?: double): any;
  getProfileDataAsync(aSinceTime?: double): Promise<any>;
  getProfileDataAsArrayBuffer(aSinceTime?: double): Promise<any>;
  getProfileDataAsGzippedArrayBuffer(aSinceTime?: double): Promise<any>;
  dumpProfileToFileAsync(aFilename: string, aSinceTime?: double): Promise<any>;
  dumpProfileToFile(aFilename: string): void;
  IsActive(): boolean;
  ClearAllPages(): void;
  GetFeatures(): string[];
  readonly activeConfiguration: any;
  GetAllFeatures(): string[];
  GetBufferInfo(aCurrentPosition: OutParam<u32>, aTotalSize: OutParam<u32>, aGeneration: OutParam<u32>): void;
  getElapsedTime(): double;
  readonly sharedLibraries: any;
  getSymbolTable(aDebugPath: string, aBreakpadID: string): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/dom/media/test/rdd_process_xpcom/nsIRddProcessTest.idl

interface nsIRddProcessTest extends nsISupports {
  testTelemetryProbes(): Promise<any>;
  stopProcess(): void;
}

// https://searchfox.org/mozilla-central/source/remote/components/nsIMarionette.idl

interface nsIMarionette extends nsISupports {
  readonly running: boolean;
}

// https://searchfox.org/mozilla-central/source/remote/components/nsIRemoteAgent.idl

interface nsIRemoteAgent extends nsISupports {
  readonly debuggerAddress: string;
  readonly running: boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/reputationservice/nsIApplicationReputation.idl

interface nsIApplicationReputationService extends nsISupports {
  readonly VERDICT_SAFE?: 0;
  readonly VERDICT_DANGEROUS?: 1;
  readonly VERDICT_UNCOMMON?: 2;
  readonly VERDICT_POTENTIALLY_UNWANTED?: 3;
  readonly VERDICT_DANGEROUS_HOST?: 4;

  queryReputation(aQuery: nsIApplicationReputationQuery, aCallback: nsIApplicationReputationCallback): void;
  isBinary(aFilename: string): boolean;
  isExecutable(aFilename: string): boolean;
}

interface nsIApplicationReputationQuery extends nsISupports {
  readonly sourceURI: nsIURI;
  readonly referrerInfo: nsIReferrerInfo;
  readonly suggestedFileName: string;
  readonly fileSize: u32;
  readonly sha256Hash: string;
  readonly signatureInfo: u8[][][];
  readonly redirects: nsIArray;
}

type nsIApplicationReputationCallback = Callable<{
  onComplete(aShouldBlock: boolean, aStatus: nsresult, aVerdict: u32): void;
}>

// https://searchfox.org/mozilla-central/source/security/sandbox/common/mozISandboxSettings.idl

interface mozISandboxSettings extends nsISupports {
  readonly effectiveContentSandboxLevel: i32;
  readonly contentWin32kLockdownState: i32;
  readonly contentWin32kLockdownStateString: string;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/satchel/nsIFormFillController.idl

interface nsIFormFillController extends nsISupports {
  readonly focusedElement: Element;
  readonly passwordPopupAutomaticallyOpened: boolean;
  markAsAutoCompletableField(aElement: Element): void;
  showPopup(): void;
}

type nsIFormFillCompleteObserver = Callable<{
  onSearchCompletion(result: nsIAutoCompleteResult): void;
}>

// https://searchfox.org/mozilla-central/source/services/interfaces/mozIAppServicesLogger.idl

interface mozIAppServicesLogger extends nsISupports {
  register(target: string, logger: mozIServicesLogSink): void;
}

// https://searchfox.org/mozilla-central/source/services/interfaces/mozIBridgedSyncEngine.idl

interface mozIBridgedSyncEngineCallback extends nsISupports {
  handleSuccess(result: nsIVariant): void;
  handleError(code: nsresult, message: string): void;
}

interface mozIBridgedSyncEngineApplyCallback extends nsISupports {
  handleSuccess(outgoingEnvelopesAsJSON: string[]): void;
  handleError(code: nsresult, message: string): void;
}

interface mozIBridgedSyncEngine extends nsISupports {
  readonly storageVersion: i32;
  readonly allowSkippedRecord: boolean;
  logger: mozIServicesLogSink;
  getLastSync(callback: mozIBridgedSyncEngineCallback): void;
  setLastSync(lastSyncMillis: i64, callback: mozIBridgedSyncEngineCallback): void;
  getSyncId(callback: mozIBridgedSyncEngineCallback): void;
  resetSyncId(callback: mozIBridgedSyncEngineCallback): void;
  ensureCurrentSyncId(newSyncId: string, callback: mozIBridgedSyncEngineCallback): void;
  syncStarted(callback: mozIBridgedSyncEngineCallback): void;
  storeIncoming(incomingEnvelopesAsJSON: string[], callback: mozIBridgedSyncEngineCallback): void;
  apply(callback: mozIBridgedSyncEngineApplyCallback): void;
  setUploaded(newTimestampMillis: i64, uploadedIds: string[], callback: mozIBridgedSyncEngineCallback): void;
  syncFinished(callback: mozIBridgedSyncEngineCallback): void;
  reset(callback: mozIBridgedSyncEngineCallback): void;
  wipe(callback: mozIBridgedSyncEngineCallback): void;
}

// https://searchfox.org/mozilla-central/source/services/interfaces/mozIInterruptible.idl

interface mozIInterruptible extends nsISupports {
  interrupt(): void;
}

// https://searchfox.org/mozilla-central/source/services/interfaces/mozIServicesLogSink.idl

interface mozIServicesLogSink extends nsISupports {
  readonly LEVEL_OFF?: 0;
  readonly LEVEL_ERROR?: 1;
  readonly LEVEL_WARN?: 2;
  readonly LEVEL_INFO?: 3;
  readonly LEVEL_DEBUG?: 4;
  readonly LEVEL_TRACE?: 5;

  maxLevel: i16;
  error(message: string): void;
  warn(message: string): void;
  debug(message: string): void;
  trace(message: string): void;
  info(message: string): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/sessionstore/nsISessionStoreFunctions.idl

interface nsISessionStoreFunctions extends nsISupports {
  UpdateSessionStore(aBrowser: Element, aBrowsingContext: BrowsingContext, aPermanentKey: any, aEpoch: u32, aCollectSHistory: boolean, aData: any): void;
  UpdateSessionStoreForStorage(aBrowser: Element, aBrowsingContext: BrowsingContext, aPermanentKey: any, aEpoch: u32, aData: any): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/sessionstore/nsISessionStoreRestoreData.idl

interface nsISessionStoreRestoreData extends nsISupports {
  url: string;
  innerHTML: string;
  scroll: string;
  addTextField(aIsXPath: boolean, aIdOrXPath: string, aValue: string): void;
  addCheckbox(aIsXPath: boolean, aIdOrXPath: string, aValue: boolean): void;
  addFileList(aIsXPath: boolean, aIdOrXPath: string, aType: string, aFileList: string[]): void;
  addSingleSelect(aIsXPath: boolean, aIdOrXPath: string, aSelectedIndex: u32, aValue: string): void;
  addMultipleSelect(aIsXPath: boolean, aIdOrXPath: string, aValues: string[]): void;
  addCustomElement(aIsXPath: boolean, aIdOrXPath: string, aValue: any, aState: any): void;
  addChild(aChild: nsISessionStoreRestoreData, aIndex: u32): void;
}

// https://searchfox.org/mozilla-central/source/browser/components/shell/nsIShellService.idl

interface nsIShellService extends nsISupports {
  readonly BACKGROUND_TILE?: 1;
  readonly BACKGROUND_STRETCH?: 2;
  readonly BACKGROUND_CENTER?: 3;
  readonly BACKGROUND_FILL?: 4;
  readonly BACKGROUND_FIT?: 5;
  readonly BACKGROUND_SPAN?: 6;

  isDefaultBrowser(aForAllTypes?: boolean): boolean;
  setDefaultBrowser(aForAllUsers: boolean): void;
  setDesktopBackground(aElement: Element, aPosition: i32, aImageName: string): void;
  desktopBackgroundColor: u32;
}

// https://searchfox.org/mozilla-central/source/docshell/shistory/nsIBFCacheEntry.idl

interface nsIBFCacheEntry extends nsISupports {
  RemoveFromBFCacheSync(): void;
  RemoveFromBFCacheAsync(): void;
}

// https://searchfox.org/mozilla-central/source/docshell/shistory/nsISHEntry.idl

interface nsISHEntry extends nsISupports {
  URI: nsIURI;
  originalURI: nsIURI;
  resultPrincipalURI: nsIURI;
  unstrippedURI: nsIURI;
  loadReplace: boolean;
  title: string;
  name: string;
  isSubFrame: boolean;
  hasUserInteraction: boolean;
  hasUserActivation: boolean;
  referrerInfo: nsIReferrerInfo;
  documentViewer: nsIDocumentViewer;
  readonly isInBFCache: boolean;
  sticky: boolean;
  windowState: nsISupports;
  refreshURIList: nsIMutableArray;
  postData: nsIInputStream;
  readonly hasPostData: boolean;
  layoutHistoryState: nsILayoutHistoryState;
  parent: nsISHEntry;
  loadType: u32;
  ID: u32;
  cacheKey: u32;
  saveLayoutStateFlag: boolean;
  contentType: string;
  URIWasModified: boolean;
  triggeringPrincipal: nsIPrincipal;
  principalToInherit: nsIPrincipal;
  partitionedPrincipalToInherit: nsIPrincipal;
  csp: nsIContentSecurityPolicy;
  stateData: nsIStructuredCloneContainer;
  docshellID: nsID;
  readonly isSrcdocEntry: boolean;
  srcdocData: string;
  baseURI: nsIURI;
  scrollRestorationIsManual: boolean;
  readonly loadedInThisProcess: boolean;
  readonly childCount: i32;
  persist: boolean;
  setScrollPosition(x: i32, y: i32): void;
  getScrollPosition(x: OutParam<i32>, y: OutParam<i32>): void;
  initLayoutHistoryState(): nsILayoutHistoryState;
  clone(): nsISHEntry;
  hasDynamicallyAddedChild(): boolean;
  adoptBFCacheEntry(aEntry: nsISHEntry): void;
  abandonBFCacheEntry(): void;
  sharesDocumentWith(aEntry: nsISHEntry): boolean;
  setLoadTypeAsHistory(): void;
  AddChild(aChild: nsISHEntry, aOffset: i32, aUseRemoteSubframes?: boolean): void;
  GetChildAt(aIndex: i32): nsISHEntry;
  readonly bfcacheID: u64;
  wireframe: any;
}

// https://searchfox.org/mozilla-central/source/docshell/shistory/nsISHistory.idl

interface nsISHistory extends nsISupports {
  readonly count: i32;
  index: i32;
  readonly requestedIndex: i32;
  getEntryAtIndex(aIndex: i32): nsISHEntry;
  purgeHistory(aNumEntries: i32): void;
  addSHistoryListener(aListener: nsISHistoryListener): void;
  removeSHistoryListener(aListener: nsISHistoryListener): void;
  reloadCurrentEntry(): void;
  addEntry(aEntry: nsISHEntry, aPersist: boolean): void;
  updateIndex(): void;
  replaceEntry(aIndex: i32, aReplaceEntry: nsISHEntry): void;
  notifyOnHistoryReload(): boolean;
  evictOutOfRangeDocumentViewers(aIndex: i32): void;
  evictAllDocumentViewers(): void;
  reload(aReloadFlags: u32): void;
  createEntry(): nsISHEntry;
  canGoBackFromEntryAtIndex(aIndex: i32): boolean;
}

// https://searchfox.org/mozilla-central/source/docshell/shistory/nsISHistoryListener.idl

interface nsISHistoryListener extends nsISupports {
  OnHistoryNewEntry(aNewURI: nsIURI, aOldIndex: i32): void;
  OnHistoryReload(): boolean;
  OnHistoryGotoIndex(): void;
  OnHistoryPurge(aNumEntries: i32): void;
  OnHistoryTruncate(aNumEntries: i32): void;
  OnHistoryReplaceEntry(): void;
  OnDocumentViewerEvicted(aNumEvicted: u32): void;
}

// https://searchfox.org/mozilla-central/source/extensions/spellcheck/idl/mozIPersonalDictionary.idl

interface mozIPersonalDictionary extends nsISupports {
  load(): void;
  save(): void;
  readonly wordList: nsIStringEnumerator;
  check(word: string): boolean;
  addWord(word: string): void;
  removeWord(word: string): void;
  ignoreWord(word: string): void;
  endSession(): void;
}

// https://searchfox.org/mozilla-central/source/extensions/spellcheck/idl/mozISpellCheckingEngine.idl

interface mozISpellCheckingEngine extends nsISupports {
  dictionaries: string[];
  personalDictionary: mozIPersonalDictionary;
  getDictionaryList(): string[];
  check(word: string): boolean;
  suggest(word: string): string[];
  loadDictionariesFromDir(dir: nsIFile): void;
  addDirectory(dir: nsIFile): void;
  removeDirectory(dir: nsIFile): void;
  addDictionary(lang: string, file: nsIURI): void;
  removeDictionary(lang: string, file: nsIURI): boolean;
}

// https://searchfox.org/mozilla-central/source/startupcache/nsIStartupCacheInfo.idl

interface nsIStartupCacheInfo extends nsISupports {
  readonly IgnoreDiskCache: boolean;
  readonly FoundDiskCacheOnInit: boolean;
  readonly WroteToDiskCache: boolean;
  readonly DiskCachePath: string;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageAsyncConnection.idl

interface mozIStorageAsyncConnection extends nsISupports {
  readonly TRANSACTION_DEFAULT?: -1;
  readonly TRANSACTION_DEFERRED?: 0;
  readonly TRANSACTION_IMMEDIATE?: 1;
  readonly TRANSACTION_EXCLUSIVE?: 2;

  defaultTransactionType: i32;
  variableLimit: i32;
  readonly transactionInProgress: boolean;
  asyncClose(aCallback?: mozIStorageCompletionCallback): void;
  asyncClone(aReadOnly: boolean, aCallback: mozIStorageCompletionCallback): void;
  readonly databaseFile: nsIFile;
  interrupt(): void;
  asyncVacuum(aCallback?: mozIStorageCompletionCallback, aUseIncremental?: boolean, aSetPageSize?: i32): void;
  createAsyncStatement(aSQLStatement: string): mozIStorageAsyncStatement;
  executeAsync(aStatements: mozIStorageBaseStatement[], aCallback?: mozIStorageStatementCallback): mozIStoragePendingStatement;
  executeSimpleSQLAsync(aSQLStatement: string, aCallback?: mozIStorageStatementCallback): mozIStoragePendingStatement;
  loadExtension(aExtensionName: string, aCallback?: mozIStorageCompletionCallback): void;
  createFunction(aFunctionName: string, aNumArguments: i32, aFunction: mozIStorageFunction): void;
  removeFunction(aFunctionName: string): void;
  setProgressHandler(aGranularity: i32, aHandler: mozIStorageProgressHandler): mozIStorageProgressHandler;
  removeProgressHandler(): mozIStorageProgressHandler;
  backupToFileAsync(aDestinationFile: nsIFile, aCallback: mozIStorageCompletionCallback, aPagesPerStep?: u32, aStepDelayMs?: u32): void;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageAsyncStatement.idl

interface mozIStorageAsyncStatement extends mozIStorageBaseStatement {
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageBaseStatement.idl

interface mozIStorageBaseStatement extends mozIStorageBindingParams {
  readonly MOZ_STORAGE_STATEMENT_INVALID?: 0;
  readonly MOZ_STORAGE_STATEMENT_READY?: 1;
  readonly MOZ_STORAGE_STATEMENT_EXECUTING?: 2;

  finalize(): void;
  bindParameters(aParameters: mozIStorageBindingParamsArray): void;
  newBindingParamsArray(): mozIStorageBindingParamsArray;
  executeAsync(aCallback?: mozIStorageStatementCallback): mozIStoragePendingStatement;
  readonly state: i32;
  escapeStringForLIKE(aValue: string, aEscapeChar: string): string;
  escapeUTF8StringForLIKE(aValue: string, aEscapeChar: string): string;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageBindingParams.idl

interface mozIStorageBindingParams extends nsISupports {
  bindByName(aName: string, aValue: nsIVariant): void;
  bindBlobByName(aName: string, aValue: u8[]): void;
  bindStringAsBlobByName(aName: string, aValue: string): void;
  bindUTF8StringAsBlobByName(aName: string, aValue: string): void;
  bindArrayOfIntegersByName(aName: string, aValue: i64[]): void;
  bindArrayOfDoublesByName(aName: string, aValue: double[]): void;
  bindArrayOfStringsByName(aName: string, aValue: string[]): void;
  bindArrayOfUTF8StringsByName(aName: string, aValue: string[]): void;
  bindByIndex(aIndex: u32, aValue: nsIVariant): void;
  bindBlobByIndex(aIndex: u32, aValue: u8[]): void;
  bindStringAsBlobByIndex(aIndex: u32, aValue: string): void;
  bindUTF8StringAsBlobByIndex(aIndex: u32, aValue: string): void;
  bindArrayOfIntegersByIndex(aIndex: u32, aValue: i64[]): void;
  bindArrayOfDoublesByIndex(aIndex: u32, aValue: double[]): void;
  bindArrayOfStringsByIndex(aIndex: u32, aValue: string[]): void;
  bindArrayOfUTF8StringsByIndex(aIndex: u32, aValue: string[]): void;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageBindingParamsArray.idl

interface mozIStorageBindingParamsArray extends nsISupports {
  newBindingParams(): mozIStorageBindingParams;
  addParams(aParameters: mozIStorageBindingParams): void;
  readonly length: u32;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageCompletionCallback.idl

type mozIStorageCompletionCallback = Callable<{
  complete(status: nsresult, value?: nsISupports): void;
}>

// https://searchfox.org/mozilla-central/source/storage/mozIStorageConnection.idl

interface mozIStorageConnection extends mozIStorageAsyncConnection {
  close(): void;
  clone(aReadOnly?: boolean): mozIStorageConnection;
  readonly defaultPageSize: i32;
  readonly connectionReady: boolean;
  readonly lastInsertRowID: i64;
  readonly affectedRows: i32;
  readonly lastError: i32;
  readonly lastErrorString: string;
  schemaVersion: i32;
  createStatement(aSQLStatement: string): mozIStorageStatement;
  executeSimpleSQL(aSQLStatement: string): void;
  tableExists(aTableName: string): boolean;
  indexExists(aIndexName: string): boolean;
  beginTransaction(): void;
  commitTransaction(): void;
  rollbackTransaction(): void;
  createTable(aTableName: string, aTableSchema: string): void;
  setGrowthIncrement(aIncrement: i32, aDatabaseName: string): void;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageError.idl

interface mozIStorageError extends nsISupports {
  readonly ERROR?: 1;
  readonly INTERNAL?: 2;
  readonly PERM?: 3;
  readonly ABORT?: 4;
  readonly BUSY?: 5;
  readonly LOCKED?: 6;
  readonly NOMEM?: 7;
  readonly READONLY?: 8;
  readonly INTERRUPT?: 9;
  readonly IOERR?: 10;
  readonly CORRUPT?: 11;
  readonly FULL?: 13;
  readonly CANTOPEN?: 14;
  readonly EMPTY?: 16;
  readonly SCHEMA?: 17;
  readonly TOOBIG?: 18;
  readonly CONSTRAINT?: 19;
  readonly MISMATCH?: 20;
  readonly MISUSE?: 21;
  readonly NOLFS?: 22;
  readonly AUTH?: 23;
  readonly FORMAT?: 24;
  readonly RANGE?: 25;
  readonly NOTADB?: 26;

  readonly result: i32;
  readonly message: string;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageFunction.idl

type mozIStorageFunction = Callable<{
  onFunctionCall(aFunctionArguments: mozIStorageValueArray): nsIVariant;
}>

// https://searchfox.org/mozilla-central/source/storage/mozIStoragePendingStatement.idl

interface mozIStoragePendingStatement extends nsISupports {
  cancel(): void;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageProgressHandler.idl

interface mozIStorageProgressHandler extends nsISupports {
  onProgress(aConnection: mozIStorageConnection): boolean;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageResultSet.idl

interface mozIStorageResultSet extends nsISupports {
  getNextRow(): mozIStorageRow;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageRow.idl

interface mozIStorageRow extends mozIStorageValueArray {
  getResultByIndex(aIndex: u32): nsIVariant;
  getResultByName(aName: string): nsIVariant;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageService.idl

interface mozIStorageService extends nsISupports {
  readonly OPEN_DEFAULT?: 0;
  readonly OPEN_SHARED?: 1;
  readonly OPEN_READONLY?: 2;
  readonly OPEN_IGNORE_LOCKING_MODE?: 4;
  readonly OPEN_NOT_EXCLUSIVE?: 8;
  readonly CONNECTION_DEFAULT?: 0;
  readonly CONNECTION_INTERRUPTIBLE?: 1;

  openAsyncDatabase(aDatabaseStore: nsIVariant, aOpenFlags: u32, aConnectionFlags: u32, aCallback: mozIStorageCompletionCallback): void;
  openSpecialDatabase(aStorageKey: string, aName?: string, aConnectionFlags?: u32): mozIStorageConnection;
  openDatabase(aDatabaseFile: nsIFile, aConnectionFlags?: u32): mozIStorageConnection;
  openUnsharedDatabase(aDatabaseFile: nsIFile, aConnectionFlags?: u32): mozIStorageConnection;
  openDatabaseWithFileURL(aFileURL: nsIFileURL, aTelemetryFilename?: string, aConnectionFlags?: u32): mozIStorageConnection;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageStatement.idl

interface mozIStorageStatement extends mozIStorageBaseStatement {
  readonly VALUE_TYPE_NULL?: 0;
  readonly VALUE_TYPE_INTEGER?: 1;
  readonly VALUE_TYPE_FLOAT?: 2;
  readonly VALUE_TYPE_TEXT?: 3;
  readonly VALUE_TYPE_BLOB?: 4;

  clone(): mozIStorageStatement;
  readonly parameterCount: u32;
  getParameterName(aParamIndex: u32): string;
  getParameterIndex(aName: string): u32;
  readonly columnCount: u32;
  getColumnName(aColumnIndex: u32): string;
  getColumnIndex(aName: string): u32;
  reset(): void;
  execute(): void;
  executeStep(): boolean;
  readonly numEntries: u32;
  getTypeOfIndex(aIndex: u32): i32;
  getVariant(aIndex: u32): nsIVariant;
  getInt32(aIndex: u32): i32;
  getInt64(aIndex: u32): i64;
  getDouble(aIndex: u32): double;
  getUTF8String(aIndex: u32): string;
  getString(aIndex: u32): string;
  getBlob(aIndex: u32, aDataSize: OutParam<u32>, aData: OutParam<u8[]>): void;
  getBlobAsString(aIndex: u32): string;
  getBlobAsUTF8String(aIndex: u32): string;
  getIsNull(aIndex: u32): boolean;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageStatementCallback.idl

interface mozIStorageStatementCallback extends nsISupports {
  readonly REASON_FINISHED?: 0;
  readonly REASON_CANCELED?: 1;
  readonly REASON_ERROR?: 2;

  handleResult(aResultSet: mozIStorageResultSet): void;
  handleError(aError: mozIStorageError): void;
  handleCompletion(aReason: u16): void;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageVacuumParticipant.idl

interface mozIStorageVacuumParticipant extends nsISupports {
  readonly expectedDatabasePageSize: i32;
  readonly useIncrementalVacuum: boolean;
  readonly databaseConnection: mozIStorageAsyncConnection;
  onBeginVacuum(): boolean;
  onEndVacuum(aSucceeded: boolean): void;
}

// https://searchfox.org/mozilla-central/source/storage/mozIStorageValueArray.idl

interface mozIStorageValueArray extends nsISupports {
  readonly VALUE_TYPE_NULL?: 0;
  readonly VALUE_TYPE_INTEGER?: 1;
  readonly VALUE_TYPE_FLOAT?: 2;
  readonly VALUE_TYPE_TEXT?: 3;
  readonly VALUE_TYPE_BLOB?: 4;

  readonly numEntries: u32;
  getTypeOfIndex(aIndex: u32): i32;
  getInt32(aIndex: u32): i32;
  getInt64(aIndex: u32): i64;
  getDouble(aIndex: u32): double;
  getUTF8String(aIndex: u32): string;
  getString(aIndex: u32): string;
  getBlob(aIndex: u32, aDataSize: OutParam<u32>, aData: OutParam<u8[]>): void;
  getBlobAsString(aIndex: u32): string;
  getBlobAsUTF8String(aIndex: u32): string;
  getIsNull(aIndex: u32): boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/telemetry/core/nsITelemetry.idl

type nsIFetchTelemetryDataCallback = Callable<{
  complete(): void;
}>

interface nsITelemetry extends nsISupports {
  readonly HISTOGRAM_EXPONENTIAL?: 0;
  readonly HISTOGRAM_LINEAR?: 1;
  readonly HISTOGRAM_BOOLEAN?: 2;
  readonly HISTOGRAM_FLAG?: 3;
  readonly HISTOGRAM_COUNT?: 4;
  readonly HISTOGRAM_CATEGORICAL?: 5;
  readonly SCALAR_TYPE_COUNT?: 0;
  readonly SCALAR_TYPE_STRING?: 1;
  readonly SCALAR_TYPE_BOOLEAN?: 2;
  readonly DATASET_ALL_CHANNELS?: 0;
  readonly DATASET_PRERELEASE_CHANNELS?: 1;
  readonly INCLUDE_OLD_LOADEVENTS?: 1;
  readonly KEEP_LOADEVENTS_NEW?: 2;
  readonly INCLUDE_PRIVATE_FIELDS_IN_LOADEVENTS?: 4;
  readonly EXCLUDE_STACKINFO_FROM_LOADEVENTS?: 8;

  getCategoricalLabels(): any;
  getSnapshotForHistograms(aStoreName?: string, aClearStore?: boolean, aFilterTest?: boolean): any;
  getSnapshotForKeyedHistograms(aStoreName?: string, aClearStore?: boolean, aFilterTest?: boolean): any;
  getSnapshotForScalars(aStoreName?: string, aClearStore?: boolean, aFilterTest?: boolean): any;
  getSnapshotForKeyedScalars(aStoreName?: string, aClearStore?: boolean, aFilterTest?: boolean): any;
  readonly lastShutdownDuration: u32;
  readonly failedProfileLockCount: u32;
  readonly slowSQL: any;
  readonly debugSlowSQL: any;
  getUntrustedModuleLoadEvents(aFlags?: u32): Promise<any>;
  readonly areUntrustedModuleLoadEventsReady: boolean;
  readonly lateWrites: any;
  getHistogramById(id: string): any;
  getKeyedHistogramById(id: string): any;
  canRecordBase: boolean;
  canRecordExtended: boolean;
  readonly canRecordReleaseData: boolean;
  readonly canRecordPrereleaseData: boolean;
  readonly isOfficialTelemetry: boolean;
  asyncFetchTelemetryData(aCallback: nsIFetchTelemetryDataCallback): void;
  readonly fileIOReports: any;
  msSinceProcessStart(): double;
  msSinceProcessStartIncludingSuspend(): double;
  msSinceProcessStartExcludingSuspend(): double;
  msSystemNow(): double;
  clearScalars(): void;
  flushBatchedChildTelemetry(): void;
  snapshotEvents(aDataset: u32, aClear?: boolean, aEventLimit?: u32): any;
  registerBuiltinEvents(aCategory: string, aEventData: any): void;
  registerBuiltinScalars(aCategoryName: string, aScalarData: any): void;
  clearEvents(): void;
  getAllStores(): any;
  earlyInit(): void;
  delayedInit(): void;
  shutdown(): void;
  gatherMemory(): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/telemetry/dap/nsIDAPTelemetry.idl

interface nsIDAPTelemetry extends nsISupports {
  GetReportPrioSum(leaderHpkeConfig: u8[], helperHpkeConfig: u8[], measurement: u32, task_id: u8[], bits: u32, time_precision: u64, report: OutParam<u8[]>): void;
  GetReportPrioSumVec(leaderHpkeConfig: u8[], helperHpkeConfig: u8[], measurement: u32[], task_id: u8[], bits: u32, time_precision: u64, report: OutParam<u8[]>): void;
  GetReportPrioHistogram(leaderHpkeConfig: u8[], helperHpkeConfig: u8[], measurement: u32, task_id: u8[], length: u32, time_precision: u64, report: OutParam<u8[]>): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/test/httpserver/nsIHttpServer.idl

interface nsIHttpServer extends nsISupports {
  start(port: i32): void;
  start_ipv6(port: i32): void;
  start_dualStack(port: i32): void;
  stop(callback: nsIHttpServerStoppedCallback): void;
  registerFile(path: string, file: nsIFile, handler?: nsIHttpRequestHandler): void;
  registerPathHandler(path: string, handler: nsIHttpRequestHandler): void;
  registerPrefixHandler(prefix: string, handler: nsIHttpRequestHandler): void;
  registerErrorHandler(code: u32, handler: nsIHttpRequestHandler): void;
  registerDirectory(path: string, dir: nsIFile): void;
  registerContentType(extension: string, type: string): void;
  setIndexHandler(handler: nsIHttpRequestHandler): void;
  readonly identity: nsIHttpServerIdentity;
  getState(path: string, key: string): string;
  setState(path: string, key: string, value: string): void;
  getSharedState(key: string): string;
  setSharedState(key: string, value: string): void;
  getObjectState(key: string): nsISupports;
  setObjectState(key: string, value: nsISupports): void;
}

type nsIHttpServerStoppedCallback = Callable<{
  onStopped(): void;
}>

interface nsIHttpServerIdentity extends nsISupports {
  readonly primaryScheme: string;
  readonly primaryHost: string;
  readonly primaryPort: i32;
  add(scheme: string, host: string, port: i32): void;
  remove(scheme: string, host: string, port: i32): boolean;
  has(scheme: string, host: string, port: i32): boolean;
  getScheme(host: string, port: i32): string;
  setPrimary(scheme: string, host: string, port: i32): void;
}

type nsIHttpRequestHandler = Callable<{
  handle(request: nsIHttpRequest, response: nsIHttpResponse): void;
}>

interface nsIHttpRequest extends nsISupports {
  readonly method: string;
  readonly scheme: string;
  readonly host: string;
  readonly port: u32;
  readonly path: string;
  readonly queryString: string;
  readonly httpVersion: string;
  getHeader(fieldName: string): string;
  hasHeader(fieldName: string): boolean;
  readonly headers: nsISimpleEnumerator;
  readonly bodyInputStream: nsIInputStream;
}

interface nsIHttpResponse extends nsISupports {
  setStatusLine(httpVersion: string, statusCode: u16, description: string): void;
  setHeader(name: string, value: string, merge?: boolean): void;
  setHeaderNoCheck(name: string, value: string): void;
  readonly bodyOutputStream: nsIOutputStream;
  write(data: string): void;
  processAsync(): void;
  seizePower(): void;
  finish(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/thumbnails/nsIPageThumbsStorageService.idl

interface nsIPageThumbsStorageService extends nsISupports {
  getLeafNameForURL(aURL: string): string;
  readonly path: string;
  getFilePathForURL(aURL: string): string;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/antitracking/bouncetrackingprotection/nsIBTPRemoteExceptionList.idl

interface nsIBTPRemoteExceptionList extends nsISupports {
  init(aProtection: nsIBounceTrackingProtection): Promise<any>;
  shutdown(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/antitracking/bouncetrackingprotection/nsIBounceTrackingMapEntry.idl

interface nsIBounceTrackingMapEntry extends nsISupports {
  readonly siteHost: string;
  readonly timeStamp: PRTime;
}

interface nsIBounceTrackingPurgeEntry extends nsIBounceTrackingMapEntry {
  readonly purgeTime: PRTime;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/antitracking/bouncetrackingprotection/nsIBounceTrackingProtection.idl

}  // global

declare enum nsIBounceTrackingProtection_Modes {
  MODE_DISABLED = 0,
  MODE_ENABLED = 1,
  MODE_ENABLED_STANDBY = 2,
  MODE_ENABLED_DRY_RUN = 3,
  MAX_MODE_VALUE = 3,
}

declare global {

namespace nsIBounceTrackingProtection {
  type Modes = nsIBounceTrackingProtection_Modes;
}

interface nsIBounceTrackingProtection extends nsISupports, Enums<typeof nsIBounceTrackingProtection_Modes> {
  clearAll(): void;
  clearBySiteHostAndOriginAttributes(aSiteHost: string, originAttributes: any): void;
  clearBySiteHostAndOriginAttributesPattern(aSiteHost: string, aOriginAttributesPattern: any): void;
  clearByTimeRange(aFrom: PRTime, aTo: PRTime): void;
  clearByOriginAttributesPattern(aPattern: string): void;
  addSiteHostExceptions(aSiteHosts: string[]): void;
  removeSiteHostExceptions(aSiteHosts: string[]): void;
  hasRecentlyPurgedSite(aSiteHost: string): boolean;
  testGetSiteHostExceptions(): string[];
  testRunPurgeBounceTrackers(): Promise<any>;
  testClearExpiredUserActivations(): void;
  testGetBounceTrackerCandidateHosts(originAttributes: any): nsIBounceTrackingMapEntry[];
  testGetUserActivationHosts(originAttributes: any): nsIBounceTrackingMapEntry[];
  testAddBounceTrackerCandidate(originAttributes: any, aSiteHost: string, aBounceTime: PRTime): void;
  testAddUserActivation(originAttributes: any, aSiteHost: string, aActivationTime: PRTime): void;
  testGetRecentlyPurgedTrackers(originAttributes: any): nsIBounceTrackingPurgeEntry[];
  testMaybeMigrateUserInteractionPermissions(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/antitracking/nsIContentBlockingAllowList.idl

interface nsIContentBlockingAllowList extends nsISupports {
  computeContentBlockingAllowListPrincipal(aPrincipal: nsIPrincipal): nsIPrincipal;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/antitracking/nsIPartitioningExceptionListService.idl

type nsIPartitioningExceptionListObserver = Callable<{
  onExceptionListUpdate(aList: string): void;
}>

interface nsIPartitioningExceptionListService extends nsISupports {
  registerAndRunExceptionListObserver(aObserver: nsIPartitioningExceptionListObserver): void;
  unregisterExceptionListObserver(aObserver: nsIPartitioningExceptionListObserver): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/antitracking/nsIPurgeTrackerService.idl

interface nsIPurgeTrackerService extends nsISupports {
  purgeTrackingCookieJars(): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/antitracking/nsITrackingDBService.idl

interface nsITrackingDBService extends nsISupports {
  readonly OTHER_COOKIES_BLOCKED_ID?: 0;
  readonly TRACKERS_ID?: 1;
  readonly TRACKING_COOKIES_ID?: 2;
  readonly CRYPTOMINERS_ID?: 3;
  readonly FINGERPRINTERS_ID?: 4;
  readonly SOCIAL_ID?: 5;
  readonly SUSPICIOUS_FINGERPRINTERS_ID?: 6;
  readonly BOUNCETRACKERS_ID?: 7;

  recordContentBlockingLog(data: string): void;
  saveEvents(data: string): Promise<any>;
  clearAll(): Promise<any>;
  clearSince(since: i64): Promise<any>;
  getEventsByDateRange(dateFrom: i64, dateTo: i64): Promise<any>;
  sumAllEvents(): Promise<any>;
  getEarliestRecordedDate(): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/antitracking/nsIURLDecorationAnnotationsService.idl

interface nsIURLDecorationAnnotationsService extends nsISupports {
  ensureUpdated(): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/antitracking/nsIURLQueryStringStripper.idl

interface nsIURLQueryStringStripper extends nsISupports {
  strip(aURI: nsIURI, aIsPBM: boolean, aOutput: OutParam<nsIURI>): u32;
  stripForCopyOrShare(aURI: nsIURI): nsIURI;
  canStripForShare(aURI: nsIURI): boolean;
  testGetStripList(): string;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/antitracking/nsIURLQueryStrippingListService.idl

interface nsIURLQueryStrippingListObserver extends nsISupports {
  onQueryStrippingListUpdate(aStripList: string, aAllowList: string): void;
  onStripOnShareUpdate(aStripRules: string[]): void;
}

interface nsIURLQueryStrippingListService extends nsISupports {
  registerAndRunObserver(aObserver: nsIURLQueryStrippingListObserver): void;
  registerAndRunObserverStripOnShare(aObserver: nsIURLQueryStrippingListObserver): void;
  unregisterObserver(aObserver: nsIURLQueryStrippingListObserver): void;
  unregisterStripOnShareObserver(aObserver: nsIURLQueryStrippingListObserver): void;
  clearLists(): void;
  testWaitForInit(): Promise<any>;
  testSetList(testFile: any): Promise<any>;
  testHasStripOnShareObservers(): boolean;
  testHasQPSObservers(): boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/asyncshutdown/nsIAsyncShutdown.idl

interface nsIAsyncShutdownBlocker extends nsISupports {
  readonly name: string;
  blockShutdown(aBarrierClient: nsIAsyncShutdownClient): void;
  readonly state: nsIPropertyBag;
}

interface nsIAsyncShutdownClient extends nsISupports {
  readonly name: string;
  readonly isClosed: boolean;
  addBlocker(aBlocker: nsIAsyncShutdownBlocker, aFileName: string, aLineNumber: i32, aStack: string): void;
  removeBlocker(aBlocker: nsIAsyncShutdownBlocker): void;
  readonly jsclient: any;
}

type nsIAsyncShutdownCompletionCallback = Callable<{
  done(): void;
}>

interface nsIAsyncShutdownBarrier extends nsISupports {
  readonly client: nsIAsyncShutdownClient;
  readonly state: nsIPropertyBag;
  wait(aOnReady: nsIAsyncShutdownCompletionCallback): void;
}

interface nsIAsyncShutdownService extends nsISupports {
  makeBarrier(aName: string): nsIAsyncShutdownBarrier;
  readonly profileBeforeChange: nsIAsyncShutdownClient;
  readonly profileChangeTeardown: nsIAsyncShutdownClient;
  readonly appShutdownConfirmed: nsIAsyncShutdownClient;
  readonly quitApplicationGranted: nsIAsyncShutdownClient;
  readonly sendTelemetry: nsIAsyncShutdownClient;
  readonly webWorkersShutdown: nsIAsyncShutdownClient;
  readonly xpcomWillShutdown: nsIAsyncShutdownClient;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/backgroundtasks/nsIBackgroundTasks.idl

interface nsIBackgroundTasks extends nsISupports {
  readonly isBackgroundTaskMode: boolean;
  backgroundTaskName(): string;
  overrideBackgroundTaskNameForTesting(taskName: string): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/backgroundtasks/nsIBackgroundTasksManager.idl

interface nsIBackgroundTasksManager extends nsICommandLineHandler {
  runBackgroundTaskNamed(aTaskName: string, aCommandLine: nsICommandLine): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/backgroundtasks/nsIBackgroundTasksRunner.idl

interface nsIBackgroundTasksRunner extends nsISupports {
  runInDetachedProcess(aTaskName: string, aCommandLine: string[]): void;
  removeDirectoryInDetachedProcess(aParentDirPath: string, aChildDirName: string, aSecondsToWait: string, aOtherFoldersSuffix: string, aMetricsId?: string): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/cleardata/nsIClearBySiteEntry.idl

interface nsIClearBySiteEntry extends nsISupports {
  schemelessSite: string;
  patternJSON: string;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/cleardata/nsIClearDataService.idl

interface nsIClearDataService extends nsISupports {
  readonly CLEAR_COOKIES?: 1;
  readonly CLEAR_NETWORK_CACHE?: 2;
  readonly CLEAR_IMAGE_CACHE?: 4;
  readonly CLEAR_JS_CACHE?: 8;
  readonly CLEAR_DOWNLOADS?: 16;
  readonly CLEAR_MEDIA_DEVICES?: 64;
  readonly CLEAR_DOM_QUOTA?: 128;
  readonly CLEAR_PREDICTOR_NETWORK_DATA?: 256;
  readonly CLEAR_DOM_PUSH_NOTIFICATIONS?: 512;
  readonly CLEAR_HISTORY?: 1024;
  readonly CLEAR_MESSAGING_LAYER_SECURITY_STATE?: 2048;
  readonly CLEAR_AUTH_TOKENS?: 4096;
  readonly CLEAR_AUTH_CACHE?: 8192;
  readonly CLEAR_SITE_PERMISSIONS?: 16384;
  readonly CLEAR_CONTENT_PREFERENCES?: 32768;
  readonly CLEAR_HSTS?: 65536;
  readonly CLEAR_EME?: 131072;
  readonly CLEAR_REPORTS?: 262144;
  readonly CLEAR_STORAGE_ACCESS?: 524288;
  readonly CLEAR_CERT_EXCEPTIONS?: 1048576;
  readonly CLEAR_CONTENT_BLOCKING_RECORDS?: 2097152;
  readonly CLEAR_CSS_CACHE?: 4194304;
  readonly CLEAR_PREFLIGHT_CACHE?: 8388608;
  readonly CLEAR_CLIENT_AUTH_REMEMBER_SERVICE?: 16777216;
  readonly CLEAR_CREDENTIAL_MANAGER_STATE?: 33554432;
  readonly CLEAR_COOKIE_BANNER_EXCEPTION?: 67108864;
  readonly CLEAR_COOKIE_BANNER_EXECUTED_RECORD?: 134217728;
  readonly CLEAR_FINGERPRINTING_PROTECTION_STATE?: 268435456;
  readonly CLEAR_BOUNCE_TRACKING_PROTECTION_STATE?: 536870912;
  readonly CLEAR_STORAGE_PERMISSIONS?: 1073741824;
  readonly CLEAR_SHUTDOWN_EXCEPTIONS?: 2147483648;
  readonly CLEAR_ALL?: 4294967295;
  readonly CLEAR_PERMISSIONS?: 2147500032;
  readonly CLEAR_ALL_CACHES?: 12648462;
  readonly CLEAR_DOM_STORAGES?: 262784;
  readonly CLEAR_FORGET_ABOUT_SITE?: 3218591647;
  readonly CLEAR_COOKIES_AND_SITE_DATA?: 2013739649;
  readonly CLEAR_STATE_FOR_TRACKER_PURGING?: 2043624143;

  deleteDataFromLocalFiles(aIsUserRequest: boolean, aFlags: u32, aCallback: nsIClearDataCallback): void;
  deleteDataFromHost(aHost: string, aIsUserRequest: boolean, aFlags: u32, aCallback: nsIClearDataCallback): void;
  deleteDataFromSite(aSchemelessSite: string, aOriginAttributesPattern: any, aIsUserRequest: boolean, aFlags: u32, aCallback: nsIClearDataCallback): void;
  deleteDataFromSiteAndOriginAttributesPatternString(aSchemelessSite: string, aOriginAttributesPatternString: string, aIsUserRequest: boolean, aFlags: u32, aCallback: nsIClearDataCallback): void;
  deleteDataFromPrincipal(aPrincipal: nsIPrincipal, aIsUserRequest: boolean, aFlags: u32, aCallback: nsIClearDataCallback): void;
  deleteDataInTimeRange(aFrom: PRTime, aTo: PRTime, aIsUserRequest: boolean, aFlags: u32, aCallback: nsIClearDataCallback): void;
  deleteData(aFlags: u32, aCallback: nsIClearDataCallback): void;
  deleteDataFromOriginAttributesPattern(aOriginAttributesPattern: any, aCallback?: nsIClearDataCallback): void;
  deleteUserInteractionForClearingHistory(aPrincipalsWithStorage: nsIPrincipal[], aFrom?: PRTime, aCallback?: nsIClearDataCallback): void;
  cleanupAfterDeletionAtShutdown(aFlags: u32, aCallback: nsIClearDataCallback): void;
  hostMatchesSite(aHost: string, aOriginAttributes: any, aSchemelessSite: string, aOriginAttributesPattern?: any): boolean;
}

type nsIClearDataCallback = Callable<{
  onDataDeleted(aFailedFlags: u32): void;
}>

// https://searchfox.org/mozilla-central/source/toolkit/components/contentanalysis/nsIContentAnalysis.idl

}  // global

declare enum nsIContentAnalysisAcknowledgement_Result {
  eSuccess = 1,
  eInvalidResponse = 2,
  eTooLate = 3,
}

declare enum nsIContentAnalysisAcknowledgement_FinalAction {
  eUnspecified = 0,
  eAllow = 1,
  eReportOnly = 2,
  eWarn = 3,
  eBlock = 4,
}

declare global {

namespace nsIContentAnalysisAcknowledgement {
  type Result = nsIContentAnalysisAcknowledgement_Result;
  type FinalAction = nsIContentAnalysisAcknowledgement_FinalAction;
}

interface nsIContentAnalysisAcknowledgement extends nsISupports, Enums<typeof nsIContentAnalysisAcknowledgement_Result & typeof nsIContentAnalysisAcknowledgement_FinalAction> {
  readonly result: nsIContentAnalysisAcknowledgement.Result;
  readonly finalAction: nsIContentAnalysisAcknowledgement.FinalAction;
}

interface nsIContentAnalysisResult extends nsISupports {
  readonly shouldAllowContent: boolean;
}

}  // global

declare enum nsIContentAnalysisResponse_Action {
  eUnspecified = 0,
  eReportOnly = 1,
  eWarn = 2,
  eBlock = 3,
  eAllow = 1000,
  eCanceled = 1001,
}

declare enum nsIContentAnalysisResponse_CancelError {
  eUserInitiated = 0,
  eNoAgent = 1,
  eInvalidAgentSignature = 2,
  eErrorOther = 3,
  eOtherRequestInGroupCancelled = 4,
  eShutdown = 5,
  eTimeout = 6,
}

declare global {

namespace nsIContentAnalysisResponse {
  type Action = nsIContentAnalysisResponse_Action;
  type CancelError = nsIContentAnalysisResponse_CancelError;
}

interface nsIContentAnalysisResponse extends nsIContentAnalysisResult, Enums<typeof nsIContentAnalysisResponse_Action & typeof nsIContentAnalysisResponse_CancelError> {
  readonly action: nsIContentAnalysisResponse.Action;
  readonly cancelError: nsIContentAnalysisResponse.CancelError;
  readonly requestToken: string;
  readonly userActionId: string;
  readonly isCachedResponse: boolean;
  readonly isSyntheticResponse: boolean;
  acknowledge(aCaa: nsIContentAnalysisAcknowledgement): void;
}

interface nsIClientDownloadResource extends nsISupports {
  readonly DOWNLOAD_URL?: 0;
  readonly DOWNLOAD_REDIRECT?: 1;
  readonly TAB_URL?: 2;
  readonly TAB_REDIRECT?: 3;
  readonly PPAPI_DOCUMENT?: 4;
  readonly PPAPI_PLUGIN?: 5;

  readonly url: string;
  readonly type: u32;
}

}  // global

declare enum nsIContentAnalysisRequest_AnalysisType {
  eUnspecified = 0,
  eFileDownloaded = 1,
  eFileAttached = 2,
  eBulkDataEntry = 3,
  ePrint = 4,
  eFileTransfer = 5,
}

declare enum nsIContentAnalysisRequest_Reason {
  eUnknown = 0,
  eClipboardPaste = 1,
  eDragAndDrop = 2,
  eFilePickerDialog = 3,
  ePrintPreviewPrint = 4,
  eSystemDialogPrint = 5,
  eNormalDownload = 6,
  eSaveAsDownload = 7,
}

declare enum nsIContentAnalysisRequest_OperationType {
  eCustomDisplayString = 0,
  eClipboard = 1,
  eDroppedText = 2,
  eOperationPrint = 3,
}

declare global {

namespace nsIContentAnalysisRequest {
  type AnalysisType = nsIContentAnalysisRequest_AnalysisType;
  type Reason = nsIContentAnalysisRequest_Reason;
  type OperationType = nsIContentAnalysisRequest_OperationType;
}

interface nsIContentAnalysisRequest extends nsISupports, Enums<typeof nsIContentAnalysisRequest_AnalysisType & typeof nsIContentAnalysisRequest_Reason & typeof nsIContentAnalysisRequest_OperationType> {
  readonly analysisType: nsIContentAnalysisRequest.AnalysisType;
  readonly reason: nsIContentAnalysisRequest.Reason;
  readonly operationTypeForDisplay: nsIContentAnalysisRequest.OperationType;
  readonly operationDisplayString: string;
  dataTransfer: DataTransfer;
  readonly transferable: nsITransferable;
  readonly textContent: string;
  readonly filePath: string;
  readonly printDataHandle: u64;
  readonly printDataSize: u64;
  readonly printerName: string;
  readonly url: nsIURI;
  readonly sha256Digest: string;
  readonly resources: nsIClientDownloadResource[];
  readonly email: string;
  requestToken: string;
  readonly windowGlobalParent: WindowGlobalParent;
  userActionId: string;
  userActionRequestsCount: i64;
  readonly sourceWindowGlobal: WindowGlobalParent;
  timeoutMultiplier: u32;
  testOnlyIgnoreCanceledAndAlwaysSubmitToAgent: boolean;
}

interface nsIContentAnalysisCallback extends nsISupports {
  contentResult(aResult: nsIContentAnalysisResult): void;
  error(aResult: nsresult): void;
}

interface nsIContentAnalysisDiagnosticInfo extends nsISupports {
  readonly connectedToAgent: boolean;
  readonly agentPath: string;
  readonly failedSignatureVerification: boolean;
  readonly requestCount: i64;
}

interface nsIContentAnalysis extends nsISupports {
  readonly isActive: boolean;
  readonly mightBeActive: boolean;
  isSetByEnterprisePolicy: boolean;
  analyzeContentRequests(aCars: nsIContentAnalysisRequest[], aAutoAcknowledge: boolean): Promise<any>;
  analyzeContentRequestsCallback(aCars: nsIContentAnalysisRequest[], aAutoAcknowledge: boolean, callback: nsIContentAnalysisCallback): void;
  analyzeBatchContentRequest(aCar: nsIContentAnalysisRequest, aAutoAcknowledge: boolean): Promise<any>;
  analyzeContentRequestPrivate(aRequest: nsIContentAnalysisRequest, aAutoAcknowledge: boolean, aCallback: nsIContentAnalysisCallback): void;
  cancelRequestsByUserAction(aUserActionId: string): void;
  cancelAllRequestsAssociatedWithUserAction(aUserActionId: string): void;
  respondToWarnDialog(aRequestToken: string, aAllowContent: boolean): void;
  cancelAllRequests(aForbidFutureRequests?: boolean): void;
  testOnlySetCACmdLineArg(aVal: boolean): void;
  getDiagnosticInfo(): Promise<any>;
  getURIForBrowsingContext(aBrowsingContext: BrowsingContext): nsIURI;
  getURIForDropEvent(aEvent: DragEvent): nsIURI;
  setCachedResponse(aURI: nsIURI, aSequenceNumber: i32, aAction: nsIContentAnalysisResponse.Action): void;
  getCachedResponse(aURI: nsIURI, aSequenceNumber: i32, aAction: OutParam<nsIContentAnalysisResponse.Action>, aIsValid: OutParam<boolean>): void;
  showBlockedRequestDialog(aRequest: nsIContentAnalysisRequest): void;
  makeResponseForTest(aAction: nsIContentAnalysisResponse.Action, aToken: string, aUserActionId: string): nsIContentAnalysisResponse;
  sendCancelToAgent(aUserActionId: string): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/cookiebanners/nsIClickRule.idl

}  // global

declare enum nsIClickRule_RunContext {
  RUN_TOP = 0,
  RUN_CHILD = 1,
  RUN_ALL = 2,
}

declare global {

namespace nsIClickRule {
  type RunContext = nsIClickRule_RunContext;
}

interface nsIClickRule extends nsISupports, Enums<typeof nsIClickRule_RunContext> {
  readonly presence: string;
  readonly skipPresenceVisibilityCheck: boolean;
  readonly runContext: nsIClickRule.RunContext;
  readonly hide: string;
  readonly optOut: string;
  readonly optIn: string;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/cookiebanners/nsICookieBannerListService.idl

interface nsICookieBannerListService extends nsISupports {
  init(): void;
  initForTest(): Promise<any>;
  shutdown(): void;
  importAllRules(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/cookiebanners/nsICookieBannerRule.idl

interface nsICookieBannerRule extends nsISupports {
  id: string;
  domains: string[];
  readonly cookiesOptOut: nsICookieRule[];
  readonly cookiesOptIn: nsICookieRule[];
  clearCookies(): void;
  addCookie(aIsOptOut: boolean, aName: string, aValue: string, aHost: string, aPath: string, aExpiryRelative: i64, aUnsetValue: string, aIsSecure: boolean, aIsHttpOnly: boolean, aIsSession: boolean, aSameSite: i32, aSchemeMap: nsICookie.schemeType): void;
  readonly clickRule: nsIClickRule;
  addClickRule(aPresence: string, aSkipPresenceVisibilityCheck?: boolean, aRunContext?: nsIClickRule.RunContext, aHide?: string, aOptOut?: string, aOptIn?: string): void;
  clearClickRule(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/cookiebanners/nsICookieBannerService.idl

}  // global

declare enum nsICookieBannerService_Modes {
  MODE_DISABLED = 0,
  MODE_REJECT = 1,
  MODE_REJECT_OR_ACCEPT = 2,
  MODE_UNSET = 3,
}

declare global {

namespace nsICookieBannerService {
  type Modes = nsICookieBannerService_Modes;
}

interface nsICookieBannerService extends nsISupports, Enums<typeof nsICookieBannerService_Modes> {
  readonly isEnabled: boolean;
  readonly rules: nsICookieBannerRule[];
  resetRules(doImport?: boolean): void;
  getCookiesForURI(aURI: nsIURI, aIsPrivateBrowsing: boolean): nsICookieRule[];
  getClickRulesForDomain(aDomain: string, aIsTopLevel: boolean): nsIClickRule[];
  insertRule(aRule: nsICookieBannerRule): void;
  removeRule(aRule: nsICookieBannerRule): void;
  hasRuleForBrowsingContextTree(aBrowsingContext: BrowsingContext): boolean;
  getDomainPref(aTopLevelURI: nsIURI, aIsPrivate: boolean): nsICookieBannerService.Modes;
  setDomainPref(aTopLevelURI: nsIURI, aMode: nsICookieBannerService.Modes, aIsPrivate: boolean): void;
  setDomainPrefAndPersistInPrivateBrowsing(aTopLevelURI: nsIURI, aMode: nsICookieBannerService.Modes): void;
  removeDomainPref(aTopLevelURI: nsIURI, aIsPrivate: boolean): void;
  removeAllDomainPrefs(aIsPrivate: boolean): void;
  shouldStopBannerClickingForSite(aSite: string, aIsTopLevel: boolean, aIsPrivate: boolean): boolean;
  markSiteExecuted(aSite: string, aIsTopLevel: boolean, aIsPrivate: boolean): void;
  removeExecutedRecordForSite(aSite: string, aIsPrivate: boolean): void;
  removeAllExecutedRecords(aIsPrivate: boolean): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/cookiebanners/nsICookieBannerTelemetryService.idl

interface nsICookieBannerTelemetryService extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/toolkit/components/cookiebanners/nsICookieRule.idl

interface nsICookieRule extends nsISupports {
  readonly cookie: nsICookie;
  readonly expiryRelative: i64;
  readonly unsetValue: string;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/crashes/nsICrashService.idl

interface nsICrashService extends nsISupports {
  readonly CRASH_TYPE_CRASH?: 0;
  readonly CRASH_TYPE_HANG?: 1;

  addCrash(processType: i32, crashType: i32, id: string): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/finalizationwitness/nsIFinalizationWitnessService.idl

interface nsIFinalizationWitnessService extends nsISupports {
  make(aTopic: string, aString: string): any;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/media/nsIWindowsMediaFoundationCDMOriginsListService.idl

interface nsIOriginStatusEntry extends nsISupports {
  readonly origin: string;
  readonly status: i32;
}

interface nsIOriginsListLoadCallback extends nsISupports {
  onOriginsListLoaded(aEntries: nsIArray): void;
}

interface nsIWindowsMediaFoundationCDMOriginsListService extends nsISupports {
  readonly ORIGIN_BLOCKED?: 0;
  readonly ORIGIN_ALLOWED?: 1;

  setCallback(aCallback: nsIOriginsListLoadCallback): void;
  removeCallback(aCallback: nsIOriginsListLoadCallback): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/modules/nsIBrowserWindowTracker.idl

interface nsIVisibleTab extends nsISupports {
  contentTitle: string;
  browserId: i64;
}

interface nsIBrowserWindowTracker extends nsISupports {
  getAllVisibleTabs(): nsIVisibleTab[];
  getBrowserById(aBrowserId: u64): nsISupports;
}

// https://searchfox.org/mozilla-central/source/toolkit/modules/nsIRegion.idl

interface nsIRegion extends nsISupports {
  readonly current: string;
  readonly home: string;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/processtools/nsIProcessToolsService.idl

interface nsIProcessToolsService extends nsISupports {
  kill(pid: u64): void;
  crash(pid: u64): void;
  readonly pid: u64;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/resistfingerprinting/nsIFingerprintingWebCompatService.idl

interface nsIFingerprintingOverride extends nsISupports {
  readonly firstPartyDomain: string;
  readonly thirdPartyDomain: string;
  readonly overrides: string;
  readonly isBaseline: boolean;
}

interface nsIFingerprintingWebCompatService extends nsISupports {
  init(): void;
  shutdown(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/resistfingerprinting/nsIRFPService.idl

interface nsIRFPService extends nsISupports {
  setFingerprintingOverrides(aOverrides: nsIFingerprintingOverride[]): void;
  getFingerprintingOverrides(aDomainKey: string): nsIRFPTargetSetIDL;
  cleanAllOverrides(): void;
  readonly enabledFingerprintingProtectionsBaseline: nsIRFPTargetSetIDL;
  readonly enabledFingerprintingProtections: nsIRFPTargetSetIDL;
  cleanAllRandomKeys(): void;
  cleanRandomKeyByPrincipal(aPrincipal: nsIPrincipal): void;
  cleanRandomKeyBySite(aSchemelessSite: string, originAttributes: any): void;
  cleanRandomKeyByHost(aHost: string, aPattern: string): void;
  cleanRandomKeyByOriginAttributesPattern(aPattern: string): void;
  getSpoofedUserAgent(aDesktopMode: boolean): string;
  testGenerateRandomKey(aChannel: nsIChannel): u8[];
}

// https://searchfox.org/mozilla-central/source/toolkit/components/resistfingerprinting/nsIRFPTargetSetIDL.idl

interface nsIRFPTargetSetIDL extends nsISupports {
  low: u64;
  high: u64;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/resistfingerprinting/nsIUserCharacteristicsPageService.idl

interface nsIUserCharacteristicsPageService extends nsISupports {
  createContentPage(principal: nsIPrincipal): Promise<any>;
  pageLoaded(browsingContext: BrowsingContext, data: any): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/search/nsISearchService.idl

interface nsISearchSubmission extends nsISupports {
  readonly postData: nsIInputStream;
  readonly uri: nsIURI;
}

interface nsISearchEngine extends nsISupports {
  getSubmission(searchTerms: string, responseType?: string): nsISearchSubmission;
  readonly searchURLWithNoTerms: nsIURI;
  searchTermFromResult(uri: nsIURI): string;
  readonly searchUrlQueryParamName: string;
  readonly searchUrlPublicSuffix: string;
  supportsResponseType(responseType: string): boolean;
  getIconURL(preferredWidth?: u16): Promise<any>;
  speculativeConnect(options: any): void;
  alias: string;
  readonly aliases: string[];
  hidden: boolean;
  hideOneOffButton: boolean;
  readonly name: string;
  readonly id: string;
  readonly telemetryId: string;
  readonly identifier: string;
  readonly loadPath: string;
  readonly isAppProvided: boolean;
  readonly inMemory: boolean;
  readonly overriddenById: string;
  readonly isGeneralPurposeEngine: boolean;
  readonly searchUrlDomain: string;
  readonly clickUrl: string;
  readonly searchForm: string;
  readonly partnerCode: string;
}

interface nsISearchParseSubmissionResult extends nsISupports {
  readonly engine: nsISearchEngine;
  readonly terms: string;
  readonly termsParameterName: string;
}

}  // global

declare enum nsISearchService_OpenSearchInstallErrors {
  ERROR_DOWNLOAD_FAILURE = 1,
  ERROR_DUPLICATE_ENGINE = 2,
  ERROR_ENGINE_CORRUPTED = 3,
}

declare enum nsISearchService_DefaultEngineChangeReason {
  CHANGE_REASON_UNKNOWN = 0,
  CHANGE_REASON_USER = 1,
  CHANGE_REASON_USER_PRIVATE_SPLIT = 2,
  CHANGE_REASON_USER_SEARCHBAR = 3,
  CHANGE_REASON_USER_SEARCHBAR_CONTEXT = 4,
  CHANGE_REASON_ADDON_INSTALL = 5,
  CHANGE_REASON_ADDON_UNINSTALL = 6,
  CHANGE_REASON_CONFIG = 7,
  CHANGE_REASON_LOCALE = 8,
  CHANGE_REASON_REGION = 9,
  CHANGE_REASON_EXPERIMENT = 10,
  CHANGE_REASON_ENTERPRISE = 11,
  CHANGE_REASON_UITOUR = 12,
  CHANGE_REASON_ENGINE_UPDATE = 13,
  CHANGE_REASON_USER_PRIVATE_PREF_ENABLED = 14,
  CHANGE_REASON_ENGINE_IGNORE_LIST_UPDATED = 15,
  CHANGE_REASON_NO_EXISTING_DEFAULT_ENGINE = 16,
}

declare global {

namespace nsISearchService {
  type OpenSearchInstallErrors = nsISearchService_OpenSearchInstallErrors;
  type DefaultEngineChangeReason = nsISearchService_DefaultEngineChangeReason;
}

interface nsISearchService extends nsISupports, Enums<typeof nsISearchService_OpenSearchInstallErrors & typeof nsISearchService_DefaultEngineChangeReason> {
  init(): Promise<any>;
  readonly promiseInitialized: Promise<any>;
  readonly isInitialized: boolean;
  readonly hasSuccessfullyInitialized: boolean;
  runBackgroundChecks(): Promise<any>;
  resetToAppDefaultEngine(): void;
  addOpenSearchEngine(engineURL: string, iconURL: string): Promise<any>;
  addUserEngine(formInfo: any): Promise<any>;
  addEnginesFromExtension(extension: any): Promise<any>;
  restoreDefaultEngines(): void;
  getEngineByAlias(alias: string): Promise<any>;
  getEngineByName(aEngineName: string): nsISearchEngine;
  getEngineById(aEngineId: string): nsISearchEngine;
  getEngines(): Promise<any>;
  getVisibleEngines(): Promise<any>;
  getAppProvidedEngines(): Promise<any>;
  getEnginesByExtensionID(extensionID: string): Promise<any>;
  findContextualSearchEngineByHost(host: string): Promise<any>;
  shouldShowInstallPrompt(engine: any): Promise<any>;
  addSearchEngine(engine: any): Promise<any>;
  moveEngine(engine: nsISearchEngine, newIndex: i32): Promise<any>;
  removeEngine(engine: nsISearchEngine): Promise<any>;
  removeWebExtensionEngine(id: string): Promise<any>;
  readonly appDefaultEngine: nsISearchEngine;
  readonly appPrivateDefaultEngine: nsISearchEngine;
  defaultEngine: nsISearchEngine;
  getDefault(): Promise<any>;
  setDefault(engine: nsISearchEngine, changeReason: u16): Promise<any>;
  defaultPrivateEngine: nsISearchEngine;
  getDefaultPrivate(): Promise<any>;
  setDefaultPrivate(engine: nsISearchEngine, changeReason: u16): Promise<any>;
  readonly separatePrivateDefaultUrlbarResultEnabled: boolean;
  maybeSetAndOverrideDefault(extension: any): Promise<any>;
  getDefaultEngineInfo(): any;
  parseSubmissionURL(url: string): nsISearchParseSubmissionResult;
  getAlternateDomains(domain: string): string[];
}

// https://searchfox.org/mozilla-central/source/toolkit/components/shell/nsIToolkitShellService.idl

interface nsIToolkitShellService extends nsISupports {
  isDefaultApplication(): boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/terminator/nsITerminatorTest.idl

interface nsITerminatorTest extends nsISupports {
  getTicksForShutdownPhases(): any;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/xulstore/nsIXULStore.idl

interface nsIXULStore extends nsISupports {
  persist(aNode: Node, attr: string): void;
  setValue(doc: string, id: string, attr: string, value: string): void;
  hasValue(doc: string, id: string, attr: string): boolean;
  getValue(doc: string, id: string, attr: string): string;
  removeValue(doc: string, id: string, attr: string): void;
  removeDocument(doc: string): void;
  getIDsEnumerator(doc: string): nsIStringEnumerator;
  getAttributeEnumerator(doc: string, id: string): nsIStringEnumerator;
}

// https://searchfox.org/mozilla-central/source/toolkit/profile/nsIProfileMigrator.idl

interface nsIProfileStartup extends nsISupports {
  readonly directory: nsIFile;
  doStartup(): void;
}

interface nsIProfileMigrator extends nsISupports {
  migrate(aStartup: nsIProfileStartup, aKey: string, aProfileName?: string): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/profile/nsIProfileUnlocker.idl

interface nsIProfileUnlocker extends nsISupports {
  readonly ATTEMPT_QUIT?: 0;
  readonly FORCE_QUIT?: 1;

  unlock(aSeverity: u32): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/profile/nsIToolkitProfile.idl

interface nsIProfileLock extends nsISupports {
  readonly directory: nsIFile;
  readonly localDirectory: nsIFile;
  readonly replacedLockTime: PRTime;
  unlock(): void;
}

interface nsIToolkitProfile extends nsISupports {
  rootDir: nsIFile;
  readonly localDir: nsIFile;
  name: string;
  storeID: string;
  showProfileSelector: boolean;
  remove(removeFiles: boolean): void;
  removeInBackground(removeFiles: boolean): void;
  lock(aUnlocker: OutParam<nsIProfileUnlocker>): nsIProfileLock;
}

// https://searchfox.org/mozilla-central/source/toolkit/profile/nsIToolkitProfileService.idl

}  // global

declare enum nsIToolkitProfileService_downgradeUIFlags {
  hasSync = 1,
}

declare enum nsIToolkitProfileService_downgradeUIChoice {
  quit = 0,
  createNewProfile = 1,
}

declare enum nsIToolkitProfileService_profileManagerResult {
  exit = 0,
  launchWithProfile = 1,
  restart = 2,
}

declare global {

namespace nsIToolkitProfileService {
  type downgradeUIFlags = nsIToolkitProfileService_downgradeUIFlags;
  type downgradeUIChoice = nsIToolkitProfileService_downgradeUIChoice;
  type profileManagerResult = nsIToolkitProfileService_profileManagerResult;
}

interface nsIToolkitProfileService extends nsISupports, Enums<typeof nsIToolkitProfileService_downgradeUIFlags & typeof nsIToolkitProfileService_downgradeUIChoice & typeof nsIToolkitProfileService_profileManagerResult> {
  readonly isListOutdated: boolean;
  startWithLastProfile: boolean;
  readonly profiles: nsISimpleEnumerator;
  readonly currentProfile: nsIToolkitProfile;
  readonly groupProfile: nsIToolkitProfile;
  defaultProfile: nsIToolkitProfile;
  selectStartupProfile(aArgv: string[], aIsResetting: boolean, aUpdateChannel: string, aLegacyInstallHash: string, aRootDir: OutParam<nsIFile>, aLocalDir: OutParam<nsIFile>, aProfile: OutParam<nsIToolkitProfile>): boolean;
  getProfileByName(aName: string): nsIToolkitProfile;
  getProfileByDir(aRootDir: nsIFile, aLocalDir?: nsIFile): nsIToolkitProfile;
  createProfile(aRootDir: nsIFile, aName: string): nsIToolkitProfile;
  createUniqueProfile(aRootDir: nsIFile, aNamePrefix: string): nsIToolkitProfile;
  readonly profileCount: u32;
  flush(): void;
  asyncFlush(): Promise<any>;
  asyncFlushGroupProfile(): Promise<any>;
  removeProfileFilesByPath(aRootDir: nsIFile, aLocalDir: nsIFile, aTimeout: u32): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/remote/nsIRemoteService.idl

interface nsIRemoteService extends nsISupports {
  sendCommandLine(aProfile: string, aArgs: string[], aRaise?: boolean): void;
}

// https://searchfox.org/mozilla-central/source/editor/txmgr/nsITransaction.idl

interface nsITransaction extends nsISupports {
  doTransaction(): void;
  undoTransaction(): void;
  redoTransaction(): void;
  readonly isTransient: boolean;
  merge(aTransaction: nsITransaction): boolean;
}

// https://searchfox.org/mozilla-central/source/editor/txmgr/nsITransactionManager.idl

interface nsITransactionManager extends nsISupports {
  doTransaction(aTransaction: nsITransaction): void;
  undoTransaction(): void;
  redoTransaction(): void;
  clear(): void;
  clearUndoStack(): void;
  clearRedoStack(): void;
  beginBatch(aData: nsISupports): void;
  endBatch(aAllowEmpty: boolean): void;
  readonly numberOfUndoItems: i32;
  readonly numberOfRedoItems: i32;
  maxTransactionCount: i32;
  batchTopUndo(): void;
  removeTopUndo(): void;
  peekUndoStack(): nsITransaction;
  peekRedoStack(): nsITransaction;
}

// https://searchfox.org/mozilla-central/source/editor/spellchecker/nsIInlineSpellChecker.idl

interface nsIInlineSpellChecker extends nsISupports {
  readonly spellChecker: nsIEditorSpellCheck;
  init(aEditor: nsIEditor): void;
  cleanup(aDestroyingFrames: boolean): void;
  enableRealTimeSpell: boolean;
  spellCheckRange(aSelection: Range): void;
  getMisspelledWord(aNode: Node, aOffset: u32): Range;
  replaceWord(aNode: Node, aOffset: u32, aNewword: string): void;
  addWordToDictionary(aWord: string): void;
  removeWordFromDictionary(aWord: string): void;
  ignoreWord(aWord: string): void;
  ignoreWords(aWordsToIgnore: string[]): void;
  updateCurrentDictionary(): void;
  readonly spellCheckPending: boolean;
}

// https://searchfox.org/mozilla-central/source/intl/uconv/nsIScriptableUConv.idl

interface nsIScriptableUnicodeConverter extends nsISupports {
  ConvertFromUnicode(aSrc: string): string;
  Finish(): string;
  ConvertToUnicode(aSrc: string): string;
  charset: string;
  isInternal: boolean;
}

// https://searchfox.org/mozilla-central/source/intl/uconv/nsITextToSubURI.idl

interface nsITextToSubURI extends nsISupports {
  ConvertAndEscape(charset: string, text: string): string;
  UnEscapeAndConvert(charset: string, text: string): string;
  unEscapeURIForUI(aURIFragment: string, aDontEscape?: boolean): string;
  unEscapeNonAsciiURI(aCharset: string, aURIFragment: string): string;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/timermanager/nsIUpdateTimerManager.idl

interface nsIUpdateTimerManager extends nsISupports {
  registerTimer(id: string, callback: nsITimerCallback, interval: u32, skipFirst?: boolean): void;
  unregisterTimer(id: string): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/mozapps/update/nsIUpdateService.idl

interface nsIUpdatePatch extends nsISupports {
  readonly type: string;
  readonly URL: string;
  finalURL: string;
  readonly size: u32;
  state: string;
  errorCode: i32;
  selected: boolean;
  serialize(updates: Document): Element;
}

interface nsIUpdate extends nsISupports {
  readonly type: string;
  readonly name: string;
  readonly displayVersion: string;
  readonly appVersion: string;
  readonly platformVersion: string;
  readonly previousAppVersion: string;
  readonly buildID: string;
  readonly detailsURL: string;
  readonly serviceURL: string;
  readonly channel: string;
  readonly unsupported: boolean;
  promptWaitTime: i64;
  isCompleteUpdate: boolean;
  installDate: i64;
  statusText: string;
  readonly selectedPatch: nsIUpdatePatch;
  state: string;
  errorCode: i32;
  elevationFailure: boolean;
  readonly patchCount: u32;
  getPatchAt(index: u32): nsIUpdatePatch;
  serialize(updates: Document): Element;
}

interface nsIUpdateCheckResult extends nsISupports {
  readonly checksAllowed: boolean;
  readonly succeeded: boolean;
  readonly request: any;
  readonly updates: nsIUpdate[];
}

interface nsIUpdateCheck extends nsISupports {
  readonly id: i32;
  readonly result: Promise<any>;
}

interface nsIUpdateCheckerInternal extends nsISupports {
  checkForUpdates(checkType: i32): nsIUpdateCheck;
}

interface nsIUpdateChecker extends nsISupports {
  readonly BACKGROUND_CHECK?: 1;
  readonly FOREGROUND_CHECK?: 2;

  checkForUpdates(checkType: i32): nsIUpdateCheck;
  getUpdateURL(checkType: i32): Promise<any>;
  stopCheck(id: i32): void;
  stopAllChecks(): void;
  readonly internal: nsIUpdateCheckerInternal;
}

interface nsIApplicationUpdateServiceInternal extends nsISupports {
  init(force: boolean): Promise<any>;
  downloadUpdate(update: nsIUpdate): Promise<any>;
  stopDownload(): Promise<any>;
}

interface nsIApplicationUpdateService extends nsISupports {
  readonly DOWNLOAD_SUCCESS?: 1;
  readonly DOWNLOAD_FAILURE_CANNOT_RESUME_IN_BACKGROUND?: 2;
  readonly DOWNLOAD_FAILURE_GENERIC?: 3;
  readonly STATE_IDLE?: 1;
  readonly STATE_DOWNLOADING?: 2;
  readonly STATE_STAGING?: 4;
  readonly STATE_PENDING?: 5;
  readonly STATE_SWAP?: 6;

  init(): Promise<any>;
  checkForBackgroundUpdates(): Promise<any>;
  selectUpdate(updates: nsIUpdate[]): Promise<any>;
  addDownloadListener(listener: nsIRequestObserver): void;
  removeDownloadListener(listener: nsIRequestObserver): void;
  downloadUpdate(update: nsIUpdate): Promise<any>;
  onCheckComplete(result: nsIUpdateCheckResult): Promise<any>;
  stopDownload(): Promise<any>;
  readonly disabled: boolean;
  readonly canUsuallyCheckForUpdates: boolean;
  readonly canCheckForUpdates: boolean;
  readonly elevationRequired: boolean;
  readonly canUsuallyApplyUpdates: boolean;
  readonly canApplyUpdates: boolean;
  readonly isOtherInstanceHandlingUpdates: boolean;
  readonly canUsuallyStageUpdates: boolean;
  readonly canStageUpdates: boolean;
  readonly canUsuallyUseBits: boolean;
  readonly canUseBits: boolean;
  readonly manualUpdateOnly: boolean;
  readonly isAppBaseDirWritable: boolean;
  onlyDownloadUpdatesThisSession: boolean;
  getStateName(state: i32): string;
  readonly currentState: i32;
  readonly stateTransition: Promise<any>;
  readonly internal: nsIApplicationUpdateServiceInternal;
}

interface nsIUpdateProcessor extends nsISupports {
  processUpdate(): void;
  getServiceRegKeyExists(): boolean;
  attemptAutomaticApplicationRestartWithLaunchArgs(argvExtra: string[]): i32;
  waitForProcessExit(pid: u32, timeoutMS: u32): void;
}

interface nsIUpdateSyncManager extends nsISupports {
  isOtherInstanceRunning(): boolean;
  resetLock(anAppFile?: nsIFile): void;
}

interface nsIUpdateMutex extends nsISupports {
  isLocked(): boolean;
  tryLock(): boolean;
  unlock(): void;
}

interface nsIUpdateManagerInternal extends nsISupports {
  reload(skipFiles: boolean): Promise<any>;
  getHistory(): nsIUpdate[];
  addUpdateToHistory(update: nsIUpdate): void;
  readyUpdate: nsIUpdate;
  downloadingUpdate: nsIUpdate;
  refreshUpdateStatus(): Promise<any>;
}

interface nsIUpdateManager extends nsISupports {
  getHistory(): Promise<any>;
  getReadyUpdate(): Promise<any>;
  getDownloadingUpdate(): Promise<any>;
  updateInstalledAtStartup(): Promise<any>;
  lastUpdateInstalled(): Promise<any>;
  addUpdateToHistory(update: nsIUpdate): Promise<any>;
  saveUpdates(): void;
  refreshUpdateStatus(): Promise<any>;
  elevationOptedIn(): Promise<any>;
  cleanupDownloadingUpdate(): Promise<any>;
  cleanupReadyUpdate(): Promise<any>;
  cleanupActiveUpdates(): Promise<any>;
  doInstallCleanup(): Promise<any>;
  doUninstallCleanup(): Promise<any>;
  readonly internal: nsIUpdateManagerInternal;
}

interface nsIApplicationUpdateServiceStub extends nsISupports {
  init(): Promise<any>;
  initUpdate(): Promise<any>;
  readonly updateDisabled: boolean;
  readonly updateDisabledForTesting: boolean;
}

// https://searchfox.org/mozilla-central/source/uriloader/base/nsCURILoader.idl

// https://searchfox.org/mozilla-central/source/uriloader/base/nsIContentHandler.idl

interface nsIContentHandler extends nsISupports {
  handleContent(aContentType: string, aWindowContext: nsIInterfaceRequestor, aRequest: nsIRequest): void;
}

// https://searchfox.org/mozilla-central/source/uriloader/base/nsIDocumentLoader.idl

interface nsIDocumentLoader extends nsISupports {
  stop(): void;
  readonly container: nsISupports;
  readonly loadGroup: nsILoadGroup;
  readonly documentChannel: nsIChannel;
}

// https://searchfox.org/mozilla-central/source/uriloader/base/nsITransfer.idl

interface nsITransfer extends nsIWebProgressListener2 {
  readonly DOWNLOAD_ACCEPTABLE?: 0;
  readonly DOWNLOAD_FORBIDDEN?: 1;
  readonly DOWNLOAD_POTENTIALLY_UNSAFE?: 2;

  init(aSource: nsIURI, aSourceOriginalURI: nsIURI, aTarget: nsIURI, aDisplayName: string, aMIMEInfo: nsIMIMEInfo, startTime: PRTime, aTempFile: nsIFile, aCancelable: nsICancelable, aIsPrivate: boolean, aDownloadClassification: i32, aReferrerInfo: nsIReferrerInfo, aOpenDownloadsListOnStart?: boolean): void;
  initWithBrowsingContext(aSource: nsIURI, aTarget: nsIURI, aDisplayName: string, aMIMEInfo: nsIMIMEInfo, startTime: PRTime, aTempFile: nsIFile, aCancelable: nsICancelable, aIsPrivate: boolean, aDownloadClassification: i32, aReferrerInfo: nsIReferrerInfo, aOpenDownloadsListOnStart: boolean, aBrowsingContext: BrowsingContext, aHandleInternally: boolean, aHttpChannel: nsIHttpChannel): void;
  setSha256Hash(aHash: string): void;
  setSignatureInfo(aSignatureInfo: u8[][][]): void;
  setRedirects(aRedirects: nsIArray): void;
  readonly downloadPromise: Promise<any>;
}

// https://searchfox.org/mozilla-central/source/uriloader/base/nsIURIContentListener.idl

interface nsIURIContentListener extends nsISupports {
  doContent(aContentType: string, aIsContentPreferred: boolean, aRequest: nsIRequest, aContentHandler: OutParam<nsIStreamListener>): boolean;
  isPreferred(aContentType: string, aDesiredContentType: OutParam<string>): boolean;
  canHandleContent(aContentType: string, aIsContentPreferred: boolean, aDesiredContentType: OutParam<string>): boolean;
  loadCookie: nsISupports;
  parentContentListener: nsIURIContentListener;
}

// https://searchfox.org/mozilla-central/source/uriloader/base/nsIURILoader.idl

interface nsIURILoader extends nsISupports {
  readonly IS_CONTENT_PREFERRED?: 1;
  readonly DONT_RETARGET?: 2;

  registerContentListener(aContentListener: nsIURIContentListener): void;
  unRegisterContentListener(aContentListener: nsIURIContentListener): void;
  openURI(aChannel: nsIChannel, aFlags: u32, aWindowContext: nsIInterfaceRequestor): void;
  openChannel(aChannel: nsIChannel, aFlags: u32, aWindowContext: nsIInterfaceRequestor): nsIStreamListener;
  stop(aLoadCookie: nsISupports): void;
}

// https://searchfox.org/mozilla-central/source/uriloader/base/nsIWebProgress.idl

interface nsIWebProgress extends nsISupports {
  readonly NOTIFY_STATE_REQUEST?: 1;
  readonly NOTIFY_STATE_DOCUMENT?: 2;
  readonly NOTIFY_STATE_NETWORK?: 4;
  readonly NOTIFY_STATE_WINDOW?: 8;
  readonly NOTIFY_STATE_ALL?: 15;
  readonly NOTIFY_PROGRESS?: 16;
  readonly NOTIFY_STATUS?: 32;
  readonly NOTIFY_SECURITY?: 64;
  readonly NOTIFY_LOCATION?: 128;
  readonly NOTIFY_REFRESH?: 256;
  readonly NOTIFY_CONTENT_BLOCKING?: 512;
  readonly NOTIFY_ALL?: 1023;

  addProgressListener(aListener: nsIWebProgressListener, aNotifyMask: u32): void;
  removeProgressListener(aListener: nsIWebProgressListener): void;
  readonly browsingContext: BrowsingContext;
  readonly DOMWindow: mozIDOMWindowProxy;
  readonly isTopLevel: boolean;
  readonly isLoadingDocument: boolean;
  readonly loadType: u32;
  target: nsIEventTarget;
  readonly documentRequest: nsIRequest;
}

// https://searchfox.org/mozilla-central/source/uriloader/base/nsIWebProgressListener.idl

interface nsIWebProgressListener extends nsISupports {
  readonly STATE_START?: 1;
  readonly STATE_REDIRECTING?: 2;
  readonly STATE_TRANSFERRING?: 4;
  readonly STATE_NEGOTIATING?: 8;
  readonly STATE_STOP?: 16;
  readonly STATE_IS_REQUEST?: 65536;
  readonly STATE_IS_DOCUMENT?: 131072;
  readonly STATE_IS_NETWORK?: 262144;
  readonly STATE_IS_WINDOW?: 524288;
  readonly STATE_IS_REDIRECTED_DOCUMENT?: 1048576;
  readonly STATE_RESTORING?: 16777216;
  readonly STATE_IS_INSECURE?: 4;
  readonly STATE_IS_BROKEN?: 1;
  readonly STATE_IS_SECURE?: 2;
  readonly STATE_BLOCKED_MIXED_ACTIVE_CONTENT?: 16;
  readonly STATE_LOADED_MIXED_ACTIVE_CONTENT?: 32;
  readonly STATE_BLOCKED_MIXED_DISPLAY_CONTENT?: 256;
  readonly STATE_LOADED_MIXED_DISPLAY_CONTENT?: 512;
  readonly STATE_IDENTITY_EV_TOPLEVEL?: 1048576;
  readonly STATE_IDENTITY_ASSOCIATED?: 2097152;
  readonly STATE_USES_SSL_3?: 16777216;
  readonly STATE_USES_WEAK_CRYPTO?: 33554432;
  readonly STATE_CERT_USER_OVERRIDDEN?: 67108864;
  readonly STATE_BLOCKED_TRACKING_CONTENT?: 4096;
  readonly STATE_LOADED_LEVEL_1_TRACKING_CONTENT?: 8192;
  readonly STATE_LOADED_LEVEL_2_TRACKING_CONTENT?: 1048576;
  readonly STATE_BLOCKED_FINGERPRINTING_CONTENT?: 64;
  readonly STATE_LOADED_FINGERPRINTING_CONTENT?: 1024;
  readonly STATE_REPLACED_FINGERPRINTING_CONTENT?: 134217728;
  readonly STATE_ALLOWED_FINGERPRINTING_CONTENT?: 512;
  readonly STATE_BLOCKED_CRYPTOMINING_CONTENT?: 2048;
  readonly STATE_LOADED_CRYPTOMINING_CONTENT?: 2097152;
  readonly STATE_BLOCKED_UNSAFE_CONTENT?: 16384;
  readonly STATE_COOKIES_LOADED?: 32768;
  readonly STATE_COOKIES_LOADED_TRACKER?: 262144;
  readonly STATE_COOKIES_LOADED_SOCIALTRACKER?: 524288;
  readonly STATE_COOKIES_BLOCKED_BY_PERMISSION?: 268435456;
  readonly STATE_COOKIES_BLOCKED_TRACKER?: 536870912;
  readonly STATE_COOKIES_BLOCKED_SOCIALTRACKER?: 16777216;
  readonly STATE_COOKIES_BLOCKED_ALL?: 1073741824;
  readonly STATE_COOKIES_PARTITIONED_TRACKER?: 2;
  readonly STATE_COOKIES_PARTITIONED_FOREIGN?: 2147483648;
  readonly STATE_COOKIES_BLOCKED_FOREIGN?: 128;
  readonly STATE_BLOCKED_SOCIALTRACKING_CONTENT?: 65536;
  readonly STATE_LOADED_SOCIALTRACKING_CONTENT?: 131072;
  readonly STATE_REPLACED_TRACKING_CONTENT?: 16;
  readonly STATE_ALLOWED_TRACKING_CONTENT?: 32;
  readonly STATE_BLOCKED_EMAILTRACKING_CONTENT?: 4194304;
  readonly STATE_LOADED_EMAILTRACKING_LEVEL_1_CONTENT?: 8388608;
  readonly STATE_LOADED_EMAILTRACKING_LEVEL_2_CONTENT?: 256;
  readonly STATE_ALLOWED_CANVAS_FINGERPRINTING?: 33554432;
  readonly STATE_ALLOWED_FONT_FINGERPRINTING?: 67108864;
  readonly STATE_BLOCKED_SUSPICIOUS_FINGERPRINTING?: 4;
  readonly STATE_PURGED_BOUNCETRACKER?: 8;
  readonly STATE_HTTPS_ONLY_MODE_UPGRADED?: 4194304;
  readonly STATE_HTTPS_ONLY_MODE_UPGRADE_FAILED?: 8388608;
  readonly STATE_HTTPS_ONLY_MODE_UPGRADED_FIRST?: 134217728;
  readonly LOCATION_CHANGE_SAME_DOCUMENT?: 1;
  readonly LOCATION_CHANGE_ERROR_PAGE?: 2;
  readonly LOCATION_CHANGE_RELOAD?: 4;
  readonly LOCATION_CHANGE_HASHCHANGE?: 8;
  readonly LOCATION_CHANGE_SESSION_STORE?: 16;

  onStateChange(aWebProgress: nsIWebProgress, aRequest: nsIRequest, aStateFlags: u32, aStatus: nsresult): void;
  onProgressChange(aWebProgress: nsIWebProgress, aRequest: nsIRequest, aCurSelfProgress: i32, aMaxSelfProgress: i32, aCurTotalProgress: i32, aMaxTotalProgress: i32): void;
  onLocationChange(aWebProgress: nsIWebProgress, aRequest: nsIRequest, aLocation: nsIURI, aFlags?: u32): void;
  onStatusChange(aWebProgress: nsIWebProgress, aRequest: nsIRequest, aStatus: nsresult, aMessage: string): void;
  onSecurityChange(aWebProgress: nsIWebProgress, aRequest: nsIRequest, aState: u32): void;
  onContentBlockingEvent(aWebProgress: nsIWebProgress, aRequest: nsIRequest, aEvent: u32): void;
}

// https://searchfox.org/mozilla-central/source/uriloader/base/nsIWebProgressListener2.idl

interface nsIWebProgressListener2 extends nsIWebProgressListener {
  onProgressChange64(aWebProgress: nsIWebProgress, aRequest: nsIRequest, aCurSelfProgress: i64, aMaxSelfProgress: i64, aCurTotalProgress: i64, aMaxTotalProgress: i64): void;
  onRefreshAttempted(aWebProgress: nsIWebProgress, aRefreshURI: nsIURI, aMillis: u32, aSameURI: boolean): boolean;
}

// https://searchfox.org/mozilla-central/source/netwerk/url-classifier/nsIChannelClassifierService.idl

interface nsIUrlClassifierBlockedChannel extends nsISupports {
  readonly TRACKING_PROTECTION?: 0;
  readonly SOCIAL_TRACKING_PROTECTION?: 1;
  readonly FINGERPRINTING_PROTECTION?: 2;
  readonly CRYPTOMINING_PROTECTION?: 3;

  readonly reason: u8;
  readonly tables: string;
  readonly url: string;
  readonly tabId: u64;
  readonly channelId: u64;
  readonly isPrivateBrowsing: boolean;
  readonly topLevelUrl: string;
  replace(): void;
  allow(): void;
}

interface nsIChannelClassifierService extends nsISupports {
  addListener(aObserver: nsIObserver): void;
  removeListener(aObserver: nsIObserver): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/url-classifier/nsIURIClassifier.idl

type nsIURIClassifierCallback = Callable<{
  onClassifyComplete(aErrorCode: nsresult, aList: string, aProvider: string, aFullHash: string): void;
}>

interface nsIURIClassifier extends nsISupports {
  classify(aPrincipal: nsIPrincipal, aCallback: nsIURIClassifierCallback): boolean;
  asyncClassifyLocalWithFeatures(aURI: nsIURI, aFeatures: nsIUrlClassifierFeature[], aListType: nsIUrlClassifierFeature.listType, aCallback: nsIUrlClassifierFeatureCallback, aIdlePriority?: boolean): void;
  asyncClassifyLocalWithFeatureNames(aURI: nsIURI, aFeatures: string[], aListType: nsIUrlClassifierFeature.listType, aCallback: nsIUrlClassifierFeatureCallback): void;
  getFeatureByName(aFeatureName: string): nsIUrlClassifierFeature;
  getFeatureNames(): string[];
  createFeatureWithTables(aName: string, aBlocklistTables: string[], aEntitylistTables: string[]): nsIUrlClassifierFeature;
  sendThreatHitReport(aChannel: nsIChannel, aProvider: string, aList: string, aFullHash: string): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/url-classifier/nsIUrlClassifierExceptionList.idl

interface nsIUrlClassifierExceptionList extends nsISupports {
  init(aFeature: string): void;
  addEntry(aEntry: nsIUrlClassifierExceptionListEntry): void;
  matches(aURI: nsIURI, aTopLevelURI: nsIURI, aIsPrivateBrowsing: boolean): boolean;
  testGetEntries(): nsIUrlClassifierExceptionListEntry[];
}

// https://searchfox.org/mozilla-central/source/netwerk/url-classifier/nsIUrlClassifierExceptionListEntry.idl

interface nsIUrlClassifierExceptionListEntry extends nsISupports {
  init(aUrlPattern: string, aTopLevelUrlPattern: string, aIsPrivateBrowsingOnly: boolean, aFilterContentBlockingCategories: string[], aClassifierFeatures: string[]): void;
  matches(aURI: nsIURI, aTopLevelURI: nsIURI, aIsPrivateBrowsing: boolean): boolean;
  readonly urlPattern: string;
  readonly topLevelUrlPattern: string;
  readonly isPrivateBrowsingOnly: boolean;
  readonly filterContentBlockingCategories: string[];
  readonly classifierFeatures: string[];
}

// https://searchfox.org/mozilla-central/source/netwerk/url-classifier/nsIUrlClassifierExceptionListService.idl

type nsIUrlClassifierExceptionListObserver = Callable<{
  onExceptionListUpdate(aList: nsIUrlClassifierExceptionList): void;
}>

interface nsIUrlClassifierExceptionListService extends nsISupports {
  registerAndRunExceptionListObserver(aFeature: string, aPrefName: string, aObserver: nsIUrlClassifierExceptionListObserver): void;
  unregisterExceptionListObserver(aFeature: string, aObserver: nsIUrlClassifierExceptionListObserver): void;
  clear(): void;
}

// https://searchfox.org/mozilla-central/source/netwerk/url-classifier/nsIUrlClassifierFeature.idl

}  // global

declare enum nsIUrlClassifierFeature_listType {
  blocklist = 0,
  entitylist = 1,
}

declare enum nsIUrlClassifierFeature_URIType {
  blocklistURI = 0,
  entitylistURI = 1,
  pairwiseEntitylistURI = 2,
}

declare global {

namespace nsIUrlClassifierFeature {
  type listType = nsIUrlClassifierFeature_listType;
  type URIType = nsIUrlClassifierFeature_URIType;
}

interface nsIUrlClassifierFeature extends nsISupports, Enums<typeof nsIUrlClassifierFeature_listType & typeof nsIUrlClassifierFeature_URIType> {
  readonly name: string;
  readonly exceptionList: nsIUrlClassifierExceptionList;
}

interface nsIUrlClassifierFeatureResult extends nsISupports {
  readonly uri: nsIURI;
  readonly feature: nsIUrlClassifierFeature;
  readonly list: string;
}

type nsIUrlClassifierFeatureCallback = Callable<{
  onClassifyComplete(aResults: nsIUrlClassifierFeatureResult[]): void;
}>

// https://searchfox.org/mozilla-central/source/toolkit/components/url-classifier/IUrlClassifierUITelemetry.idl

interface IUrlClassifierUITelemetry extends nsISupports {
  readonly WARNING_MALWARE_PAGE_TOP?: 1;
  readonly WARNING_MALWARE_PAGE_TOP_WHY_BLOCKED?: 2;
  readonly WARNING_MALWARE_PAGE_TOP_GET_ME_OUT_OF_HERE?: 3;
  readonly WARNING_MALWARE_PAGE_TOP_IGNORE_WARNING?: 4;
  readonly WARNING_MALWARE_PAGE_FRAME?: 5;
  readonly WARNING_MALWARE_PAGE_FRAME_WHY_BLOCKED?: 6;
  readonly WARNING_MALWARE_PAGE_FRAME_GET_ME_OUT_OF_HERE?: 7;
  readonly WARNING_MALWARE_PAGE_FRAME_IGNORE_WARNING?: 8;
  readonly WARNING_PHISHING_PAGE_TOP?: 9;
  readonly WARNING_PHISHING_PAGE_TOP_WHY_BLOCKED?: 10;
  readonly WARNING_PHISHING_PAGE_TOP_GET_ME_OUT_OF_HERE?: 11;
  readonly WARNING_PHISHING_PAGE_TOP_IGNORE_WARNING?: 12;
  readonly WARNING_PHISHING_PAGE_FRAME?: 13;
  readonly WARNING_PHISHING_PAGE_FRAME_WHY_BLOCKED?: 14;
  readonly WARNING_PHISHING_PAGE_FRAME_GET_ME_OUT_OF_HERE?: 15;
  readonly WARNING_PHISHING_PAGE_FRAME_IGNORE_WARNING?: 16;
  readonly WARNING_UNWANTED_PAGE_TOP?: 17;
  readonly WARNING_UNWANTED_PAGE_TOP_WHY_BLOCKED?: 18;
  readonly WARNING_UNWANTED_PAGE_TOP_GET_ME_OUT_OF_HERE?: 19;
  readonly WARNING_UNWANTED_PAGE_TOP_IGNORE_WARNING?: 20;
  readonly WARNING_UNWANTED_PAGE_FRAME?: 21;
  readonly WARNING_UNWANTED_PAGE_FRAME_WHY_BLOCKED?: 22;
  readonly WARNING_UNWANTED_PAGE_FRAME_GET_ME_OUT_OF_HERE?: 23;
  readonly WARNING_UNWANTED_PAGE_FRAME_IGNORE_WARNING?: 24;
  readonly WARNING_HARMFUL_PAGE_TOP?: 25;
  readonly WARNING_HARMFUL_PAGE_TOP_WHY_BLOCKED?: 26;
  readonly WARNING_HARMFUL_PAGE_TOP_GET_ME_OUT_OF_HERE?: 27;
  readonly WARNING_HARMFUL_PAGE_TOP_IGNORE_WARNING?: 28;
  readonly WARNING_HARMFUL_PAGE_FRAME?: 29;
  readonly WARNING_HARMFUL_PAGE_FRAME_WHY_BLOCKED?: 30;
  readonly WARNING_HARMFUL_PAGE_FRAME_GET_ME_OUT_OF_HERE?: 31;
  readonly WARNING_HARMFUL_PAGE_FRAME_IGNORE_WARNING?: 32;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/url-classifier/nsIUrlClassifierDBService.idl

type nsIUrlClassifierCallback = Callable<{
  handleEvent(value: string): void;
}>

interface nsIUrlClassifierUpdateObserver extends nsISupports {
  updateUrlRequested(url: string, table: string): void;
  streamFinished(status: nsresult, delay: u32): void;
  updateError(error: nsresult): void;
  updateSuccess(requestedTimeout: u32): void;
}

interface nsIUrlClassifierDBService extends nsISupports {
  lookup(principal: nsIPrincipal, tables: string, c: nsIUrlClassifierCallback): void;
  getTables(c: nsIUrlClassifierCallback): void;
  setHashCompleter(tableName: string, completer: nsIUrlClassifierHashCompleter): void;
  clearLastResults(): void;
  beginUpdate(updater: nsIUrlClassifierUpdateObserver, tables: string): void;
  beginStream(table: string): void;
  updateStream(updateChunk: string): void;
  finishStream(): void;
  finishUpdate(): void;
  cancelUpdate(): void;
  resetDatabase(): void;
  reloadDatabase(): void;
  clearCache(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/url-classifier/nsIUrlClassifierHashCompleter.idl

interface nsIFullHashMatch extends nsISupports {
  readonly tableName: string;
  readonly fullHash: string;
  readonly cacheDuration: u32;
}

interface nsIUrlClassifierHashCompleterCallback extends nsISupports {
  completionV2(hash: string, table: string, chunkId: u32): void;
  completionV4(partialHash: string, table: string, negativeCacheDuration: u32, fullHashes: nsIArray): void;
  completionFinished(status: nsresult): void;
}

interface nsIUrlClassifierHashCompleter extends nsISupports {
  complete(partialHash: string, gethashUrl: string, tableName: string, callback: nsIUrlClassifierHashCompleterCallback): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/url-classifier/nsIUrlClassifierInfo.idl

interface nsIUrlClassifierPositiveCacheEntry extends nsISupports {
  readonly fullhash: string;
  readonly expiry: i64;
}

interface nsIUrlClassifierCacheEntry extends nsISupports {
  readonly prefix: string;
  readonly expiry: i64;
  readonly matches: nsIArray;
}

interface nsIUrlClassifierCacheInfo extends nsISupports {
  readonly table: string;
  readonly entries: nsIArray;
}

type nsIUrlClassifierGetCacheCallback = Callable<{
  onGetCacheComplete(info: nsIUrlClassifierCacheInfo): void;
}>

interface nsIUrlClassifierInfo extends nsISupports {
  getCacheInfo(table: string, callback: nsIUrlClassifierGetCacheCallback): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/url-classifier/nsIUrlClassifierPrefixSet.idl

interface nsIUrlClassifierPrefixSet extends nsISupports {
  init(aName: string): void;
  setPrefixes(aPrefixes: u32[], aLength: u32): void;
  getPrefixes(aCount: OutParam<u32>): u32[];
  contains(aPrefix: u32): boolean;
  isEmpty(): boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/url-classifier/nsIUrlClassifierRemoteSettingsService.idl

interface nsIUrlClassifierRemoteSettingsService extends nsISupports {
  fetchList(aPayload: string, aListener: nsIStreamListener): void;
  clear(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/url-classifier/nsIUrlClassifierStreamUpdater.idl

interface nsIUrlClassifierStreamUpdater extends nsISupports {
  downloadUpdates(aRequestTables: string, aRequestPayload: string, aIsPostRequest: boolean, aUpdateUrl: string, aSuccessCallback: nsIUrlClassifierCallback, aUpdateErrorCallback: nsIUrlClassifierCallback, aDownloadErrorCallback: nsIUrlClassifierCallback): boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/url-classifier/nsIUrlClassifierUtils.idl

interface nsIUrlClassifierParseFindFullHashCallback extends nsISupports {
  onCompleteHashFound(aCompleteHash: string, aTableNames: string, aPerHashCacheDuration: u32): void;
  onResponseParsed(aMinWaitDuration: u32, aNegCacheDuration: u32): void;
}

interface nsIUrlClassifierUtils extends nsISupports {
  getKeyForURI(uri: nsIURI): string;
  getProvider(tableName: string): string;
  getTelemetryProvider(tableName: string): string;
  getProtocolVersion(provider: string): string;
  convertThreatTypeToListNames(threatType: u32): string;
  convertListNameToThreatType(listName: string): u32;
  makeUpdateRequestV4(aListNames: string[], aStatesBase64: string[]): string;
  makeFindFullHashRequestV4(aListNames: string[], aListStatesBase64: string[], aPrefixes: string[]): string;
  makeThreatHitReport(aChannel: nsIChannel, aListName: string, aHashBase64: string): string;
  parseFindFullHashResponseV4(aResponse: string, aCallback: nsIUrlClassifierParseFindFullHashCallback): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/url-classifier/nsIUrlListManager.idl

interface nsIUrlListManager extends nsISupports {
  getGethashUrl(tableName: string): string;
  getUpdateUrl(tableName: string): string;
  registerTable(tableName: string, providerName: string, updateUrl: string, gethashUrl: string): boolean;
  unregisterTable(tableName: string): void;
  enableUpdate(tableName: string): void;
  disableAllUpdates(): void;
  disableUpdate(tableName: string): void;
  maybeToggleUpdateChecking(): void;
  checkForUpdates(updateUrl: string): boolean;
  forceUpdates(tableNames: string): boolean;
  getBackOffTime(provider: string): u64;
  isRegistered(): boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/urlformatter/nsIURLFormatter.idl

interface nsIURLFormatter extends nsISupports {
  formatURL(aFormat: string): string;
  formatURLPref(aPref: string): string;
  trimSensitiveURLs(aMsg: string): string;
}

// https://searchfox.org/mozilla-central/source/ipc/glue/test/utility_process_xpcom/nsIUtilityProcessTest.idl

interface nsIUtilityProcessTest extends nsISupports {
  startProcess(actorsToAdd?: string[]): Promise<any>;
  untilChildProcessDead(pid: u32): Promise<any>;
  noteIntentionalCrash(pid: u32): void;
  stopProcess(utilityActorName?: string): void;
  testTelemetryProbes(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/browser/nsIWebBrowser.idl

interface nsIWebBrowser extends nsISupports {
  containerWindow: nsIWebBrowserChrome;
  readonly contentDOMWindow: mozIDOMWindowProxy;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/browser/nsIWebBrowserChrome.idl

interface nsIWebBrowserChrome extends nsISupports {
  readonly CHROME_DEFAULT?: 1;
  readonly CHROME_WINDOW_BORDERS?: 2;
  readonly CHROME_WINDOW_CLOSE?: 4;
  readonly CHROME_WINDOW_RESIZE?: 8;
  readonly CHROME_MENUBAR?: 16;
  readonly CHROME_TOOLBAR?: 32;
  readonly CHROME_LOCATIONBAR?: 64;
  readonly CHROME_STATUSBAR?: 128;
  readonly CHROME_PERSONAL_TOOLBAR?: 256;
  readonly CHROME_SCROLLBARS?: 512;
  readonly CHROME_TITLEBAR?: 1024;
  readonly CHROME_EXTRA?: 2048;
  readonly CHROME_ALL?: 4094;
  readonly CHROME_WINDOW_MINIMIZE?: 16384;
  readonly CHROME_ALERT?: 32768;
  readonly CHROME_PRIVATE_WINDOW?: 65536;
  readonly CHROME_NON_PRIVATE_WINDOW?: 131072;
  readonly CHROME_PRIVATE_LIFETIME?: 262144;
  readonly CHROME_ALWAYS_ON_TOP?: 524288;
  readonly CHROME_REMOTE_WINDOW?: 1048576;
  readonly CHROME_FISSION_WINDOW?: 2097152;
  readonly CHROME_SUPPRESS_ANIMATION?: 16777216;
  readonly CHROME_CENTER_SCREEN?: 134217728;
  readonly CHROME_DEPENDENT?: 268435456;
  readonly CHROME_MODAL?: 536870912;
  readonly CHROME_OPENAS_DIALOG?: 1073741824;
  readonly CHROME_OPENAS_CHROME?: 2147483648;
  readonly CHROME_MINIMAL_POPUP?: 18126;

  setLinkStatus(status: string): void;
  chromeFlags: u32;
  showAsModal(): void;
  isWindowModal(): boolean;
  blur(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/browser/nsIWebBrowserPrint.idl

interface nsIWebBrowserPrint extends nsISupports {
  readonly PRINTPREVIEW_GOTO_PAGENUM?: 0;
  readonly PRINTPREVIEW_PREV_PAGE?: 1;
  readonly PRINTPREVIEW_NEXT_PAGE?: 2;
  readonly PRINTPREVIEW_HOME?: 3;
  readonly PRINTPREVIEW_END?: 4;

  readonly doingPrint: boolean;
  readonly doingPrintPreview: boolean;
  readonly rawNumPages: i32;
  readonly printPreviewNumPages: i32;
  readonly printPreviewCurrentPageNumber: i32;
  closeWindowAfterPrint: boolean;
  printPreviewScrollToPage(aNavType: i16, aPageNum: i32): void;
  exitPrintPreview(): void;
}

// https://searchfox.org/mozilla-central/source/dom/webbrowserpersist/nsIWebBrowserPersist.idl

interface nsIWebBrowserPersist extends nsICancelable {
  readonly PERSIST_FLAGS_NONE?: 0;
  readonly PERSIST_FLAGS_FROM_CACHE?: 1;
  readonly PERSIST_FLAGS_BYPASS_CACHE?: 2;
  readonly PERSIST_FLAGS_IGNORE_REDIRECTED_DATA?: 4;
  readonly PERSIST_FLAGS_IGNORE_IFRAMES?: 8;
  readonly PERSIST_FLAGS_NO_CONVERSION?: 16;
  readonly PERSIST_FLAGS_REPLACE_EXISTING_FILES?: 32;
  readonly PERSIST_FLAGS_NO_BASE_TAG_MODIFICATIONS?: 64;
  readonly PERSIST_FLAGS_FIXUP_ORIGINAL_DOM?: 128;
  readonly PERSIST_FLAGS_FIXUP_LINKS_TO_DESTINATION?: 256;
  readonly PERSIST_FLAGS_DONT_FIXUP_LINKS?: 512;
  readonly PERSIST_FLAGS_SERIALIZE_OUTPUT?: 1024;
  readonly PERSIST_FLAGS_DONT_CHANGE_FILENAMES?: 2048;
  readonly PERSIST_FLAGS_FAIL_ON_BROKEN_LINKS?: 4096;
  readonly PERSIST_FLAGS_CLEANUP_ON_FAILURE?: 8192;
  readonly PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION?: 16384;
  readonly PERSIST_FLAGS_APPEND_TO_FILE?: 32768;
  readonly PERSIST_FLAGS_DISABLE_HTTPS_ONLY?: 65536;
  readonly PERSIST_STATE_READY?: 1;
  readonly PERSIST_STATE_SAVING?: 2;
  readonly PERSIST_STATE_FINISHED?: 3;
  readonly ENCODE_FLAGS_SELECTION_ONLY?: 1;
  readonly ENCODE_FLAGS_FORMATTED?: 2;
  readonly ENCODE_FLAGS_RAW?: 4;
  readonly ENCODE_FLAGS_BODY_ONLY?: 8;
  readonly ENCODE_FLAGS_PREFORMATTED?: 16;
  readonly ENCODE_FLAGS_WRAP?: 32;
  readonly ENCODE_FLAGS_FORMAT_FLOWED?: 64;
  readonly ENCODE_FLAGS_ABSOLUTE_LINKS?: 128;
  readonly ENCODE_FLAGS_CR_LINEBREAKS?: 512;
  readonly ENCODE_FLAGS_LF_LINEBREAKS?: 1024;
  readonly ENCODE_FLAGS_NOSCRIPT_CONTENT?: 2048;
  readonly ENCODE_FLAGS_NOFRAMES_CONTENT?: 4096;
  readonly ENCODE_FLAGS_ENCODE_BASIC_ENTITIES?: 8192;

  persistFlags: u32;
  readonly currentState: u32;
  readonly result: nsresult;
  progressListener: nsIWebProgressListener;
  saveURI(aURI: nsIURI, aTriggeringPrincipal: nsIPrincipal, aCacheKey: u32, aReferrerInfo: nsIReferrerInfo, aCookieJarSettings: nsICookieJarSettings, aPostData: nsIInputStream, aExtraHeaders: string, aFile: nsISupports, aContentPolicyType: nsContentPolicyType, aIsPrivate: boolean): void;
  saveChannel(aChannel: nsIChannel, aFile: nsISupports): void;
  saveDocument(aDocument: nsISupports, aFile: nsISupports, aDataPath: nsISupports, aOutputContentType: string, aEncodingFlags: u32, aWrapColumn: u32): void;
  cancelSave(): void;
}

// https://searchfox.org/mozilla-central/source/dom/webbrowserpersist/nsIWebBrowserPersistDocument.idl

interface nsIWebBrowserPersistURIMap extends nsISupports {
  readonly numMappedURIs: u32;
  getURIMapping(aIndex: u32, aMapFrom: OutParam<string>, aMapTo: OutParam<string>): void;
  readonly targetBaseURI: string;
}

interface nsIWebBrowserPersistDocument extends nsISupports {
  readonly isClosed: boolean;
  readonly isPrivate: boolean;
  readonly documentURI: string;
  readonly baseURI: string;
  readonly contentType: string;
  readonly characterSet: string;
  readonly title: string;
  readonly referrerInfo: nsIReferrerInfo;
  readonly cookieJarSettings: nsICookieJarSettings;
  readonly contentDisposition: string;
  readonly postData: nsIInputStream;
  readonly principal: nsIPrincipal;
  readonly cacheKey: u32;
  persistFlags: u32;
  readResources(aVisitor: nsIWebBrowserPersistResourceVisitor): void;
  writeContent(aStream: nsIOutputStream, aURIMap: nsIWebBrowserPersistURIMap, aRequestedContentType: string, aEncoderFlags: u32, aWrapColumn: u32, aCompletion: nsIWebBrowserPersistWriteCompletion): void;
}

interface nsIWebBrowserPersistResourceVisitor extends nsISupports {
  visitResource(aDocument: nsIWebBrowserPersistDocument, aURI: string, aContentPolicyType: nsContentPolicyType): void;
  visitDocument(aDocument: nsIWebBrowserPersistDocument, aSubDocument: nsIWebBrowserPersistDocument): void;
  visitBrowsingContext(aDocument: nsIWebBrowserPersistDocument, aContext: BrowsingContext): void;
  endVisit(aDocument: nsIWebBrowserPersistDocument, aStatus: nsresult): void;
}

type nsIWebBrowserPersistWriteCompletion = Callable<{
  onFinish(aDocument: nsIWebBrowserPersistDocument, aStream: nsIOutputStream, aContentType: string, aStatus: nsresult): void;
}>

interface nsIWebBrowserPersistDocumentReceiver extends nsISupports {
  onDocumentReady(aDocument: nsIWebBrowserPersistDocument): void;
  onError(aFailure: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/extensions/extIWebNavigation.idl

interface extIWebNavigation extends nsISupports {
  onDocumentChange(bc: BrowsingContext, transitionData: any, location: nsIURI): void;
  onHistoryChange(bc: BrowsingContext, transitionData: any, location: nsIURI, isHistoryStateUpdated: boolean, isReferenceFragmentUpdated: boolean): void;
  onStateChange(bc: BrowsingContext, requestURI: nsIURI, status: nsresult, stateFlags: u32): void;
  onCreatedNavigationTarget(bc: BrowsingContext, sourceBC: BrowsingContext, url: string): void;
  onDOMContentLoaded(bc: BrowsingContext, documentURI: nsIURI): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/extensions/mozIExtensionAPIRequestHandling.idl

interface mozIExtensionServiceWorkerInfo extends nsISupports {
  readonly principal: nsIPrincipal;
  readonly scriptURL: string;
  readonly clientInfoId: string;
  readonly descriptorId: u64;
}

}  // global

declare enum mozIExtensionListenerCallOptions_APIObjectType {
  NONE = 0,
  RUNTIME_PORT = 1,
}

declare enum mozIExtensionListenerCallOptions_CallbackType {
  CALLBACK_NONE = 0,
  CALLBACK_SEND_RESPONSE = 1,
}

declare global {

namespace mozIExtensionListenerCallOptions {
  type APIObjectType = mozIExtensionListenerCallOptions_APIObjectType;
  type CallbackType = mozIExtensionListenerCallOptions_CallbackType;
}

interface mozIExtensionListenerCallOptions extends nsISupports, Enums<typeof mozIExtensionListenerCallOptions_APIObjectType & typeof mozIExtensionListenerCallOptions_CallbackType> {
  readonly apiObjectType: mozIExtensionListenerCallOptions.APIObjectType;
  readonly apiObjectDescriptor: any;
  readonly apiObjectPrepended: boolean;
  callbackType: mozIExtensionListenerCallOptions.CallbackType;
}

interface mozIExtensionEventListener extends nsISupports {
  callListener(args: any[], listenerCallOptions?: mozIExtensionListenerCallOptions): Promise<any>;
}

}  // global

declare enum mozIExtensionAPIRequest_RequestType {
  CALL_FUNCTION = 0,
  CALL_FUNCTION_NO_RETURN = 1,
  CALL_FUNCTION_ASYNC = 2,
  ADD_LISTENER = 3,
  REMOVE_LISTENER = 4,
  GET_PROPERTY = 5,
}

declare global {

namespace mozIExtensionAPIRequest {
  type RequestType = mozIExtensionAPIRequest_RequestType;
}

interface mozIExtensionAPIRequest extends nsISupports, Enums<typeof mozIExtensionAPIRequest_RequestType> {
  toString(): string;
  readonly requestType: string;
  readonly apiNamespace: string;
  readonly apiName: string;
  readonly apiObjectType: string;
  readonly apiObjectId: string;
  readonly args: any;
  normalizedArgs: any;
  readonly callerSavedFrame: any;
  readonly serviceWorkerInfo: mozIExtensionServiceWorkerInfo;
  readonly eventListener: mozIExtensionEventListener;
}

}  // global

declare enum mozIExtensionAPIRequestResult_ResultType {
  RETURN_VALUE = 0,
  EXTENSION_ERROR = 1,
}

declare global {

namespace mozIExtensionAPIRequestResult {
  type ResultType = mozIExtensionAPIRequestResult_ResultType;
}

interface mozIExtensionAPIRequestResult extends nsISupports, Enums<typeof mozIExtensionAPIRequestResult_ResultType> {
  readonly type: mozIExtensionAPIRequestResult.ResultType;
  readonly value: any;
}

interface mozIExtensionAPIRequestHandler extends nsISupports {
  handleAPIRequest(extension: nsISupports, apiRequest: mozIExtensionAPIRequest): mozIExtensionAPIRequestResult;
  initExtensionWorker(extension: nsISupports, serviceWorkerInfo: mozIExtensionServiceWorkerInfo): void;
  onExtensionWorkerLoaded(extension: nsISupports, serviceWorkerDescriptorId: u64): void;
  onExtensionWorkerDestroyed(extension: nsISupports, serviceWorkerDescriptorId: u64): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/extensions/mozIExtensionProcessScript.idl

interface mozIExtensionProcessScript extends nsISupports {
  preloadContentScript(contentScript: nsISupports): void;
  loadContentScript(contentScript: WebExtensionContentScript, window: mozIDOMWindow): Promise<any>;
  initExtensionDocument(extension: nsISupports, doc: Document, privileged: boolean): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/extensions/nsINativeMessagingPortal.idl

interface nsINativeMessagingPortal extends nsISupports {
  shouldUse(): boolean;
  readonly available: Promise<any>;
  createSession(aApplication: string): Promise<any>;
  closeSession(aHandle: string): Promise<any>;
  getManifest(aHandle: string, aName: string, aExtension: string): Promise<any>;
  start(aHandle: string, aName: string, aExtension: string): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/dom/media/webvtt/nsIWebVTTListener.idl

interface nsIWebVTTListener extends nsISupports {
  onCue(cue: any): void;
  onRegion(region: any): void;
  onParsingError(errorCode: i32): void;
}

// https://searchfox.org/mozilla-central/source/dom/media/webvtt/nsIWebVTTParserWrapper.idl

interface nsIWebVTTParserWrapper extends nsISupports {
  loadParser(window: mozIDOMWindow): void;
  parse(data: string): void;
  flush(): void;
  watch(callback: nsIWebVTTListener): void;
  cancel(): void;
  convertCueToDOMTree(window: mozIDOMWindow, cue: nsISupports): DocumentFragment;
  processCues(window: mozIDOMWindow, cues: nsIVariant, overlay: nsISupports, controls: nsISupports): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIAppShell.idl

// https://searchfox.org/mozilla-central/source/widget/nsIBaseWindow.idl

interface nsIBaseWindow extends nsISupports {
  readonly eRepaint?: 1;
  readonly eDelayResize?: 2;

  destroy(): void;
  setPosition(x: i32, y: i32): void;
  setPositionDesktopPix(x: i32, y: i32): void;
  getPosition(x: OutParam<i32>, y: OutParam<i32>): void;
  setSize(cx: i32, cy: i32, fRepaint: boolean): void;
  getSize(cx: OutParam<i32>, cy: OutParam<i32>): void;
  setPositionAndSize(x: i32, y: i32, cx: i32, cy: i32, flags: u32): void;
  getPositionAndSize(x: OutParam<i32>, y: OutParam<i32>, cx: OutParam<i32>, cy: OutParam<i32>): void;
  repaint(force: boolean): void;
  readonly nativeHandle: string;
  visibility: boolean;
  enabled: boolean;
  readonly devicePixelsPerDesktopPixel: double;
  title: string;
}

// https://searchfox.org/mozilla-central/source/widget/nsIBidiKeyboard.idl

interface nsIBidiKeyboard extends nsISupports {
  reset(): void;
  isLangRTL(): boolean;
  readonly haveBidiKeyboards: boolean;
}

// https://searchfox.org/mozilla-central/source/widget/nsIClipboard.idl

interface nsIAsyncSetClipboardData extends nsISupports {
  setData(aTransferable: nsITransferable, aOwner?: nsIClipboardOwner): void;
  abort(aReason: nsresult): void;
}

type nsIAsyncClipboardRequestCallback = Callable<{
  onComplete(aResult: nsresult): void;
}>

interface nsIClipboardDataSnapshot extends nsISupports {
  readonly valid: boolean;
  readonly flavorList: string[];
  getData(aTransferable: nsITransferable, aCallback: nsIAsyncClipboardRequestCallback): void;
  getDataSync(aTransferable: nsITransferable): void;
}

interface nsIClipboardGetDataSnapshotCallback extends nsISupports {
  onSuccess(aClipboardDataSnapshot: nsIClipboardDataSnapshot): void;
  onError(aResult: nsresult): void;
}

}  // global

declare enum nsIClipboard_ClipboardType {
  kSelectionClipboard = 0,
  kGlobalClipboard = 1,
  kFindClipboard = 2,
  kSelectionCache = 3,
}

declare global {

namespace nsIClipboard {
  type ClipboardType = nsIClipboard_ClipboardType;
}

interface nsIClipboard extends nsISupports, Enums<typeof nsIClipboard_ClipboardType> {
  setData(aTransferable: nsITransferable, anOwner: nsIClipboardOwner, aWhichClipboard: nsIClipboard.ClipboardType, aSettingWindowContext?: WindowContext): void;
  asyncSetData(aWhichClipboard: nsIClipboard.ClipboardType, aSettingWindowContext?: WindowContext, aCallback?: nsIAsyncClipboardRequestCallback): nsIAsyncSetClipboardData;
  getData(aTransferable: nsITransferable, aWhichClipboard: nsIClipboard.ClipboardType, aRequestingWindowContext?: WindowContext): void;
  getDataSnapshot(aFlavorList: string[], aWhichClipboard: nsIClipboard.ClipboardType, aRequestingWindowContext: WindowContext, aRequestingPrincipal: nsIPrincipal, aCallback: nsIClipboardGetDataSnapshotCallback): void;
  getDataSnapshotSync(aFlavorList: string[], aWhichClipboard: nsIClipboard.ClipboardType, aRequestingWindowContext?: WindowContext): nsIClipboardDataSnapshot;
  emptyClipboard(aWhichClipboard: nsIClipboard.ClipboardType): void;
  hasDataMatchingFlavors(aFlavorList: string[], aWhichClipboard: nsIClipboard.ClipboardType): boolean;
  isClipboardTypeSupported(aWhichClipboard: nsIClipboard.ClipboardType): boolean;
}

// https://searchfox.org/mozilla-central/source/widget/nsIClipboardHelper.idl

}  // global

declare enum nsIClipboardHelper_SensitiveData {
  NotSensitive = 0,
  Sensitive = 1,
}

declare global {

namespace nsIClipboardHelper {
  type SensitiveData = nsIClipboardHelper_SensitiveData;
}

interface nsIClipboardHelper extends nsISupports, Enums<typeof nsIClipboardHelper_SensitiveData> {
  copyStringToClipboard(aString: string, aClipboardID: nsIClipboard.ClipboardType, aSettingWindowContext?: WindowContext, aSensitive?: nsIClipboardHelper.SensitiveData): void;
  copyString(aString: string, aSettingWindowContext?: WindowContext, aSensitive?: nsIClipboardHelper.SensitiveData): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIClipboardOwner.idl

interface nsIClipboardOwner extends nsISupports {
  LosingOwnership(aTransferable: nsITransferable): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIColorPicker.idl

interface nsIColorPickerShownCallback extends nsISupports {
  update(color: string): void;
  done(color: string): void;
}

interface nsIColorPicker extends nsISupports {
  init(browsingContext: BrowsingContext, title: string, initialColor: string, defaultColors: string[]): void;
  open(aColorPickerShownCallback: nsIColorPickerShownCallback): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIDisplayInfo.idl

interface nsIDisplayInfo extends nsISupports {
  readonly id: i32;
  readonly connected: boolean;
}

// https://searchfox.org/mozilla-central/source/widget/nsIDragService.idl

interface nsIDragService extends nsISupports {
  readonly DRAGDROP_ACTION_NONE?: 0;
  readonly DRAGDROP_ACTION_COPY?: 1;
  readonly DRAGDROP_ACTION_MOVE?: 2;
  readonly DRAGDROP_ACTION_LINK?: 4;
  readonly DRAGDROP_ACTION_UNINITIALIZED?: 64;

  getCurrentSession(aWidgetProvider?: nsISupports): nsIDragSession;
  startDragSessionForTests(aWidgetProvider: nsISupports, aAllowedEffect: u32): void;
  suppress(): void;
  unsuppress(): void;
  getMockDragController(): nsIMockDragServiceController;
  readonly isMockService: boolean;
  neverAllowSessionIsSynthesizedForTests: boolean;
}

// https://searchfox.org/mozilla-central/source/widget/nsIDragSession.idl

interface nsIDragSession extends nsISupports {
  canDrop: boolean;
  onlyChromeDrop: boolean;
  dragAction: u32;
  readonly numDropItems: u32;
  sourceWindowContext: WindowContext;
  sourceTopWindowContext: WindowContext;
  readonly sourceNode: Node;
  triggeringPrincipal: nsIPrincipal;
  csp: nsIContentSecurityPolicy;
  dataTransfer: DataTransfer;
  getData(aTransferable: nsITransferable, aItemIndex: u32): void;
  isDataFlavorSupported(aDataFlavor: string): boolean;
  userCancelled(): void;
  dragEventDispatchedToChildProcess(): void;
  updateDragEffect(): void;
  updateDragImage(aImage: Node, aImageX: i32, aImageY: i32): void;
  setDragEndPoint(aScreenX: i32, aScreenY: i32): void;
  setDragEndPointForTests(aScreenX: float, aScreenY: float): void;
  endDragSession(aDoneDrag: boolean, aKeyModifiers?: u32): void;
  sendStoreDropTargetAndDelayEndDragSession(aEvent: DragEvent): void;
  sendDispatchToDropTargetAndResumeEndDragSession(aShouldDrop: boolean, aAllowedFiles: nsIFile[]): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIFilePicker.idl

}  // global

declare enum nsIFilePicker_Mode {
  modeOpen = 0,
  modeSave = 1,
  modeGetFolder = 2,
  modeOpenMultiple = 3,
}

declare enum nsIFilePicker_ResultCode {
  returnOK = 0,
  returnCancel = 1,
  returnReplace = 2,
}

declare enum nsIFilePicker_CaptureTarget {
  captureNone = 0,
  captureDefault = 1,
  captureUser = 2,
  captureEnv = 3,
}

declare global {

namespace nsIFilePicker {
  type Mode = nsIFilePicker_Mode;
  type ResultCode = nsIFilePicker_ResultCode;
  type CaptureTarget = nsIFilePicker_CaptureTarget;
}

interface nsIFilePicker extends nsISupports, Enums<typeof nsIFilePicker_Mode & typeof nsIFilePicker_ResultCode & typeof nsIFilePicker_CaptureTarget> {
  readonly filterAll?: 1;
  readonly filterHTML?: 2;
  readonly filterText?: 4;
  readonly filterImages?: 8;
  readonly filterXML?: 16;
  readonly filterXUL?: 32;
  readonly filterApps?: 64;
  readonly filterAllowURLs?: 128;
  readonly filterAudio?: 256;
  readonly filterVideo?: 512;
  readonly filterPDF?: 1024;

  init(browsingContext: BrowsingContext, title: string, mode: nsIFilePicker.Mode): void;
  isModeSupported(mode: nsIFilePicker.Mode): Promise<any>;
  appendFilters(filterMask: i32): void;
  appendFilter(title: string, filter: string): void;
  appendRawFilter(filter: string): void;
  defaultString: string;
  defaultExtension: string;
  filterIndex: i32;
  displayDirectory: nsIFile;
  displaySpecialDirectory: string;
  readonly file: nsIFile;
  readonly fileURL: nsIURI;
  readonly files: nsISimpleEnumerator;
  readonly domFileOrDirectory: nsISupports;
  readonly domFileOrDirectoryEnumerator: nsISimpleEnumerator;
  addToRecentDocs: boolean;
  open(aFilePickerShownCallback: nsIFilePickerShownCallback): void;
  readonly mode: nsIFilePicker.Mode;
  okButtonLabel: string;
  capture: nsIFilePicker.CaptureTarget;
  readonly domFilesInWebKitDirectory: nsISimpleEnumerator;
}

type nsIFilePickerShownCallback = Callable<{
  done(aResult: nsIFilePicker.ResultCode): void;
}>

// https://searchfox.org/mozilla-central/source/widget/nsIFormatConverter.idl

interface nsIFormatConverter extends nsISupports {
  getInputDataFlavors(): string[];
  getOutputDataFlavors(): string[];
  canConvert(aFromDataFlavor: string, aToDataFlavor: string): boolean;
  convert(aFromDataFlavor: string, aFromData: nsISupports, aToDataFlavor: string, aToData: OutParam<nsISupports>): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIGfxInfo.idl

}  // global

declare enum nsIGfxInfo_FontVisibilityDeviceDetermination {
  Unassigned = 0,
  Unknown_Platform = 1,
  Windows_Platform = 2,
  MacOS_Unknown = 3,
  Android_Unknown_Release_Version = 4,
  Android_Unknown_Peloton = 5,
  Android_Unknown_vbox = 6,
  Android_Unknown_mitv = 7,
  Android_Chromebook = 8,
  Android_Amazon = 9,
  Android_sub_9 = 10,
  Android_9_11 = 11,
  Android_12_plus = 12,
  Linux_Unknown = 13,
  Linux_Ubuntu_any = 14,
  Linux_Ubuntu_20 = 15,
  Linux_Ubuntu_22 = 16,
  Linux_Fedora_any = 17,
  Linux_Fedora_38 = 18,
  Linux_Fedora_39 = 19,
  MacOS_13_plus = 20,
  MacOS_sub_13 = 21,
}

declare global {

namespace nsIGfxInfo {
  type FontVisibilityDeviceDetermination = nsIGfxInfo_FontVisibilityDeviceDetermination;
}

interface nsIGfxInfo extends nsISupports, Enums<typeof nsIGfxInfo_FontVisibilityDeviceDetermination> {
  readonly D2DEnabled: boolean;
  readonly DWriteEnabled: boolean;
  readonly EmbeddedInFirefoxReality: boolean;
  readonly AzureCanvasBackend: string;
  readonly AzureContentBackend: string;
  readonly usingGPUProcess: boolean;
  readonly usingRemoteCanvas: boolean;
  readonly usingAcceleratedCanvas: boolean;
  readonly hasBattery: boolean;
  readonly DWriteVersion: string;
  readonly cleartypeParameters: string;
  readonly textScaleFactor: float;
  readonly windowProtocol: string;
  readonly testType: string;
  readonly ContentBackend: string;
  readonly isHeadless: boolean;
  readonly TargetFrameRate: u32;
  readonly CodecSupportInfo: string;
  readonly fontVisibilityDetermination: nsIGfxInfo.FontVisibilityDeviceDetermination;
  readonly fontVisibilityDeterminationStr: string;
  readonly adapterDescription: string;
  readonly adapterDescription2: string;
  readonly adapterDriver: string;
  readonly adapterDriver2: string;
  readonly adapterVendorID: string;
  readonly adapterVendorID2: string;
  readonly adapterDeviceID: string;
  readonly adapterDeviceID2: string;
  readonly adapterSubsysID: string;
  readonly adapterSubsysID2: string;
  readonly adapterRAM: u32;
  readonly adapterRAM2: u32;
  readonly adapterDriverVendor: string;
  readonly adapterDriverVendor2: string;
  readonly adapterDriverVersion: string;
  readonly adapterDriverVersion2: string;
  readonly adapterDriverDate: string;
  readonly adapterDriverDate2: string;
  readonly isGPU2Active: boolean;
  readonly drmRenderDevice: string;
  getMonitors(): any;
  getFailures(indices: OutParam<i32[]>): string[];
  getFeatureStatus(aFeature: i32, aFailureId?: OutParam<string>): i32;
  getFeatureStatusStr(aFeature: string, aFailureId?: OutParam<string>): string;
  getFeatureSuggestedDriverVersion(aFeature: i32): string;
  getFeatureSuggestedDriverVersionStr(aFeature: string): string;
  getInfo(): any;
  getFeatureLog(): any;
  getFeatures(): any;
  getActiveCrashGuards(): any;
  controlGPUProcessForXPCShell(aEnable: boolean): boolean;
  killGPUProcessForTests(): void;
  crashGPUProcessForTests(): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIGfxInfoDebug.idl

interface nsIGfxInfoDebug extends nsISupports {
  spoofVendorID(aVendorID: string): void;
  spoofDeviceID(aDeviceID: string): void;
  spoofDriverVersion(aDriverVersion: string): void;
  spoofOSVersion(aVersion: u32): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIMockDragServiceController.idl

}  // global

declare enum nsIMockDragServiceController_EventType {
  eDragEnter = 0,
  eDragOver = 1,
  eDragExit = 2,
  eDrop = 3,
  eMouseDown = 4,
  eMouseMove = 5,
  eMouseUp = 6,
}

declare global {

namespace nsIMockDragServiceController {
  type EventType = nsIMockDragServiceController_EventType;
}

interface nsIMockDragServiceController extends nsISupports, Enums<typeof nsIMockDragServiceController_EventType> {
  readonly mockDragService: nsIDragService;
  sendEvent(aBC: BrowsingContext, aEventType: nsIMockDragServiceController.EventType, aScreenX: i32, aScreenY: i32, aKeyModifiers?: u32): void;
  cancelDrag(aKeyModifiers?: u32): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIPaper.idl

interface nsIPaper extends nsISupports {
  readonly id: string;
  readonly name: string;
  readonly width: double;
  readonly height: double;
  readonly unwriteableMargin: Promise<any>;
}

// https://searchfox.org/mozilla-central/source/widget/nsIPaperMargin.idl

interface nsIPaperMargin extends nsISupports {
  readonly top: double;
  readonly right: double;
  readonly bottom: double;
  readonly left: double;
}

// https://searchfox.org/mozilla-central/source/widget/nsIPrintDialogService.idl

interface nsIPrintDialogService extends nsISupports {
  init(): void;
  showPrintDialog(aParent: mozIDOMWindowProxy, aHaveSelection: boolean, aPrintSettings: nsIPrintSettings): void;
  showPageSetupDialog(aParent: mozIDOMWindowProxy, aPrintSettings: nsIPrintSettings): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIPrintSettings.idl

}  // global

declare enum nsIPrintSettings_OutputDestinationType {
  kOutputDestinationPrinter = 0,
  kOutputDestinationFile = 1,
  kOutputDestinationStream = 2,
}

declare global {

namespace nsIPrintSettings {
  type OutputDestinationType = nsIPrintSettings_OutputDestinationType;
}

interface nsIPrintSettings extends nsISupports, Enums<typeof nsIPrintSettings_OutputDestinationType> {
  readonly kInitSaveHeaderLeft?: 2;
  readonly kInitSaveHeaderCenter?: 4;
  readonly kInitSaveHeaderRight?: 8;
  readonly kInitSaveFooterLeft?: 16;
  readonly kInitSaveFooterCenter?: 32;
  readonly kInitSaveFooterRight?: 64;
  readonly kInitSaveBGColors?: 128;
  readonly kInitSaveBGImages?: 256;
  readonly kInitSavePaperSize?: 512;
  readonly kInitSaveDuplex?: 2048;
  readonly kInitSaveUnwriteableMargins?: 16384;
  readonly kInitSaveEdges?: 32768;
  readonly kInitSaveReversed?: 65536;
  readonly kInitSaveInColor?: 131072;
  readonly kInitSaveOrientation?: 262144;
  readonly kInitSavePrinterName?: 1048576;
  readonly kInitSavePrintToFile?: 2097152;
  readonly kInitSaveToFileName?: 4194304;
  readonly kInitSavePageDelay?: 8388608;
  readonly kInitSaveMargins?: 16777216;
  readonly kInitSaveShrinkToFit?: 134217728;
  readonly kInitSaveScaling?: 268435456;
  readonly kInitSaveAll?: 4294967295;
  readonly kGlobalSettings?: 134447614;
  readonly kPrintDialogPersistSettings?: 428313598;
  readonly kJustLeft?: 0;
  readonly kJustCenter?: 1;
  readonly kJustRight?: 2;
  readonly kPaperSizeInches?: 0;
  readonly kPaperSizeMillimeters?: 1;
  readonly kPortraitOrientation?: 0;
  readonly kLandscapeOrientation?: 1;
  readonly kOutputFormatNative?: 0;
  readonly kOutputFormatPDF?: 2;
  readonly kDuplexNone?: 0;
  readonly kDuplexFlipOnLongEdge?: 1;
  readonly kDuplexFlipOnShortEdge?: 2;

  GetEffectivePageSize(aWidth: OutParam<double>, aHeight: OutParam<double>): void;
  clone(): nsIPrintSettings;
  assign(aPS: nsIPrintSettings): void;
  equivalentTo(aPrintSettings: nsIPrintSettings): boolean;
  edgeTop: double;
  edgeLeft: double;
  edgeBottom: double;
  edgeRight: double;
  marginTop: double;
  marginLeft: double;
  marginBottom: double;
  marginRight: double;
  unwriteableMarginTop: double;
  unwriteableMarginLeft: double;
  unwriteableMarginBottom: double;
  unwriteableMarginRight: double;
  scaling: double;
  printBGColors: boolean;
  printBGImages: boolean;
  honorPageRuleMargins: boolean;
  usePageRuleSizeAsPaperSize: boolean;
  ignoreUnwriteableMargins: boolean;
  showMarginGuides: boolean;
  printSelectionOnly: boolean;
  title: string;
  docURL: string;
  headerStrLeft: string;
  headerStrCenter: string;
  headerStrRight: string;
  footerStrLeft: string;
  footerStrCenter: string;
  footerStrRight: string;
  printSilent: boolean;
  shrinkToFit: boolean;
  paperId: string;
  paperWidth: double;
  paperHeight: double;
  paperSizeUnit: i16;
  printReversed: boolean;
  printInColor: boolean;
  orientation: i32;
  numCopies: i32;
  numPagesPerSheet: i32;
  outputDestination: nsIPrintSettings.OutputDestinationType;
  outputFormat: i16;
  printerName: string;
  toFileName: string;
  outputStream: nsIOutputStream;
  printPageDelay: i32;
  resolution: i32;
  duplex: i32;
  isInitializedFromPrinter: boolean;
  isInitializedFromPrefs: boolean;
  pageRanges: i32[];
}

// https://searchfox.org/mozilla-central/source/widget/nsIPrintSettingsService.idl

interface nsIPrintSettingsService extends nsISupports {
  createNewPrintSettings(): nsIPrintSettings;
  readonly lastUsedPrinterName: string;
  initPrintSettingsFromPrinter(aPrinterName: string, aPrintSettings: nsIPrintSettings): void;
  initPrintSettingsFromPrefs(aPrintSettings: nsIPrintSettings, aUsePrinterNamePrefix: boolean, aFlags: u32): void;
  maybeSavePrintSettingsToPrefs(aPrintSettings: nsIPrintSettings, aFlags: u32): void;
  maybeSaveLastUsedPrinterNameToPrefs(aPrinterName: string): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsIPrinter.idl

interface nsIPrinterInfo extends nsISupports {
  readonly paperList: nsIPaper[];
  readonly defaultSettings: nsIPrintSettings;
}

interface nsIPrinter extends nsISupports {
  readonly name: string;
  readonly systemName: string;
  readonly printerInfo: Promise<any>;
  copyFromWithValidation(aSettingsToCopyFrom: nsIPrintSettings): Promise<any>;
  readonly supportsDuplex: Promise<any>;
  readonly supportsColor: Promise<any>;
  readonly supportsMonochrome: Promise<any>;
  readonly supportsCollation: Promise<any>;
}

// https://searchfox.org/mozilla-central/source/widget/nsIPrinterList.idl

interface nsIPrinterList extends nsISupports {
  initPrintSettingsFromPrinter(aPrinterName: string, aPrintSettings: nsIPrintSettings): void;
  readonly systemDefaultPrinterName: string;
  getPrinterByName(aPrinterName: string): Promise<any>;
  getPrinterBySystemName(aPrinterName: string): Promise<any>;
  getNamedOrDefaultPrinter(aPrinterName: string): Promise<any>;
  readonly printers: Promise<any>;
  readonly fallbackPaperList: Promise<any>;
}

// https://searchfox.org/mozilla-central/source/widget/nsIScreen.idl

interface nsIScreen extends nsISupports {
  GetRect(left: OutParam<i32>, top: OutParam<i32>, width: OutParam<i32>, height: OutParam<i32>): void;
  GetAvailRect(left: OutParam<i32>, top: OutParam<i32>, width: OutParam<i32>, height: OutParam<i32>): void;
  GetRectDisplayPix(left: OutParam<i32>, top: OutParam<i32>, width: OutParam<i32>, height: OutParam<i32>): void;
  GetAvailRectDisplayPix(left: OutParam<i32>, top: OutParam<i32>, width: OutParam<i32>, height: OutParam<i32>): void;
  readonly pixelDepth: i32;
  readonly colorDepth: i32;
  readonly contentsScaleFactor: double;
  readonly defaultCSSScaleFactor: double;
  readonly dpi: float;
  readonly refreshRate: i32;
  readonly isPseudoDisplay: boolean;
}

// https://searchfox.org/mozilla-central/source/widget/nsIScreenManager.idl

interface nsIScreenManager extends nsISupports {
  screenForRect(left: i32, top: i32, width: i32, height: i32): nsIScreen;
  readonly primaryScreen: nsIScreen;
  readonly totalScreenPixels: i64;
}

// https://searchfox.org/mozilla-central/source/widget/nsISharePicker.idl

interface nsISharePicker extends nsISupports {
  init(openerWindow: mozIDOMWindowProxy): void;
  readonly openerWindow: mozIDOMWindowProxy;
  share(title: string, text: string, url: nsIURI): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/widget/nsISound.idl

interface nsISound extends nsISupports {
  readonly EVENT_NEW_MAIL_RECEIVED?: 0;
  readonly EVENT_ALERT_DIALOG_OPEN?: 1;
  readonly EVENT_CONFIRM_DIALOG_OPEN?: 2;
  readonly EVENT_PROMPT_DIALOG_OPEN?: 3;
  readonly EVENT_SELECT_DIALOG_OPEN?: 4;
  readonly EVENT_MENU_EXECUTE?: 5;
  readonly EVENT_MENU_POPUP?: 6;
  readonly EVENT_EDITOR_MAX_LEN?: 7;

  play(aURL: nsIURL): void;
  beep(): void;
  init(): void;
  playEventSound(aEventId: u32): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsISystemStatusBar.idl

interface nsISystemStatusBar extends nsISupports {
  addItem(aMenuElement: Element): void;
  removeItem(aMenuElement: Element): void;
}

// https://searchfox.org/mozilla-central/source/widget/nsITransferable.idl

interface nsIFlavorDataProvider extends nsISupports {
  getFlavorData(aTransferable: nsITransferable, aFlavor: string, aData: OutParam<nsISupports>): void;
}

interface nsITransferable extends nsISupports {
  init(aContext: nsILoadContext): void;
  flavorsTransferableCanExport(): string[];
  getTransferData(aFlavor: string, aData: OutParam<nsISupports>): void;
  getAnyTransferData(aFlavor: OutParam<string>, aData: OutParam<nsISupports>): void;
  flavorsTransferableCanImport(): string[];
  setTransferData(aFlavor: string, aData: nsISupports): void;
  clearAllData(): void;
  addDataFlavor(aDataFlavor: string): void;
  removeDataFlavor(aDataFlavor: string): void;
  converter: nsIFormatConverter;
}

// https://searchfox.org/mozilla-central/source/widget/nsIUserIdleService.idl

interface nsIUserIdleService extends nsISupports {
  readonly idleTime: u32;
  addIdleObserver(observer: nsIObserver, time: u32): void;
  removeIdleObserver(observer: nsIObserver, time: u32): void;
  disabled: boolean;
}

// https://searchfox.org/mozilla-central/source/widget/nsIUserIdleServiceInternal.idl

interface nsIUserIdleServiceInternal extends nsIUserIdleService {
  resetIdleTimeOut(idleDeltaInMS: u32): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/windowcreator/nsIWindowCreator.idl

interface nsIWindowCreator extends nsISupports {
  createChromeWindow(parent: nsIWebBrowserChrome, chromeFlags: u32, aOpenWindowInfo: nsIOpenWindowInfo, cancel: OutParam<boolean>): nsIWebBrowserChrome;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/windowcreator/nsIWindowProvider.idl

interface nsIWindowProvider extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/toolkit/components/windowwatcher/nsIDialogParamBlock.idl

interface nsIDialogParamBlock extends nsISupports {
  GetInt(inIndex: i32): i32;
  SetInt(inIndex: i32, inInt: i32): void;
  SetNumberStrings(inNumStrings: i32): void;
  GetString(inIndex: i32): string;
  SetString(inIndex: i32, inString: string): void;
  objects: nsIMutableArray;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/windowwatcher/nsIOpenWindowInfo.idl

interface nsIOpenWindowInfo extends nsISupports {
  readonly parent: BrowsingContext;
  readonly isRemote: boolean;
  readonly forceNoOpener: boolean;
  readonly isForPrinting: boolean;
  readonly isForWindowDotPrint: boolean;
  readonly isTopLevelCreatedByWebContent: boolean;
  readonly hasValidUserGestureActivation: boolean;
  readonly textDirectiveUserActivation: boolean;
  readonly originAttributes: any;
  cancel(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/windowwatcher/nsIPromptCollection.idl

interface nsIPromptCollection extends nsISupports {
  asyncBeforeUnloadCheck(aBrowsingContext: BrowsingContext): Promise<any>;
  confirmRepost(aBrowsingContext: BrowsingContext): boolean;
  confirmFolderUpload(aBrowsingContext: BrowsingContext, aDirectoryName: string): boolean;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/windowwatcher/nsIPromptFactory.idl

interface nsIPromptFactory extends nsISupports {
  getPrompt<T extends nsIID>(aParent: mozIDOMWindowProxy, iid: T): nsQIResult<T>;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/windowwatcher/nsIPromptService.idl

interface nsIPromptService extends nsISupports {
  readonly BUTTON_POS_0?: 1;
  readonly BUTTON_POS_1?: 256;
  readonly BUTTON_POS_2?: 65536;
  readonly BUTTON_TITLE_OK?: 1;
  readonly BUTTON_TITLE_CANCEL?: 2;
  readonly BUTTON_TITLE_YES?: 3;
  readonly BUTTON_TITLE_NO?: 4;
  readonly BUTTON_TITLE_SAVE?: 5;
  readonly BUTTON_TITLE_DONT_SAVE?: 6;
  readonly BUTTON_TITLE_REVERT?: 7;
  readonly BUTTON_TITLE_IS_STRING?: 127;
  readonly BUTTON_POS_0_DEFAULT?: 0;
  readonly BUTTON_POS_1_DEFAULT?: 16777216;
  readonly BUTTON_POS_2_DEFAULT?: 33554432;
  readonly BUTTON_DELAY_ENABLE?: 67108864;
  readonly SHOW_SPINNER?: 134217728;
  readonly BUTTON_NONE_ENABLE_BIT?: 268435456;
  readonly BUTTON_NONE?: 268435583;
  readonly BUTTON_POS_1_IS_SECONDARY?: 536870912;
  readonly STD_OK_CANCEL_BUTTONS?: 513;
  readonly STD_YES_NO_BUTTONS?: 1027;
  readonly MODAL_TYPE_CONTENT?: 1;
  readonly MODAL_TYPE_TAB?: 2;
  readonly MODAL_TYPE_WINDOW?: 3;
  readonly MODAL_TYPE_INTERNAL_WINDOW?: 4;

  alert(aParent: mozIDOMWindowProxy, aDialogTitle: string, aText: string): void;
  alertBC(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string): void;
  asyncAlert(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string): Promise<any>;
  alertCheck(aParent: mozIDOMWindowProxy, aDialogTitle: string, aText: string, aCheckMsg: string, aCheckState: InOutParam<boolean>): void;
  alertCheckBC(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aCheckMsg: string, aCheckState: InOutParam<boolean>): void;
  asyncAlertCheck(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aCheckMsg: string, aCheckState: boolean): Promise<any>;
  confirm(aParent: mozIDOMWindowProxy, aDialogTitle: string, aText: string): boolean;
  confirmBC(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string): boolean;
  asyncConfirm(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string): Promise<any>;
  confirmCheck(aParent: mozIDOMWindowProxy, aDialogTitle: string, aText: string, aCheckMsg: string, aCheckState: InOutParam<boolean>): boolean;
  confirmCheckBC(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aCheckMsg: string, aCheckState: InOutParam<boolean>): boolean;
  asyncConfirmCheck(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aCheckMsg: string, aCheckState: boolean): Promise<any>;
  confirmEx(aParent: mozIDOMWindowProxy, aDialogTitle: string, aText: string, aButtonFlags: u32, aButton0Title: string, aButton1Title: string, aButton2Title: string, aCheckMsg: string, aCheckState: InOutParam<boolean>): i32;
  confirmExBC(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aButtonFlags: u32, aButton0Title: string, aButton1Title: string, aButton2Title: string, aCheckMsg: string, aCheckState: InOutParam<boolean>): i32;
  asyncConfirmEx(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aButtonFlags: u32, aButton0Title: string, aButton1Title: string, aButton2Title: string, aCheckMsg: string, aCheckState: boolean, aExtraArgs?: any): Promise<any>;
  prompt(aParent: mozIDOMWindowProxy, aDialogTitle: string, aText: string, aValue: InOutParam<string>, aCheckMsg: string, aCheckState: InOutParam<boolean>): boolean;
  promptBC(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aValue: InOutParam<string>, aCheckMsg: string, aCheckState: InOutParam<boolean>): boolean;
  asyncPrompt(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aValue: string, aCheckMsg: string, aCheckState: boolean): Promise<any>;
  promptUsernameAndPassword(aParent: mozIDOMWindowProxy, aDialogTitle: string, aText: string, aUsername: InOutParam<string>, aPassword: InOutParam<string>): boolean;
  promptUsernameAndPasswordBC(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aUsername: InOutParam<string>, aPassword: InOutParam<string>): boolean;
  asyncPromptUsernameAndPassword(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aUsername: string, aPassword: string): Promise<any>;
  promptPassword(aParent: mozIDOMWindowProxy, aDialogTitle: string, aText: string, aPassword: InOutParam<string>): boolean;
  promptPasswordBC(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aPassword: InOutParam<string>): boolean;
  asyncPromptPassword(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aPassword: string): Promise<any>;
  select(aParent: mozIDOMWindowProxy, aDialogTitle: string, aText: string, aSelectList: string[], aOutSelection: OutParam<i32>): boolean;
  selectBC(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aSelectList: string[], aOutSelection: OutParam<i32>): boolean;
  asyncSelect(aBrowsingContext: BrowsingContext, modalType: u32, aDialogTitle: string, aText: string, aSelectList: string[]): Promise<any>;
  promptAuth(aParent: mozIDOMWindowProxy, aChannel: nsIChannel, level: u32, authInfo: nsIAuthInformation): boolean;
  promptAuthBC(aBrowsingContext: BrowsingContext, modalType: u32, aChannel: nsIChannel, level: u32, authInfo: nsIAuthInformation): boolean;
  asyncPromptAuth(aBrowsingContext: BrowsingContext, modalType: u32, aChannel: nsIChannel, level: u32, authInfo: nsIAuthInformation): Promise<any>;
  confirmUserPaste(aWindow: WindowGlobalParent): Promise<any>;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/windowwatcher/nsIWindowWatcher.idl

interface nsIWindowWatcher extends nsISupports {
  openWindow(aParent: mozIDOMWindowProxy, aUrl: string, aName: string, aFeatures: string, aArguments: nsISupports): mozIDOMWindowProxy;
  registerNotification(aObserver: nsIObserver): void;
  unregisterNotification(aObserver: nsIObserver): void;
  getWindowEnumerator(): nsISimpleEnumerator;
  getNewPrompter(aParent: mozIDOMWindowProxy): nsIPrompt;
  getNewAuthPrompter(aParent: mozIDOMWindowProxy): nsIAuthPrompt;
  setWindowCreator(creator: nsIWindowCreator): void;
  hasWindowCreator(): boolean;
  getChromeForWindow(aWindow: mozIDOMWindowProxy): nsIWebBrowserChrome;
  getWindowByName(aTargetName: string): mozIDOMWindowProxy;
  readonly activeWindow: mozIDOMWindowProxy;
}

// https://searchfox.org/mozilla-central/source/toolkit/components/windowwatcher/nsPIWindowWatcher.idl

// https://searchfox.org/mozilla-central/source/xpcom/base/nsIAvailableMemoryWatcherBase.idl

interface nsITabUnloader extends nsISupports {
  unloadTabAsync(): void;
}

interface nsIAvailableMemoryWatcherBase extends nsISupports {
  registerTabUnloader(aTabUnloader: nsITabUnloader): void;
  onUnloadAttemptCompleted(aResult: nsresult): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsIConsoleListener.idl

type nsIConsoleListener = Callable<{
  observe(aMessage: nsIConsoleMessage): void;
}>

// https://searchfox.org/mozilla-central/source/xpcom/base/nsIConsoleMessage.idl

interface nsIConsoleMessage extends nsISupports {
  readonly debug?: 0;
  readonly info?: 1;
  readonly warn?: 2;
  readonly error?: 3;

  readonly logLevel: u32;
  readonly timeStamp: i64;
  readonly microSecondTimeStamp: i64;
  readonly message: string;
  isForwardedFromContentProcess: boolean;
  toString(): string;
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsIConsoleService.idl

}  // global

declare enum nsIConsoleService_OutputMode {
  SuppressLog = 0,
  OutputToLog = 1,
}

declare global {

namespace nsIConsoleService {
  type OutputMode = nsIConsoleService_OutputMode;
}

interface nsIConsoleService extends nsISupports, Enums<typeof nsIConsoleService_OutputMode> {
  logMessage(message: nsIConsoleMessage): void;
  logMessageWithMode(message: nsIConsoleMessage, mode: nsIConsoleService.OutputMode): void;
  logStringMessage(message: string): void;
  getMessageArray(): nsIConsoleMessage[];
  registerListener(listener: nsIConsoleListener): void;
  unregisterListener(listener: nsIConsoleListener): void;
  reset(): void;
  resetWindow(windowInnerId: u64): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsICycleCollectorListener.idl

interface nsICycleCollectorHandler extends nsISupports {
  noteRefCountedObject(aAddress: string, aRefCount: u32, aObjectDescription: string): void;
  noteGCedObject(aAddress: string, aMarked: boolean, aObjectDescription: string, aCompartmentAddress: string): void;
  noteEdge(aFromAddress: string, aToAddress: string, aEdgeName: string): void;
  describeRoot(aAddress: string, aKnownEdges: u32): void;
  describeGarbage(aAddress: string): void;
}

interface nsICycleCollectorLogSink extends nsISupports {
  closeGCLog(): void;
  closeCCLog(): void;
  filenameIdentifier: string;
  processIdentifier: i32;
  readonly gcLog: nsIFile;
  readonly ccLog: nsIFile;
}

interface nsICycleCollectorListener extends nsISupports {
  allTraces(): nsICycleCollectorListener;
  readonly wantAllTraces: boolean;
  disableLog: boolean;
  logSink: nsICycleCollectorLogSink;
  wantAfterProcessing: boolean;
  processNext(aHandler: nsICycleCollectorHandler): boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsIDebug2.idl

interface nsIDebug2 extends nsISupports {
  readonly isDebugBuild: boolean;
  readonly assertionCount: i32;
  readonly isDebuggerAttached: boolean;
  assertion(aStr: string, aExpr: string, aFile: string, aLine: i32): void;
  warning(aStr: string, aFile: string, aLine: i32): void;
  break(aFile: string, aLine: i32): void;
  abort(aFile: string, aLine: i32): void;
  rustPanic(aMessage: string): void;
  rustLog(aTarget: string, aMessage: string): void;
  crashWithOOM(): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsIException.idl

interface nsIStackFrame extends nsISupports {
  readonly filename: string;
  readonly name: string;
  readonly sourceId: i32;
  readonly lineNumber: i32;
  readonly columnNumber: i32;
  readonly asyncCause: string;
  readonly asyncCaller: nsIStackFrame;
  readonly caller: nsIStackFrame;
  readonly formattedStack: string;
  readonly nativeSavedFrame: any;
  toString(): string;
}

interface nsIException extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsIInterfaceRequestor.idl

interface nsIInterfaceRequestor extends nsISupports {
  getInterface<T extends nsIID>(uuid: T): nsQIResult<T>;
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsIMemoryInfoDumper.idl

type nsIFinishDumpingCallback = Callable<{
  callback(data: nsISupports): void;
}>

interface nsIDumpGCAndCCLogsCallback extends nsISupports {
  onDump(aGCLog: nsIFile, aCCLog: nsIFile, aIsParent: boolean): void;
  onFinish(): void;
}

interface nsIMemoryInfoDumper extends nsISupports {
  dumpMemoryReportsToNamedFile(aFilename: string, aFinishDumping: nsIFinishDumpingCallback, aFinishDumpingData: nsISupports, aAnonymize: boolean, aMinimizeMemoryUsage: boolean): void;
  dumpMemoryInfoToTempDir(aIdentifier: string, aAnonymize: boolean, aMinimizeMemoryUsage: boolean): void;
  dumpGCAndCCLogsToFile(aIdentifier: string, aDumpAllTraces: boolean, aDumpChildProcesses: boolean, aCallback: nsIDumpGCAndCCLogsCallback): void;
  dumpGCAndCCLogsToSink(aDumpAllTraces: boolean, aSink: nsICycleCollectorLogSink): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsIMemoryReporter.idl

type nsIHandleReportCallback = Callable<{
  callback(process: string, path: string, kind: i32, units: i32, amount: i64, description: string, data: nsISupports): void;
}>

interface nsIMemoryReporter extends nsISupports {
  readonly KIND_NONHEAP?: 0;
  readonly KIND_HEAP?: 1;
  readonly KIND_OTHER?: 2;
  readonly UNITS_BYTES?: 0;
  readonly UNITS_COUNT?: 1;
  readonly UNITS_COUNT_CUMULATIVE?: 2;
  readonly UNITS_PERCENTAGE?: 3;

  collectReports(callback: nsIHandleReportCallback, data: nsISupports, anonymize: boolean): void;
}

type nsIFinishReportingCallback = Callable<{
  callback(data: nsISupports): void;
}>

type nsIHeapAllocatedCallback = Callable<{
  callback(bytesAllocated: i64): void;
}>

interface nsIMemoryReporterManager extends nsISupports {
  init(): void;
  registerStrongReporter(reporter: nsIMemoryReporter): void;
  registerStrongAsyncReporter(reporter: nsIMemoryReporter): void;
  registerWeakReporter(reporter: nsIMemoryReporter): void;
  registerWeakAsyncReporter(reporter: nsIMemoryReporter): void;
  unregisterStrongReporter(reporter: nsIMemoryReporter): void;
  unregisterWeakReporter(reporter: nsIMemoryReporter): void;
  blockRegistrationAndHideExistingReporters(): void;
  unblockRegistrationAndRestoreOriginalReporters(): void;
  registerStrongReporterEvenIfBlocked(aReporter: nsIMemoryReporter): void;
  getReports(handleReport: nsIHandleReportCallback, handleReportData: nsISupports, finishReporting: nsIFinishReportingCallback, finishReportingData: nsISupports, anonymize: boolean): void;
  getReportsExtended(handleReport: nsIHandleReportCallback, handleReportData: nsISupports, finishReporting: nsIFinishReportingCallback, finishReportingData: nsISupports, anonymize: boolean, minimizeMemoryUsage: boolean, DMDDumpIdent: string): void;
  readonly vsize: i64;
  readonly vsizeMaxContiguous: i64;
  readonly resident: i64;
  readonly residentFast: i64;
  readonly residentPeak: i64;
  readonly residentUnique: i64;
  readonly heapAllocated: i64;
  readonly heapOverheadFraction: i64;
  readonly JSMainRuntimeGCHeap: i64;
  readonly JSMainRuntimeTemporaryPeak: i64;
  readonly JSMainRuntimeCompartmentsSystem: i64;
  readonly JSMainRuntimeCompartmentsUser: i64;
  readonly JSMainRuntimeRealmsSystem: i64;
  readonly JSMainRuntimeRealmsUser: i64;
  readonly imagesContentUsedUncompressed: i64;
  readonly storageSQLite: i64;
  readonly lowMemoryEventsPhysical: i64;
  readonly ghostWindows: i64;
  readonly pageFaultsHard: i64;
  readonly hasMozMallocUsableSize: boolean;
  readonly isDMDEnabled: boolean;
  readonly isDMDRunning: boolean;
  minimizeMemoryUsage(callback: nsIRunnable): void;
  sizeOfTab(window: mozIDOMWindowProxy, jsObjectsSize: OutParam<i64>, jsStringsSize: OutParam<i64>, jsOtherSize: OutParam<i64>, domSize: OutParam<i64>, styleSize: OutParam<i64>, otherSize: OutParam<i64>, totalSize: OutParam<i64>, jsMilliseconds: OutParam<double>, nonJSMilliseconds: OutParam<double>): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsISecurityConsoleMessage.idl

// https://searchfox.org/mozilla-central/source/xpcom/base/nsISupports.idl

interface nsISupports {
  QueryInterface?<T extends nsIID>(aIID: T): nsQIResult<T>;
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsIUUIDGenerator.idl

interface nsIUUIDGenerator extends nsISupports {
  generateUUID(): nsID;
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsIVersionComparator.idl

interface nsIVersionComparator extends nsISupports {
  compare(A: string, B: string): i32;
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsIWeakReference.idl

interface nsIWeakReference extends nsISupports {
  QueryReferent<T extends nsIID>(uuid: T): nsQIResult<T>;
}

interface nsISupportsWeakReference extends nsISupports {
  GetWeakReference(): nsIWeakReference;
}

// https://searchfox.org/mozilla-central/source/xpcom/base/nsrootidl.idl

// https://searchfox.org/mozilla-central/source/xpcom/components/nsICategoryManager.idl

interface nsICategoryEntry extends nsISupportsCString {
  readonly entry: string;
  readonly value: string;
}

interface nsICategoryManager extends nsISupports {
  getCategoryEntry(aCategory: string, aEntry: string): string;
  addCategoryEntry(aCategory: string, aEntry: string, aValue: string, aPersist: boolean, aReplace: boolean): string;
  deleteCategoryEntry(aCategory: string, aEntry: string, aPersist: boolean): void;
  deleteCategory(aCategory: string): void;
  enumerateCategory(aCategory: string): nsISimpleEnumerator;
  enumerateCategories(): nsISimpleEnumerator;
}

// https://searchfox.org/mozilla-central/source/xpcom/components/nsIClassInfo.idl

interface nsIClassInfo extends nsISupports {
  readonly SINGLETON?: 1;
  readonly THREADSAFE?: 2;
  readonly SINGLETON_CLASSINFO?: 32;
  readonly RESERVED?: 2147483648;

  readonly interfaces: nsID[];
  readonly contractID: string;
  readonly classDescription: string;
  readonly classID: nsID;
  readonly flags: u32;
}

// https://searchfox.org/mozilla-central/source/xpcom/components/nsIComponentManager.idl

interface nsIComponentManager extends nsISupports {
  getClassObject<T extends nsIID>(aClass: nsID, aIID: T): nsQIResult<T>;
  getClassObjectByContractID<T extends nsIID>(aContractID: string, aIID: T): nsQIResult<T>;
  addBootstrappedManifestLocation(aLocation: nsIFile): void;
  removeBootstrappedManifestLocation(aLocation: nsIFile): void;
  getManifestLocations(): nsIArray;
  getComponentESModules(): nsIUTF8StringEnumerator;
}

// https://searchfox.org/mozilla-central/source/xpcom/components/nsIComponentRegistrar.idl

interface nsIComponentRegistrar extends nsISupports {
  autoRegister(aSpec: nsIFile): void;
  registerFactory(aClass: nsID, aClassName: string, aContractID: string, aFactory: nsIFactory): void;
  unregisterFactory(aClass: nsID, aFactory: nsIFactory): void;
  isCIDRegistered(aClass: nsID): boolean;
  isContractIDRegistered(aContractID: string): boolean;
  getContractIDs(): string[];
  contractIDToCID(aContractID: string): nsID;
}

// https://searchfox.org/mozilla-central/source/xpcom/components/nsIFactory.idl

interface nsIFactory extends nsISupports {
  createInstance<T extends nsIID>(iid: T): nsQIResult<T>;
}

// https://searchfox.org/mozilla-central/source/xpcom/components/nsIServiceManager.idl

interface nsIServiceManager extends nsISupports {
  getService<T extends nsIID>(aClass: nsID, aIID: T): nsQIResult<T>;
  getServiceByContractID<T extends nsIID>(aContractID: string, aIID: T): nsQIResult<T>;
  isServiceInstantiated(aClass: nsID, aIID: nsID): boolean;
  isServiceInstantiatedByContractID(aContractID: string, aIID: nsID): boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIArray.idl

interface nsIArray extends nsISupports {
  readonly length: u32;
  queryElementAt<T extends nsIID>(index: u32, uuid: T): nsQIResult<T>;
  indexOf(startIndex: u32, element: nsISupports): u32;
  enumerate(aElemIID?: nsID): nsISimpleEnumerator;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIArrayExtensions.idl

interface nsIArrayExtensions extends nsIArray {
  Count(): u32;
  GetElementAt(index: u32): nsISupports;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIINIParser.idl

interface nsIINIParser extends nsISupports {
  initFromString(aData: string): void;
  getSections(): nsIUTF8StringEnumerator;
  getKeys(aSection: string): nsIUTF8StringEnumerator;
  getString(aSection: string, aKey: string): string;
}

interface nsIINIParserWriter extends nsISupports {
  setString(aSection: string, aKey: string, aValue: string): void;
  writeFile(aINIFile: nsIFile): void;
  writeToString(): string;
}

interface nsIINIParserFactory extends nsISupports {
  createINIParser(aINIFile?: nsIFile): nsIINIParser;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIMutableArray.idl

interface nsIMutableArray extends nsIArrayExtensions {
  appendElement(element: nsISupports): void;
  removeElementAt(index: u32): void;
  insertElementAt(element: nsISupports, index: u32): void;
  replaceElementAt(element: nsISupports, index: u32): void;
  clear(): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIObserver.idl

type nsIObserver = Callable<{
  observe(aSubject: nsISupports, aTopic: string, aData: string): void;
}>

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIObserverService.idl

interface nsIObserverService extends nsISupports {
  addObserver(anObserver: nsIObserver, aTopic: string, ownsWeak?: boolean): void;
  removeObserver(anObserver: nsIObserver, aTopic: string): void;
  notifyObservers(aSubject: nsISupports, aTopic: string, someData?: string): void;
  enumerateObservers(aTopic: string): nsISimpleEnumerator;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIPersistentProperties2.idl

interface nsIPropertyElement extends nsISupports {
  key: string;
  value: string;
}

interface nsIPersistentProperties extends nsIProperties {
  load(input: nsIInputStream): void;
  save(output: nsIOutputStream, header: string): void;
  enumerate(): nsISimpleEnumerator;
  getStringProperty(key: string): string;
  setStringProperty(key: string, value: string): string;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIProperties.idl

interface nsIProperties extends nsISupports {
  get<T extends nsIID>(prop: string, iid: T): nsQIResult<T>;
  set(prop: string, value: nsISupports): void;
  has(prop: string): boolean;
  undefine(prop: string): void;
  getKeys(): string[];
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIProperty.idl

interface nsIProperty extends nsISupports {
  readonly name: string;
  readonly value: nsIVariant;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIPropertyBag.idl

interface nsIPropertyBag extends nsISupports {
  readonly enumerator: nsISimpleEnumerator;
  getProperty(name: string): nsIVariant;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIPropertyBag2.idl

interface nsIPropertyBag2 extends nsIPropertyBag {
  getPropertyAsInt32(prop: string): i32;
  getPropertyAsUint32(prop: string): u32;
  getPropertyAsInt64(prop: string): i64;
  getPropertyAsUint64(prop: string): u64;
  getPropertyAsDouble(prop: string): double;
  getPropertyAsAString(prop: string): string;
  getPropertyAsACString(prop: string): string;
  getPropertyAsAUTF8String(prop: string): string;
  getPropertyAsBool(prop: string): boolean;
  getPropertyAsInterface<T extends nsIID>(prop: string, iid: T): nsQIResult<T>;
  get(prop: string): nsIVariant;
  hasKey(prop: string): boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsISerializable.idl

interface nsISerializable extends nsISupports {
  read(aInputStream: nsIObjectInputStream): void;
  write(aOutputStream: nsIObjectOutputStream): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsISimpleEnumerator.idl

interface nsIJSEnumerator extends nsISupports {
  iterator(): nsIJSEnumerator;
  next(): any;
}

interface nsISimpleEnumeratorBase extends nsISupports {
  iterator(): nsIJSEnumerator;
  entries(aIface: nsID): nsIJSEnumerator;
}

interface nsISimpleEnumerator extends nsISimpleEnumeratorBase {
  hasMoreElements(): boolean;
  getNext(): nsISupports;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIStringEnumerator.idl

interface nsIStringEnumeratorBase extends nsISupports {
  iterator(): nsIJSEnumerator;
}

interface nsIStringEnumerator extends nsIStringEnumeratorBase {
  hasMore(): boolean;
  getNext(): string;
}

interface nsIUTF8StringEnumerator extends nsIStringEnumeratorBase {
  hasMore(): boolean;
  getNext(): string;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsISupportsIterators.idl

interface nsIOutputIterator extends nsISupports {
  putElement(anElementToPut: nsISupports): void;
  stepForward(): void;
}

interface nsIInputIterator extends nsISupports {
  getElement(): nsISupports;
  stepForward(): void;
  isEqualTo(anotherIterator: nsISupports): boolean;
  clone(): nsISupports;
}

interface nsIForwardIterator extends nsISupports {
  getElement(): nsISupports;
  putElement(anElementToPut: nsISupports): void;
  stepForward(): void;
  isEqualTo(anotherIterator: nsISupports): boolean;
  clone(): nsISupports;
}

interface nsIBidirectionalIterator extends nsISupports {
  getElement(): nsISupports;
  putElement(anElementToPut: nsISupports): void;
  stepForward(): void;
  stepBackward(): void;
  isEqualTo(anotherIterator: nsISupports): boolean;
  clone(): nsISupports;
}

interface nsIRandomAccessIterator extends nsISupports {
  getElement(): nsISupports;
  getElementAt(anOffset: i32): nsISupports;
  putElement(anElementToPut: nsISupports): void;
  putElementAt(anOffset: i32, anElementToPut: nsISupports): void;
  stepForward(): void;
  stepForwardBy(anOffset: i32): void;
  stepBackward(): void;
  stepBackwardBy(anOffset: i32): void;
  isEqualTo(anotherIterator: nsISupports): boolean;
  clone(): nsISupports;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsISupportsPrimitives.idl

interface nsISupportsPrimitive extends nsISupports {
  readonly TYPE_ID?: 1;
  readonly TYPE_CSTRING?: 2;
  readonly TYPE_STRING?: 3;
  readonly TYPE_PRBOOL?: 4;
  readonly TYPE_PRUINT8?: 5;
  readonly TYPE_PRUINT16?: 6;
  readonly TYPE_PRUINT32?: 7;
  readonly TYPE_PRUINT64?: 8;
  readonly TYPE_PRTIME?: 9;
  readonly TYPE_CHAR?: 10;
  readonly TYPE_PRINT16?: 11;
  readonly TYPE_PRINT32?: 12;
  readonly TYPE_PRINT64?: 13;
  readonly TYPE_FLOAT?: 14;
  readonly TYPE_DOUBLE?: 15;
  readonly TYPE_INTERFACE_POINTER?: 17;

  readonly type: u16;
}

interface nsISupportsID extends nsISupportsPrimitive {
  data: nsID;
  toString(): string;
}

interface nsISupportsCString extends nsISupportsPrimitive {
  data: string;
  toString(): string;
}

interface nsISupportsString extends nsISupportsPrimitive {
  data: string;
  toString(): string;
}

interface nsISupportsPRBool extends nsISupportsPrimitive {
  data: boolean;
  toString(): string;
}

interface nsISupportsPRUint8 extends nsISupportsPrimitive {
  data: u8;
  toString(): string;
}

interface nsISupportsPRUint16 extends nsISupportsPrimitive {
  data: u16;
  toString(): string;
}

interface nsISupportsPRUint32 extends nsISupportsPrimitive {
  data: u32;
  toString(): string;
}

interface nsISupportsPRUint64 extends nsISupportsPrimitive {
  data: u64;
  toString(): string;
}

interface nsISupportsPRTime extends nsISupportsPrimitive {
  data: PRTime;
  toString(): string;
}

interface nsISupportsChar extends nsISupportsPrimitive {
  data: string;
  toString(): string;
}

interface nsISupportsPRInt16 extends nsISupportsPrimitive {
  data: i16;
  toString(): string;
}

interface nsISupportsPRInt32 extends nsISupportsPrimitive {
  data: i32;
  toString(): string;
}

interface nsISupportsPRInt64 extends nsISupportsPrimitive {
  data: i64;
  toString(): string;
}

interface nsISupportsFloat extends nsISupportsPrimitive {
  data: float;
  toString(): string;
}

interface nsISupportsDouble extends nsISupportsPrimitive {
  data: double;
  toString(): string;
}

interface nsISupportsInterfacePointer extends nsISupportsPrimitive {
  data: nsISupports;
  dataIID: nsID;
  toString(): string;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIVariant.idl

interface nsIVariant extends nsISupports {
}

interface nsIWritableVariant extends nsIVariant {
  writable: boolean;
  setAsInt8(aValue: u8): void;
  setAsInt16(aValue: i16): void;
  setAsInt32(aValue: i32): void;
  setAsInt64(aValue: i64): void;
  setAsUint8(aValue: u8): void;
  setAsUint16(aValue: u16): void;
  setAsUint32(aValue: u32): void;
  setAsUint64(aValue: u64): void;
  setAsFloat(aValue: float): void;
  setAsDouble(aValue: double): void;
  setAsBool(aValue: boolean): void;
  setAsChar(aValue: string): void;
  setAsWChar(aValue: string): void;
  setAsID(aValue: nsID): void;
  setAsAString(aValue: string): void;
  setAsACString(aValue: string): void;
  setAsAUTF8String(aValue: string): void;
  setAsString(aValue: string): void;
  setAsWString(aValue: string): void;
  setAsISupports(aValue: nsISupports): void;
  setAsStringWithSize(size: u32, str: string): void;
  setAsWStringWithSize(size: u32, str: string): void;
  setAsVoid(): void;
  setAsEmpty(): void;
  setAsEmptyArray(): void;
  setFromVariant(aValue: nsIVariant): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIWritablePropertyBag.idl

interface nsIWritablePropertyBag extends nsIPropertyBag {
  setProperty(name: string, value: nsIVariant): void;
  deleteProperty(name: string): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/ds/nsIWritablePropertyBag2.idl

interface nsIWritablePropertyBag2 extends nsIPropertyBag2 {
  setPropertyAsInt32(prop: string, value: i32): void;
  setPropertyAsUint32(prop: string, value: u32): void;
  setPropertyAsInt64(prop: string, value: i64): void;
  setPropertyAsUint64(prop: string, value: u64): void;
  setPropertyAsDouble(prop: string, value: double): void;
  setPropertyAsAString(prop: string, value: string): void;
  setPropertyAsACString(prop: string, value: string): void;
  setPropertyAsAUTF8String(prop: string, value: string): void;
  setPropertyAsBool(prop: string, value: boolean): void;
  setPropertyAsInterface(prop: string, value: nsISupports): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIAsyncInputStream.idl

interface nsIAsyncInputStream extends nsIInputStream {
  readonly WAIT_CLOSURE_ONLY?: 1;

  closeWithStatus(aStatus: nsresult): void;
  asyncWait(aCallback: nsIInputStreamCallback, aFlags: u32, aRequestedCount: u32, aEventTarget: nsIEventTarget): void;
}

type nsIInputStreamCallback = Callable<{
  onInputStreamReady(aStream: nsIAsyncInputStream): void;
}>

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIAsyncOutputStream.idl

interface nsIAsyncOutputStream extends nsIOutputStream {
  readonly WAIT_CLOSURE_ONLY?: 1;

  closeWithStatus(reason: nsresult): void;
  asyncWait(aCallback: nsIOutputStreamCallback, aFlags: u32, aRequestedCount: u32, aEventTarget: nsIEventTarget): void;
}

type nsIOutputStreamCallback = Callable<{
  onOutputStreamReady(aStream: nsIAsyncOutputStream): void;
}>

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIBinaryInputStream.idl

interface nsIBinaryInputStream extends nsIInputStream {
  setInputStream(aInputStream: nsIInputStream): void;
  readBoolean(): boolean;
  read8(): u8;
  read16(): u16;
  read32(): u32;
  read64(): u64;
  readFloat(): float;
  readDouble(): double;
  readCString(): string;
  readString(): string;
  readBytes(aLength: u32): string;
  readByteArray(aLength: u32): u8[];
  readArrayBuffer(aLength: u64, aArrayBuffer: any): u64;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIBinaryOutputStream.idl

interface nsIBinaryOutputStream extends nsIOutputStream {
  setOutputStream(aOutputStream: nsIOutputStream): void;
  writeBoolean(aBoolean: boolean): void;
  write8(aByte: u8): void;
  write16(a16: u16): void;
  write32(a32: u32): void;
  write64(a64: u64): void;
  writeFloat(aFloat: float): void;
  writeDouble(aDouble: double): void;
  writeStringZ(aString: string): void;
  writeWStringZ(aString: string): void;
  writeUtf8Z(aString: string): void;
  writeBytes(aString: string, aLength?: u32): void;
  writeByteArray(aBytes: u8[]): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsICloneableInputStream.idl

interface nsICloneableInputStream extends nsISupports {
  readonly cloneable: boolean;
  clone(): nsIInputStream;
}

interface nsICloneableInputStreamWithRange extends nsICloneableInputStream {
  cloneWithRange(start: u64, length: u64): nsIInputStream;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIConverterInputStream.idl

interface nsIConverterInputStream extends nsIUnicharInputStream {
  readonly DEFAULT_REPLACEMENT_CHARACTER?: 65533;
  readonly ERRORS_ARE_FATAL?: 0;

  init(aStream: nsIInputStream, aCharset: string, aBufferSize: i32, aReplacementChar: u16): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIConverterOutputStream.idl

interface nsIConverterOutputStream extends nsIUnicharOutputStream {
  init(aOutStream: nsIOutputStream, aCharset: string): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIDirectoryEnumerator.idl

interface nsIDirectoryEnumerator extends nsISimpleEnumerator {
  readonly nextFile: nsIFile;
  close(): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIDirectoryService.idl

interface nsIDirectoryServiceProvider extends nsISupports {
  getFile(prop: string, persistent: OutParam<boolean>): nsIFile;
}

interface nsIDirectoryServiceProvider2 extends nsIDirectoryServiceProvider {
  getFiles(prop: string): nsISimpleEnumerator;
}

interface nsIDirectoryService extends nsISupports {
  init(): void;
  registerProvider(prov: nsIDirectoryServiceProvider): void;
  unregisterProvider(prov: nsIDirectoryServiceProvider): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIFile.idl

interface nsIFile extends nsISupports {
  readonly NORMAL_FILE_TYPE?: 0;
  readonly DIRECTORY_TYPE?: 1;
  readonly OS_READAHEAD?: 1073741824;
  readonly DELETE_ON_CLOSE?: 2147483648;

  append(node: string): void;
  normalize(): void;
  create(type: u32, permissions: u32, skipAncestors?: boolean): void;
  leafName: string;
  readonly displayName: string;
  hostPath(): Promise<any>;
  copyTo(newParentDir: nsIFile, newName: string): void;
  copyToFollowingLinks(newParentDir: nsIFile, newName: string): void;
  moveTo(newParentDir: nsIFile, newName: string): void;
  moveToFollowingLinks(newParentDir: nsIFile, newName: string): void;
  renameTo(newParentDir: nsIFile, newName: string): void;
  remove(recursive: boolean, removeCount?: InOutParam<u32>): void;
  permissions: u32;
  permissionsOfLink: u32;
  lastAccessedTime: PRTime;
  lastAccessedTimeOfLink: PRTime;
  lastModifiedTime: PRTime;
  lastModifiedTimeOfLink: PRTime;
  readonly creationTime: PRTime;
  readonly creationTimeOfLink: PRTime;
  fileSize: i64;
  readonly fileSizeOfLink: i64;
  readonly target: string;
  readonly path: string;
  exists(): boolean;
  isWritable(): boolean;
  isReadable(): boolean;
  isExecutable(): boolean;
  isHidden(): boolean;
  isDirectory(): boolean;
  isFile(): boolean;
  isSymlink(): boolean;
  isSpecial(): boolean;
  createUnique(type: u32, permissions: u32): void;
  clone(): nsIFile;
  equals(inFile: nsIFile): boolean;
  contains(inFile: nsIFile): boolean;
  readonly parent: nsIFile;
  readonly directoryEntries: nsIDirectoryEnumerator;
  initWithPath(filePath: string): void;
  initWithFile(aFile: nsIFile): void;
  readonly diskSpaceAvailable: i64;
  readonly diskCapacity: i64;
  appendRelativePath(relativeFilePath: string): void;
  persistentDescriptor: string;
  reveal(): void;
  launch(): void;
  getRelativeDescriptor(fromFile: nsIFile): string;
  setRelativeDescriptor(fromFile: nsIFile, relativeDesc: string): void;
  getRelativePath(fromFile: nsIFile): string;
  setRelativePath(fromFile: nsIFile, relativeDesc: string): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIIOUtil.idl

interface nsIIOUtil extends nsISupports {
  inputStreamIsBuffered(aStream: nsIInputStream): boolean;
  outputStreamIsBuffered(aStream: nsIOutputStream): boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIInputStream.idl

interface nsIInputStream extends nsISupports {
  close(): void;
  available(): u64;
  streamStatus(): void;
  isNonBlocking(): boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIInputStreamLength.idl

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIInputStreamPriority.idl

interface nsIInputStreamPriority extends nsISupports {
  priority: u32;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIInputStreamTee.idl

interface nsIInputStreamTee extends nsIInputStream {
  source: nsIInputStream;
  sink: nsIOutputStream;
  eventTarget: nsIEventTarget;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsILineInputStream.idl

interface nsILineInputStream extends nsISupports {
  readLine(aLine: OutParam<string>): boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsILocalFileWin.idl

interface nsILocalFileWin extends nsIFile {
  initWithCommandLine(aCommandLine: string): void;
  getVersionInfoField(aField: string): string;
  readOnly: boolean;
  useDOSDevicePathSyntax: boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIMultiplexInputStream.idl

interface nsIMultiplexInputStream extends nsISupports {
  readonly count: u32;
  appendStream(stream: nsIInputStream): void;
  getStream(index: u32): nsIInputStream;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIObjectInputStream.idl

interface nsIObjectInputStream extends nsIBinaryInputStream {
  readObject(aIsStrongRef: boolean): nsISupports;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIObjectOutputStream.idl

interface nsIObjectOutputStream extends nsIBinaryOutputStream {
  writeObject(aObject: nsISupports, aIsStrongRef: boolean): void;
  writeSingleRefObject(aObject: nsISupports): void;
  writeCompoundObject(aObject: nsISupports, aIID: nsID, aIsStrongRef: boolean): void;
  writeID(aID: nsID): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIOutputStream.idl

interface nsIOutputStream extends nsISupports {
  close(): void;
  flush(): void;
  streamStatus(): void;
  write(aBuf: string, aCount: u32): u32;
  writeFrom(aFromStream: nsIInputStream, aCount: u32): u32;
  isNonBlocking(): boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIPipe.idl

interface nsIPipe extends nsISupports {
  init(nonBlockingInput: boolean, nonBlockingOutput: boolean, segmentSize: u32, segmentCount: u32): void;
  readonly inputStream: nsIAsyncInputStream;
  readonly outputStream: nsIAsyncOutputStream;
}

interface nsISearchableInputStream extends nsISupports {
  search(forString: string, ignoreCase: boolean, found: OutParam<boolean>, offsetSearchedTo: OutParam<u32>): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIRandomAccessStream.idl

interface nsIRandomAccessStream extends nsISeekableStream {
  getInputStream(): nsIInputStream;
  getOutputStream(): nsIOutputStream;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsISafeOutputStream.idl

interface nsISafeOutputStream extends nsISupports {
  finish(): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIScriptableBase64Encoder.idl

interface nsIScriptableBase64Encoder extends nsISupports {
  encodeToCString(stream: nsIInputStream, length: u32): string;
  encodeToString(stream: nsIInputStream, length: u32): string;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIScriptableInputStream.idl

interface nsIScriptableInputStream extends nsISupports {
  close(): void;
  init(aInputStream: nsIInputStream): void;
  available(): u64;
  read(aCount: u32): string;
  readBytes(aCount: u32): string;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsISeekableStream.idl

interface nsISeekableStream extends nsITellableStream {
  readonly NS_SEEK_SET?: 0;
  readonly NS_SEEK_CUR?: 1;
  readonly NS_SEEK_END?: 2;

  seek(whence: i32, offset: i64): void;
  setEOF(): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIStorageStream.idl

interface nsIStorageStream extends nsISupports {
  init(segmentSize: u32, maxSize: u32): void;
  getOutputStream(startPosition: i32): nsIOutputStream;
  newInputStream(startPosition: i32): nsIInputStream;
  length: u32;
  readonly writeInProgress: boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIStreamBufferAccess.idl

interface nsIStreamBufferAccess extends nsISupports {
  disableBuffering(): void;
  enableBuffering(): void;
  readonly unbufferedStream: nsISupports;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIStringStream.idl

interface nsIStringInputStream extends nsIInputStream {
  setByteStringData(data: string): void;
  setUTF8Data(data: string): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsITellableStream.idl

interface nsITellableStream extends nsISupports {
  tell(): i64;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIUnicharInputStream.idl

interface nsIUnicharInputStream extends nsISupports {
  readString(aCount: u32, aString: OutParam<string>): u32;
  close(): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIUnicharLineInputStream.idl

interface nsIUnicharLineInputStream extends nsISupports {
  readLine(aLine: OutParam<string>): boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/io/nsIUnicharOutputStream.idl

interface nsIUnicharOutputStream extends nsISupports {
  write(aCount: u32, c: u16[]): boolean;
  writeString(str: string): boolean;
  flush(): void;
  close(): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/system/nsIBlocklistService.idl

interface nsIBlocklistService extends nsISupports {
  readonly STATE_NOT_BLOCKED?: 0;
  readonly STATE_SOFTBLOCKED?: 1;
  readonly STATE_BLOCKED?: 2;
  readonly STATE_MAX?: 3;

  readonly isLoaded: boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/system/nsICrashReporter.idl

interface nsICrashReporter extends nsISupports {
  readonly crashReporterEnabled: boolean;
  serverURL: nsIURL;
  minidumpPath: nsIFile;
  getMinidumpForID(id: string): nsIFile;
  getExtraFileForID(id: string): nsIFile;
  annotateCrashReport(key: string, data: any): void;
  removeCrashReportAnnotation(key: string): void;
  isAnnotationValid(value: string): boolean;
  isAnnotationAllowedForPing(value: string): boolean;
  isAnnotationAllowedForReport(value: string): boolean;
  appendAppNotesToCrashReport(data: string): void;
  registerAppMemory(ptr: u64, size: u64): void;
  submitReports: boolean;
  UpdateCrashEventsDir(): void;
  saveMemoryReport(): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/system/nsIDeviceSensors.idl

interface nsIDeviceSensorData extends nsISupports {
  readonly TYPE_ORIENTATION?: 0;
  readonly TYPE_ACCELERATION?: 1;
  readonly TYPE_PROXIMITY?: 2;
  readonly TYPE_LINEAR_ACCELERATION?: 3;
  readonly TYPE_GYROSCOPE?: 4;
  readonly TYPE_LIGHT?: 5;
  readonly TYPE_ROTATION_VECTOR?: 6;
  readonly TYPE_GAME_ROTATION_VECTOR?: 7;

  readonly type: u32;
  readonly x: double;
  readonly y: double;
  readonly z: double;
}

interface nsIDeviceSensors extends nsISupports {
  hasWindowListener(aType: u32, aWindow: nsIDOMWindow): boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/system/nsIGIOService.idl

interface nsIGIOHandlerApp extends nsIHandlerApp {
  readonly id: string;
  launchFile(fileName: string): void;
  getMozIconURL(): string;
}

interface nsIGIOMimeApp extends nsIHandlerApp {
  readonly EXPECTS_URIS?: 0;
  readonly EXPECTS_PATHS?: 1;
  readonly EXPECTS_URIS_FOR_NON_FILES?: 2;

  readonly id: string;
  readonly command: string;
  readonly expectsURIs: i32;
  readonly supportedURISchemes: nsIUTF8StringEnumerator;
  setAsDefaultForMimeType(mimeType: string): void;
  setAsDefaultForFileExtensions(extensions: string): void;
  setAsDefaultForURIScheme(uriScheme: string): void;
}

interface nsIGIOService extends nsISupports {
  getMimeTypeFromExtension(extension: string): string;
  getAppForURIScheme(aURIScheme: string): nsIHandlerApp;
  getAppsForURIScheme(aURIScheme: string): nsIMutableArray;
  getAppForMimeType(mimeType: string): nsIHandlerApp;
  createHandlerAppFromAppId(appId: string): nsIGIOHandlerApp;
  createAppFromCommand(cmd: string, appName: string): nsIGIOMimeApp;
  findAppFromCommand(cmd: string): nsIGIOMimeApp;
  getDescriptionForMimeType(mimeType: string): string;
  readonly isRunningUnderFlatpak: boolean;
  readonly isRunningUnderSnap: boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/system/nsIGSettingsService.idl

interface nsIGSettingsCollection extends nsISupports {
  setString(key: string, value: string): void;
  setBoolean(key: string, value: boolean): void;
  setInt(key: string, value: i32): void;
  getString(key: string): string;
  getBoolean(key: string): boolean;
  getInt(key: string): i32;
  getStringList(key: string): nsIArray;
}

interface nsIGSettingsService extends nsISupports {
  getCollectionForSchema(schema: string): nsIGSettingsCollection;
}

// https://searchfox.org/mozilla-central/source/xpcom/system/nsIGeolocationProvider.idl

interface nsIGeolocationUpdate extends nsISupports {
  update(position: nsIDOMGeoPosition): void;
  notifyError(error: u16): void;
}

interface nsIGeolocationProvider extends nsISupports {
  startup(): void;
  watch(callback: nsIGeolocationUpdate): void;
  shutdown(): void;
  setHighAccuracy(enable: boolean): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/system/nsIHapticFeedback.idl

interface nsIHapticFeedback extends nsISupports {
  readonly ShortPress?: 0;
  readonly LongPress?: 1;

  performSimpleAction(isLongPress: i32): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/system/nsIPlatformInfo.idl

interface nsIPlatformInfo extends nsISupports {
  readonly platformVersion: string;
  readonly platformBuildID: string;
}

// https://searchfox.org/mozilla-central/source/xpcom/system/nsISystemInfo.idl

interface nsISystemInfo extends nsISupports {
  readonly diskInfo: Promise<any>;
  readonly countryCode: Promise<any>;
  readonly osInfo: Promise<any>;
  readonly processInfo: Promise<any>;
}

// https://searchfox.org/mozilla-central/source/xpcom/system/nsIXULAppInfo.idl

interface nsIXULAppInfo extends nsIPlatformInfo {
  readonly vendor: string;
  readonly name: string;
  readonly ID: string;
  readonly version: string;
  readonly appBuildID: string;
  readonly UAName: string;
  readonly sourceURL: string;
  readonly updateURL: string;
}

// https://searchfox.org/mozilla-central/source/xpcom/system/nsIXULRuntime.idl

}  // global

declare enum nsIXULRuntime_ExperimentStatus {
  eExperimentStatusUnenrolled = 0,
  eExperimentStatusControl = 1,
  eExperimentStatusTreatment = 2,
  eExperimentStatusDisqualified = 3,
  eExperimentStatusRollout = 4,
  eExperimentStatusCount = 5,
}

declare enum nsIXULRuntime_ContentWin32kLockdownState {
  LockdownEnabled = 1,
  MissingWebRender = 2,
  OperatingSystemNotSupported = 3,
  PrefNotSet = 4,
  MissingRemoteWebGL = 5,
  MissingNonNativeTheming = 6,
  DisabledByEnvVar = 7,
  DisabledByE10S = 9,
  DisabledByUserPref = 10,
  EnabledByUserPref = 11,
  DisabledByControlGroup = 12,
  EnabledByTreatmentGroup = 13,
  DisabledByDefault = 14,
  EnabledByDefault = 15,
  DecodersArentRemote = 16,
  IncompatibleMitigationPolicy = 17,
}

declare enum nsIXULRuntime_FissionDecisionStatus {
  eFissionStatusUnknown = 0,
  eFissionDisabledByE10sEnv = 3,
  eFissionEnabledByEnv = 4,
  eFissionDisabledByEnv = 5,
  eFissionEnabledByDefault = 7,
  eFissionDisabledByDefault = 8,
  eFissionEnabledByUserPref = 9,
  eFissionDisabledByUserPref = 10,
  eFissionDisabledByE10sOther = 11,
}

declare global {

namespace nsIXULRuntime {
  type ExperimentStatus = nsIXULRuntime_ExperimentStatus;
  type ContentWin32kLockdownState = nsIXULRuntime_ContentWin32kLockdownState;
  type FissionDecisionStatus = nsIXULRuntime_FissionDecisionStatus;
}

interface nsIXULRuntime extends nsISupports, Enums<typeof nsIXULRuntime_ExperimentStatus & typeof nsIXULRuntime_ContentWin32kLockdownState & typeof nsIXULRuntime_FissionDecisionStatus> {
  readonly PROCESS_TYPE_DEFAULT?: 0;
  readonly PROCESS_TYPE_CONTENT?: 2;
  readonly PROCESS_TYPE_IPDLUNITTEST?: 3;
  readonly PROCESS_TYPE_GMPLUGIN?: 4;
  readonly PROCESS_TYPE_GPU?: 5;
  readonly PROCESS_TYPE_VR?: 6;
  readonly PROCESS_TYPE_RDD?: 7;
  readonly PROCESS_TYPE_SOCKET?: 8;
  readonly PROCESS_TYPE_FORKSERVER?: 10;
  readonly PROCESS_TYPE_UTILITY?: 11;
  readonly E10S_MULTI_EXPERIMENT?: 1;

  readonly inSafeMode: boolean;
  readonly win32kExperimentStatus: nsIXULRuntime.ExperimentStatus;
  readonly win32kLiveStatusTestingOnly: nsIXULRuntime.ContentWin32kLockdownState;
  readonly win32kSessionStatus: nsIXULRuntime.ContentWin32kLockdownState;
  readonly fissionAutostart: boolean;
  readonly fissionDecisionStatus: nsIXULRuntime.FissionDecisionStatus;
  readonly fissionDecisionStatusString: string;
  readonly sessionHistoryInParent: boolean;
  readonly sessionStorePlatformCollection: boolean;
  logConsoleErrors: boolean;
  readonly OS: string;
  readonly XPCOMABI: string;
  readonly widgetToolkit: string;
  readonly processType: u32;
  readonly processID: u32;
  readonly uniqueProcessID: u64;
  readonly remoteType: string;
  readonly browserTabsRemoteAutostart: boolean;
  readonly maxWebProcessCount: u32;
  readonly accessibilityEnabled: boolean;
  readonly accessibilityInstantiator: string;
  readonly is64Bit: boolean;
  readonly isTextRecognitionSupported: boolean;
  invalidateCachesOnRestart(): void;
  readonly replacedLockTime: PRTime;
  readonly defaultUpdateChannel: string;
  readonly distributionID: string;
  readonly windowsDLLBlocklistStatus: boolean;
  readonly restartedByOS: boolean;
  readonly nativeMenubar: boolean;
  readonly chromeColorSchemeIsDark: boolean;
  readonly contentThemeDerivedColorSchemeIsDark: boolean;
  readonly prefersReducedMotion: boolean;
  readonly drawInTitlebar: boolean;
  readonly caretBlinkCount: i32;
  readonly caretBlinkTime: i32;
  readonly desktopEnvironment: string;
  readonly isWayland: boolean;
  readonly processStartupShortcut: string;
  readonly launcherProcessState: u32;
  readonly lastAppVersion: string;
  readonly lastAppBuildID: string;
}

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsIDirectTaskDispatcher.idl

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsIEnvironment.idl

interface nsIEnvironment extends nsISupports {
  set(aName: string, aValue: string): void;
  get(aName: string): string;
  exists(aName: string): boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsIEventTarget.idl

interface nsIEventTarget extends nsISupports {
  readonly DISPATCH_NORMAL?: 0;
  readonly DISPATCH_AT_END?: 2;
  readonly DISPATCH_EVENT_MAY_BLOCK?: 4;
  readonly DISPATCH_IGNORE_BLOCK_DISPATCH?: 8;

  isOnCurrentThread(): boolean;
  dispatch(event: nsIRunnable, flags: u32): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsIIdlePeriod.idl

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsINamed.idl

interface nsINamed extends nsISupports {
  readonly name: string;
}

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsIProcess.idl

interface nsIProcess extends nsISupports {
  init(executable: nsIFile): void;
  kill(): void;
  run(blocking: boolean, args: string[], count: u32): void;
  runAsync(args: string[], count: u32, observer?: nsIObserver, holdWeak?: boolean): void;
  runw(blocking: boolean, args: string[], count: u32): void;
  runwAsync(args: string[], count: u32, observer?: nsIObserver, holdWeak?: boolean): void;
  startHidden: boolean;
  noShell: boolean;
  readonly pid: u32;
  readonly exitValue: i32;
  readonly isRunning: boolean;
}

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsIRunnable.idl

type nsIRunnable = Callable<{
  run(): void;
}>

interface nsIRunnablePriority extends nsISupports {
  readonly PRIORITY_IDLE?: 0;
  readonly PRIORITY_DEFERRED_TIMERS?: 1;
  readonly PRIORITY_LOW?: 2;
  readonly PRIORITY_NORMAL?: 4;
  readonly PRIORITY_MEDIUMHIGH?: 5;
  readonly PRIORITY_INPUT_HIGH?: 6;
  readonly PRIORITY_VSYNC?: 7;
  readonly PRIORITY_RENDER_BLOCKING?: 9;
  readonly PRIORITY_CONTROL?: 10;

  readonly priority: u32;
}

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsISerialEventTarget.idl

interface nsISerialEventTarget extends nsIEventTarget {
}

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsISupportsPriority.idl

interface nsISupportsPriority extends nsISupports {
  readonly PRIORITY_HIGHEST?: -20;
  readonly PRIORITY_HIGH?: -10;
  readonly PRIORITY_NORMAL?: 0;
  readonly PRIORITY_LOW?: 10;
  readonly PRIORITY_LOWEST?: 20;

  priority: i32;
  adjustPriority(delta: i32): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsIThread.idl

}  // global

declare enum nsIThread_QoSPriority {
  QOS_PRIORITY_NORMAL = 0,
  QOS_PRIORITY_LOW = 1,
}

declare global {

namespace nsIThread {
  type QoSPriority = nsIThread_QoSPriority;
}

interface nsIThread extends nsISerialEventTarget, Enums<typeof nsIThread_QoSPriority> {
  shutdown(): void;
  hasPendingEvents(): boolean;
  hasPendingHighPriorityEvents(): boolean;
  processNextEvent(mayWait: boolean): boolean;
  asyncShutdown(): void;
  beginShutdown(): nsIThreadShutdown;
}

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsIThreadInternal.idl

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsIThreadManager.idl

type nsINestedEventLoopCondition = Callable<{
  isDone(): boolean;
}>

interface nsIThreadManager extends nsISupports {
  readonly mainThread: nsIThread;
  readonly currentThread: nsIThread;
  dispatchToMainThread(event: nsIRunnable, priority?: u32): void;
  dispatchToMainThreadWithMicroTask(event: nsIRunnable, priority?: u32): void;
  idleDispatchToMainThread(event: nsIRunnable, timeout?: u32): void;
  dispatchDirectTaskToCurrentThread(event: nsIRunnable): void;
  spinEventLoopUntil(aVeryGoodReasonToDoThis: string, condition: nsINestedEventLoopCondition): void;
  spinEventLoopUntilOrQuit(aVeryGoodReasonToDoThis: string, condition: nsINestedEventLoopCondition): void;
  spinEventLoopUntilEmpty(): void;
  readonly mainThreadEventTarget: nsIEventTarget;
}

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsIThreadPool.idl

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsIThreadShutdown.idl

interface nsIThreadShutdown extends nsISupports {
  onCompletion(aEvent: nsIRunnable): void;
  readonly completed: boolean;
  stopWaitingAndLeakThread(): void;
}

// https://searchfox.org/mozilla-central/source/xpcom/threads/nsITimer.idl

type nsITimerCallback = Callable<{
  notify(timer: nsITimer): void;
}>

interface nsITimer extends nsISupports {
  readonly TYPE_ONE_SHOT?: 0;
  readonly TYPE_REPEATING_SLACK?: 1;
  readonly TYPE_REPEATING_PRECISE?: 2;
  readonly TYPE_REPEATING_PRECISE_CAN_SKIP?: 3;
  readonly TYPE_REPEATING_SLACK_LOW_PRIORITY?: 4;
  readonly TYPE_ONE_SHOT_LOW_PRIORITY?: 5;

  init(aObserver: nsIObserver, aDelayInMs: u32, aType: u32): void;
  initWithCallback(aCallback: nsITimerCallback, aDelayInMs: u32, aType: u32): void;
  cancel(): void;
  delay: u32;
  type: u32;
  readonly callback: nsITimerCallback;
  target: nsIEventTarget;
  readonly name: string;
}

interface nsITimerManager extends nsISupports {
  getTimers(): nsITimer[];
}

// https://searchfox.org/mozilla-central/source/xpcom/tests/NotXPCOMTest.idl

interface nsIScriptableOK extends nsISupports {
  method1(): void;
}

interface nsIScriptableWithNotXPCOM extends nsISupports {
}

// https://searchfox.org/mozilla-central/source/js/xpconnect/idl/mozIJSSubScriptLoader.idl

interface mozIJSSubScriptLoader extends nsISupports {
  loadSubScript(url: string, obj?: any): any;
  loadSubScriptWithOptions(url: string, options: any): any;
}

// https://searchfox.org/mozilla-central/source/js/xpconnect/idl/nsIXPCScriptable.idl

// https://searchfox.org/mozilla-central/source/js/xpconnect/idl/xpcIJSWeakReference.idl

interface xpcIJSWeakReference extends nsISupports {
  get(): any;
}

// https://searchfox.org/mozilla-central/source/js/xpconnect/idl/xpccomponents.idl

interface nsIXPCComponents_Classes extends nsISupports {
}

interface nsIXPCComponents_Results extends nsISupports {
}

interface nsIXPCComponents_ID extends nsISupports {
}

interface nsIXPCComponents_Exception extends nsISupports {
}

interface nsIXPCComponents_Constructor extends nsISupports {
}

interface nsIXPCComponents_utils_Sandbox extends nsISupports {
}

type nsIScheduledGCCallback = Callable<{
  callback(): void;
}>

interface nsIXPCComponents_Utils extends nsISupports {
  printStderr(message: string): void;
  reportError(error: any, stack?: any): void;
  readonly Sandbox: nsIXPCComponents_utils_Sandbox;
  evalInSandbox(source: string, sandbox: any, version?: any, filename?: string, lineNo?: i32, enforceFilenameRestrictions?: boolean): any;
  getUAWidgetScope(principal: nsIPrincipal): any;
  getSandboxMetadata(sandbox: any): any;
  setSandboxMetadata(sandbox: any, metadata: any): void;
  isESModuleLoaded(aResourceURI: string): boolean;
  importGlobalProperties(aPropertyList: any): void;
  getWeakReference(obj: any): xpcIJSWeakReference;
  forceGC(): void;
  forceCC(aListener?: nsICycleCollectorListener): void;
  createCCLogger(): nsICycleCollectorListener;
  finishCC(): void;
  ccSlice(budget: i64): void;
  getMaxCCSliceTimeSinceClear(): i32;
  clearMaxCCTime(): void;
  forceShrinkingGC(): void;
  schedulePreciseGC(callback: nsIScheduledGCCallback): void;
  schedulePreciseShrinkingGC(callback: nsIScheduledGCCallback): void;
  unlinkGhostWindows(): void;
  intentionallyLeak(): void;
  getJSTestingFunctions(): any;
  getFunctionSourceLocation(func: any): any;
  callFunctionWithAsyncStack(func: any, stack: nsIStackFrame, asyncCause: string): any;
  getGlobalForObject(obj: any): any;
  isProxy(vobject: any): boolean;
  exportFunction(vfunction: any, vscope: any, voptions?: any): any;
  createObjectIn(vobj: any, voptions?: any): any;
  makeObjectPropsNormal(vobj: any): void;
  isDeadWrapper(obj: any): boolean;
  isRemoteProxy(val: any): boolean;
  recomputeWrappers(vobj?: any): void;
  setWantXrays(vscope: any): void;
  dispatch(runnable: any, scope?: any): void;
  readonly isInAutomation: boolean;
  exitIfInAutomation(): void;
  crashIfNotInAutomation(): void;
  setGCZeal(zeal: i32): void;
  nukeSandbox(obj: any): void;
  blockScriptForGlobal(global: any): void;
  unblockScriptForGlobal(global: any): void;
  isOpaqueWrapper(obj: any): boolean;
  isXrayWrapper(obj: any): boolean;
  waiveXrays(aVal: any): any;
  unwaiveXrays(aVal: any): any;
  getClassName(aObj: any, aUnwrap: boolean): string;
  getIncumbentGlobal(callback?: any): any;
  getDebugName(obj: any): string;
  getWatchdogTimestamp(aCategory: string): PRTime;
  getJSEngineTelemetryValue(): any;
  cloneInto(value: any, scope: any, options?: any): any;
  getWebIDLCallerPrincipal(): nsIPrincipal;
  getObjectPrincipal(obj: any): nsIPrincipal;
  getRealmLocation(obj: any): string;
  now(): double;
  readUTF8File(file: nsIFile): string;
  readUTF8URI(url: nsIURI): string;
  createSpellChecker(): nsIEditorSpellCheck;
  createCommandLine(args: string[], workingDir: nsIFile, state: u32): nsISupports;
  createCommandParams(): nsICommandParams;
  createLoadContext(): nsILoadContext;
  createPrivateLoadContext(): nsILoadContext;
  createPersistentProperties(): nsIPersistentProperties;
  createDocumentEncoder(contentType: string): nsIDocumentEncoder;
  createHTMLCopyEncoder(): nsIDocumentEncoder;
  readonly loadedESModules: string[];
  getModuleImportStack(aLocation: string): string;
}

interface nsIXPCComponents extends nsISupports {
  readonly interfaces: nsIXPCComponents_Interfaces;
  readonly results: nsIXPCComponents_Results;
  isSuccessCode(result: nsresult): boolean;
  readonly classes: nsIXPCComponents_Classes;
  readonly stack: nsIStackFrame;
  readonly manager: nsIComponentManager;
  readonly utils: nsIXPCComponents_Utils;
  readonly ID: nsIXPCComponents_ID;
  readonly Exception: nsIXPCComponents_Exception;
  readonly Constructor: nsIXPCComponents_Constructor;
  returnCode: any;
}

// https://searchfox.org/mozilla-central/source/js/xpconnect/tests/idl/xpctest_attributes.idl

interface nsIXPCTestObjectReadOnly extends nsISupports {
  readonly strReadOnly: string;
  readonly boolReadOnly: boolean;
  readonly shortReadOnly: i16;
  readonly longReadOnly: i32;
  readonly floatReadOnly: float;
  readonly charReadOnly: string;
  readonly timeReadOnly: PRTime;
}

interface nsIXPCTestObjectReadWrite extends nsISupports {
  stringProperty: string;
  booleanProperty: boolean;
  shortProperty: i16;
  longProperty: i32;
  floatProperty: float;
  charProperty: string;
  timeProperty: PRTime;
}

// https://searchfox.org/mozilla-central/source/js/xpconnect/tests/idl/xpctest_bug809674.idl

interface nsIXPCTestBug809674 extends nsISupports {
  addArgs(x: u32, y: u32): u32;
  addSubMulArgs(x: u32, y: u32, subOut: OutParam<u32>, mulOut: OutParam<u32>): u32;
  addVals(x: any, y: any): any;
  methodNoArgs(): u32;
  methodNoArgsNoRetVal(): void;
  addMany(x1: u32, x2: u32, x3: u32, x4: u32, x5: u32, x6: u32, x7: u32, x8: u32): u32;
  valProperty: any;
  uintProperty: u32;
  methodWithOptionalArgc(): void;
}

// https://searchfox.org/mozilla-central/source/js/xpconnect/tests/idl/xpctest_cenums.idl

}  // global

declare enum nsIXPCTestCEnums_testFlagsExplicit {
  shouldBe1Explicit = 1,
  shouldBe2Explicit = 2,
  shouldBe4Explicit = 4,
  shouldBe8Explicit = 8,
  shouldBe12Explicit = 12,
}

declare enum nsIXPCTestCEnums_testFlagsImplicit {
  shouldBe0Implicit = 0,
  shouldBe1Implicit = 1,
  shouldBe2Implicit = 2,
  shouldBe3Implicit = 3,
  shouldBe5Implicit = 5,
  shouldBe6Implicit = 6,
  shouldBe2AgainImplicit = 2,
  shouldBe3AgainImplicit = 3,
}

declare global {

namespace nsIXPCTestCEnums {
  type testFlagsExplicit = nsIXPCTestCEnums_testFlagsExplicit;
  type testFlagsImplicit = nsIXPCTestCEnums_testFlagsImplicit;
}

interface nsIXPCTestCEnums extends nsISupports, Enums<typeof nsIXPCTestCEnums_testFlagsExplicit & typeof nsIXPCTestCEnums_testFlagsImplicit> {
  readonly testConst?: 1;

  testCEnumInput(abc: nsIXPCTestCEnums.testFlagsExplicit): void;
  testCEnumOutput(): nsIXPCTestCEnums.testFlagsExplicit;
}

// https://searchfox.org/mozilla-central/source/js/xpconnect/tests/idl/xpctest_interfaces.idl

interface nsIXPCTestInterfaceA extends nsISupports {
  name: string;
}

interface nsIXPCTestInterfaceB extends nsISupports {
  name: string;
}

interface nsIXPCTestInterfaceC extends nsISupports {
  someInteger: i32;
}

// https://searchfox.org/mozilla-central/source/js/xpconnect/tests/idl/xpctest_params.idl

interface nsIXPCTestParams extends nsISupports {
  testBoolean(a: boolean, b: InOutParam<boolean>): boolean;
  testOctet(a: u8, b: InOutParam<u8>): u8;
  testShort(a: i16, b: InOutParam<i16>): i16;
  testLong(a: i32, b: InOutParam<i32>): i32;
  testLongLong(a: i64, b: InOutParam<i64>): i64;
  testUnsignedShort(a: u16, b: InOutParam<u16>): u16;
  testUnsignedLong(a: u32, b: InOutParam<u32>): u32;
  testUnsignedLongLong(a: u64, b: InOutParam<u64>): u64;
  testFloat(a: float, b: InOutParam<float>): float;
  testDouble(a: double, b: InOutParam<float>): double;
  testChar(a: string, b: InOutParam<string>): string;
  testString(a: string, b: InOutParam<string>): string;
  testWchar(a: string, b: InOutParam<string>): string;
  testWstring(a: string, b: InOutParam<string>): string;
  testAString(a: string, b: InOutParam<string>): string;
  testAUTF8String(a: string, b: InOutParam<string>): string;
  testACString(a: string, b: InOutParam<string>): string;
  testJsval(a: any, b: InOutParam<any>): any;
  testShortSequence(a: i16[], b: InOutParam<i16[]>): i16[];
  testDoubleSequence(a: double[], b: InOutParam<double[]>): double[];
  testInterfaceSequence(a: nsIXPCTestInterfaceA[], b: InOutParam<nsIXPCTestInterfaceA[]>): nsIXPCTestInterfaceA[];
  testAStringSequence(a: string[], b: InOutParam<string[]>): string[];
  testACStringSequence(a: string[], b: InOutParam<string[]>): string[];
  testJsvalSequence(a: any[], b: InOutParam<any[]>): any[];
  testSequenceSequence(a: i16[][], b: InOutParam<i16[][]>): i16[][];
  testOptionalSequence(arr?: u8[]): u8[];
  testShortArray(aLength: u32, a: i16[], bLength: InOutParam<u32>, b: InOutParam<i16[]>, rvLength: OutParam<u32>): i16[];
  testDoubleArray(aLength: u32, a: double[], bLength: InOutParam<u32>, b: InOutParam<double[]>, rvLength: OutParam<u32>): double[];
  testStringArray(aLength: u32, a: string[], bLength: InOutParam<u32>, b: InOutParam<string[]>, rvLength: OutParam<u32>): string[];
  testWstringArray(aLength: u32, a: string[], bLength: InOutParam<u32>, b: InOutParam<string[]>, rvLength: OutParam<u32>): string[];
  testInterfaceArray(aLength: u32, a: nsIXPCTestInterfaceA[], bLength: InOutParam<u32>, b: InOutParam<nsIXPCTestInterfaceA[]>, rvLength: OutParam<u32>): nsIXPCTestInterfaceA[];
  testByteArrayOptionalLength(a: u8[], aLength?: u32): u32;
  testSizedString(aLength: u32, a: string, bLength: InOutParam<u32>, b: InOutParam<string>, rvLength: OutParam<u32>): string;
  testSizedWstring(aLength: u32, a: string, bLength: InOutParam<u32>, b: InOutParam<string>, rvLength: OutParam<u32>): string;
  testJsvalArray(aLength: u32, a: any[], bLength: InOutParam<u32>, b: InOutParam<any[]>, rvLength: OutParam<u32>): any[];
  testOutAString(o: OutParam<string>): void;
  testStringArrayOptionalSize(a: string[], aLength?: u32): string;
  testOmittedOptionalOut(aJSObj: nsIXPCTestParams, aOut?: OutParam<nsIURI>): void;
  readonly testNaN: double;
}

// https://searchfox.org/mozilla-central/source/js/xpconnect/tests/idl/xpctest_returncode.idl

interface nsIXPCTestReturnCodeParent extends nsISupports {
  callChild(childBehavior: i32): nsresult;
}

interface nsIXPCTestReturnCodeChild extends nsISupports {
  readonly CHILD_SHOULD_THROW?: 0;
  readonly CHILD_SHOULD_RETURN_SUCCESS?: 1;
  readonly CHILD_SHOULD_RETURN_RESULTCODE?: 2;
  readonly CHILD_SHOULD_NEST_RESULTCODES?: 3;

  doIt(behavior: i32): void;
}

// https://searchfox.org/mozilla-central/source/js/xpconnect/tests/idl/xpctest_utils.idl

type nsIXPCTestFunctionInterface = Callable<{
  echo(arg: string): string;
}>

interface nsIXPCTestUtils extends nsISupports {
  doubleWrapFunction(f: nsIXPCTestFunctionInterface): nsIXPCTestFunctionInterface;
}

interface nsIXPCTestTypeScript extends nsISupports {
  exposedProp: i32;
  exposedMethod(arg: i32): void;
}

// https://searchfox.org/mozilla-central/source/dom/xul/nsIBrowserController.idl

interface nsIBrowserController extends nsISupports {
  enableDisableCommands(action: string, enabledCommands: string[], disabledCommands: string[]): void;
}

// https://searchfox.org/mozilla-central/source/dom/xul/nsIController.idl

interface nsIController extends nsISupports {
  isCommandEnabled(command: string): boolean;
  supportsCommand(command: string): boolean;
  doCommand(command: string): void;
  onEvent(eventName: string): void;
}

interface nsICommandController extends nsISupports {
  getCommandStateWithParams(command: string, aCommandParams: nsICommandParams): void;
  doCommandWithParams(command: string, aCommandParams: nsICommandParams): void;
  getSupportedCommands(): string[];
}

// https://searchfox.org/mozilla-central/source/dom/xul/nsIControllers.idl

interface nsIControllers extends nsISupports {
  getControllerForCommand(command: string): nsIController;
  insertControllerAt(index: u32, controller: nsIController): void;
  removeControllerAt(index: u32): nsIController;
  getControllerAt(index: u32): nsIController;
  appendController(controller: nsIController): void;
  removeController(controller: nsIController): void;
  getControllerId(controller: nsIController): u32;
  getControllerById(controllerID: u32): nsIController;
  getControllerCount(): u32;
}

// https://searchfox.org/mozilla-central/source/toolkit/xre/nsINativeAppSupport.idl

interface nsINativeAppSupport extends nsISupports {
  start(): boolean;
  enable(): void;
  onLastWindowClosing(): void;
  ReOpen(): void;
}

// https://searchfox.org/mozilla-central/source/toolkit/xre/nsIXREDirProvider.idl

interface nsIXREDirProvider extends nsISupports {
  setUserDataDirectory(aFile: nsIFile, aLocal: boolean): void;
  getInstallHash(): string;
}

// https://searchfox.org/mozilla-central/source/modules/libjar/zipwriter/nsIZipWriter.idl

interface nsIZipWriter extends nsISupports {
  readonly COMPRESSION_NONE?: 0;
  readonly COMPRESSION_FASTEST?: 1;
  readonly COMPRESSION_DEFAULT?: 6;
  readonly COMPRESSION_BEST?: 9;

  comment: string;
  readonly inQueue: boolean;
  readonly file: nsIFile;
  open(aFile: nsIFile, aIoFlags: i32): void;
  getEntry(aZipEntry: string): nsIZipEntry;
  hasEntry(aZipEntry: string): boolean;
  addEntryDirectory(aZipEntry: string, aModTime: PRTime, aQueue: boolean): void;
  addEntryFile(aZipEntry: string, aCompression: i32, aFile: nsIFile, aQueue: boolean): void;
  addEntryChannel(aZipEntry: string, aModTime: PRTime, aCompression: i32, aChannel: nsIChannel, aQueue: boolean): void;
  addEntryStream(aZipEntry: string, aModTime: PRTime, aCompression: i32, aStream: nsIInputStream, aQueue: boolean): void;
  removeEntry(aZipEntry: string, aQueue: boolean): void;
  processQueue(aObserver: nsIRequestObserver, aContext: nsISupports): void;
  close(): void;
  alignStoredFiles(aAlignSize: u16): void;
}

interface nsIXPCComponents_Interfaces {
  nsIBits: nsJSIID<nsIBits>;
  nsIBitsNewRequestCallback: nsJSIID<nsIBitsNewRequestCallback>;
  nsIBitsRequest: nsJSIID<nsIBitsRequest>;
  nsIBitsCallback: nsJSIID<nsIBitsCallback>;
  nsIAccessibilityService: nsJSIID<nsIAccessibilityService>;
  nsIAccessible: nsJSIID<nsIAccessible>;
  nsIAccessibleAnnouncementEvent: nsJSIID<nsIAccessibleAnnouncementEvent>;
  nsIAccessibleApplication: nsJSIID<nsIAccessibleApplication>;
  nsIAccessibleCaretMoveEvent: nsJSIID<nsIAccessibleCaretMoveEvent>;
  nsIAccessibleDocument: nsJSIID<nsIAccessibleDocument>;
  nsIAccessibleEditableText: nsJSIID<nsIAccessibleEditableText>;
  nsIAccessibleEvent: nsJSIID<nsIAccessibleEvent>;
  nsIAccessibleHideEvent: nsJSIID<nsIAccessibleHideEvent>;
  nsIAccessibleHyperLink: nsJSIID<nsIAccessibleHyperLink>;
  nsIAccessibleHyperText: nsJSIID<nsIAccessibleHyperText>;
  nsIAccessibleImage: nsJSIID<nsIAccessibleImage>;
  nsIAccessibleObjectAttributeChangedEvent: nsJSIID<nsIAccessibleObjectAttributeChangedEvent>;
  nsIAccessiblePivot: nsJSIID<nsIAccessiblePivot>;
  nsIAccessibleTraversalRule: nsJSIID<nsIAccessibleTraversalRule>;
  nsIAccessibleRelation: nsJSIID<nsIAccessibleRelation>;
  nsIAccessibleRole: nsJSIID<nsIAccessibleRole>;
  nsIAccessibleScrollingEvent: nsJSIID<nsIAccessibleScrollingEvent>;
  nsIAccessibleSelectable: nsJSIID<nsIAccessibleSelectable>;
  nsIAccessibleStateChangeEvent: nsJSIID<nsIAccessibleStateChangeEvent>;
  nsIAccessibleStates: nsJSIID<nsIAccessibleStates>;
  nsIAccessibleTable: nsJSIID<nsIAccessibleTable>;
  nsIAccessibleTableCell: nsJSIID<nsIAccessibleTableCell>;
  nsIAccessibleTableChangeEvent: nsJSIID<nsIAccessibleTableChangeEvent>;
  nsIAccessibleText: nsJSIID<nsIAccessibleText>;
  nsIAccessibleTextChangeEvent: nsJSIID<nsIAccessibleTextChangeEvent>;
  nsIAccessibleTextLeafPoint: nsJSIID<nsIAccessibleTextLeafPoint>;
  nsIAccessibleTextRange: nsJSIID<nsIAccessibleTextRange>;
  nsIAccessibleTextSelectionChangeEvent: nsJSIID<nsIAccessibleTextSelectionChangeEvent>;
  nsIAccessibleScrollType: nsJSIID<nsIAccessibleScrollType>;
  nsIAccessibleCoordinateType: nsJSIID<nsIAccessibleCoordinateType>;
  nsIAccessibleValue: nsJSIID<nsIAccessibleValue>;
  nsIAlertNotificationImageListener: nsJSIID<nsIAlertNotificationImageListener>;
  nsIAlertAction: nsJSIID<nsIAlertAction>;
  nsIAlertNotification: nsJSIID<nsIAlertNotification>;
  nsIAlertsService: nsJSIID<nsIAlertsService>;
  nsIAlertsDoNotDisturb: nsJSIID<nsIAlertsDoNotDisturb>;
  nsIAppShellService: nsJSIID<nsIAppShellService>;
  nsIAppWindow: nsJSIID<nsIAppWindow>;
  nsIWindowMediator: nsJSIID<nsIWindowMediator>;
  nsIWindowMediatorListener: nsJSIID<nsIWindowMediatorListener>;
  nsIWindowlessBrowser: nsJSIID<nsIWindowlessBrowser>;
  nsIXULBrowserWindow: nsJSIID<nsIXULBrowserWindow>;
  nsIAppStartup: nsJSIID<nsIAppStartup, typeof nsIAppStartup_IDLShutdownPhase>;
  nsIAutoCompleteController: nsJSIID<nsIAutoCompleteController>;
  nsIAutoCompleteInput: nsJSIID<nsIAutoCompleteInput>;
  nsIAutoCompletePopup: nsJSIID<nsIAutoCompletePopup>;
  nsIAutoCompleteResult: nsJSIID<nsIAutoCompleteResult>;
  nsIAutoCompleteSearch: nsJSIID<nsIAutoCompleteSearch>;
  nsIAutoCompleteObserver: nsJSIID<nsIAutoCompleteObserver>;
  nsIAutoCompleteSimpleResult: nsJSIID<nsIAutoCompleteSimpleResult>;
  nsIAutoCompleteSimpleResultListener: nsJSIID<nsIAutoCompleteSimpleResultListener>;
  nsIAutoCompleteSimpleSearch: nsJSIID<nsIAutoCompleteSimpleSearch>;
  nsIAutoplay: nsJSIID<nsIAutoplay>;
  nsIHangDetails: nsJSIID<nsIHangDetails>;
  nsIBrowserHandler: nsJSIID<nsIBrowserHandler>;
  nsIAddonPolicyService: nsJSIID<nsIAddonPolicyService>;
  nsIAddonContentPolicy: nsJSIID<nsIAddonContentPolicy>;
  nsIDomainPolicy: nsJSIID<nsIDomainPolicy>;
  nsIDomainSet: nsJSIID<nsIDomainSet>;
  nsIPrincipal: nsJSIID<nsIPrincipal>;
  nsIScriptSecurityManager: nsJSIID<nsIScriptSecurityManager>;
  nsICaptivePortalCallback: nsJSIID<nsICaptivePortalCallback>;
  nsICaptivePortalDetector: nsJSIID<nsICaptivePortalDetector>;
  nsICascadeFilter: nsJSIID<nsICascadeFilter>;
  nsIChromeRegistry: nsJSIID<nsIChromeRegistry>;
  nsIXULChromeRegistry: nsJSIID<nsIXULChromeRegistry>;
  nsIToolkitChromeRegistry: nsJSIID<nsIToolkitChromeRegistry>;
  nsICommandManager: nsJSIID<nsICommandManager>;
  nsICommandParams: nsJSIID<nsICommandParams>;
  nsIControllerCommand: nsJSIID<nsIControllerCommand>;
  nsIControllerCommandTable: nsJSIID<nsIControllerCommandTable>;
  nsIControllerContext: nsJSIID<nsIControllerContext>;
  nsICommandLine: nsJSIID<nsICommandLine>;
  nsICommandLineHandler: nsJSIID<nsICommandLineHandler>;
  nsICommandLineValidator: nsJSIID<nsICommandLineValidator>;
  nsIEditingSession: nsJSIID<nsIEditingSession>;
  nsIEventListenerChange: nsJSIID<nsIEventListenerChange>;
  nsIListenerChangeListener: nsJSIID<nsIListenerChangeListener>;
  nsIEventListenerInfo: nsJSIID<nsIEventListenerInfo>;
  nsIEventListenerService: nsJSIID<nsIEventListenerService>;
  mozIGeckoMediaPluginChromeService: nsJSIID<mozIGeckoMediaPluginChromeService>;
  mozIGeckoMediaPluginService: nsJSIID<mozIGeckoMediaPluginService>;
  nsIDocShell: nsJSIID<nsIDocShell, typeof nsIDocShell_DocShellEnumeratorDirection & typeof nsIDocShell_AppType & typeof nsIDocShell_BusyFlags & typeof nsIDocShell_LoadCommand>;
  nsIDocShellTreeItem: nsJSIID<nsIDocShellTreeItem>;
  nsIDocShellTreeOwner: nsJSIID<nsIDocShellTreeOwner>;
  nsIDocumentLoaderFactory: nsJSIID<nsIDocumentLoaderFactory>;
  nsIDocumentViewer: nsJSIID<nsIDocumentViewer, typeof nsIDocumentViewer_PermitUnloadAction & typeof nsIDocumentViewer_PermitUnloadResult>;
  nsIDocumentViewerEdit: nsJSIID<nsIDocumentViewerEdit>;
  nsILoadContext: nsJSIID<nsILoadContext>;
  nsILoadURIDelegate: nsJSIID<nsILoadURIDelegate>;
  nsIPrivacyTransitionObserver: nsJSIID<nsIPrivacyTransitionObserver>;
  nsIReflowObserver: nsJSIID<nsIReflowObserver>;
  nsIRefreshURI: nsJSIID<nsIRefreshURI>;
  nsITooltipListener: nsJSIID<nsITooltipListener>;
  nsITooltipTextProvider: nsJSIID<nsITooltipTextProvider>;
  nsIURIFixupInfo: nsJSIID<nsIURIFixupInfo>;
  nsIURIFixup: nsJSIID<nsIURIFixup>;
  nsIWebNavigation: nsJSIID<nsIWebNavigation>;
  nsIWebNavigationInfo: nsJSIID<nsIWebNavigationInfo>;
  nsIWebPageDescriptor: nsJSIID<nsIWebPageDescriptor>;
  mozIDOMWindow: nsJSIID<mozIDOMWindow>;
  mozIDOMWindowProxy: nsJSIID<mozIDOMWindowProxy>;
  nsIContentPolicy: nsJSIID<nsIContentPolicy, typeof nsIContentPolicy_nsContentPolicyType>;
  nsIDroppedLinkItem: nsJSIID<nsIDroppedLinkItem>;
  nsIDroppedLinkHandler: nsJSIID<nsIDroppedLinkHandler>;
  nsIEventSourceEventListener: nsJSIID<nsIEventSourceEventListener>;
  nsIEventSourceEventService: nsJSIID<nsIEventSourceEventService>;
  nsIImageLoadingContent: nsJSIID<nsIImageLoadingContent>;
  nsIMessageSender: nsJSIID<nsIMessageSender>;
  nsIObjectLoadingContent: nsJSIID<nsIObjectLoadingContent>;
  nsIScriptableContentIterator: nsJSIID<nsIScriptableContentIterator, typeof nsIScriptableContentIterator_IteratorType>;
  nsISelectionController: nsJSIID<nsISelectionController, typeof nsISelectionController_ControllerScrollFlags>;
  nsISelectionDisplay: nsJSIID<nsISelectionDisplay>;
  nsISelectionListener: nsJSIID<nsISelectionListener>;
  nsISlowScriptDebugCallback: nsJSIID<nsISlowScriptDebugCallback>;
  nsISlowScriptDebuggerStartupCallback: nsJSIID<nsISlowScriptDebuggerStartupCallback>;
  nsISlowScriptDebugRemoteCallback: nsJSIID<nsISlowScriptDebugRemoteCallback>;
  nsISlowScriptDebug: nsJSIID<nsISlowScriptDebug>;
  nsIConsoleAPIStorage: nsJSIID<nsIConsoleAPIStorage>;
  mozIRemoteLazyInputStream: nsJSIID<mozIRemoteLazyInputStream>;
  nsIDOMProcessChild: nsJSIID<nsIDOMProcessChild>;
  nsIDOMProcessParent: nsJSIID<nsIDOMProcessParent>;
  nsIContentParentKeepAlive: nsJSIID<nsIContentParentKeepAlive>;
  nsIHangReport: nsJSIID<nsIHangReport>;
  nsILoginDetectionService: nsJSIID<nsILoginDetectionService>;
  nsISuspendedTypes: nsJSIID<nsISuspendedTypes>;
  nsIBrowser: nsJSIID<nsIBrowser>;
  nsIBrowserChild: nsJSIID<nsIBrowserChild>;
  nsIOpenURIInFrameParams: nsJSIID<nsIOpenURIInFrameParams>;
  nsIBrowserDOMWindow: nsJSIID<nsIBrowserDOMWindow>;
  nsIBrowserUsage: nsJSIID<nsIBrowserUsage>;
  nsIContentPermissionType: nsJSIID<nsIContentPermissionType>;
  nsIContentPermissionRequest: nsJSIID<nsIContentPermissionRequest>;
  nsIContentPermissionPrompt: nsJSIID<nsIContentPermissionPrompt>;
  nsIContentPrefObserver: nsJSIID<nsIContentPrefObserver>;
  nsIContentPrefService2: nsJSIID<nsIContentPrefService2>;
  nsIContentPrefCallback2: nsJSIID<nsIContentPrefCallback2>;
  nsIContentPref: nsJSIID<nsIContentPref>;
  nsIDOMGlobalPropertyInitializer: nsJSIID<nsIDOMGlobalPropertyInitializer>;
  nsIDOMWindow: nsJSIID<nsIDOMWindow>;
  nsIDOMWindowUtils: nsJSIID<nsIDOMWindowUtils>;
  nsITranslationNodeList: nsJSIID<nsITranslationNodeList>;
  nsIJSRAIIHelper: nsJSIID<nsIJSRAIIHelper>;
  nsIFocusManager: nsJSIID<nsIFocusManager>;
  nsIGeckoViewServiceWorker: nsJSIID<nsIGeckoViewServiceWorker>;
  nsIPermissionDelegateHandler: nsJSIID<nsIPermissionDelegateHandler>;
  nsIQueryContentEventResult: nsJSIID<nsIQueryContentEventResult>;
  nsIRemoteTab: nsJSIID<nsIRemoteTab, typeof nsIRemoteTab_NavigationType>;
  nsIServiceWorkerUnregisterCallback: nsJSIID<nsIServiceWorkerUnregisterCallback>;
  nsIServiceWorkerInfo: nsJSIID<nsIServiceWorkerInfo>;
  nsIServiceWorkerRegistrationInfoListener: nsJSIID<nsIServiceWorkerRegistrationInfoListener>;
  nsIServiceWorkerRegistrationInfo: nsJSIID<nsIServiceWorkerRegistrationInfo>;
  nsIServiceWorkerManagerListener: nsJSIID<nsIServiceWorkerManagerListener>;
  nsIServiceWorkerManager: nsJSIID<nsIServiceWorkerManager>;
  nsIStructuredCloneContainer: nsJSIID<nsIStructuredCloneContainer>;
  nsITextInputProcessor: nsJSIID<nsITextInputProcessor>;
  nsITextInputProcessorNotification: nsJSIID<nsITextInputProcessorNotification>;
  nsITextInputProcessorCallback: nsJSIID<nsITextInputProcessorCallback>;
  nsIScriptErrorNote: nsJSIID<nsIScriptErrorNote>;
  nsIScriptError: nsJSIID<nsIScriptError>;
  nsIDOMGeoPosition: nsJSIID<nsIDOMGeoPosition>;
  nsIDOMGeoPositionCallback: nsJSIID<nsIDOMGeoPositionCallback>;
  nsIDOMGeoPositionCoords: nsJSIID<nsIDOMGeoPositionCoords>;
  nsIDOMGeoPositionErrorCallback: nsJSIID<nsIDOMGeoPositionErrorCallback>;
  nsICredentialChooserService: nsJSIID<nsICredentialChooserService>;
  nsICredentialChosenCallback: nsJSIID<nsICredentialChosenCallback>;
  nsIIdentityCredentialPromptService: nsJSIID<nsIIdentityCredentialPromptService>;
  nsIIdentityCredentialStorageService: nsJSIID<nsIIdentityCredentialStorageService>;
  nsIIDBPermissionsRequest: nsJSIID<nsIIDBPermissionsRequest>;
  nsIIndexedDatabaseManager: nsJSIID<nsIIndexedDatabaseManager>;
  nsILocalStorageManager: nsJSIID<nsILocalStorageManager>;
  nsIAudioDeviceInfo: nsJSIID<nsIAudioDeviceInfo>;
  nsIMediaDevice: nsJSIID<nsIMediaDevice>;
  nsIMediaManagerService: nsJSIID<nsIMediaManagerService>;
  nsITCPSocketCallback: nsJSIID<nsITCPSocketCallback>;
  nsIUDPSocketInternal: nsJSIID<nsIUDPSocketInternal>;
  nsINotificationActionStorageEntry: nsJSIID<nsINotificationActionStorageEntry>;
  nsINotificationStorageEntry: nsJSIID<nsINotificationStorageEntry>;
  nsINotificationStorageCallback: nsJSIID<nsINotificationStorageCallback>;
  nsINotificationStorage: nsJSIID<nsINotificationStorage>;
  nsIPaymentResponseData: nsJSIID<nsIPaymentResponseData>;
  nsIGeneralResponseData: nsJSIID<nsIGeneralResponseData>;
  nsIBasicCardResponseData: nsJSIID<nsIBasicCardResponseData>;
  nsIPaymentActionResponse: nsJSIID<nsIPaymentActionResponse>;
  nsIPaymentCanMakeActionResponse: nsJSIID<nsIPaymentCanMakeActionResponse>;
  nsIPaymentShowActionResponse: nsJSIID<nsIPaymentShowActionResponse>;
  nsIPaymentAbortActionResponse: nsJSIID<nsIPaymentAbortActionResponse>;
  nsIPaymentCompleteActionResponse: nsJSIID<nsIPaymentCompleteActionResponse>;
  nsIMethodChangeDetails: nsJSIID<nsIMethodChangeDetails>;
  nsIGeneralChangeDetails: nsJSIID<nsIGeneralChangeDetails>;
  nsIBasicCardChangeDetails: nsJSIID<nsIBasicCardChangeDetails>;
  nsIPaymentAddress: nsJSIID<nsIPaymentAddress>;
  nsIPaymentMethodData: nsJSIID<nsIPaymentMethodData>;
  nsIPaymentCurrencyAmount: nsJSIID<nsIPaymentCurrencyAmount>;
  nsIPaymentItem: nsJSIID<nsIPaymentItem>;
  nsIPaymentDetailsModifier: nsJSIID<nsIPaymentDetailsModifier>;
  nsIPaymentShippingOption: nsJSIID<nsIPaymentShippingOption>;
  nsIPaymentDetails: nsJSIID<nsIPaymentDetails>;
  nsIPaymentOptions: nsJSIID<nsIPaymentOptions>;
  nsIPaymentRequest: nsJSIID<nsIPaymentRequest>;
  nsIPaymentRequestService: nsJSIID<nsIPaymentRequestService>;
  nsIPaymentUIService: nsJSIID<nsIPaymentUIService>;
  nsIDOMMozWakeLockListener: nsJSIID<nsIDOMMozWakeLockListener>;
  nsIPowerManagerService: nsJSIID<nsIPowerManagerService>;
  nsIWakeLock: nsJSIID<nsIWakeLock>;
  nsIPushErrorReporter: nsJSIID<nsIPushErrorReporter>;
  nsIPushNotifier: nsJSIID<nsIPushNotifier>;
  nsIPushData: nsJSIID<nsIPushData>;
  nsIPushMessage: nsJSIID<nsIPushMessage>;
  nsIPushSubscription: nsJSIID<nsIPushSubscription>;
  nsIPushSubscriptionCallback: nsJSIID<nsIPushSubscriptionCallback>;
  nsIUnsubscribeResultCallback: nsJSIID<nsIUnsubscribeResultCallback>;
  nsIPushClearResultCallback: nsJSIID<nsIPushClearResultCallback>;
  nsIPushService: nsJSIID<nsIPushService>;
  nsIPushQuotaManager: nsJSIID<nsIPushQuotaManager>;
  nsIQuotaArtificialFailure: nsJSIID<nsIQuotaArtificialFailure, typeof nsIQuotaArtificialFailure_Category>;
  nsIQuotaUsageCallback: nsJSIID<nsIQuotaUsageCallback>;
  nsIQuotaCallback: nsJSIID<nsIQuotaCallback>;
  nsIQuotaManagerService: nsJSIID<nsIQuotaManagerService>;
  nsIQuotaManagerServiceInternal: nsJSIID<nsIQuotaManagerServiceInternal>;
  nsIQuotaRequestBase: nsJSIID<nsIQuotaRequestBase>;
  nsIQuotaUsageRequest: nsJSIID<nsIQuotaUsageRequest>;
  nsIQuotaRequest: nsJSIID<nsIQuotaRequest>;
  nsIQuotaFullOriginMetadataResult: nsJSIID<nsIQuotaFullOriginMetadataResult>;
  nsIQuotaUsageResult: nsJSIID<nsIQuotaUsageResult>;
  nsIQuotaOriginUsageResult: nsJSIID<nsIQuotaOriginUsageResult>;
  nsIQuotaEstimateResult: nsJSIID<nsIQuotaEstimateResult>;
  nsIQuotaUtilsService: nsJSIID<nsIQuotaUtilsService>;
  nsIContentSecurityManager: nsJSIID<nsIContentSecurityManager>;
  nsIContentSecurityPolicy: nsJSIID<nsIContentSecurityPolicy, typeof nsIContentSecurityPolicy_CSPDirective & typeof nsIContentSecurityPolicy_RequireTrustedTypesForDirectiveState>;
  nsICSPEventListener: nsJSIID<nsICSPEventListener>;
  nsIReferrerInfo: nsJSIID<nsIReferrerInfo, typeof nsIReferrerInfo_ReferrerPolicyIDL>;
  nsIHttpsOnlyModePermission: nsJSIID<nsIHttpsOnlyModePermission>;
  nsIDocumentEncoderNodeFixup: nsJSIID<nsIDocumentEncoderNodeFixup>;
  nsIDocumentEncoder: nsJSIID<nsIDocumentEncoder>;
  nsIWebProtocolHandlerRegistrar: nsJSIID<nsIWebProtocolHandlerRegistrar>;
  nsISDBCallback: nsJSIID<nsISDBCallback>;
  nsISDBCloseCallback: nsJSIID<nsISDBCloseCallback>;
  nsISDBConnection: nsJSIID<nsISDBConnection>;
  nsISDBRequest: nsJSIID<nsISDBRequest>;
  nsISDBResult: nsJSIID<nsISDBResult>;
  nsIDOMStorageManager: nsJSIID<nsIDOMStorageManager>;
  nsIStorageActivityService: nsJSIID<nsIStorageActivityService>;
  nsISessionStorageService: nsJSIID<nsISessionStorageService>;
  nsIOSPermissionRequest: nsJSIID<nsIOSPermissionRequest>;
  nsICredentialParameters: nsJSIID<nsICredentialParameters>;
  nsIWebAuthnAutoFillEntry: nsJSIID<nsIWebAuthnAutoFillEntry>;
  nsIWebAuthnService: nsJSIID<nsIWebAuthnService>;
  nsISpeechTaskCallback: nsJSIID<nsISpeechTaskCallback>;
  nsISpeechTask: nsJSIID<nsISpeechTask>;
  nsISpeechService: nsJSIID<nsISpeechService>;
  nsISynthVoiceRegistry: nsJSIID<nsISynthVoiceRegistry>;
  nsIWorkerChannelLoadInfo: nsJSIID<nsIWorkerChannelLoadInfo>;
  nsIWorkerChannelInfo: nsJSIID<nsIWorkerChannelInfo>;
  nsIWorkerDebuggerListener: nsJSIID<nsIWorkerDebuggerListener>;
  nsIWorkerDebugger: nsJSIID<nsIWorkerDebugger>;
  nsIWorkerDebuggerManagerListener: nsJSIID<nsIWorkerDebuggerManagerListener>;
  nsIWorkerDebuggerManager: nsJSIID<nsIWorkerDebuggerManager>;
  txIEXSLTFunctions: nsJSIID<txIEXSLTFunctions>;
  nsIDOMXULButtonElement: nsJSIID<nsIDOMXULButtonElement>;
  nsIDOMXULCommandDispatcher: nsJSIID<nsIDOMXULCommandDispatcher>;
  nsIDOMXULContainerItemElement: nsJSIID<nsIDOMXULContainerItemElement>;
  nsIDOMXULContainerElement: nsJSIID<nsIDOMXULContainerElement>;
  nsIDOMXULControlElement: nsJSIID<nsIDOMXULControlElement>;
  nsIDOMXULMenuListElement: nsJSIID<nsIDOMXULMenuListElement>;
  nsIDOMXULMultiSelectControlElement: nsJSIID<nsIDOMXULMultiSelectControlElement>;
  nsIDOMXULRadioGroupElement: nsJSIID<nsIDOMXULRadioGroupElement>;
  nsIDOMXULRelatedElement: nsJSIID<nsIDOMXULRelatedElement>;
  nsIDOMXULSelectControlElement: nsJSIID<nsIDOMXULSelectControlElement>;
  nsIDOMXULSelectControlItemElement: nsJSIID<nsIDOMXULSelectControlItemElement>;
  mozIDownloadPlatform: nsJSIID<mozIDownloadPlatform>;
  nsIDocumentStateListener: nsJSIID<nsIDocumentStateListener>;
  nsIEditActionListener: nsJSIID<nsIEditActionListener>;
  nsIEditor: nsJSIID<nsIEditor>;
  nsIEditorMailSupport: nsJSIID<nsIEditorMailSupport>;
  nsIEditorSpellCheck: nsJSIID<nsIEditorSpellCheck>;
  nsIEditorSpellCheckCallback: nsJSIID<nsIEditorSpellCheckCallback>;
  nsIHTMLAbsPosEditor: nsJSIID<nsIHTMLAbsPosEditor>;
  nsIHTMLEditor: nsJSIID<nsIHTMLEditor>;
  nsIHTMLInlineTableEditor: nsJSIID<nsIHTMLInlineTableEditor>;
  nsIHTMLObjectResizer: nsJSIID<nsIHTMLObjectResizer>;
  nsITableEditor: nsJSIID<nsITableEditor>;
  nsIEnterprisePolicies: nsJSIID<nsIEnterprisePolicies>;
  amIAddonManagerStartup: nsJSIID<amIAddonManagerStartup>;
  amIWebInstallPrompt: nsJSIID<amIWebInstallPrompt>;
  nsIContentDispatchChooser: nsJSIID<nsIContentDispatchChooser>;
  nsIExternalHelperAppService: nsJSIID<nsIExternalHelperAppService>;
  nsPIExternalAppLauncher: nsJSIID<nsPIExternalAppLauncher>;
  nsIHelperAppLauncher: nsJSIID<nsIHelperAppLauncher>;
  nsIExternalProtocolService: nsJSIID<nsIExternalProtocolService>;
  nsIHandlerService: nsJSIID<nsIHandlerService>;
  nsIHelperAppLauncherDialog: nsJSIID<nsIHelperAppLauncherDialog>;
  nsISharingHandlerApp: nsJSIID<nsISharingHandlerApp>;
  nsITypeAheadFind: nsJSIID<nsITypeAheadFind>;
  nsIFOG: nsJSIID<nsIFOG>;
  nsIGleanPingTestCallback: nsJSIID<nsIGleanPingTestCallback>;
  nsIGleanPingSubmitCallback: nsJSIID<nsIGleanPingSubmitCallback>;
  nsIGleanPing: nsJSIID<nsIGleanPing>;
  nsIFontEnumerator: nsJSIID<nsIFontEnumerator>;
  nsIParserUtils: nsJSIID<nsIParserUtils>;
  nsIExpatSink: nsJSIID<nsIExpatSink>;
  nsISFVBareItem: nsJSIID<nsISFVBareItem>;
  nsISFVInteger: nsJSIID<nsISFVInteger>;
  nsISFVString: nsJSIID<nsISFVString>;
  nsISFVBool: nsJSIID<nsISFVBool>;
  nsISFVDecimal: nsJSIID<nsISFVDecimal>;
  nsISFVToken: nsJSIID<nsISFVToken>;
  nsISFVByteSeq: nsJSIID<nsISFVByteSeq>;
  nsISFVParams: nsJSIID<nsISFVParams>;
  nsISFVParametrizable: nsJSIID<nsISFVParametrizable>;
  nsISFVItemOrInnerList: nsJSIID<nsISFVItemOrInnerList>;
  nsISFVSerialize: nsJSIID<nsISFVSerialize>;
  nsISFVItem: nsJSIID<nsISFVItem>;
  nsISFVInnerList: nsJSIID<nsISFVInnerList>;
  nsISFVList: nsJSIID<nsISFVList>;
  nsISFVDictionary: nsJSIID<nsISFVDictionary>;
  nsISFVService: nsJSIID<nsISFVService>;
  imgICache: nsJSIID<imgICache>;
  imgIContainer: nsJSIID<imgIContainer, typeof imgIContainer_DecodeResult>;
  imgIContainerDebug: nsJSIID<imgIContainerDebug>;
  imgIEncoder: nsJSIID<imgIEncoder>;
  imgILoader: nsJSIID<imgILoader>;
  imgINotificationObserver: nsJSIID<imgINotificationObserver>;
  imgIRequest: nsJSIID<imgIRequest>;
  imgIScriptedNotificationObserver: nsJSIID<imgIScriptedNotificationObserver>;
  imgITools: nsJSIID<imgITools>;
  imgIContainerCallback: nsJSIID<imgIContainerCallback>;
  nsIMozIconURI: nsJSIID<nsIMozIconURI>;
  inIDeepTreeWalker: nsJSIID<inIDeepTreeWalker>;
  nsIStringBundle: nsJSIID<nsIStringBundle>;
  nsIStringBundleService: nsJSIID<nsIStringBundleService>;
  nsIJARChannel: nsJSIID<nsIJARChannel>;
  nsIJARURI: nsJSIID<nsIJARURI>;
  nsIZipEntry: nsJSIID<nsIZipEntry>;
  nsIZipReader: nsJSIID<nsIZipReader>;
  nsIZipReaderCache: nsJSIID<nsIZipReaderCache>;
  IJSDebugger: nsJSIID<IJSDebugger>;
  nsIJSInspector: nsJSIID<nsIJSInspector>;
  nsIKeyValueService: nsJSIID<nsIKeyValueService, typeof nsIKeyValueService_RecoveryStrategy>;
  nsIKeyValueImportSourceSpec: nsJSIID<nsIKeyValueImportSourceSpec>;
  nsIKeyValueImporter: nsJSIID<nsIKeyValueImporter, typeof nsIKeyValueImporter_ConflictPolicy & typeof nsIKeyValueImporter_CleanupPolicy>;
  nsIKeyValueDatabaseImportOptions: nsJSIID<nsIKeyValueDatabaseImportOptions>;
  nsIKeyValueDatabase: nsJSIID<nsIKeyValueDatabase>;
  nsIKeyValuePair: nsJSIID<nsIKeyValuePair>;
  nsIKeyValueEnumerator: nsJSIID<nsIKeyValueEnumerator>;
  nsIKeyValueDatabaseCallback: nsJSIID<nsIKeyValueDatabaseCallback>;
  nsIKeyValueEnumeratorCallback: nsJSIID<nsIKeyValueEnumeratorCallback>;
  nsIKeyValuePairCallback: nsJSIID<nsIKeyValuePairCallback>;
  nsIKeyValueVariantCallback: nsJSIID<nsIKeyValueVariantCallback>;
  nsIKeyValueVoidCallback: nsJSIID<nsIKeyValueVoidCallback>;
  nsILayoutHistoryState: nsJSIID<nsILayoutHistoryState>;
  nsIPreloadedStyleSheet: nsJSIID<nsIPreloadedStyleSheet>;
  nsISVGPaintContext: nsJSIID<nsISVGPaintContext>;
  nsIStyleSheetService: nsJSIID<nsIStyleSheetService>;
  nsITreeSelection: nsJSIID<nsITreeSelection>;
  nsITreeView: nsJSIID<nsITreeView>;
  mozILocaleService: nsJSIID<mozILocaleService>;
  mozIOSPreferences: nsJSIID<mozIOSPreferences>;
  nsILoginInfo: nsJSIID<nsILoginInfo>;
  nsILoginSearchCallback: nsJSIID<nsILoginSearchCallback>;
  nsILoginManager: nsJSIID<nsILoginManager>;
  nsILoginManagerAuthPrompter: nsJSIID<nsILoginManagerAuthPrompter>;
  nsILoginManagerCrypto: nsJSIID<nsILoginManagerCrypto>;
  nsILoginManagerPrompter: nsJSIID<nsILoginManagerPrompter>;
  nsILoginMetaInfo: nsJSIID<nsILoginMetaInfo>;
  nsIPromptInstance: nsJSIID<nsIPromptInstance>;
  nsIEdgeMigrationUtils: nsJSIID<nsIEdgeMigrationUtils>;
  nsIMIMEHeaderParam: nsJSIID<nsIMIMEHeaderParam>;
  nsIHandlerInfo: nsJSIID<nsIHandlerInfo>;
  nsIMIMEInfo: nsJSIID<nsIMIMEInfo>;
  nsIHandlerApp: nsJSIID<nsIHandlerApp>;
  nsILocalHandlerApp: nsJSIID<nsILocalHandlerApp>;
  nsIWebHandlerApp: nsJSIID<nsIWebHandlerApp>;
  nsIDBusHandlerApp: nsJSIID<nsIDBusHandlerApp>;
  nsIMIMEService: nsJSIID<nsIMIMEService>;
  nsIMLUtils: nsJSIID<nsIMLUtils>;
  nsIFind: nsJSIID<nsIFind>;
  nsIFindService: nsJSIID<nsIFindService>;
  nsIWebBrowserFind: nsJSIID<nsIWebBrowserFind>;
  nsIWebBrowserFindInFrames: nsJSIID<nsIWebBrowserFindInFrames>;
  mozIMozIntl: nsJSIID<mozIMozIntl>;
  mozIMozIntlHelper: nsJSIID<mozIMozIntlHelper>;
  mozIThirdPartyUtil: nsJSIID<mozIThirdPartyUtil>;
  nsIAndroidContentInputStream: nsJSIID<nsIAndroidContentInputStream>;
  nsIArrayBufferInputStream: nsJSIID<nsIArrayBufferInputStream>;
  nsIAsyncStreamCopier: nsJSIID<nsIAsyncStreamCopier>;
  nsIAsyncStreamCopier2: nsJSIID<nsIAsyncStreamCopier2>;
  nsIAsyncVerifyRedirectCallback: nsJSIID<nsIAsyncVerifyRedirectCallback>;
  nsIAuthInformation: nsJSIID<nsIAuthInformation>;
  nsIAuthPrompt: nsJSIID<nsIAuthPrompt>;
  nsIAuthPrompt2: nsJSIID<nsIAuthPrompt2>;
  nsIAuthPromptAdapterFactory: nsJSIID<nsIAuthPromptAdapterFactory>;
  nsIAuthPromptCallback: nsJSIID<nsIAuthPromptCallback>;
  nsIAuthPromptProvider: nsJSIID<nsIAuthPromptProvider>;
  nsIBackgroundFileSaver: nsJSIID<nsIBackgroundFileSaver>;
  nsIBackgroundFileSaverObserver: nsJSIID<nsIBackgroundFileSaverObserver>;
  nsIBufferedInputStream: nsJSIID<nsIBufferedInputStream>;
  nsIBufferedOutputStream: nsJSIID<nsIBufferedOutputStream>;
  nsIByteRangeRequest: nsJSIID<nsIByteRangeRequest>;
  nsIInputStreamReceiver: nsJSIID<nsIInputStreamReceiver>;
  nsICacheInfoChannel: nsJSIID<nsICacheInfoChannel, typeof nsICacheInfoChannel_PreferredAlternativeDataDeliveryType>;
  nsICachingChannel: nsJSIID<nsICachingChannel>;
  nsICancelable: nsJSIID<nsICancelable>;
  nsICaptivePortalServiceCallback: nsJSIID<nsICaptivePortalServiceCallback>;
  nsICaptivePortalService: nsJSIID<nsICaptivePortalService>;
  nsIChannel: nsJSIID<nsIChannel>;
  nsIIdentChannel: nsJSIID<nsIIdentChannel>;
  nsIChannelEventSink: nsJSIID<nsIChannelEventSink>;
  nsIChildChannel: nsJSIID<nsIChildChannel>;
  nsIClassOfService: nsJSIID<nsIClassOfService, typeof nsIClassOfService_FetchPriority>;
  nsIClassifiedChannel: nsJSIID<nsIClassifiedChannel, typeof nsIClassifiedChannel_ClassificationFlags>;
  nsIContentSniffer: nsJSIID<nsIContentSniffer>;
  nsIDHCPClient: nsJSIID<nsIDHCPClient>;
  nsINetDashboardCallback: nsJSIID<nsINetDashboardCallback>;
  nsIDashboard: nsJSIID<nsIDashboard>;
  nsIDownloader: nsJSIID<nsIDownloader>;
  nsIDownloadObserver: nsJSIID<nsIDownloadObserver>;
  nsIEncodedChannel: nsJSIID<nsIEncodedChannel>;
  nsIExternalProtocolHandler: nsJSIID<nsIExternalProtocolHandler>;
  nsIFileInputStream: nsJSIID<nsIFileInputStream>;
  nsIFileOutputStream: nsJSIID<nsIFileOutputStream>;
  nsIFileRandomAccessStream: nsJSIID<nsIFileRandomAccessStream>;
  nsIFileMetadata: nsJSIID<nsIFileMetadata>;
  nsIAsyncFileMetadata: nsJSIID<nsIAsyncFileMetadata>;
  nsIFileMetadataCallback: nsJSIID<nsIFileMetadataCallback>;
  nsIFileURL: nsJSIID<nsIFileURL>;
  nsIFileURLMutator: nsJSIID<nsIFileURLMutator>;
  nsIFormPOSTActionChannel: nsJSIID<nsIFormPOSTActionChannel>;
  nsIIOService: nsJSIID<nsIIOService>;
  nsIIncrementalDownload: nsJSIID<nsIIncrementalDownload>;
  nsIIncrementalStreamLoaderObserver: nsJSIID<nsIIncrementalStreamLoaderObserver>;
  nsIIncrementalStreamLoader: nsJSIID<nsIIncrementalStreamLoader>;
  nsIInputStreamChannel: nsJSIID<nsIInputStreamChannel>;
  nsIInputStreamPump: nsJSIID<nsIInputStreamPump>;
  nsIInterceptionInfo: nsJSIID<nsIInterceptionInfo>;
  nsILoadContextInfo: nsJSIID<nsILoadContextInfo>;
  nsILoadContextInfoFactory: nsJSIID<nsILoadContextInfoFactory>;
  nsILoadGroup: nsJSIID<nsILoadGroup>;
  nsILoadGroupChild: nsJSIID<nsILoadGroupChild>;
  nsILoadInfo: nsJSIID<nsILoadInfo, typeof nsILoadInfo_StoragePermissionState & typeof nsILoadInfo_IPAddressSpace & typeof nsILoadInfo_CrossOriginOpenerPolicy & typeof nsILoadInfo_CrossOriginEmbedderPolicy & typeof nsILoadInfo_SchemelessInputType & typeof nsILoadInfo_HTTPSUpgradeTelemetryType>;
  nsIMIMEInputStream: nsJSIID<nsIMIMEInputStream>;
  nsIMockNetworkLayerController: nsJSIID<nsIMockNetworkLayerController>;
  nsIMultiPartChannel: nsJSIID<nsIMultiPartChannel>;
  nsIMultiPartChannelListener: nsJSIID<nsIMultiPartChannelListener>;
  nsINestedURI: nsJSIID<nsINestedURI>;
  nsINestedURIMutator: nsJSIID<nsINestedURIMutator>;
  nsINestedAboutURIMutator: nsJSIID<nsINestedAboutURIMutator>;
  nsIJSURIMutator: nsJSIID<nsIJSURIMutator>;
  nsINetAddr: nsJSIID<nsINetAddr>;
  nsINetUtil: nsJSIID<nsINetUtil>;
  nsINetworkConnectivityService: nsJSIID<nsINetworkConnectivityService, typeof nsINetworkConnectivityService_ConnectivityState>;
  nsIListNetworkAddressesListener: nsJSIID<nsIListNetworkAddressesListener>;
  nsIGetHostnameListener: nsJSIID<nsIGetHostnameListener>;
  nsINetworkInfoService: nsJSIID<nsINetworkInfoService>;
  nsIInterceptedBodyCallback: nsJSIID<nsIInterceptedBodyCallback>;
  nsIInterceptedChannel: nsJSIID<nsIInterceptedChannel>;
  nsINetworkInterceptController: nsJSIID<nsINetworkInterceptController>;
  nsINetworkLinkService: nsJSIID<nsINetworkLinkService>;
  nsINetworkPredictor: nsJSIID<nsINetworkPredictor>;
  nsINetworkPredictorVerifier: nsJSIID<nsINetworkPredictorVerifier>;
  nsINullChannel: nsJSIID<nsINullChannel>;
  nsIParentChannel: nsJSIID<nsIParentChannel>;
  nsIPermission: nsJSIID<nsIPermission>;
  nsIPermissionManager: nsJSIID<nsIPermissionManager>;
  nsIPrivateBrowsingChannel: nsJSIID<nsIPrivateBrowsingChannel>;
  nsIProgressEventSink: nsJSIID<nsIProgressEventSink>;
  nsIPrompt: nsJSIID<nsIPrompt>;
  nsIProtocolHandlerWithDynamicFlags: nsJSIID<nsIProtocolHandlerWithDynamicFlags>;
  nsIProtocolHandler: nsJSIID<nsIProtocolHandler>;
  nsIProtocolProxyCallback: nsJSIID<nsIProtocolProxyCallback>;
  nsIProxyProtocolFilterResult: nsJSIID<nsIProxyProtocolFilterResult>;
  nsIProtocolProxyFilter: nsJSIID<nsIProtocolProxyFilter>;
  nsIProtocolProxyChannelFilter: nsJSIID<nsIProtocolProxyChannelFilter>;
  nsIProxyConfigChangedCallback: nsJSIID<nsIProxyConfigChangedCallback>;
  nsIProtocolProxyService: nsJSIID<nsIProtocolProxyService>;
  nsIProtocolProxyService2: nsJSIID<nsIProtocolProxyService2>;
  nsIProxiedChannel: nsJSIID<nsIProxiedChannel>;
  nsIProxiedProtocolHandler: nsJSIID<nsIProxiedProtocolHandler>;
  nsIProxyInfo: nsJSIID<nsIProxyInfo>;
  nsIRandomGenerator: nsJSIID<nsIRandomGenerator>;
  nsIRedirectChannelRegistrar: nsJSIID<nsIRedirectChannelRegistrar>;
  nsIRedirectHistoryEntry: nsJSIID<nsIRedirectHistoryEntry>;
  nsIRedirectResultListener: nsJSIID<nsIRedirectResultListener>;
  nsIRequest: nsJSIID<nsIRequest, typeof nsIRequest_TRRMode>;
  nsIRequestObserver: nsJSIID<nsIRequestObserver>;
  nsIRequestObserverProxy: nsJSIID<nsIRequestObserverProxy>;
  nsIResumableChannel: nsJSIID<nsIResumableChannel>;
  nsISecCheckWrapChannel: nsJSIID<nsISecCheckWrapChannel>;
  nsISecureBrowserUI: nsJSIID<nsISecureBrowserUI>;
  nsISensitiveInfoHiddenURI: nsJSIID<nsISensitiveInfoHiddenURI>;
  nsISerializationHelper: nsJSIID<nsISerializationHelper>;
  nsIServerSocket: nsJSIID<nsIServerSocket>;
  nsIServerSocketListener: nsJSIID<nsIServerSocketListener>;
  nsISimpleStreamListener: nsJSIID<nsISimpleStreamListener>;
  nsISimpleURIMutator: nsJSIID<nsISimpleURIMutator>;
  nsISocketTransport: nsJSIID<nsISocketTransport>;
  nsISTSShutdownObserver: nsJSIID<nsISTSShutdownObserver>;
  nsISocketTransportService: nsJSIID<nsISocketTransportService>;
  nsIRoutedSocketTransportService: nsJSIID<nsIRoutedSocketTransportService>;
  nsISpeculativeConnect: nsJSIID<nsISpeculativeConnect>;
  nsIStandardURL: nsJSIID<nsIStandardURL>;
  nsIStandardURLMutator: nsJSIID<nsIStandardURLMutator>;
  nsIStreamListener: nsJSIID<nsIStreamListener>;
  nsIStreamListenerTee: nsJSIID<nsIStreamListenerTee>;
  nsIStreamLoaderObserver: nsJSIID<nsIStreamLoaderObserver>;
  nsIStreamLoader: nsJSIID<nsIStreamLoader>;
  nsIStreamTransportService: nsJSIID<nsIStreamTransportService>;
  nsISuspendableChannelWrapper: nsJSIID<nsISuspendableChannelWrapper>;
  nsISyncStreamListener: nsJSIID<nsISyncStreamListener>;
  nsISystemProxySettings: nsJSIID<nsISystemProxySettings>;
  nsITLSServerSocket: nsJSIID<nsITLSServerSocket>;
  nsITLSClientStatus: nsJSIID<nsITLSClientStatus>;
  nsITLSServerConnectionInfo: nsJSIID<nsITLSServerConnectionInfo>;
  nsITLSServerSecurityObserver: nsJSIID<nsITLSServerSecurityObserver>;
  nsIThreadRetargetableStreamListener: nsJSIID<nsIThreadRetargetableStreamListener>;
  nsIInputChannelThrottleQueue: nsJSIID<nsIInputChannelThrottleQueue>;
  nsIThrottledInputChannel: nsJSIID<nsIThrottledInputChannel>;
  nsIServerTiming: nsJSIID<nsIServerTiming>;
  nsITimedChannel: nsJSIID<nsITimedChannel, typeof nsITimedChannel_BodyInfoAccess>;
  nsITraceableChannel: nsJSIID<nsITraceableChannel>;
  nsITransport: nsJSIID<nsITransport>;
  nsITransportEventSink: nsJSIID<nsITransportEventSink>;
  nsIUDPSocket: nsJSIID<nsIUDPSocket>;
  nsIUDPSocketListener: nsJSIID<nsIUDPSocketListener>;
  nsIUDPMessage: nsJSIID<nsIUDPMessage>;
  nsIURI: nsJSIID<nsIURI>;
  nsIURISetSpec: nsJSIID<nsIURISetSpec>;
  nsIURISetters: nsJSIID<nsIURISetters>;
  nsIURIMutator: nsJSIID<nsIURIMutator>;
  nsIURIWithSpecialOrigin: nsJSIID<nsIURIWithSpecialOrigin>;
  nsIURL: nsJSIID<nsIURL>;
  nsIURLMutator: nsJSIID<nsIURLMutator>;
  nsIURLParser: nsJSIID<nsIURLParser>;
  nsIUploadChannel: nsJSIID<nsIUploadChannel>;
  nsIUploadChannel2: nsJSIID<nsIUploadChannel2>;
  nsPISocketTransportService: nsJSIID<nsPISocketTransportService>;
  nsIAboutModule: nsJSIID<nsIAboutModule>;
  nsICacheEntry: nsJSIID<nsICacheEntry>;
  nsICacheEntryMetaDataVisitor: nsJSIID<nsICacheEntryMetaDataVisitor>;
  nsICacheEntryDoomCallback: nsJSIID<nsICacheEntryDoomCallback>;
  nsICacheEntryOpenCallback: nsJSIID<nsICacheEntryOpenCallback>;
  nsICachePurgeLock: nsJSIID<nsICachePurgeLock>;
  nsICacheStorage: nsJSIID<nsICacheStorage>;
  nsICacheStorageService: nsJSIID<nsICacheStorageService>;
  nsICacheStorageConsumptionObserver: nsJSIID<nsICacheStorageConsumptionObserver>;
  nsICacheStorageVisitor: nsJSIID<nsICacheStorageVisitor>;
  nsICacheTesting: nsJSIID<nsICacheTesting>;
  nsICookie: nsJSIID<nsICookie, typeof nsICookie_schemeType>;
  nsICookieJarSettings: nsJSIID<nsICookieJarSettings>;
  nsICookieManager: nsJSIID<nsICookieManager>;
  nsICookieNotification: nsJSIID<nsICookieNotification, typeof nsICookieNotification_Action>;
  nsICookiePermission: nsJSIID<nsICookiePermission>;
  nsICookieTransactionCallback: nsJSIID<nsICookieTransactionCallback>;
  nsICookieService: nsJSIID<nsICookieService>;
  nsIThirdPartyCookieBlockingExceptionListService: nsJSIID<nsIThirdPartyCookieBlockingExceptionListService>;
  nsIThirdPartyCookieExceptionEntry: nsJSIID<nsIThirdPartyCookieExceptionEntry>;
  nsIDNSAdditionalInfo: nsJSIID<nsIDNSAdditionalInfo>;
  nsIDNSByTypeRecord: nsJSIID<nsIDNSByTypeRecord>;
  nsIDNSTXTRecord: nsJSIID<nsIDNSTXTRecord>;
  nsISVCParam: nsJSIID<nsISVCParam>;
  nsISVCParamAlpn: nsJSIID<nsISVCParamAlpn>;
  nsISVCParamNoDefaultAlpn: nsJSIID<nsISVCParamNoDefaultAlpn>;
  nsISVCParamPort: nsJSIID<nsISVCParamPort>;
  nsISVCParamIPv4Hint: nsJSIID<nsISVCParamIPv4Hint>;
  nsISVCParamEchConfig: nsJSIID<nsISVCParamEchConfig>;
  nsISVCParamIPv6Hint: nsJSIID<nsISVCParamIPv6Hint>;
  nsISVCParamODoHConfig: nsJSIID<nsISVCParamODoHConfig>;
  nsISVCBRecord: nsJSIID<nsISVCBRecord>;
  nsIDNSHTTPSSVCRecord: nsJSIID<nsIDNSHTTPSSVCRecord>;
  nsIDNSListener: nsJSIID<nsIDNSListener>;
  nsIDNSRecord: nsJSIID<nsIDNSRecord>;
  nsIDNSAddrRecord: nsJSIID<nsIDNSAddrRecord>;
  nsIDNSService: nsJSIID<nsIDNSService, typeof nsIDNSService_ResolveType & typeof nsIDNSService_ResolverMode & typeof nsIDNSService_DNSFlags & typeof nsIDNSService_ConfirmationState>;
  nsIEffectiveTLDService: nsJSIID<nsIEffectiveTLDService>;
  nsIIDNService: nsJSIID<nsIIDNService>;
  nsINativeDNSResolverOverride: nsJSIID<nsINativeDNSResolverOverride>;
  nsITRRSkipReason: nsJSIID<nsITRRSkipReason, typeof nsITRRSkipReason_value>;
  nsPIDNSService: nsJSIID<nsPIDNSService>;
  nsIFileChannel: nsJSIID<nsIFileChannel>;
  nsIFileProtocolHandler: nsJSIID<nsIFileProtocolHandler>;
  nsIDataChannel: nsJSIID<nsIDataChannel>;
  nsIBinaryHttpRequest: nsJSIID<nsIBinaryHttpRequest>;
  nsIBinaryHttpResponse: nsJSIID<nsIBinaryHttpResponse>;
  nsIBinaryHttp: nsJSIID<nsIBinaryHttp>;
  nsICORSPreflightCache: nsJSIID<nsICORSPreflightCache>;
  nsICORSPreflightCacheEntry: nsJSIID<nsICORSPreflightCacheEntry>;
  nsIEarlyHintObserver: nsJSIID<nsIEarlyHintObserver>;
  nsIHttpActivityObserver: nsJSIID<nsIHttpActivityObserver>;
  nsIHttpActivityDistributor: nsJSIID<nsIHttpActivityDistributor>;
  nsIHttpAuthManager: nsJSIID<nsIHttpAuthManager>;
  nsIHttpChannel: nsJSIID<nsIHttpChannel>;
  nsIHttpUpgradeListener: nsJSIID<nsIHttpUpgradeListener>;
  nsIHttpChannelInternal: nsJSIID<nsIHttpChannelInternal>;
  nsIHttpHeaderVisitor: nsJSIID<nsIHttpHeaderVisitor>;
  nsIHttpProtocolHandler: nsJSIID<nsIHttpProtocolHandler>;
  nsINetworkErrorLogging: nsJSIID<nsINetworkErrorLogging>;
  nsIObliviousHttpClientResponse: nsJSIID<nsIObliviousHttpClientResponse>;
  nsIObliviousHttpClientRequest: nsJSIID<nsIObliviousHttpClientRequest>;
  nsIObliviousHttpServerResponse: nsJSIID<nsIObliviousHttpServerResponse>;
  nsIObliviousHttpServer: nsJSIID<nsIObliviousHttpServer>;
  nsIObliviousHttp: nsJSIID<nsIObliviousHttp>;
  nsIObliviousHttpService: nsJSIID<nsIObliviousHttpService>;
  nsIObliviousHttpChannel: nsJSIID<nsIObliviousHttpChannel>;
  nsIRaceCacheWithNetwork: nsJSIID<nsIRaceCacheWithNetwork>;
  nsIReplacedHttpResponse: nsJSIID<nsIReplacedHttpResponse>;
  nsIWellKnownOpportunisticUtils: nsJSIID<nsIWellKnownOpportunisticUtils>;
  nsICompressConvStats: nsJSIID<nsICompressConvStats>;
  nsIResProtocolHandler: nsJSIID<nsIResProtocolHandler>;
  nsISubstitutingProtocolHandler: nsJSIID<nsISubstitutingProtocolHandler>;
  nsISocketProvider: nsJSIID<nsISocketProvider>;
  nsISocketProviderService: nsJSIID<nsISocketProviderService>;
  mozITXTToHTMLConv: nsJSIID<mozITXTToHTMLConv>;
  nsIDirIndex: nsJSIID<nsIDirIndex>;
  nsIDirIndexListener: nsJSIID<nsIDirIndexListener>;
  nsIDirIndexParser: nsJSIID<nsIDirIndexParser>;
  nsIStreamConverter: nsJSIID<nsIStreamConverter>;
  nsIStreamConverterService: nsJSIID<nsIStreamConverterService>;
  nsITXTToHTMLConv: nsJSIID<nsITXTToHTMLConv>;
  nsITransportProvider: nsJSIID<nsITransportProvider>;
  nsIWebSocketChannel: nsJSIID<nsIWebSocketChannel>;
  nsIWebSocketFrame: nsJSIID<nsIWebSocketFrame>;
  nsIWebSocketEventListener: nsJSIID<nsIWebSocketEventListener>;
  nsIWebSocketEventService: nsJSIID<nsIWebSocketEventService>;
  nsIWebSocketImpl: nsJSIID<nsIWebSocketImpl>;
  nsIWebSocketListener: nsJSIID<nsIWebSocketListener>;
  nsIWebTransport: nsJSIID<nsIWebTransport, typeof nsIWebTransport_WebTransportError & typeof nsIWebTransport_HTTPVersion>;
  WebTransportSessionEventListener: nsJSIID<WebTransportSessionEventListener, typeof WebTransportSessionEventListener_DatagramOutcome>;
  nsIWebTransportStreamCallback: nsJSIID<nsIWebTransportStreamCallback>;
  nsIWebTransportHash: nsJSIID<nsIWebTransportHash>;
  nsIWebTransportSendStreamStats: nsJSIID<nsIWebTransportSendStreamStats>;
  nsIWebTransportReceiveStreamStats: nsJSIID<nsIWebTransportReceiveStreamStats>;
  nsIWebTransportStreamStatsCallback: nsJSIID<nsIWebTransportStreamStatsCallback>;
  nsIWebTransportReceiveStream: nsJSIID<nsIWebTransportReceiveStream>;
  nsIWebTransportSendStream: nsJSIID<nsIWebTransportSendStream>;
  nsIWebTransportBidirectionalStream: nsJSIID<nsIWebTransportBidirectionalStream>;
  nsIWifiAccessPoint: nsJSIID<nsIWifiAccessPoint>;
  nsIWifiListener: nsJSIID<nsIWifiListener>;
  nsIWifiMonitor: nsJSIID<nsIWifiMonitor>;
  nsIParentalControlsService: nsJSIID<nsIParentalControlsService>;
  IPeerConnectionObserver: nsJSIID<IPeerConnectionObserver>;
  IPeerConnection: nsJSIID<IPeerConnection>;
  nsIRemotePermissionService: nsJSIID<nsIRemotePermissionService>;
  nsICertOverride: nsJSIID<nsICertOverride>;
  nsICertOverrideService: nsJSIID<nsICertOverrideService>;
  nsICertStorageCallback: nsJSIID<nsICertStorageCallback>;
  nsIRevocationState: nsJSIID<nsIRevocationState>;
  nsIIssuerAndSerialRevocationState: nsJSIID<nsIIssuerAndSerialRevocationState>;
  nsISubjectAndPubKeyRevocationState: nsJSIID<nsISubjectAndPubKeyRevocationState>;
  nsICertInfo: nsJSIID<nsICertInfo>;
  nsICertStorage: nsJSIID<nsICertStorage>;
  nsICertTreeItem: nsJSIID<nsICertTreeItem>;
  nsICertTree: nsJSIID<nsICertTree>;
  nsICertificateDialogs: nsJSIID<nsICertificateDialogs>;
  nsIClientAuthDialogCallback: nsJSIID<nsIClientAuthDialogCallback>;
  nsIClientAuthDialogService: nsJSIID<nsIClientAuthDialogService>;
  nsIClientAuthRememberRecord: nsJSIID<nsIClientAuthRememberRecord>;
  nsIClientAuthRememberService: nsJSIID<nsIClientAuthRememberService, typeof nsIClientAuthRememberService_Duration>;
  nsIContentSignatureVerifier: nsJSIID<nsIContentSignatureVerifier>;
  nsICryptoHash: nsJSIID<nsICryptoHash>;
  nsIDataStorageManager: nsJSIID<nsIDataStorageManager, typeof nsIDataStorageManager_DataStorage>;
  nsIDataStorage: nsJSIID<nsIDataStorage, typeof nsIDataStorage_DataType>;
  nsIDataStorageItem: nsJSIID<nsIDataStorageItem>;
  nsINSSComponent: nsJSIID<nsINSSComponent>;
  nsINSSErrorsService: nsJSIID<nsINSSErrorsService>;
  nsINSSVersion: nsJSIID<nsINSSVersion>;
  nsIOSKeyStore: nsJSIID<nsIOSKeyStore>;
  nsIOSReauthenticator: nsJSIID<nsIOSReauthenticator>;
  nsIPK11Token: nsJSIID<nsIPK11Token>;
  nsIPK11TokenDB: nsJSIID<nsIPK11TokenDB>;
  nsIPKCS11Module: nsJSIID<nsIPKCS11Module>;
  nsIPKCS11ModuleDB: nsJSIID<nsIPKCS11ModuleDB>;
  nsIPKCS11Slot: nsJSIID<nsIPKCS11Slot>;
  nsIPublicKeyPinningService: nsJSIID<nsIPublicKeyPinningService>;
  nsISecretDecoderRing: nsJSIID<nsISecretDecoderRing>;
  nsISecurityUITelemetry: nsJSIID<nsISecurityUITelemetry>;
  nsISiteSecurityService: nsJSIID<nsISiteSecurityService, typeof nsISiteSecurityService_ResetStateBy>;
  nsITLSSocketControl: nsJSIID<nsITLSSocketControl>;
  nsITokenPasswordDialogs: nsJSIID<nsITokenPasswordDialogs>;
  nsITransportSecurityInfo: nsJSIID<nsITransportSecurityInfo, typeof nsITransportSecurityInfo_OverridableErrorCategory>;
  nsIX509Cert: nsJSIID<nsIX509Cert>;
  nsIAppSignatureInfo: nsJSIID<nsIAppSignatureInfo, typeof nsIAppSignatureInfo_SignatureAlgorithm>;
  nsIOpenSignedAppFileCallback: nsJSIID<nsIOpenSignedAppFileCallback>;
  nsIAsyncBoolCallback: nsJSIID<nsIAsyncBoolCallback>;
  nsICertVerificationCallback: nsJSIID<nsICertVerificationCallback>;
  nsIX509CertDB: nsJSIID<nsIX509CertDB, typeof nsIX509CertDB_VerifyUsage>;
  nsIX509CertValidity: nsJSIID<nsIX509CertValidity>;
  mozIVisitInfo: nsJSIID<mozIVisitInfo>;
  mozIPlaceInfo: nsJSIID<mozIPlaceInfo>;
  mozIVisitInfoCallback: nsJSIID<mozIVisitInfoCallback>;
  mozIVisitedStatusCallback: nsJSIID<mozIVisitedStatusCallback>;
  mozIAsyncHistory: nsJSIID<mozIAsyncHistory>;
  mozIPlacesAutoComplete: nsJSIID<mozIPlacesAutoComplete>;
  mozIPlacesPendingOperation: nsJSIID<mozIPlacesPendingOperation>;
  mozISyncedBookmarksMirrorProgressListener: nsJSIID<mozISyncedBookmarksMirrorProgressListener>;
  mozISyncedBookmarksMirrorCallback: nsJSIID<mozISyncedBookmarksMirrorCallback>;
  mozISyncedBookmarksMirrorLogger: nsJSIID<mozISyncedBookmarksMirrorLogger>;
  mozISyncedBookmarksMerger: nsJSIID<mozISyncedBookmarksMerger, typeof mozISyncedBookmarksMerger_SyncedItemKinds & typeof mozISyncedBookmarksMerger_SyncedItemValidity>;
  nsIFaviconService: nsJSIID<nsIFaviconService>;
  nsIFaviconDataCallback: nsJSIID<nsIFaviconDataCallback>;
  nsIFavicon: nsJSIID<nsIFavicon>;
  nsINavBookmarksService: nsJSIID<nsINavBookmarksService, typeof nsINavBookmarksService_ChangeSource>;
  nsINavHistoryResultNode: nsJSIID<nsINavHistoryResultNode, typeof nsINavHistoryResultNode_ResultType>;
  nsINavHistoryContainerResultNode: nsJSIID<nsINavHistoryContainerResultNode>;
  nsINavHistoryQueryResultNode: nsJSIID<nsINavHistoryQueryResultNode>;
  nsINavHistoryResultObserver: nsJSIID<nsINavHistoryResultObserver>;
  nsINavHistoryResult: nsJSIID<nsINavHistoryResult>;
  nsINavHistoryQuery: nsJSIID<nsINavHistoryQuery>;
  nsINavHistoryQueryOptions: nsJSIID<nsINavHistoryQueryOptions>;
  nsINavHistoryService: nsJSIID<nsINavHistoryService, typeof nsINavHistoryService_TransitionType>;
  nsIPlacesPreviewsHelperService: nsJSIID<nsIPlacesPreviewsHelperService>;
  nsITaggingService: nsJSIID<nsITaggingService>;
  nsIPrefBranch: nsJSIID<nsIPrefBranch>;
  nsIPrefLocalizedString: nsJSIID<nsIPrefLocalizedString>;
  nsIPrefStatsCallback: nsJSIID<nsIPrefStatsCallback>;
  nsIPrefObserver: nsJSIID<nsIPrefObserver>;
  nsIPrefService: nsJSIID<nsIPrefService>;
  nsIRelativeFilePref: nsJSIID<nsIRelativeFilePref>;
  nsIPrefetchService: nsJSIID<nsIPrefetchService>;
  nsIPrivateAttributionService: nsJSIID<nsIPrivateAttributionService>;
  nsIProfilerStartParams: nsJSIID<nsIProfilerStartParams>;
  nsIProfiler: nsJSIID<nsIProfiler>;
  nsIRddProcessTest: nsJSIID<nsIRddProcessTest>;
  nsIMarionette: nsJSIID<nsIMarionette>;
  nsIRemoteAgent: nsJSIID<nsIRemoteAgent>;
  nsIApplicationReputationService: nsJSIID<nsIApplicationReputationService>;
  nsIApplicationReputationQuery: nsJSIID<nsIApplicationReputationQuery>;
  nsIApplicationReputationCallback: nsJSIID<nsIApplicationReputationCallback>;
  mozISandboxSettings: nsJSIID<mozISandboxSettings>;
  nsIFormFillController: nsJSIID<nsIFormFillController>;
  nsIFormFillCompleteObserver: nsJSIID<nsIFormFillCompleteObserver>;
  mozIAppServicesLogger: nsJSIID<mozIAppServicesLogger>;
  mozIBridgedSyncEngineCallback: nsJSIID<mozIBridgedSyncEngineCallback>;
  mozIBridgedSyncEngineApplyCallback: nsJSIID<mozIBridgedSyncEngineApplyCallback>;
  mozIBridgedSyncEngine: nsJSIID<mozIBridgedSyncEngine>;
  mozIInterruptible: nsJSIID<mozIInterruptible>;
  mozIServicesLogSink: nsJSIID<mozIServicesLogSink>;
  nsISessionStoreFunctions: nsJSIID<nsISessionStoreFunctions>;
  nsISessionStoreRestoreData: nsJSIID<nsISessionStoreRestoreData>;
  nsIShellService: nsJSIID<nsIShellService>;
  nsIBFCacheEntry: nsJSIID<nsIBFCacheEntry>;
  nsISHEntry: nsJSIID<nsISHEntry>;
  nsISHistory: nsJSIID<nsISHistory>;
  nsISHistoryListener: nsJSIID<nsISHistoryListener>;
  mozIPersonalDictionary: nsJSIID<mozIPersonalDictionary>;
  mozISpellCheckingEngine: nsJSIID<mozISpellCheckingEngine>;
  nsIStartupCacheInfo: nsJSIID<nsIStartupCacheInfo>;
  mozIStorageAsyncConnection: nsJSIID<mozIStorageAsyncConnection>;
  mozIStorageAsyncStatement: nsJSIID<mozIStorageAsyncStatement>;
  mozIStorageBaseStatement: nsJSIID<mozIStorageBaseStatement>;
  mozIStorageBindingParams: nsJSIID<mozIStorageBindingParams>;
  mozIStorageBindingParamsArray: nsJSIID<mozIStorageBindingParamsArray>;
  mozIStorageCompletionCallback: nsJSIID<mozIStorageCompletionCallback>;
  mozIStorageConnection: nsJSIID<mozIStorageConnection>;
  mozIStorageError: nsJSIID<mozIStorageError>;
  mozIStorageFunction: nsJSIID<mozIStorageFunction>;
  mozIStoragePendingStatement: nsJSIID<mozIStoragePendingStatement>;
  mozIStorageProgressHandler: nsJSIID<mozIStorageProgressHandler>;
  mozIStorageResultSet: nsJSIID<mozIStorageResultSet>;
  mozIStorageRow: nsJSIID<mozIStorageRow>;
  mozIStorageService: nsJSIID<mozIStorageService>;
  mozIStorageStatement: nsJSIID<mozIStorageStatement>;
  mozIStorageStatementCallback: nsJSIID<mozIStorageStatementCallback>;
  mozIStorageVacuumParticipant: nsJSIID<mozIStorageVacuumParticipant>;
  mozIStorageValueArray: nsJSIID<mozIStorageValueArray>;
  nsIFetchTelemetryDataCallback: nsJSIID<nsIFetchTelemetryDataCallback>;
  nsITelemetry: nsJSIID<nsITelemetry>;
  nsIDAPTelemetry: nsJSIID<nsIDAPTelemetry>;
  nsIHttpServer: nsJSIID<nsIHttpServer>;
  nsIHttpServerStoppedCallback: nsJSIID<nsIHttpServerStoppedCallback>;
  nsIHttpServerIdentity: nsJSIID<nsIHttpServerIdentity>;
  nsIHttpRequestHandler: nsJSIID<nsIHttpRequestHandler>;
  nsIHttpRequest: nsJSIID<nsIHttpRequest>;
  nsIHttpResponse: nsJSIID<nsIHttpResponse>;
  nsIPageThumbsStorageService: nsJSIID<nsIPageThumbsStorageService>;
  nsIBTPRemoteExceptionList: nsJSIID<nsIBTPRemoteExceptionList>;
  nsIBounceTrackingMapEntry: nsJSIID<nsIBounceTrackingMapEntry>;
  nsIBounceTrackingPurgeEntry: nsJSIID<nsIBounceTrackingPurgeEntry>;
  nsIBounceTrackingProtection: nsJSIID<nsIBounceTrackingProtection, typeof nsIBounceTrackingProtection_Modes>;
  nsIContentBlockingAllowList: nsJSIID<nsIContentBlockingAllowList>;
  nsIPartitioningExceptionListObserver: nsJSIID<nsIPartitioningExceptionListObserver>;
  nsIPartitioningExceptionListService: nsJSIID<nsIPartitioningExceptionListService>;
  nsIPurgeTrackerService: nsJSIID<nsIPurgeTrackerService>;
  nsITrackingDBService: nsJSIID<nsITrackingDBService>;
  nsIURLDecorationAnnotationsService: nsJSIID<nsIURLDecorationAnnotationsService>;
  nsIURLQueryStringStripper: nsJSIID<nsIURLQueryStringStripper>;
  nsIURLQueryStrippingListObserver: nsJSIID<nsIURLQueryStrippingListObserver>;
  nsIURLQueryStrippingListService: nsJSIID<nsIURLQueryStrippingListService>;
  nsIAsyncShutdownBlocker: nsJSIID<nsIAsyncShutdownBlocker>;
  nsIAsyncShutdownClient: nsJSIID<nsIAsyncShutdownClient>;
  nsIAsyncShutdownCompletionCallback: nsJSIID<nsIAsyncShutdownCompletionCallback>;
  nsIAsyncShutdownBarrier: nsJSIID<nsIAsyncShutdownBarrier>;
  nsIAsyncShutdownService: nsJSIID<nsIAsyncShutdownService>;
  nsIBackgroundTasks: nsJSIID<nsIBackgroundTasks>;
  nsIBackgroundTasksManager: nsJSIID<nsIBackgroundTasksManager>;
  nsIBackgroundTasksRunner: nsJSIID<nsIBackgroundTasksRunner>;
  nsIClearBySiteEntry: nsJSIID<nsIClearBySiteEntry>;
  nsIClearDataService: nsJSIID<nsIClearDataService>;
  nsIClearDataCallback: nsJSIID<nsIClearDataCallback>;
  nsIContentAnalysisAcknowledgement: nsJSIID<nsIContentAnalysisAcknowledgement, typeof nsIContentAnalysisAcknowledgement_Result & typeof nsIContentAnalysisAcknowledgement_FinalAction>;
  nsIContentAnalysisResult: nsJSIID<nsIContentAnalysisResult>;
  nsIContentAnalysisResponse: nsJSIID<nsIContentAnalysisResponse, typeof nsIContentAnalysisResponse_Action & typeof nsIContentAnalysisResponse_CancelError>;
  nsIClientDownloadResource: nsJSIID<nsIClientDownloadResource>;
  nsIContentAnalysisRequest: nsJSIID<nsIContentAnalysisRequest, typeof nsIContentAnalysisRequest_AnalysisType & typeof nsIContentAnalysisRequest_Reason & typeof nsIContentAnalysisRequest_OperationType>;
  nsIContentAnalysisCallback: nsJSIID<nsIContentAnalysisCallback>;
  nsIContentAnalysisDiagnosticInfo: nsJSIID<nsIContentAnalysisDiagnosticInfo>;
  nsIContentAnalysis: nsJSIID<nsIContentAnalysis>;
  nsIClickRule: nsJSIID<nsIClickRule, typeof nsIClickRule_RunContext>;
  nsICookieBannerListService: nsJSIID<nsICookieBannerListService>;
  nsICookieBannerRule: nsJSIID<nsICookieBannerRule>;
  nsICookieBannerService: nsJSIID<nsICookieBannerService, typeof nsICookieBannerService_Modes>;
  nsICookieBannerTelemetryService: nsJSIID<nsICookieBannerTelemetryService>;
  nsICookieRule: nsJSIID<nsICookieRule>;
  nsICrashService: nsJSIID<nsICrashService>;
  nsIFinalizationWitnessService: nsJSIID<nsIFinalizationWitnessService>;
  nsIOriginStatusEntry: nsJSIID<nsIOriginStatusEntry>;
  nsIOriginsListLoadCallback: nsJSIID<nsIOriginsListLoadCallback>;
  nsIWindowsMediaFoundationCDMOriginsListService: nsJSIID<nsIWindowsMediaFoundationCDMOriginsListService>;
  nsIVisibleTab: nsJSIID<nsIVisibleTab>;
  nsIBrowserWindowTracker: nsJSIID<nsIBrowserWindowTracker>;
  nsIRegion: nsJSIID<nsIRegion>;
  nsIProcessToolsService: nsJSIID<nsIProcessToolsService>;
  nsIFingerprintingOverride: nsJSIID<nsIFingerprintingOverride>;
  nsIFingerprintingWebCompatService: nsJSIID<nsIFingerprintingWebCompatService>;
  nsIRFPService: nsJSIID<nsIRFPService>;
  nsIRFPTargetSetIDL: nsJSIID<nsIRFPTargetSetIDL>;
  nsIUserCharacteristicsPageService: nsJSIID<nsIUserCharacteristicsPageService>;
  nsISearchSubmission: nsJSIID<nsISearchSubmission>;
  nsISearchEngine: nsJSIID<nsISearchEngine>;
  nsISearchParseSubmissionResult: nsJSIID<nsISearchParseSubmissionResult>;
  nsISearchService: nsJSIID<nsISearchService, typeof nsISearchService_OpenSearchInstallErrors & typeof nsISearchService_DefaultEngineChangeReason>;
  nsIToolkitShellService: nsJSIID<nsIToolkitShellService>;
  nsITerminatorTest: nsJSIID<nsITerminatorTest>;
  nsIXULStore: nsJSIID<nsIXULStore>;
  nsIProfileStartup: nsJSIID<nsIProfileStartup>;
  nsIProfileMigrator: nsJSIID<nsIProfileMigrator>;
  nsIProfileUnlocker: nsJSIID<nsIProfileUnlocker>;
  nsIProfileLock: nsJSIID<nsIProfileLock>;
  nsIToolkitProfile: nsJSIID<nsIToolkitProfile>;
  nsIToolkitProfileService: nsJSIID<nsIToolkitProfileService, typeof nsIToolkitProfileService_downgradeUIFlags & typeof nsIToolkitProfileService_downgradeUIChoice & typeof nsIToolkitProfileService_profileManagerResult>;
  nsIRemoteService: nsJSIID<nsIRemoteService>;
  nsITransaction: nsJSIID<nsITransaction>;
  nsITransactionManager: nsJSIID<nsITransactionManager>;
  nsIInlineSpellChecker: nsJSIID<nsIInlineSpellChecker>;
  nsIScriptableUnicodeConverter: nsJSIID<nsIScriptableUnicodeConverter>;
  nsITextToSubURI: nsJSIID<nsITextToSubURI>;
  nsIUpdateTimerManager: nsJSIID<nsIUpdateTimerManager>;
  nsIUpdatePatch: nsJSIID<nsIUpdatePatch>;
  nsIUpdate: nsJSIID<nsIUpdate>;
  nsIUpdateCheckResult: nsJSIID<nsIUpdateCheckResult>;
  nsIUpdateCheck: nsJSIID<nsIUpdateCheck>;
  nsIUpdateCheckerInternal: nsJSIID<nsIUpdateCheckerInternal>;
  nsIUpdateChecker: nsJSIID<nsIUpdateChecker>;
  nsIApplicationUpdateServiceInternal: nsJSIID<nsIApplicationUpdateServiceInternal>;
  nsIApplicationUpdateService: nsJSIID<nsIApplicationUpdateService>;
  nsIUpdateProcessor: nsJSIID<nsIUpdateProcessor>;
  nsIUpdateSyncManager: nsJSIID<nsIUpdateSyncManager>;
  nsIUpdateMutex: nsJSIID<nsIUpdateMutex>;
  nsIUpdateManagerInternal: nsJSIID<nsIUpdateManagerInternal>;
  nsIUpdateManager: nsJSIID<nsIUpdateManager>;
  nsIApplicationUpdateServiceStub: nsJSIID<nsIApplicationUpdateServiceStub>;
  nsIContentHandler: nsJSIID<nsIContentHandler>;
  nsIDocumentLoader: nsJSIID<nsIDocumentLoader>;
  nsITransfer: nsJSIID<nsITransfer>;
  nsIURIContentListener: nsJSIID<nsIURIContentListener>;
  nsIURILoader: nsJSIID<nsIURILoader>;
  nsIWebProgress: nsJSIID<nsIWebProgress>;
  nsIWebProgressListener: nsJSIID<nsIWebProgressListener>;
  nsIWebProgressListener2: nsJSIID<nsIWebProgressListener2>;
  nsIUrlClassifierBlockedChannel: nsJSIID<nsIUrlClassifierBlockedChannel>;
  nsIChannelClassifierService: nsJSIID<nsIChannelClassifierService>;
  nsIURIClassifierCallback: nsJSIID<nsIURIClassifierCallback>;
  nsIURIClassifier: nsJSIID<nsIURIClassifier>;
  nsIUrlClassifierExceptionList: nsJSIID<nsIUrlClassifierExceptionList>;
  nsIUrlClassifierExceptionListEntry: nsJSIID<nsIUrlClassifierExceptionListEntry>;
  nsIUrlClassifierExceptionListObserver: nsJSIID<nsIUrlClassifierExceptionListObserver>;
  nsIUrlClassifierExceptionListService: nsJSIID<nsIUrlClassifierExceptionListService>;
  nsIUrlClassifierFeature: nsJSIID<nsIUrlClassifierFeature, typeof nsIUrlClassifierFeature_listType & typeof nsIUrlClassifierFeature_URIType>;
  nsIUrlClassifierFeatureResult: nsJSIID<nsIUrlClassifierFeatureResult>;
  nsIUrlClassifierFeatureCallback: nsJSIID<nsIUrlClassifierFeatureCallback>;
  IUrlClassifierUITelemetry: nsJSIID<IUrlClassifierUITelemetry>;
  nsIUrlClassifierCallback: nsJSIID<nsIUrlClassifierCallback>;
  nsIUrlClassifierUpdateObserver: nsJSIID<nsIUrlClassifierUpdateObserver>;
  nsIUrlClassifierDBService: nsJSIID<nsIUrlClassifierDBService>;
  nsIFullHashMatch: nsJSIID<nsIFullHashMatch>;
  nsIUrlClassifierHashCompleterCallback: nsJSIID<nsIUrlClassifierHashCompleterCallback>;
  nsIUrlClassifierHashCompleter: nsJSIID<nsIUrlClassifierHashCompleter>;
  nsIUrlClassifierPositiveCacheEntry: nsJSIID<nsIUrlClassifierPositiveCacheEntry>;
  nsIUrlClassifierCacheEntry: nsJSIID<nsIUrlClassifierCacheEntry>;
  nsIUrlClassifierCacheInfo: nsJSIID<nsIUrlClassifierCacheInfo>;
  nsIUrlClassifierGetCacheCallback: nsJSIID<nsIUrlClassifierGetCacheCallback>;
  nsIUrlClassifierInfo: nsJSIID<nsIUrlClassifierInfo>;
  nsIUrlClassifierPrefixSet: nsJSIID<nsIUrlClassifierPrefixSet>;
  nsIUrlClassifierRemoteSettingsService: nsJSIID<nsIUrlClassifierRemoteSettingsService>;
  nsIUrlClassifierStreamUpdater: nsJSIID<nsIUrlClassifierStreamUpdater>;
  nsIUrlClassifierParseFindFullHashCallback: nsJSIID<nsIUrlClassifierParseFindFullHashCallback>;
  nsIUrlClassifierUtils: nsJSIID<nsIUrlClassifierUtils>;
  nsIUrlListManager: nsJSIID<nsIUrlListManager>;
  nsIURLFormatter: nsJSIID<nsIURLFormatter>;
  nsIUtilityProcessTest: nsJSIID<nsIUtilityProcessTest>;
  nsIWebBrowser: nsJSIID<nsIWebBrowser>;
  nsIWebBrowserChrome: nsJSIID<nsIWebBrowserChrome>;
  nsIWebBrowserPrint: nsJSIID<nsIWebBrowserPrint>;
  nsIWebBrowserPersist: nsJSIID<nsIWebBrowserPersist>;
  nsIWebBrowserPersistURIMap: nsJSIID<nsIWebBrowserPersistURIMap>;
  nsIWebBrowserPersistDocument: nsJSIID<nsIWebBrowserPersistDocument>;
  nsIWebBrowserPersistResourceVisitor: nsJSIID<nsIWebBrowserPersistResourceVisitor>;
  nsIWebBrowserPersistWriteCompletion: nsJSIID<nsIWebBrowserPersistWriteCompletion>;
  nsIWebBrowserPersistDocumentReceiver: nsJSIID<nsIWebBrowserPersistDocumentReceiver>;
  extIWebNavigation: nsJSIID<extIWebNavigation>;
  mozIExtensionServiceWorkerInfo: nsJSIID<mozIExtensionServiceWorkerInfo>;
  mozIExtensionListenerCallOptions: nsJSIID<mozIExtensionListenerCallOptions, typeof mozIExtensionListenerCallOptions_APIObjectType & typeof mozIExtensionListenerCallOptions_CallbackType>;
  mozIExtensionEventListener: nsJSIID<mozIExtensionEventListener>;
  mozIExtensionAPIRequest: nsJSIID<mozIExtensionAPIRequest, typeof mozIExtensionAPIRequest_RequestType>;
  mozIExtensionAPIRequestResult: nsJSIID<mozIExtensionAPIRequestResult, typeof mozIExtensionAPIRequestResult_ResultType>;
  mozIExtensionAPIRequestHandler: nsJSIID<mozIExtensionAPIRequestHandler>;
  mozIExtensionProcessScript: nsJSIID<mozIExtensionProcessScript>;
  nsINativeMessagingPortal: nsJSIID<nsINativeMessagingPortal>;
  nsIWebVTTListener: nsJSIID<nsIWebVTTListener>;
  nsIWebVTTParserWrapper: nsJSIID<nsIWebVTTParserWrapper>;
  nsIBaseWindow: nsJSIID<nsIBaseWindow>;
  nsIBidiKeyboard: nsJSIID<nsIBidiKeyboard>;
  nsIAsyncSetClipboardData: nsJSIID<nsIAsyncSetClipboardData>;
  nsIAsyncClipboardRequestCallback: nsJSIID<nsIAsyncClipboardRequestCallback>;
  nsIClipboardDataSnapshot: nsJSIID<nsIClipboardDataSnapshot>;
  nsIClipboardGetDataSnapshotCallback: nsJSIID<nsIClipboardGetDataSnapshotCallback>;
  nsIClipboard: nsJSIID<nsIClipboard, typeof nsIClipboard_ClipboardType>;
  nsIClipboardHelper: nsJSIID<nsIClipboardHelper, typeof nsIClipboardHelper_SensitiveData>;
  nsIClipboardOwner: nsJSIID<nsIClipboardOwner>;
  nsIColorPickerShownCallback: nsJSIID<nsIColorPickerShownCallback>;
  nsIColorPicker: nsJSIID<nsIColorPicker>;
  nsIDisplayInfo: nsJSIID<nsIDisplayInfo>;
  nsIDragService: nsJSIID<nsIDragService>;
  nsIDragSession: nsJSIID<nsIDragSession>;
  nsIFilePicker: nsJSIID<nsIFilePicker, typeof nsIFilePicker_Mode & typeof nsIFilePicker_ResultCode & typeof nsIFilePicker_CaptureTarget>;
  nsIFilePickerShownCallback: nsJSIID<nsIFilePickerShownCallback>;
  nsIFormatConverter: nsJSIID<nsIFormatConverter>;
  nsIGfxInfo: nsJSIID<nsIGfxInfo, typeof nsIGfxInfo_FontVisibilityDeviceDetermination>;
  nsIGfxInfoDebug: nsJSIID<nsIGfxInfoDebug>;
  nsIMockDragServiceController: nsJSIID<nsIMockDragServiceController, typeof nsIMockDragServiceController_EventType>;
  nsIPaper: nsJSIID<nsIPaper>;
  nsIPaperMargin: nsJSIID<nsIPaperMargin>;
  nsIPrintDialogService: nsJSIID<nsIPrintDialogService>;
  nsIPrintSettings: nsJSIID<nsIPrintSettings, typeof nsIPrintSettings_OutputDestinationType>;
  nsIPrintSettingsService: nsJSIID<nsIPrintSettingsService>;
  nsIPrinterInfo: nsJSIID<nsIPrinterInfo>;
  nsIPrinter: nsJSIID<nsIPrinter>;
  nsIPrinterList: nsJSIID<nsIPrinterList>;
  nsIScreen: nsJSIID<nsIScreen>;
  nsIScreenManager: nsJSIID<nsIScreenManager>;
  nsISharePicker: nsJSIID<nsISharePicker>;
  nsISound: nsJSIID<nsISound>;
  nsISystemStatusBar: nsJSIID<nsISystemStatusBar>;
  nsIFlavorDataProvider: nsJSIID<nsIFlavorDataProvider>;
  nsITransferable: nsJSIID<nsITransferable>;
  nsIUserIdleService: nsJSIID<nsIUserIdleService>;
  nsIUserIdleServiceInternal: nsJSIID<nsIUserIdleServiceInternal>;
  nsIWindowCreator: nsJSIID<nsIWindowCreator>;
  nsIWindowProvider: nsJSIID<nsIWindowProvider>;
  nsIDialogParamBlock: nsJSIID<nsIDialogParamBlock>;
  nsIOpenWindowInfo: nsJSIID<nsIOpenWindowInfo>;
  nsIPromptCollection: nsJSIID<nsIPromptCollection>;
  nsIPromptFactory: nsJSIID<nsIPromptFactory>;
  nsIPromptService: nsJSIID<nsIPromptService>;
  nsIWindowWatcher: nsJSIID<nsIWindowWatcher>;
  nsITabUnloader: nsJSIID<nsITabUnloader>;
  nsIAvailableMemoryWatcherBase: nsJSIID<nsIAvailableMemoryWatcherBase>;
  nsIConsoleListener: nsJSIID<nsIConsoleListener>;
  nsIConsoleMessage: nsJSIID<nsIConsoleMessage>;
  nsIConsoleService: nsJSIID<nsIConsoleService, typeof nsIConsoleService_OutputMode>;
  nsICycleCollectorHandler: nsJSIID<nsICycleCollectorHandler>;
  nsICycleCollectorLogSink: nsJSIID<nsICycleCollectorLogSink>;
  nsICycleCollectorListener: nsJSIID<nsICycleCollectorListener>;
  nsIDebug2: nsJSIID<nsIDebug2>;
  nsIStackFrame: nsJSIID<nsIStackFrame>;
  nsIException: nsJSIID<nsIException>;
  nsIInterfaceRequestor: nsJSIID<nsIInterfaceRequestor>;
  nsIFinishDumpingCallback: nsJSIID<nsIFinishDumpingCallback>;
  nsIDumpGCAndCCLogsCallback: nsJSIID<nsIDumpGCAndCCLogsCallback>;
  nsIMemoryInfoDumper: nsJSIID<nsIMemoryInfoDumper>;
  nsIHandleReportCallback: nsJSIID<nsIHandleReportCallback>;
  nsIMemoryReporter: nsJSIID<nsIMemoryReporter>;
  nsIFinishReportingCallback: nsJSIID<nsIFinishReportingCallback>;
  nsIHeapAllocatedCallback: nsJSIID<nsIHeapAllocatedCallback>;
  nsIMemoryReporterManager: nsJSIID<nsIMemoryReporterManager>;
  nsISupports: nsJSIID<nsISupports>;
  nsIUUIDGenerator: nsJSIID<nsIUUIDGenerator>;
  nsIVersionComparator: nsJSIID<nsIVersionComparator>;
  nsIWeakReference: nsJSIID<nsIWeakReference>;
  nsISupportsWeakReference: nsJSIID<nsISupportsWeakReference>;
  nsICategoryEntry: nsJSIID<nsICategoryEntry>;
  nsICategoryManager: nsJSIID<nsICategoryManager>;
  nsIClassInfo: nsJSIID<nsIClassInfo>;
  nsIComponentManager: nsJSIID<nsIComponentManager>;
  nsIComponentRegistrar: nsJSIID<nsIComponentRegistrar>;
  nsIFactory: nsJSIID<nsIFactory>;
  nsIServiceManager: nsJSIID<nsIServiceManager>;
  nsIArray: nsJSIID<nsIArray>;
  nsIArrayExtensions: nsJSIID<nsIArrayExtensions>;
  nsIINIParser: nsJSIID<nsIINIParser>;
  nsIINIParserWriter: nsJSIID<nsIINIParserWriter>;
  nsIINIParserFactory: nsJSIID<nsIINIParserFactory>;
  nsIMutableArray: nsJSIID<nsIMutableArray>;
  nsIObserver: nsJSIID<nsIObserver>;
  nsIObserverService: nsJSIID<nsIObserverService>;
  nsIPropertyElement: nsJSIID<nsIPropertyElement>;
  nsIPersistentProperties: nsJSIID<nsIPersistentProperties>;
  nsIProperties: nsJSIID<nsIProperties>;
  nsIProperty: nsJSIID<nsIProperty>;
  nsIPropertyBag: nsJSIID<nsIPropertyBag>;
  nsIPropertyBag2: nsJSIID<nsIPropertyBag2>;
  nsISerializable: nsJSIID<nsISerializable>;
  nsIJSEnumerator: nsJSIID<nsIJSEnumerator>;
  nsISimpleEnumeratorBase: nsJSIID<nsISimpleEnumeratorBase>;
  nsISimpleEnumerator: nsJSIID<nsISimpleEnumerator>;
  nsIStringEnumeratorBase: nsJSIID<nsIStringEnumeratorBase>;
  nsIStringEnumerator: nsJSIID<nsIStringEnumerator>;
  nsIUTF8StringEnumerator: nsJSIID<nsIUTF8StringEnumerator>;
  nsIOutputIterator: nsJSIID<nsIOutputIterator>;
  nsIInputIterator: nsJSIID<nsIInputIterator>;
  nsIForwardIterator: nsJSIID<nsIForwardIterator>;
  nsIBidirectionalIterator: nsJSIID<nsIBidirectionalIterator>;
  nsIRandomAccessIterator: nsJSIID<nsIRandomAccessIterator>;
  nsISupportsPrimitive: nsJSIID<nsISupportsPrimitive>;
  nsISupportsID: nsJSIID<nsISupportsID>;
  nsISupportsCString: nsJSIID<nsISupportsCString>;
  nsISupportsString: nsJSIID<nsISupportsString>;
  nsISupportsPRBool: nsJSIID<nsISupportsPRBool>;
  nsISupportsPRUint8: nsJSIID<nsISupportsPRUint8>;
  nsISupportsPRUint16: nsJSIID<nsISupportsPRUint16>;
  nsISupportsPRUint32: nsJSIID<nsISupportsPRUint32>;
  nsISupportsPRUint64: nsJSIID<nsISupportsPRUint64>;
  nsISupportsPRTime: nsJSIID<nsISupportsPRTime>;
  nsISupportsChar: nsJSIID<nsISupportsChar>;
  nsISupportsPRInt16: nsJSIID<nsISupportsPRInt16>;
  nsISupportsPRInt32: nsJSIID<nsISupportsPRInt32>;
  nsISupportsPRInt64: nsJSIID<nsISupportsPRInt64>;
  nsISupportsFloat: nsJSIID<nsISupportsFloat>;
  nsISupportsDouble: nsJSIID<nsISupportsDouble>;
  nsISupportsInterfacePointer: nsJSIID<nsISupportsInterfacePointer>;
  nsIVariant: nsJSIID<nsIVariant>;
  nsIWritableVariant: nsJSIID<nsIWritableVariant>;
  nsIWritablePropertyBag: nsJSIID<nsIWritablePropertyBag>;
  nsIWritablePropertyBag2: nsJSIID<nsIWritablePropertyBag2>;
  nsIAsyncInputStream: nsJSIID<nsIAsyncInputStream>;
  nsIInputStreamCallback: nsJSIID<nsIInputStreamCallback>;
  nsIAsyncOutputStream: nsJSIID<nsIAsyncOutputStream>;
  nsIOutputStreamCallback: nsJSIID<nsIOutputStreamCallback>;
  nsIBinaryInputStream: nsJSIID<nsIBinaryInputStream>;
  nsIBinaryOutputStream: nsJSIID<nsIBinaryOutputStream>;
  nsICloneableInputStream: nsJSIID<nsICloneableInputStream>;
  nsICloneableInputStreamWithRange: nsJSIID<nsICloneableInputStreamWithRange>;
  nsIConverterInputStream: nsJSIID<nsIConverterInputStream>;
  nsIConverterOutputStream: nsJSIID<nsIConverterOutputStream>;
  nsIDirectoryEnumerator: nsJSIID<nsIDirectoryEnumerator>;
  nsIDirectoryServiceProvider: nsJSIID<nsIDirectoryServiceProvider>;
  nsIDirectoryServiceProvider2: nsJSIID<nsIDirectoryServiceProvider2>;
  nsIDirectoryService: nsJSIID<nsIDirectoryService>;
  nsIFile: nsJSIID<nsIFile>;
  nsIIOUtil: nsJSIID<nsIIOUtil>;
  nsIInputStream: nsJSIID<nsIInputStream>;
  nsIInputStreamPriority: nsJSIID<nsIInputStreamPriority>;
  nsIInputStreamTee: nsJSIID<nsIInputStreamTee>;
  nsILineInputStream: nsJSIID<nsILineInputStream>;
  nsILocalFileWin: nsJSIID<nsILocalFileWin>;
  nsIMultiplexInputStream: nsJSIID<nsIMultiplexInputStream>;
  nsIObjectInputStream: nsJSIID<nsIObjectInputStream>;
  nsIObjectOutputStream: nsJSIID<nsIObjectOutputStream>;
  nsIOutputStream: nsJSIID<nsIOutputStream>;
  nsIPipe: nsJSIID<nsIPipe>;
  nsISearchableInputStream: nsJSIID<nsISearchableInputStream>;
  nsIRandomAccessStream: nsJSIID<nsIRandomAccessStream>;
  nsISafeOutputStream: nsJSIID<nsISafeOutputStream>;
  nsIScriptableBase64Encoder: nsJSIID<nsIScriptableBase64Encoder>;
  nsIScriptableInputStream: nsJSIID<nsIScriptableInputStream>;
  nsISeekableStream: nsJSIID<nsISeekableStream>;
  nsIStorageStream: nsJSIID<nsIStorageStream>;
  nsIStreamBufferAccess: nsJSIID<nsIStreamBufferAccess>;
  nsIStringInputStream: nsJSIID<nsIStringInputStream>;
  nsITellableStream: nsJSIID<nsITellableStream>;
  nsIUnicharInputStream: nsJSIID<nsIUnicharInputStream>;
  nsIUnicharLineInputStream: nsJSIID<nsIUnicharLineInputStream>;
  nsIUnicharOutputStream: nsJSIID<nsIUnicharOutputStream>;
  nsIBlocklistService: nsJSIID<nsIBlocklistService>;
  nsICrashReporter: nsJSIID<nsICrashReporter>;
  nsIDeviceSensorData: nsJSIID<nsIDeviceSensorData>;
  nsIDeviceSensors: nsJSIID<nsIDeviceSensors>;
  nsIGIOHandlerApp: nsJSIID<nsIGIOHandlerApp>;
  nsIGIOMimeApp: nsJSIID<nsIGIOMimeApp>;
  nsIGIOService: nsJSIID<nsIGIOService>;
  nsIGSettingsCollection: nsJSIID<nsIGSettingsCollection>;
  nsIGSettingsService: nsJSIID<nsIGSettingsService>;
  nsIGeolocationUpdate: nsJSIID<nsIGeolocationUpdate>;
  nsIGeolocationProvider: nsJSIID<nsIGeolocationProvider>;
  nsIHapticFeedback: nsJSIID<nsIHapticFeedback>;
  nsIPlatformInfo: nsJSIID<nsIPlatformInfo>;
  nsISystemInfo: nsJSIID<nsISystemInfo>;
  nsIXULAppInfo: nsJSIID<nsIXULAppInfo>;
  nsIXULRuntime: nsJSIID<nsIXULRuntime, typeof nsIXULRuntime_ExperimentStatus & typeof nsIXULRuntime_ContentWin32kLockdownState & typeof nsIXULRuntime_FissionDecisionStatus>;
  nsIEnvironment: nsJSIID<nsIEnvironment>;
  nsIEventTarget: nsJSIID<nsIEventTarget>;
  nsINamed: nsJSIID<nsINamed>;
  nsIProcess: nsJSIID<nsIProcess>;
  nsIRunnable: nsJSIID<nsIRunnable>;
  nsIRunnablePriority: nsJSIID<nsIRunnablePriority>;
  nsISerialEventTarget: nsJSIID<nsISerialEventTarget>;
  nsISupportsPriority: nsJSIID<nsISupportsPriority>;
  nsIThread: nsJSIID<nsIThread, typeof nsIThread_QoSPriority>;
  nsINestedEventLoopCondition: nsJSIID<nsINestedEventLoopCondition>;
  nsIThreadManager: nsJSIID<nsIThreadManager>;
  nsIThreadShutdown: nsJSIID<nsIThreadShutdown>;
  nsITimerCallback: nsJSIID<nsITimerCallback>;
  nsITimer: nsJSIID<nsITimer>;
  nsITimerManager: nsJSIID<nsITimerManager>;
  nsIScriptableOK: nsJSIID<nsIScriptableOK>;
  nsIScriptableWithNotXPCOM: nsJSIID<nsIScriptableWithNotXPCOM>;
  mozIJSSubScriptLoader: nsJSIID<mozIJSSubScriptLoader>;
  xpcIJSWeakReference: nsJSIID<xpcIJSWeakReference>;
  nsIXPCComponents_Classes: nsJSIID<nsIXPCComponents_Classes>;
  nsIXPCComponents_Results: nsJSIID<nsIXPCComponents_Results>;
  nsIXPCComponents_ID: nsJSIID<nsIXPCComponents_ID>;
  nsIXPCComponents_Exception: nsJSIID<nsIXPCComponents_Exception>;
  nsIXPCComponents_Constructor: nsJSIID<nsIXPCComponents_Constructor>;
  nsIXPCComponents_utils_Sandbox: nsJSIID<nsIXPCComponents_utils_Sandbox>;
  nsIScheduledGCCallback: nsJSIID<nsIScheduledGCCallback>;
  nsIXPCComponents_Utils: nsJSIID<nsIXPCComponents_Utils>;
  nsIXPCComponents: nsJSIID<nsIXPCComponents>;
  nsIXPCTestObjectReadOnly: nsJSIID<nsIXPCTestObjectReadOnly>;
  nsIXPCTestObjectReadWrite: nsJSIID<nsIXPCTestObjectReadWrite>;
  nsIXPCTestBug809674: nsJSIID<nsIXPCTestBug809674>;
  nsIXPCTestCEnums: nsJSIID<nsIXPCTestCEnums, typeof nsIXPCTestCEnums_testFlagsExplicit & typeof nsIXPCTestCEnums_testFlagsImplicit>;
  nsIXPCTestInterfaceA: nsJSIID<nsIXPCTestInterfaceA>;
  nsIXPCTestInterfaceB: nsJSIID<nsIXPCTestInterfaceB>;
  nsIXPCTestInterfaceC: nsJSIID<nsIXPCTestInterfaceC>;
  nsIXPCTestParams: nsJSIID<nsIXPCTestParams>;
  nsIXPCTestReturnCodeParent: nsJSIID<nsIXPCTestReturnCodeParent>;
  nsIXPCTestReturnCodeChild: nsJSIID<nsIXPCTestReturnCodeChild>;
  nsIXPCTestFunctionInterface: nsJSIID<nsIXPCTestFunctionInterface>;
  nsIXPCTestUtils: nsJSIID<nsIXPCTestUtils>;
  nsIXPCTestTypeScript: nsJSIID<nsIXPCTestTypeScript>;
  nsIBrowserController: nsJSIID<nsIBrowserController>;
  nsIController: nsJSIID<nsIController>;
  nsICommandController: nsJSIID<nsICommandController>;
  nsIControllers: nsJSIID<nsIControllers>;
  nsINativeAppSupport: nsJSIID<nsINativeAppSupport>;
  nsIXREDirProvider: nsJSIID<nsIXREDirProvider>;
  nsIZipWriter: nsJSIID<nsIZipWriter>;
}

}  // global

// Typedefs from xpidl.
type AccessibleTextBoundary = i32;
type AppTrustedRoot = u32;
type COSEAlgorithmIdentifier = i32;
type CSPDirective = nsIContentSecurityPolicy.CSPDirective;
type DOMHighResTimeStamp = double;
type DOMTimeStamp = u64;
type EpochTimeStamp = u64;
type PRTime = i64;
type PivotMoveReason = i16;
type PredictorLearnReason = u32;
type PredictorPredictReason = u32;
type RequireTrustedTypesForDirectiveState = nsIContentSecurityPolicy.RequireTrustedTypesForDirectiveState;
type nsBitsErrorAction = i32;
type nsBitsErrorStage = i32;
type nsBitsErrorType = i32;
type nsContentPolicyType = nsIContentPolicy.nsContentPolicyType;
type nsCookieAccess = i32;
type nsCookiePolicy = i32;
type nsCookieStatus = i32;
type nsHandlerInfoAction = i32;
type nsLoadFlags = u32;
type nsProxyUsage = i32;
type nsSecurityFlags = u32;
type nsServerSocketFlag = u32;
type nsSuspendedTypes = u32;
type nsViewID = u64;

// XPCOM internal utility types.

/** XPCOM inout param is passed in as a js object with a value property. */
type InOutParam<T> = { value: T };

/** XPCOM out param is written to the passed in object's value property. */
type OutParam<T> = { value?: T };

/** Enable interfaces to inherit from enums: pick variants as optional. */
type Enums<enums> = Partial<Pick<enums, keyof enums>>;

/** Callable accepts either form of a [function] interface. */
type Callable<iface> = iface | Extract<iface[keyof iface], Function>


// @ts-nocheck
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */





declare global {
  const Cc: nsXPCComponents_Classes;
  const Ci: nsIXPCComponents_Interfaces;
  const Components: nsIXPCComponents;
  const Cr: nsIXPCComponents_Results;

  // Resolve typed generic overloads before the generated ones.
  const Cu: nsXPCComponents_Utils & nsIXPCComponents_Utils;

  const Services: JSServices;
  const uneval: (any) => string;
}


// @ts-nocheck
/**
 * Custom artisanal types, handcrafted especially for Gecko.
 */

declare global {
  type DeclaredLazy<T> = {
    [P in keyof T]: T[P] extends () => infer U
      ? U
      : T[P] extends keyof LazyModules
        ? Exports<T[P], P>
        : T[P] extends { pref: string; default?: infer U }
          ? Widen<U>
          : T[P] extends { service: string; iid?: infer U }
            ? nsQIResult<U>
            : never;
  };

  type LazyDefinition = Record<
    string,
    | string
    | (() => any)
    | { service: string; iid: nsIID }
    | { pref: string; default?; onUpdate?; transform? }
  >;
}

type Exports<M, P> = M extends keyof LazyModules
  ? IfKey<LazyModules[M], P>
  : never;
type IfKey<T, K> = K extends keyof T ? T[K] : never;

type LazyModules = import("./generated/lib.gecko.modules").LazyModules;

type Widen<T> = T extends boolean
  ? boolean
  : T extends number
    ? number
    : T extends string
      ? string
      : never;


// @ts-nocheck
declare var Glean: GleanImpl;
declare var GleanPings: GleanPingsImpl;
declare var InstallTrigger: InstallTriggerImpl | null;
declare var browserDOMWindow: nsIBrowserDOMWindow | null;
declare var browsingContext: BrowsingContext;
declare var clientInformation: Navigator;
declare var clientPrincipal: Principal | null;
declare var closed: boolean;
declare var content: any;
declare var controllers: XULControllers;
declare var cookieStore: CookieStore;
declare var customElements: CustomElementRegistry;
declare var desktopToDeviceScale: number;
declare var devicePixelRatio: number;
declare var docShell: nsIDocShell | null;
declare var document: Document | null;
declare var event: Event | undefined;
declare var external: External;
declare var frameElement: Element | null;
declare var frames: WindowProxy;
declare var fullScreen: boolean;
declare var history: History;
declare var innerHeight: number;
declare var innerWidth: number;
declare var intlUtils: IntlUtils;
declare var isChromeWindow: boolean;
declare var isFullyOccluded: boolean;
declare var isInFullScreenTransition: boolean;
declare var length: number;
declare var location: Location;
declare var locationbar: BarProp;
declare var menubar: BarProp;
declare var messageManager: ChromeMessageBroadcaster;
declare var mozInnerScreenX: number;
declare var mozInnerScreenY: number;
/** @deprecated */
declare const name: void;
declare var navigation: Navigation;
declare var navigator: Navigator;
declare var ondevicelight: ((this: Window, ev: Event) => any) | null;
declare var ondevicemotion: ((this: Window, ev: Event) => any) | null;
declare var ondeviceorientation: ((this: Window, ev: Event) => any) | null;
declare var ondeviceorientationabsolute: ((this: Window, ev: Event) => any) | null;
declare var onorientationchange: ((this: Window, ev: Event) => any) | null;
declare var onuserproximity: ((this: Window, ev: Event) => any) | null;
declare var onvrdisplayactivate: ((this: Window, ev: Event) => any) | null;
declare var onvrdisplayconnect: ((this: Window, ev: Event) => any) | null;
declare var onvrdisplaydeactivate: ((this: Window, ev: Event) => any) | null;
declare var onvrdisplaydisconnect: ((this: Window, ev: Event) => any) | null;
declare var onvrdisplaypresentchange: ((this: Window, ev: Event) => any) | null;
declare var opener: any;
declare var orientation: number;
declare var originAgentCluster: boolean;
declare var outerHeight: number;
declare var outerWidth: number;
declare var pageXOffset: number;
declare var pageYOffset: number;
declare var paintWorklet: Worklet;
declare var parent: WindowProxy | null;
declare var performance: Performance | null;
declare var personalbar: BarProp;
declare var realFrameElement: Element | null;
declare var screen: Screen;
declare var screenEdgeSlopX: number;
declare var screenEdgeSlopY: number;
declare var screenLeft: number;
declare var screenTop: number;
declare var screenX: number;
declare var screenY: number;
declare var scrollMaxX: number;
declare var scrollMaxY: number;
declare var scrollMinX: number;
declare var scrollMinY: number;
declare var scrollX: number;
declare var scrollY: number;
declare var scrollbars: BarProp;
declare var self: WindowProxy;
declare var status: string;
declare var statusbar: BarProp;
declare var toolbar: BarProp;
declare var top: WindowProxy | null;
declare var visualViewport: VisualViewport;
declare var window: WindowProxy;
declare var windowGlobalChild: WindowGlobalChild | null;
declare var windowRoot: WindowRoot | null;
declare var windowState: number;
declare var windowUtils: nsIDOMWindowUtils;
declare function alert(): void;
declare function alert(message: string): void;
declare function blur(): void;
declare function cancelIdleCallback(handle: number): void;
declare function captureEvents(): void;
declare function close(): void;
declare function confirm(message?: string): boolean;
declare function dump(str: string): void;
declare function find(str?: string, caseSensitive?: boolean, backwards?: boolean, wrapAround?: boolean, wholeWord?: boolean, searchInFrames?: boolean, showDialog?: boolean): boolean;
declare function focus(): void;
declare function getAttention(): void;
declare function getAttentionWithCycleCount(aCycleCount: number): void;
declare function getComputedStyle(elt: Element, pseudoElt?: string | null): CSSStyleDeclaration | null;
declare function getDefaultComputedStyle(elt: Element, pseudoElt?: string): CSSStyleDeclaration | null;
declare function getGroupMessageManager(aGroup: string): ChromeMessageBroadcaster;
declare function getInterface(iid: any): any;
declare function getRegionalPrefsLocales(): string[];
declare function getSelection(): Selection | null;
declare function getWebExposedLocales(): string[];
declare function getWorkspaceID(): string;
declare function matchMedia(query: string): MediaQueryList | null;
declare function maximize(): void;
declare function minimize(): void;
declare function moveBy(x: number, y: number): void;
declare function moveTo(x: number, y: number): void;
declare function moveToWorkspace(workspaceID: string): void;
declare function mozScrollSnap(): void;
declare function notifyDefaultButtonLoaded(defaultButton: Element): void;
declare function open(url?: string | URL, target?: string, features?: string): WindowProxy | null;
declare function openDialog(url?: string, name?: string, options?: string, ...extraArguments: any[]): WindowProxy | null;
declare function postMessage(message: any, targetOrigin: string, transfer?: any[]): void;
declare function postMessage(message: any, options?: WindowPostMessageOptions): void;
declare function print(): void;
declare function printPreview(settings?: nsIPrintSettings | null, listener?: nsIWebProgressListener | null, docShellToPreviewInto?: nsIDocShell | null): WindowProxy | null;
declare function promiseDocumentFlushed(callback: PromiseDocumentFlushedCallback): Promise<any>;
declare function prompt(message?: string, _default?: string): string | null;
declare function releaseEvents(): void;
declare function requestIdleCallback(callback: IdleRequestCallback, options?: IdleRequestOptions): number;
declare function resizeBy(x: number, y: number): void;
declare function resizeTo(x: number, y: number): void;
declare function restore(): void;
declare function scroll(x: number, y: number): void;
declare function scroll(options?: ScrollToOptions): void;
declare function scrollBy(x: number, y: number): void;
declare function scrollBy(options?: ScrollToOptions): void;
declare function scrollByLines(numLines: number, options?: ScrollOptions): void;
declare function scrollByPages(numPages: number, options?: ScrollOptions): void;
declare function scrollTo(x: number, y: number): void;
declare function scrollTo(options?: ScrollToOptions): void;
declare function setCursor(cursor: string): void;
declare function setResizable(resizable: boolean): void;
declare function setScrollMarks(marks: number[], onHorizontalScrollbar?: boolean): void;
declare function shouldReportForServiceWorkerScope(aScope: string): boolean;
declare function sizeToContent(constraints?: SizeToContentConstraints): void;
declare function stop(): void;
declare function updateCommands(action: string): void;
declare function toString(): string;
declare var ownerGlobal: WindowProxy | null;
declare function dispatchEvent(event: Event): boolean;
declare function getEventHandler(type: string): EventHandler;
declare function setEventHandler(type: string, handler: EventHandler): void;
declare function cancelAnimationFrame(handle: number): void;
declare function requestAnimationFrame(callback: FrameRequestCallback): number;
declare var crypto: Crypto;
declare var onabort: ((this: Window, ev: Event) => any) | null;
declare var onanimationcancel: ((this: Window, ev: Event) => any) | null;
declare var onanimationend: ((this: Window, ev: Event) => any) | null;
declare var onanimationiteration: ((this: Window, ev: Event) => any) | null;
declare var onanimationstart: ((this: Window, ev: Event) => any) | null;
declare var onauxclick: ((this: Window, ev: Event) => any) | null;
declare var onbeforeinput: ((this: Window, ev: Event) => any) | null;
declare var onbeforematch: ((this: Window, ev: Event) => any) | null;
declare var onbeforetoggle: ((this: Window, ev: Event) => any) | null;
declare var onblur: ((this: Window, ev: Event) => any) | null;
declare var oncancel: ((this: Window, ev: Event) => any) | null;
declare var oncanplay: ((this: Window, ev: Event) => any) | null;
declare var oncanplaythrough: ((this: Window, ev: Event) => any) | null;
declare var onchange: ((this: Window, ev: Event) => any) | null;
declare var onclick: ((this: Window, ev: Event) => any) | null;
declare var onclose: ((this: Window, ev: Event) => any) | null;
declare var oncontentvisibilityautostatechange: ((this: Window, ev: Event) => any) | null;
declare var oncontextlost: ((this: Window, ev: Event) => any) | null;
declare var oncontextmenu: ((this: Window, ev: Event) => any) | null;
declare var oncontextrestored: ((this: Window, ev: Event) => any) | null;
declare var oncopy: ((this: Window, ev: Event) => any) | null;
declare var oncuechange: ((this: Window, ev: Event) => any) | null;
declare var oncut: ((this: Window, ev: Event) => any) | null;
declare var ondblclick: ((this: Window, ev: Event) => any) | null;
declare var ondrag: ((this: Window, ev: Event) => any) | null;
declare var ondragend: ((this: Window, ev: Event) => any) | null;
declare var ondragenter: ((this: Window, ev: Event) => any) | null;
declare var ondragexit: ((this: Window, ev: Event) => any) | null;
declare var ondragleave: ((this: Window, ev: Event) => any) | null;
declare var ondragover: ((this: Window, ev: Event) => any) | null;
declare var ondragstart: ((this: Window, ev: Event) => any) | null;
declare var ondrop: ((this: Window, ev: Event) => any) | null;
declare var ondurationchange: ((this: Window, ev: Event) => any) | null;
declare var onemptied: ((this: Window, ev: Event) => any) | null;
declare var onended: ((this: Window, ev: Event) => any) | null;
declare var onfocus: ((this: Window, ev: Event) => any) | null;
declare var onformdata: ((this: Window, ev: Event) => any) | null;
declare var ongotpointercapture: ((this: Window, ev: Event) => any) | null;
declare var oninput: ((this: Window, ev: Event) => any) | null;
declare var oninvalid: ((this: Window, ev: Event) => any) | null;
declare var onkeydown: ((this: Window, ev: Event) => any) | null;
declare var onkeypress: ((this: Window, ev: Event) => any) | null;
declare var onkeyup: ((this: Window, ev: Event) => any) | null;
declare var onload: ((this: Window, ev: Event) => any) | null;
declare var onloadeddata: ((this: Window, ev: Event) => any) | null;
declare var onloadedmetadata: ((this: Window, ev: Event) => any) | null;
declare var onloadstart: ((this: Window, ev: Event) => any) | null;
declare var onlostpointercapture: ((this: Window, ev: Event) => any) | null;
declare var onmousedown: ((this: Window, ev: Event) => any) | null;
declare var onmouseenter: ((this: Window, ev: Event) => any) | null;
declare var onmouseleave: ((this: Window, ev: Event) => any) | null;
declare var onmousemove: ((this: Window, ev: Event) => any) | null;
declare var onmouseout: ((this: Window, ev: Event) => any) | null;
declare var onmouseover: ((this: Window, ev: Event) => any) | null;
declare var onmouseup: ((this: Window, ev: Event) => any) | null;
declare var onmozfullscreenchange: ((this: Window, ev: Event) => any) | null;
declare var onmozfullscreenerror: ((this: Window, ev: Event) => any) | null;
declare var onpaste: ((this: Window, ev: Event) => any) | null;
declare var onpause: ((this: Window, ev: Event) => any) | null;
declare var onplay: ((this: Window, ev: Event) => any) | null;
declare var onplaying: ((this: Window, ev: Event) => any) | null;
declare var onpointercancel: ((this: Window, ev: Event) => any) | null;
declare var onpointerdown: ((this: Window, ev: Event) => any) | null;
declare var onpointerenter: ((this: Window, ev: Event) => any) | null;
declare var onpointerleave: ((this: Window, ev: Event) => any) | null;
declare var onpointermove: ((this: Window, ev: Event) => any) | null;
declare var onpointerout: ((this: Window, ev: Event) => any) | null;
declare var onpointerover: ((this: Window, ev: Event) => any) | null;
/** Available only in secure contexts. */
declare var onpointerrawupdate: ((this: Window, ev: Event) => any) | null;
declare var onpointerup: ((this: Window, ev: Event) => any) | null;
declare var onprogress: ((this: Window, ev: Event) => any) | null;
declare var onratechange: ((this: Window, ev: Event) => any) | null;
declare var onreset: ((this: Window, ev: Event) => any) | null;
declare var onresize: ((this: Window, ev: Event) => any) | null;
declare var onscroll: ((this: Window, ev: Event) => any) | null;
declare var onscrollend: ((this: Window, ev: Event) => any) | null;
declare var onsecuritypolicyviolation: ((this: Window, ev: Event) => any) | null;
declare var onseeked: ((this: Window, ev: Event) => any) | null;
declare var onseeking: ((this: Window, ev: Event) => any) | null;
declare var onselect: ((this: Window, ev: Event) => any) | null;
declare var onselectionchange: ((this: Window, ev: Event) => any) | null;
declare var onselectstart: ((this: Window, ev: Event) => any) | null;
declare var onslotchange: ((this: Window, ev: Event) => any) | null;
declare var onstalled: ((this: Window, ev: Event) => any) | null;
declare var onsubmit: ((this: Window, ev: Event) => any) | null;
declare var onsuspend: ((this: Window, ev: Event) => any) | null;
declare var ontimeupdate: ((this: Window, ev: Event) => any) | null;
declare var ontoggle: ((this: Window, ev: Event) => any) | null;
declare var ontransitioncancel: ((this: Window, ev: Event) => any) | null;
declare var ontransitionend: ((this: Window, ev: Event) => any) | null;
declare var ontransitionrun: ((this: Window, ev: Event) => any) | null;
declare var ontransitionstart: ((this: Window, ev: Event) => any) | null;
declare var onvolumechange: ((this: Window, ev: Event) => any) | null;
declare var onwaiting: ((this: Window, ev: Event) => any) | null;
declare var onwebkitanimationend: ((this: Window, ev: Event) => any) | null;
declare var onwebkitanimationiteration: ((this: Window, ev: Event) => any) | null;
declare var onwebkitanimationstart: ((this: Window, ev: Event) => any) | null;
declare var onwebkittransitionend: ((this: Window, ev: Event) => any) | null;
declare var onwheel: ((this: Window, ev: Event) => any) | null;
declare var onerror: ((this: Window, ev: Event) => any) | null;
declare var speechSynthesis: SpeechSynthesis;
declare var ontouchcancel: ((this: Window, ev: Event) => any) | null;
declare var ontouchend: ((this: Window, ev: Event) => any) | null;
declare var ontouchmove: ((this: Window, ev: Event) => any) | null;
declare var ontouchstart: ((this: Window, ev: Event) => any) | null;
declare var onafterprint: ((this: Window, ev: Event) => any) | null;
declare var onbeforeprint: ((this: Window, ev: Event) => any) | null;
declare var onbeforeunload: ((this: Window, ev: Event) => any) | null;
declare var ongamepadconnected: ((this: Window, ev: Event) => any) | null;
declare var ongamepaddisconnected: ((this: Window, ev: Event) => any) | null;
declare var onhashchange: ((this: Window, ev: Event) => any) | null;
declare var onlanguagechange: ((this: Window, ev: Event) => any) | null;
declare var onmessage: ((this: Window, ev: Event) => any) | null;
declare var onmessageerror: ((this: Window, ev: Event) => any) | null;
declare var onoffline: ((this: Window, ev: Event) => any) | null;
declare var ononline: ((this: Window, ev: Event) => any) | null;
declare var onpagehide: ((this: Window, ev: Event) => any) | null;
declare var onpageshow: ((this: Window, ev: Event) => any) | null;
declare var onpopstate: ((this: Window, ev: Event) => any) | null;
declare var onrejectionhandled: ((this: Window, ev: Event) => any) | null;
declare var onstorage: ((this: Window, ev: Event) => any) | null;
declare var onunhandledrejection: ((this: Window, ev: Event) => any) | null;
declare var onunload: ((this: Window, ev: Event) => any) | null;
declare var localStorage: Storage | null;
declare var caches: CacheStorage;
declare var crossOriginIsolated: boolean;
declare var indexedDB: IDBFactory | null;
declare var isSecureContext: boolean;
declare var origin: string;
declare var scheduler: Scheduler;
declare var trustedTypes: TrustedTypePolicyFactory;
declare function atob(atob: string): string;
declare function btoa(btoa: string): string;
declare function clearInterval(handle?: number): void;
declare function clearTimeout(handle?: number): void;
declare function createImageBitmap(aImage: ImageBitmapSource, aOptions?: ImageBitmapOptions): Promise<ImageBitmap>;
declare function createImageBitmap(aImage: ImageBitmapSource, aSx: number, aSy: number, aSw: number, aSh: number, aOptions?: ImageBitmapOptions): Promise<ImageBitmap>;
declare function fetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
declare function queueMicrotask(callback: VoidFunction): void;
declare function reportError(e: any): void;
declare function setInterval(handler: TimerHandler, timeout?: number, ...unused: any[]): number;
declare function setTimeout(handler: TimerHandler, timeout?: number, ...arguments: any[]): number;
declare function structuredClone(value: any, options?: StructuredSerializeOptions): any;
declare var sessionStorage: Storage | null;
declare function addEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
declare function addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
declare function removeEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
// @ts-nocheck
/**
 * Gecko generic/specialized adjustments for xpcom and webidl types.
 */

// More specific types for parent process browsing contexts.
interface CanonicalBrowsingContext extends LoadContextMixin {
  embedderElement: XULBrowserElement;
  currentWindowContext: WindowGlobalParent;
  parent: CanonicalBrowsingContext;
  parentWindowContext: WindowGlobalParent;
  top: CanonicalBrowsingContext;
  topWindowContext: WindowGlobalParent;
}

interface ChromeWindow extends Window {
  isChromeWindow: true;
}

interface Document {
  createXULElement(name: "browser"): XULBrowserElement;
}

type nsIGleanPingNoReason = {
  [K in keyof nsIGleanPing]: K extends "submit"
    ? (_?: never) => void
    : nsIGleanPing[K];
};

type nsIGleanPingWithReason<T> = {
  [K in keyof nsIGleanPing]: K extends "submit"
    ? (reason: T) => void
    : nsIGleanPing[K];
};

interface MessageListenerManagerMixin {
  // Overloads that define `data` arg as required, since it's ~always expected.
  addMessageListener(
    msg: string,
    listener: { receiveMessage(_: ReceiveMessageArgument & { data }) }
  );
  removeMessageListener(
    msg: string,
    listener: { receiveMessage(_: ReceiveMessageArgument & { data }) }
  );
}

interface MozQueryInterface {
  <T>(iid: T): nsQIResult<T>;
}

interface nsICryptoHash extends nsISupports {
  // Accepts a TypedArray.
  update(aData: ArrayLike<number>, aLen: number): void;
}

interface nsIDOMWindow extends Window {}

interface nsISimpleEnumerator extends Iterable<any> {}

interface nsISupports {
  wrappedJSObject?: object;
}

interface nsIXPCComponents_Constructor {
  <const T, IIDs = nsIXPCComponents_Interfaces>(
    cid,
    id: T,
    init?
  ): {
    new (...any): nsQIResult<T extends keyof IIDs ? IIDs[T] : T>;
    (...any): nsQIResult<T extends keyof IIDs ? IIDs[T] : T>;
  };
}

interface ComponentsExceptionOptions {
  result?: number;
  stack?: nsIStackFrame;
  data?: object;
}

interface nsIException extends Exception {}

interface nsIXPCComponents_Exception {
  (
    message?: string,
    resultOrOptions?: number | ComponentsExceptionOptions,
    stack?: nsIStackFrame,
    data?: object
  ): nsIException;
}

interface nsIXPCComponents_ID {
  (uuid: string): nsID;
}

interface nsIXPCComponents_utils_Sandbox {
  (principal: nsIPrincipal | nsIPrincipal[], options: object): Sandbox;
}

interface nsXPCComponents_Classes {
  [cid: string]: {
    createInstance<T>(aID: T): nsQIResult<T>;
    getService<T>(aID?: T): unknown extends T ? nsISupports : nsQIResult<T>;
  };
}

// Generic overloads.
interface nsXPCComponents_Utils {
  cloneInto<T>(value: T, ...any): T;
  createObjectIn<T = object>(_, object?: T): T;
  exportFunction<T>(func: T, ...any): T;
  getWeakReference<T>(value: T): { get(): T };
  waiveXrays<T>(object: T): T;
}

type Sandbox = typeof globalThis & nsISupports;

interface WindowGlobalParent extends WindowContext {
  readonly browsingContext: CanonicalBrowsingContext;
}

// Hand-crafted artisanal types.
interface XULBrowserElement extends XULFrameElement, FrameLoader {
  currentURI: nsIURI;
  docShellIsActive: boolean;
  isRemoteBrowser: boolean;
  remoteType: string;
}

// https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1736
interface Localization {
  formatValuesSync(aKeys: L10nKey[]): (string | null)[];
}

/**
 * Redefine the DOMStringMap interface to match its implementation.
 * xref Bug 1965336.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMStringMap)
 */
interface DOMStringMap {
  [name: string]: string | undefined;
}

// @ts-nocheck
/**
 * Gecko XPIDL base types.
 */

/**
 * Generic IDs are created by most code which passes a nsID to js.
 * https://searchfox.org/mozilla-central/source/js/xpconnect/src/XPCJSID.cpp#24
 */
interface nsID<uuid = string> {
  readonly number: uuid;
}

/**
 * In addition to nsID, interface IIDs support instanceof type guards,
 * and expose constants defined on the class, including variants from enums.
 * https://searchfox.org/mozilla-central/source/js/xpconnect/src/XPCJSID.cpp#45
 */
type nsJSIID<iface, enums = {}> = nsID &
  Constants<iface> &
  enums & {
    new (_: never): void;
    prototype: iface;
  };

/** A union type of all known interface IIDs. */
type nsIID = nsIXPCComponents_Interfaces[keyof nsIXPCComponents_Interfaces];

/** A generic to resolve QueryInterface return type from a nsIID. */
type nsQIResult<iid> = iid extends { prototype: infer U } ? U : never;

/** Picks only const number properties from T. */
type Constants<T> = { [K in keyof T as IfConst<K, T[K]>]: T[K] };

/** Resolves only for keys K whose corresponding type T is a narrow number. */
type IfConst<K, T> = T extends number ? (number extends T ? never : K) : never;

/** u32 */
type nsresult = u32;

// Numeric typedefs, useful as a quick reference in method signatures.
type double = number;
type float = number;
type i16 = number;
type i32 = number;
type i64 = number;
type u16 = number;
type u32 = number;
type u64 = number;
type u8 = number;

/**
 * Tweaks to the Gecko types to make them compatible with the current version of Zotero.
 */


declare namespace ChromeUtils {
  /**
   * @deprecated Use `ChromeUtils.importESModule` instead. See https://firefox-source-docs.mozilla.org/jsloader/jsloader-api.html#synchronous-module-import
   * @param aResourceURI
   * @param targetObj
   */
  function _import(aResourceURI: string, targetObj?: any): any;
  }

interface nsIXPCComponents_Utils {
  /**
   * @deprecated Use `ChromeUtils.importESModule` instead. See https://firefox-source-docs.mozilla.org/jsloader/jsloader-api.html#synchronous-module-import
   * @param aResourceURI
   * @param targetObj
   */
  import(aResourceURI: string, targetObj?: any): any;
}

interface DOMStringMap {
  [name: string]: string | undefined;
}

interface EventSourceEventMap {
  /**
   * Returns an object that provides methods and properties for drawing and manipulating images and graphics on a canvas element in a document. A context object includes information about colors, line widths, fonts, and other graphic parameters that can be drawn on a canvas.
   * @param contextId The identifier (ID) of the type of canvas to create. Internet Explorer 9 and Internet Explorer 10 support only a 2-D context using canvas.getContext("2d"); IE11 Preview also supports 3-D or WebGL context using canvas.getContext("experimental-webgl");
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLCanvasElement/getContext)
   */
  getContext(
    contextId: "2d",
    options?: CanvasRenderingContext2DSettings,
  ): CanvasRenderingContext2D | null;
  getContext(
    contextId: "bitmaprenderer",
    options?: ImageBitmapRenderingContext,
  ): ImageBitmapRenderingContext | null;
  getContext(
    contextId: "webgl",
    options?: WebGLContextAttributes,
  ): WebGLRenderingContext | null;
  getContext(
    contextId: "webgl2",
    options?: WebGLContextAttributes,
  ): WebGL2RenderingContext | null;
  getContext(contextId: string, options?: any): WebGLRenderingContext | null;
}


declare namespace _ZoteroTypes {
  interface ItemTree extends LibraryTree {
    [attr: string]: any;
  }

  interface ItemTreeRow extends TreeRow {
    new (ref: Zotero.DataObject, level: number, isOpen: boolean): this;
    getField(
      field: _ZoteroTypes.Item.ItemField | number,
      unformatted?: boolean,
    ): string;
    numNotes(): number;
  }
}

declare namespace _ZoteroTypes {
  interface TreeRow {
    isOpen: boolean;
    level: number;
  }
  interface LibraryTree extends React.Component {
    [attr: string]: any;

    get window(): Window;
    // get selection():TreeSelectionStub;
    get rowCount(): number;
    componentDidCatch(error: unknown, info: unknown): void;
    focus(): void;
    getParentIndex(index: number): number;
    getLevel(index: number): number;

    /**
     * Return a reference to the tree row at a given row
     *
     * @return {TreeRow}
     */
    getRow(index: number): TreeRow;

    /**
     * Return the index of the row with a given ID (e.g., "C123" for collection 123)
     *
     * @param {String} - Row id
     * @return {Integer|false}
     */
    getRowIndexByID(id: string): number | false;

    /**
     * Add a tree row to the main array, update the row count, tell the treebox that the row
     * count changed, and update the row map
     *
     * @param {TreeRow} treeRow
     * @param {Number} [beforeRow] - Row index to insert new row before
     */
    _addRow(
      treeRow: TreeRow,
      beforeRow: number,
      skipRowMapRefresh?: boolean,
    ): void;

    /**
     * Remove a row from the main array and parent row children arrays,
     * delete the row from the map, and optionally update all rows above it in the map
     */
    _removeRow(index: number, skipMapUpdate?: boolean): void;

    _removeRows(rows: number[]): void;
    _refreshRowMap(): void;
    _onSelectionChange(): void;
    _onSelectionChangeDebounced(): void;
    ensureRowIsVisible(index: number): void;
    _updateHeight(): void;
    updateHeight(): void;
    updateFontSize(): void;

    /**
     * On Windows (in Fx26), Firefox uses 'move' for unmodified drags
     * and 'copy'/'link' for drags with system-default modifier keys
     * as long as the actions are allowed by the initial effectAllowed set
     * in onDragStart, regardless of the effectAllowed or dropEffect set
     * in onDragOver. It doesn't seem to be possible to use 'copy' for
     * the default and 'move' for modified, as we need to in the collections
     * tree. To prevent inaccurate cursor feedback, we set effectAllowed to
     * 'copy' in onDragStart, which locks the cursor at 'copy'. ('none' still
     * changes the cursor, but 'move'/'link' do not.) It'd be better to use
     * the unadorned 'move', but we use 'copy' instead because with 'move' text
     * can't be dragged to some external programs (e.g., Chrome, Notepad++),
     * which seems worse than always showing 'copy' feedback.
     * However, since effectAllowed is enforced, leaving it at 'copy'
     * would prevent our modified 'move' in the collections tree from working,
     * so we also have to set effectAllowed here (called from onDragOver) to
     * the same action as the dropEffect. This allows the dropEffect setting
     * (which we use in the tree's canDrop() and drop() to determine the desired
     * action) to be changed, even if the cursor doesn't reflect the new setting.
     */
    setDropEffect(event: unknown, effect: unknown): void;

    selectLibrary(libraryID?: number): Promise<boolean>;
  }
}


declare const ZoteroContextPane: _ZoteroTypes.ZoteroContextPane;



declare const Zotero_Tabs: _ZoteroTypes.Zotero_Tabs;


declare const ZoteroPane: _ZoteroTypes.ZoteroPane;
declare const ZoteroPane_Local: _ZoteroTypes.ZoteroPane;


// Type definitions for Zotero platform (Mozilla Firefox 60/102)

declare const NetUtil: any;

// https://github.com/retorquere/zotero-better-bibtex/blob/master/typings/global.d.ts
declare interface DirectoryIterator {
  forEach(handler: any): Promise<void>;
  close(): void;
  next(): any;
}
declare interface DirectoryIteratorConstructable {
  new (path: string): DirectoryIterator;
}

declare namespace OS {
  namespace File {
    type Entry = {
      isDir: boolean;
      size: number;
      path: string;
      unixMode?: number;
      name: string;
    };
    type FileInfo = {
      isDir: boolean;
      size: number;
      unixMode?: number;
      lastModificationDate: Date;
    };
  }
}
declare const OS: {
  /**
   * @deprecated This namespace is deprecated and is removed in Firefox 115.
   * Please use the `Zotero.File` or `IOUtils` instead.
   * @see {@link https://groups.google.com/g/zotero-dev/c/t0oP9NECX54}
   * @see {@link https://firefox-source-docs.mozilla.org/dom/ioutils_migration.html | Migration Guide}
   * @see {@link https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/OSFile.jsm/OS.File_for_the_main_thread}
   */
  File: {
    exists(path: string): boolean | Promise<boolean>;
    read: (
      path: string | BufferSource,
      options?: { encoding?: string },
    ) =>
      | string
      | Promise<string>
      | Uint8Array
      | Promise<Uint8Array>
      | Promise<BufferSource>;
    move(from: string, to: string): void | Promise<void>;
    remove: (
      path: string,
      options?: { ignoreAbsent: boolean },
    ) => Promise<void>;
    writeAtomic: (
      path: string,
      data: Uint8Array | string,
      options?: { tmpPath?: string; encoding?: string },
    ) => void | Promise<void>;
    makeDir: (
      path: string,
      options?: { ignoreExisting?: boolean },
    ) => void | Promise<void>;
    stat(path: string): OS.File.FileInfo | Promise<OS.File.FileInfo>;
    copy: (
      src: string,
      tgt: string,
      options?: { noOverwrite?: boolean },
    ) => void;
    removeDir: (
      path: string,
      options?: { ignoreAbsent?: boolean; ignorePermissions?: boolean },
    ) => void;

    DirectoryIterator: DirectoryIteratorConstructable;
  };

  /**
   * @deprecated This namespace is deprecated and is removed in Firefox 115.
   * Please use the `Zotero.File` or `PathUtils` instead.
   * @see {@link https://groups.google.com/g/zotero-dev/c/t0oP9NECX54}
   * @see {@link https://firefox-source-docs.mozilla.org/dom/ioutils_migration.html | Migration Guide}
   * @see {@link https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/OSFile.jsm/OS.Path}
   */
  Path: {
    join(...args: string[]): string;
    dirname(path: string): string;
    basename(path: string): string;
    normalize(path: string): string;
    split: (path: string) => {
      absolute: boolean;
      components: string[];
      winDrive?: string;
    };
    toFileURI(path: string): string;
  };

  /**
   * @deprecated This namespace is deprecated.
   * Please use `FileUtils` instead.
   */
  Constants: {
    Path: {
      /**
       * @deprecated This property is deprecated.
       * use `FileUtils.getDir("Home", []).path` instead.
       */
      readonly homeDir: string;
      /**
       * @deprecated This property is deprecated.
       * use `FileUtils.getDir("GreBinD", []).path` instead.
       */
      readonly libDir: string;
      /**
       * @deprecated This property is deprecated.
       * use `FileUtils.getDir("ProfD", []).path` instead.
       */
      readonly profileDir: string;
      /**
       * @deprecated This property is deprecated.
       * use `FileUtils.getDir("TmpD", []).path` instead.
       */
      readonly tmpDir: string;
    };
  };
};

declare namespace _ZoteroTypes {
  namespace FileUtils {
    function getDir(
      key: string,
      pathArray: string[],
      shouldCreate?: boolean,
    ): nsIFile;
    function getFile(key: string, pathArray: string[]): nsIFile;
  }
}

declare namespace Zotero {
  /**
   * @deprecated Use standard Promise instead.
   */
  const Promise: _ZoteroTypes.Promise.Promise &
    _ZoteroTypes.Promise.PromiseConstructor<() => void>;
}

declare namespace _ZoteroTypes {
  /**
   * @deprecated Use standard Promise instead.
   */
  namespace Promise {
    type Bluebird<T> = import("bluebird")<T>;

    /**
     * @deprecated
     */
    type PromiseObject = DeferredPromise<unknown>;

    interface DeferredPromise<T> {
      promise: Bluebird<T>;
      resolve(value?: T): void;
      reject(reason?: T): void;
    }

    interface Promise<T = void> extends _ZoteroTypes.Promise.Bluebird<T> {
      method(fn: Function): () => _ZoteroTypes.Promise.Bluebird<T>;
      defer(): _ZoteroTypes.Promise.DeferredPromise<T>;
    }

    interface PromiseConstructor<T extends (...args: any) => any> {
      new (fn: T): _ZoteroTypes.Promise.Promise<ReturnType<T>>;
    }
  }
}


declare namespace _ZoteroTypes {
  namespace Reader {
    class AnnotationManager {
      _authorName: string;
      _readOnly: boolean;
      _annotations: Annotation[];
      _onChangeFilter: Function;
      _onSave: Function;
      _onDelete: Function;
      _unsavedAnnotations: Annotation[];
      _filter: Filter;

      constructor(options: {
        readOnly: boolean;
        authorName: string;
        onSave: Function;
        onDelete: Function;
        onChangeFilter: (filter: Filter) => void;
        onRender: (annotations: Annotation[]) => void;
        annotations: Annotation[];
      });

      render(): void;
      setReadOnly(readOnly: boolean): void;
      _debounceSave(): void;

      /**
       * Called when changes come from the client side
       */
      setAnnotations(annotations: Annotation[]): Promise<void>;

      /**
       * Called when deletions come from the client side
       */
      unsetAnnotations(ids: string[]): void;

      addAnnotation(
        annotation: Partial<Annotation> & { color: string; sortIndex: string },
      ): Required<Annotation> | null;
      updateAnnotations(annotations: Annotation[]): void;
      deleteAnnotations(ids: string[]): void;
      _generateObjectKey(): string;
      _save(annotation: Annotation, instant?: boolean): void;
      _getAnnotationByID(id: string): Annotation | undefined;
      setFilter(filter: Filter): Promise<void>;
    }
  }
}


declare namespace _ZoteroTypes {
  namespace Reader {
    function debounce<F extends CallableFunction>(
      func: F,
      wait?: number,
      options?: {
        leading?: boolean;
        maxWait?: number;
        trailing?: boolean;
      },
    ): F & DebounceResult;

    interface DebounceResult {
      cancel(): void;

      flush(): void;

      pending(): boolean;
    }
  }
}


declare namespace _ZoteroTypes {
  namespace Reader {
    interface Filter {
      query: string;
      colors: string[];
      tags: string[];
      authors: string[];
    }
    interface InternalReaderTools {
      pointer: {
        type: "pointer";
      };
      hand: {
        type: "hand";
      };
      highlight: {
        type: "highlight";
        color: string;
      };
      underline: {
        type: "underline";
        color: string;
      };
      note: {
        type: "note";
        color: string;
      };
      image: {
        type: "image";
        color: string;
      };
      text: {
        type: "text";
        color: string;
      };
      ink: {
        type: "ink";
        color: string;
        size: number;
      };
      eraser: {
        type: "eraser";
        size: number;
      };
    }
    interface ViewTypeMap {
      pdf: PDFView;
      epub: EPUBView;
      snapshot: SnapshotView;
    }

    interface InternalReader<T extends keyof ViewTypeMap> {
      _type: T;
      _platform: "zotero";
      _readerRef: React.RefObject<anyObj>;
      _primaryView: ViewTypeMap[T];
      _secondaryView?: ViewTypeMap[T];
      _lastViewPrimary: boolean;
      _splitViewContainer: HTMLDivElement;
      _primaryViewContainer: HTMLDivElement;
      _secondaryViewContainer: HTMLDivElement;
      _portalViewContainer: HTMLDivElement;
      _lastPortalRect: [number, number, number, number];
      _enableAnnotationDeletionFromComment: boolean;
      _annotationSelectionTriggeredFromView: boolean;
      _tools: InternalReaderTools;
      _state: {
        splitType?: "horizontal" | "vertical";
        splitSize?: string;
        primary: boolean;
        freeze: boolean;
        errorMessages: string;
        annotations: Reader.Annotation[];
        selectedAnnotationIDs: string[];
        filter: Filter;
        readOnly: boolean;
        authorName: string;
        fontSize: number;
        fontFamily: string;
        showAnnotations: boolean;
        tool: InternalReaderTools[keyof InternalReaderTools];
        thumbnails: [];
        outline: Array<OutlineItem>;
        pageLabels: anyObj;
        sidebarOpen: boolean;
        sidebarWidth: number;
        sidebarView: "annotations" | "outline" | "thumbnails";
        bottomPlaceholderHeight: number;
        toolbarPlaceholderWidth: number;
        enableAddToNote: boolean;
        primaryViewState: State | DOMViewState;
        primaryViewStats: ViewStats;
        primaryViewFindState: FindState;
        secondaryViewState: State | DOMViewState;
        secondaryViewStats: ViewStats;
        secondaryViewFindState: FindState;
      };
      _focusManager: anyObj;
      _keyboardManager: anyObj;
      _annotationManager: AnnotationManager;

      readonly _lastView: ViewTypeMap[T];
      readonly splitType: "horizontal" | "vertical" | null;
      readonly toolType: keyof InternalReaderTools;
      readonly zoomAutoEnabled: boolean;
      readonly zoomPageHeightEnabled: boolean;
      readonly zoomPageWidthEnabled: boolean;
      readonly canCopy: boolean;
      readonly canNavigateBack: boolean;
      readonly canNavigateForward: boolean;
      readonly canNavigateToFirstPage: boolean;
      readonly canNavigateToLastPage: boolean;
      readonly canNavigateToNextPage: boolean;
      readonly canNavigateToPreviousPage: boolean;
      readonly canZoomIn: boolean;
      readonly canZoomOut: boolean;
      readonly canZoomReset: boolean;
      readonly canNavigateToPreviousSection: boolean;
      readonly canNavigateToNextSection: boolean;
      flowMode: FlowMode;
      scrollMode?: 0 | 1 | 2;
      spreadMode: SpreadMode;

      disableSplitView(): void;
      toggleHorizontalSplit(enable: boolean): void;
      toggleVerticalSplit(enable: boolean): void;
      showAnnotations(enable: boolean): void;
      setReadOnly(enable: boolean): void;
      toggleHandTool(enable: boolean): void;
      enableAddToNote(enable: boolean): void;
      closeContextMenu(): void;
      findNext(primary: boolean): void;
      findPrevious(primary: boolean): void;
      toggleFindPopup({
        primary,
        open,
      }?: {
        primary: boolean;
        open: boolean;
      }): void;
      _getString(name: string): string;
      setErrorMessage(errorMessage: string): void;
      copy(): void;
      zoomIn(): void;
      zoomOut(): void;
      zoomReset(): void;
      zoomAuto(): void;
      zoomPageWidth(): void;
      zoomPageHeight(): void;
      navigate(location: Location): Promise<void>;
      navigateBack(): void;
      navigateForward(): void;
      navigateToFirstPage(): void;
      navigateToLastPage(): void;
      navigateToNextPage(): void;
      navigateToPreviousPage(): void;
      navigateToNextSection(): void;
      navigateToPreviousSection(): void;
      setFontSize(fontSize: number): void;
      setFontFamily(fontFamily: string): void;
      toggleSidebar(open: boolean): void;
      setSidebarWidth(width: number): void;
      setSidebarView(view: string): void;
      setSplitViewSize(size: string): void;
      setBottomPlaceholderHeight(height: number): void;
      setToolbarPlaceholderWidth(width: number): void;
      focusView(primary?: boolean): void;
      focus(): void;
      freeze(): void;
      unfreeze(): void;
      print(): void;
      abortPrint(): void;
      rotatePageLeft(): void;
      rotatePageRight(): void;
      rotatePages(pageIndexes: number[], degrees: number): void;
      deletePages(pageIndexes: number[], degrees: number): void;
    }
  }
}

declare namespace _ZoteroTypes {
  namespace Reader {
    // We generate and support a very limited subset of the Web Annotation Data Model:
    // https://www.w3.org/TR/annotation-model/#selectors
    // Specifically, EPUB annotations are expressed in terms of FragmentSelectors with epubcfi values,
    // and snapshot annotations are CssSelectors refined by TextQuoteSelectors, or simply TextQuoteSelectors
    // if no good CSS selector base can be found.

    // https://www.w3.org/TR/annotation-model/#fragment-selector
    type FragmentSelector = {
      type: "FragmentSelector";
      conformsTo: FragmentSelectorConformsTo;
      value: string;
      refinedBy?: Selector;
    };

    enum FragmentSelectorConformsTo {
      // Skipping: HTML, PDF, Plain Text, XML, RDF/XML, CSV, Media, SVG
      EPUB3 = "http://www.idpf.org/epub/linking/cfi/epub-cfi.html",
    }

    // https://www.w3.org/TR/annotation-model/#css-selector
    type CssSelector = {
      type: "CssSelector";
      value: string;
      refinedBy?: Selector;
    };

    // Skipping: XPath Selector

    // https://www.w3.org/TR/annotation-model/#text-quote-selector
    type TextQuoteSelector = {
      type: "TextQuoteSelector";
      exact: string;
      prefix?: string;
      suffix?: string;
      refinedBy?: Selector;
    };

    // https://www.w3.org/TR/annotation-model/#text-position-selector
    type TextPositionSelector = {
      type: "TextPositionSelector";
      start: number;
      end: number;
      refinedBy?: Selector;
    };

    // Skipping: Data Position Selector, SVG Selector, Range Selector

    type Selector =
      | FragmentSelector
      | CssSelector
      | TextQuoteSelector
      | TextPositionSelector;

    type ToolType =
      | "highlight"
      | "underline"
      | "note"
      | "image"
      | "text"
      | "ink"
      | "eraser"
      | "pointer";

    type Tool = {
      type: ToolType;
      color?: string;
    };

    type AnnotationType =
      | "highlight"
      | "underline"
      | "note"
      | "image"
      | "text"
      | "ink"
      | "eraser";

    interface Annotation {
      id: string;
      type: AnnotationType;
      color?: string;
      sortIndex: string;
      pageLabel?: string;
      position: Position;
      text?: string;
      comment?: string;
      tags: string[];
      dateCreated: string;
      dateModified: string;
      readOnly?: boolean;
      authorName?: string;
      isAuthorNameAuthoritative?: boolean;
      image?: string;
    }

    interface PDFAnnotation extends Annotation {
      position: PDFPosition;
    }

    interface WADMAnnotation extends Annotation {
      position: Selector;
    }

    type NavLocation = {
      pageNumber?: string;
      annotationID?: string;
      position?: Position;
      href?: string;
    };

    type Position = PDFPosition | Selector;

    type PDFPosition = {
      pageIndex: number;
      rects?: number[][];
      paths?: number[][];
    };

    type NewAnnotationOptionalFields =
      | "id"
      | "tags"
      | "dateCreated"
      | "dateModified"
      | "authorName"
      | "isAuthorNameAuthoritative";

    type NewAnnotation<A extends Annotation = Annotation> = Omit<
      A,
      NewAnnotationOptionalFields
    > &
      Partial<Pick<A, NewAnnotationOptionalFields>>;

    type OutlineItem = {
      title: string;
      // The whole location will be passed to navigate() once user clicks the item
      location: NavLocation;
      items?: OutlineItem[];
      expanded?: boolean;
    };

    type ViewStats = {
      pageIndex?: number;
      pageLabel?: string;
      pagesCount?: number;
      usePhysicalPageNumbers?: boolean;
      canCopy: boolean;
      canZoomOut: boolean;
      canZoomIn: boolean;
      canZoomReset: boolean;
      canNavigateBack?: boolean;
      canNavigateForward?: boolean;
      canNavigateToFirstPage?: boolean;
      canNavigateToLastPage?: boolean;
      canNavigateToPreviousPage?: boolean;
      canNavigateToNextPage?: boolean;
      canNavigateToPreviousSection?: boolean;
      canNavigateToNextSection?: boolean;
      zoomAutoEnabled?: boolean;
      zoomPageWidthEnabled?: boolean;
      zoomPageHeightEnabled?: boolean;
      scrollMode?: number;
      spreadMode?: number;
      flowMode?: string;
      fontFamily?: string;
    };

    type AnnotationPopupParams<A extends Annotation = Annotation> = {
      rect: ArrayRect;
      annotation?: A | null;
    };

    type SelectionPopupParams<A extends Annotation = Annotation> = {
      rect: ArrayRect;
      annotation?: NewAnnotation<A> | null;
    };

    type OverlayPopupParams = {
      type: string;
      url: string;
      rect: ArrayRect;
      ref: Node;
    };

    type ArrayRect = [left: number, top: number, right: number, bottom: number];

    type FindState = {
      popupOpen: boolean;
      active: boolean;
      query: string;
      highlightAll: boolean;
      caseSensitive: boolean;
      entireWord: boolean;
      // For mobile app to focus specific result
      index: number | null;
      result: {
        total: number;
        index: number;
        // Mobile app lists all results in a popup
        snippets: string[];
      } | null;
    };

    type MaybePromise<T> = Promise<T> | T;
  }
}


declare namespace _ZoteroTypes {
  namespace Reader {
    type DisplayedAnnotation = {
      id?: string;
      sourceID?: string;
      type: AnnotationType;
      color?: string;
      sortIndex?: string;
      text?: string;
      comment?: string;
      readOnly?: boolean;
      key: string;
      range: Range;
    };
    type AnnotationOverlayProps = {
      iframe: HTMLIFrameElement;
      annotations: DisplayedAnnotation[];
      selectedAnnotationIDs: string[];
      onPointerDown: (id: string, event: React.PointerEvent) => void;
      onPointerUp: (id: string, event: React.PointerEvent) => void;
      onDragStart: (id: string, dataTransfer: DataTransfer) => void;
      onResizeStart: (id: string) => void;
      onResizeEnd: (id: string, range: Range, cancelled: boolean) => void;
      disablePointerEvents: boolean;
    };
    type HighlightOrUnderlineProps = {
      annotation: DisplayedAnnotation;
      selected: boolean;
      singleSelection: boolean;
      onPointerDown?: (
        annotation: DisplayedAnnotation,
        event: React.PointerEvent,
      ) => void;
      onPointerUp?: (
        annotation: DisplayedAnnotation,
        event: React.PointerEvent,
      ) => void;
      onDragStart?: (
        annotation: DisplayedAnnotation,
        dataTransfer: DataTransfer,
      ) => void;
      onResizeStart?: (annotation: DisplayedAnnotation) => void;
      onResizeEnd?: (
        annotation: DisplayedAnnotation,
        range: Range,
        cancelled: boolean,
      ) => void;
      pointerEventsSuppressed: boolean;
      widgetContainer: Element | null;
    };
    type NoteProps = {
      annotation: DisplayedAnnotation;
      staggerIndex?: number;
      selected: boolean;
      onPointerDown?: (
        annotation: DisplayedAnnotation,
        event: React.PointerEvent,
      ) => void;
      onPointerUp?: (
        annotation: DisplayedAnnotation,
        event: React.PointerEvent,
      ) => void;
      onDragStart?: (
        annotation: DisplayedAnnotation,
        dataTransfer: DataTransfer,
      ) => void;
      disablePointerEvents: boolean;
    };
    type NotePreviewProps = {
      annotation: DisplayedAnnotation;
    };
    type StaggeredNotesProps = {
      annotations: DisplayedAnnotation[];
      selectedAnnotationIDs: string[];
      onPointerDown: (
        annotation: DisplayedAnnotation,
        event: React.PointerEvent,
      ) => void;
      onPointerUp: (
        annotation: DisplayedAnnotation,
        event: React.PointerEvent,
      ) => void;
      onDragStart: (
        annotation: DisplayedAnnotation,
        dataTransfer: DataTransfer,
      ) => void;
      pointerEventsSuppressed: boolean;
    };
    type SelectionBorderProps = {
      rect: DOMRect;
      preview?: boolean;
    };
    type RangeSelectionBorderProps = {
      range: Range;
    };
    type ResizerProps = {
      annotation: DisplayedAnnotation;
      highlightRects: DOMRect[];
      onResizeStart: (annotation: DisplayedAnnotation) => void;
      onResizeEnd: (
        annotation: DisplayedAnnotation,
        cancelled: boolean,
      ) => void;
      onResize: (annotation: DisplayedAnnotation, range: Range) => void;
    };
    type CommentIconProps = {
      annotation?: { id?: string };
      x: number;
      y: number;
      color: string;
      opacity?: string | number;
      selected?: boolean;
      large?: boolean;
      onPointerDown?: (event: React.PointerEvent) => void;
      onPointerUp?: (event: React.PointerEvent) => void;
      onDragStart?: (event: React.DragEvent) => void;
      onDragEnd?: (event: React.DragEvent) => void;
    };
  }
}


declare namespace _ZoteroTypes {
  namespace Reader {
    type DOMViewOptions<State extends DOMViewState, Data> = {
      portal?: boolean;
      container: Element;
      tool: Tool;
      selectedAnnotationIDs: string[];
      annotations: WADMAnnotation[];
      showAnnotations: boolean;
      annotationPopup: AnnotationPopupParams<WADMAnnotation> | null;
      selectionPopup: SelectionPopupParams<WADMAnnotation> | null;
      overlayPopup: OverlayPopupParams | null;
      findState: FindState;
      viewState?: State;
      fontFamily?: string;
      onSetOutline: (outline: OutlineItem[]) => void;
      onChangeViewState: (state: State, primary?: boolean) => void;
      onChangeViewStats: (stats: ViewStats) => void;
      onSetDataTransferAnnotations: (
        dataTransfer: DataTransfer,
        annotation:
          | NewAnnotation<WADMAnnotation>
          | NewAnnotation<WADMAnnotation>[],
        fromText?: boolean,
      ) => void;
      onAddAnnotation: (
        annotation: NewAnnotation<WADMAnnotation>,
        select?: boolean,
      ) => void;
      onUpdateAnnotations: (annotations: Annotation[]) => void;
      onOpenLink: (url: string) => void;
      onSelectAnnotations: (
        ids: string[],
        triggeringEvent?: KeyboardEvent | MouseEvent,
      ) => void;
      onSetSelectionPopup: (
        params?: SelectionPopupParams<WADMAnnotation> | null,
      ) => void;
      onSetAnnotationPopup: (
        params?: AnnotationPopupParams<WADMAnnotation> | null,
      ) => void;
      onSetOverlayPopup: (params?: OverlayPopupParams) => void;
      onSetFindState: (state?: FindState) => void;
      onOpenViewContextMenu: (params: { x: number; y: number }) => void;
      onOpenAnnotationContextMenu: (params: {
        ids: string[];
        x: number;
        y: number;
        view: boolean;
      }) => void;
      onFocus: () => void;
      onTabOut: (isShiftTab?: boolean) => void;
      onKeyUp: (event: KeyboardEvent) => void;
      onKeyDown: (event: KeyboardEvent) => void;
      data: Data & {
        buf?: Uint8Array;
        baseURI?: string;
      };
    };

    interface DOMViewState {
      scale?: number;
    }

    interface CustomScrollIntoViewOptions
      extends Omit<ScrollIntoViewOptions, "inline"> {
      block?: "center" | "start";
      ifNeeded?: boolean;
      offsetY?: number;
    }

    interface NavigateOptions extends CustomScrollIntoViewOptions {
      skipNavStack?: boolean;
    }

    abstract class DOMView<State extends DOMViewState, Data> {
      initializedPromise: Promise<void>;
      protected readonly _container: Element;
      protected readonly _iframe: HTMLIFrameElement;
      protected _iframeWindow: Window & typeof globalThis;
      protected _iframeDocument: Document;
      protected _tool: Tool;
      protected _selectedAnnotationIDs: string[];
      protected _annotations: WADMAnnotation[];
      protected _annotationsByID: Map<string, WADMAnnotation>;
      protected _showAnnotations: boolean;
      protected _annotationPopup: AnnotationPopupParams<WADMAnnotation> | null;
      protected _selectionPopup: SelectionPopupParams<WADMAnnotation> | null;
      protected _overlayPopup: OverlayPopupParams | null;
      protected _findState: FindState | null;
      protected abstract _find: FindProcessor | null;
      protected readonly _options: DOMViewOptions<State, Data>;
      protected _overlayPopupDelayer: anyObj;
      protected _disableAnnotationPointerEvents: boolean;
      protected _highlightedPosition: Selector | null;
      protected _pointerMovedWhileDown: boolean;
      protected _gotPointerUp: boolean;
      protected _handledPointerIDs: Set<number>;
      protected _previewAnnotation: NewAnnotation<WADMAnnotation> | null;
      protected _draggingNoteAnnotation: WADMAnnotation | null;
      protected _resizing: boolean;
      protected constructor(options: DOMViewOptions<State, Data>);

      protected _initialize(): Promise<void>;
      protected _getCSP(): string;
      protected abstract _getSrcDoc(): string;
      abstract getData(): Data;
      protected abstract _onInitialDisplay(
        viewState: Partial<Readonly<State>>,
      ): MaybePromise<void>;

      // ***
      // Utilities for annotations - abstractions over the specific types of selectors used by the two views
      // ***
      abstract toSelector(range: Range): Selector | null;
      abstract toDisplayedRange(selector: Selector): Range | null;
      protected abstract _navigateToSelector(
        selector: Selector,
        options?: NavigateOptions,
      ): void;

      // ***
      // Abstractions over document structure
      // ***
      protected abstract _getAnnotationFromRange(
        range: Range,
        type: AnnotationType,
        color?: string,
      ): NewAnnotation<WADMAnnotation> | null;
      protected abstract _updateViewState(): void;
      protected abstract _updateViewStats(): void;

      // ***
      // Utilities - called in appropriate event handlers
      // ***
      protected _isExternalLink(link: HTMLAnchorElement): boolean;
      protected _getViewportBoundingRect(range: Range): DOMRect;
      protected _getAnnotationFromTextSelection(
        type: AnnotationType,
        color?: string,
      ): NewAnnotation<WADMAnnotation> | null;
      protected _tryUseTool(): void;
      protected _tryUseToolDebounced: typeof this._tryUseTool;
      protected _handleViewUpdate(): void;
      protected _repositionPopups(): void;
      protected _renderAnnotations(): void;
      protected _openSelectionPopup(selection: Selection): void;
      protected _openAnnotationPopup(annotation: WADMAnnotation): void;
      protected _openExternalLinkOverlayPopup(
        linkNode: HTMLAnchorElement,
      ): void;

      /**
       * For use in the console during development.
       */
      protected _normalizeAnnotations(): void;

      // ***
      // Event handlers
      // ***
      protected _handleIFrameLoad(): Promise<void>;
      protected _handlePointerOver(event: PointerEvent): void;
      protected _handleDragEnter(event: DragEvent): void;
      protected _handleDragOver(event: DragEvent): void;
      protected _handleDrop(): void;
      protected _getNoteTargetRange(
        event: PointerEvent | DragEvent,
      ): Range | null;
      protected _handleClick(event: MouseEvent): void;
      protected abstract _handleInternalLinkClick(
        link: HTMLAnchorElement,
      ): void;
      protected _handleKeyDown(event: KeyboardEvent): void;
      private _handleDragStart(event: DragEvent): void;
      private _handleDragEnd(_event: DragEvent): void;
      private _handleContextMenu(event: MouseEvent): void;
      private _handleSelectionChange(): void;
      private _handleAnnotationPointerDown(
        id: string,
        event: React.PointerEvent,
      ): void;
      private _handleAnnotationPointerUp(
        id: string,
        event: React.PointerEvent,
      ): void;
      private _getAnnotationsAtPoint(
        clientX: number,
        clientY: number,
      ): string[];
      private _handleAnnotationDragStart(
        id: string,
        dataTransfer: DataTransfer,
      ): void;
      private _handleAnnotationResizeStart(_id: string): void;
      private _handleAnnotationResizeEnd(
        id: string,
        range: Range,
        cancelled: boolean,
      ): void;
      protected _handleCopy(event: ClipboardEvent): void;
      protected _handlePointerDown(event: PointerEvent): void;
      protected _handlePointerMove(event: PointerEvent): void;
      protected _handlePointerUp(event: PointerEvent): void;
      protected _handleResize(): void;
      protected _handleScroll(): void;
      private _handleFocus(): void;

      // ***
      // Setters that get called once there are changes in reader._state
      // ***
      setTool(tool: Tool): void;
      setAnnotations(annotations: WADMAnnotation[]): void;
      setShowAnnotations(show: boolean): void;
      setSelectedAnnotationIDs(ids: string[]): void;
      setAnnotationPopup(popup: AnnotationPopupParams<WADMAnnotation>): void;
      setSelectionPopup(popup: SelectionPopupParams<WADMAnnotation>): void;
      setOverlayPopup(popup: OverlayPopupParams): void;

      // ***
      // Public methods to control the view from the outside
      // ***
      focus(): void;
      navigate(location: NavLocation, options?: NavigateOptions): void;
    }
  }
}


declare namespace _ZoteroTypes {
  namespace Reader {
    type FindResult = {
      range: Range;
      highlight: DisplayedAnnotation;
    };
    interface FindProcessor {
      getAnnotations(): DisplayedAnnotation[];
      prev(): FindResult | null;
      next(): FindResult | null;
    }

    class DefaultFindProcessor implements FindProcessor {
      readonly findState: FindState;
      private readonly _buf: FindResult[];
      private _pos: number | null;
      private _initialPos: number | null;
      private readonly _onSetFindState?: (state?: FindState) => void;
      private readonly _annotationKeyPrefix?: string;

      constructor(options: {
        searchContext: SearchContext;
        startRange?: Range;
        findState: FindState;
        onSetFindState?: (state?: FindState) => void;
        annotationKeyPrefix?: string;
      });
      prev(loop?: boolean): FindResult | null;
      next(loop?: boolean): FindResult | null;

      position: number | null;
      readonly initialPosition: number | null;
      readonly current: FindResult | null;
      getResults(): FindResult[];
      getAnnotations(): DisplayedAnnotation[];
      getSnippets(): string[];
    }
  }
}

declare namespace _ZoteroTypes {
  namespace Reader {
    type SearchContext = {
      text: string;
      charDataRanges: CharDataRange[];
    };

    type CharDataRange = {
      charData: CharacterData;
      start: number;
      end: number;
    };
  }
}

declare namespace _ZoteroTypes {
  namespace Reader {
    class NavStack<T> {
      private _backStack: T[];
      private _forwardStack: T[];
      canPopBack(): boolean;
      canPopForward(): boolean;
      push(value: T): void;
      popBack(): T;
      popForward(): T;
    }
  }
}


declare namespace _ZoteroTypes {
  namespace Reader {
    type FlowMode = "paginated" | "scrolled";
    interface EPUBViewState extends DOMViewState {
      cfi?: string;
      cfiElementOffset?: number;
      savedPageMapping?: string;
      flowMode?: FlowMode;
    }
    interface EPUBViewData {
      book?: ePubJS.Book;
    }
    enum SpreadMode {
      Unknown = -1,
      None = 0,
      Odd = 1,
      Even = 2,
    }

    /**
     * Wraps the properties of a Range object in a static structure so that they don't change when the DOM changes.
     * (Range objects automatically normalize their start/end points when the DOM changes, which is not what we want -
     * even if the start or end is removed from the DOM temporarily, we want to keep our ranges unchanged.)
     */
    class PersistentRange {
      startContainer: Node;
      startOffset: number;
      endContainer: Node;
      endOffset: number;

      constructor(range: Omit<AbstractRange, "collapsed">);

      compareBoundaryPoints(
        how: number,
        other: Range | PersistentRange,
      ): number;

      getClientRects(): DOMRectList;

      getBoundingClientRect(): DOMRect;

      toRange(): Range;

      toString(): string;
    }

    /**
     * - All views use iframe to render and isolate the view from the parent window
     * - If need to add additional build steps, a submodule or additional files see pdfjs/
     *   directory in the project root and "scripts" part in packages.json
     * - If view needs styling, it should provide and load its own CSS file like pdfjs/viewer.css,
     *   because SCSS in src/common/stylesheets is only for the main window
     * - Update demo data in demo/epub and demo/snapshot directories:
     *   - Add demo annotations
     */
    class EPUBView extends DOMView<EPUBViewState, EPUBViewData> {
      protected _find: EPUBFindProcessor | null;
      readonly book: ePubJS.Book;
      flow: Flow;
      spreadMode: SpreadMode.None | SpreadMode.Odd;
      readonly pageMapping: PageMapping;
      scale: number;
      private _sectionsContainer: HTMLElement;
      private readonly _sectionViews: SectionView[];
      private readonly _navStack: NavStack<string>;
      private readonly _pageMapping: PageMapping;
      private readonly _rangeCache: Map<string, Range>;
      private _pageProgressionRTL: boolean;
      private _scale: number;
      private _flowMode: FlowMode;
      private _savedPageMapping: string;
      constructor(options: DOMViewOptions<EPUBViewState, EPUBViewData>);
      protected _getSrcDoc(): "<!DOCTYPE html><html><body></body></html>";
      getData(): { book: ePubJS.Book };
      protected _onInitialDisplay(
        viewState: Partial<Readonly<EPUBViewState>>,
      ): Promise<void>;
      private _initPageMapping(
        viewState: Partial<Readonly<EPUBViewState>>,
      ): Promise<void>;
      private _initOutline(): void;
      getCFI(rangeOrNode: Range | Node): ePubJS.EpubCFI | null;
      getRange(cfi: ePubJS.EpubCFI | string): PersistentRange | null;
      override toSelector(range: Range): FragmentSelector | null;
      override toDisplayedRange(selector: Selector): Range | null;
      readonly views: SectionView[];
      private _pushCurrentLocationToNavStack(): void;
      protected _navigateToSelector(
        selector: Selector,
        options?: NavigateOptions,
      ): void;
      protected _getAnnotationFromRange(
        range: Range,
        type: AnnotationType,
        color?: string,
      ): NewAnnotation<WADMAnnotation> | null;

      // ***
      // Event handlers
      // ***
      protected override _handleResize(): void;
      protected override _handleScroll(): void;
      protected _handleInternalLinkClick(link: HTMLAnchorElement): void;
      protected override _handleKeyDown(event: KeyboardEvent): void;
      protected override _updateViewState(): void;
      protected override _updateViewStats(): void; // View stats provide information about the view
      protected override _handleViewUpdate(): void;

      // ***
      // Setters that get called once there are changes in reader._state
      // ***
      /**
       * Unlike annotation, selection and overlay popups, find popup open state is determined
       * with .open property. All popup properties are preserved even when it's closed
       */
      setFindState(state: FindState): void;
      setFlowMode(flowMode: FlowMode): void;
      setFontFamily(fontFamily: string): void;

      // ***
      // Public methods to control the view from the outside
      // ***
      findNext(): Promise<void>;
      findPrevious(): Promise<void>;
      zoomIn(): void;
      zoomOut(): void;
      zoomReset(): void;
      private _setScale(scale: number): void;
      override navigate(location: NavLocation, options?: NavigateOptions): void;

      /**
       * This is like back/forward navigation in browsers. Try Cmd-ArrowLeft and Cmd-ArrowRight in PDF view
       */
      navigateBack(): void;
      navigateForward(): void;
      navigateToFirstPage(): void;
      navigateToLastPage(): void;
      navigateToPreviousPage(): void;
      navigateToNextPage(): void;
      canNavigateToPreviousPage(): boolean;
      canNavigateToNextPage(): boolean;
      canNavigateToPreviousSection(): boolean;
      canNavigateToNextSection(): boolean;
      navigateToPreviousSection(): void;
      navigateToNextSection(): void;

      print(): void;
      setSidebarOpen(_sidebarOpen: boolean): void;
    }
  }
}

declare namespace ePubJS {
  type Book = import("epubjs").Book;
  type EpubCFI = import("epubjs").EpubCFI;
  type Section = import("epubjs/types/section").default;
}


declare namespace _ZoteroTypes {
  namespace Reader {
    class EPUBFindProcessor implements FindProcessor {
      readonly view: EPUBView;
      readonly findState: FindState;
      private _processors: DefaultFindProcessor[];
      private _selectedProcessor: DefaultFindProcessor | null;
      private _totalResults: number;
      private readonly _onSetFindState?: (state?: FindState) => void;
      constructor(options: {
        view: EPUBView;
        startRange: Range;
        findState: FindState;
        onSetFindState?: (state?: FindState) => void;
      });
      prev(): FindResult | null;
      next(): FindResult | null;
      getAnnotations(): DisplayedAnnotation[];
      handleViewUpdate(): void;
      private _processViews(
        views: SectionView[],
        startRange?: Range,
        maxResults?: number,
      ): void;
      private _getOrCreateProcessor(
        view: SectionView,
        startRange?: Range,
      ): DefaultFindProcessor;
      private _setFindState(): void;
    }
  }
}


declare namespace _ZoteroTypes {
  namespace Reader {
    interface Flow {
      readonly startView: SectionView | null;
      readonly startRange: Range | null;
      readonly startCFI: ePubJS.EpubCFI | null;
      readonly startCFIOffsetY: number | null;
      readonly startRangeIsBeforeFirstMapping: boolean;
      readonly endView: SectionView | null;
      readonly visibleViews: SectionView[];
      scrollIntoView(
        target: Range | HTMLElement,
        options?: CustomScrollIntoViewOptions,
      ): void;
      canNavigateToPreviousPage(): boolean;
      canNavigateToNextPage(): boolean;
      navigateToPreviousPage(): void;
      navigateToNextPage(): void;
      navigateToFirstPage(): void;
      navigateToLastPage(): void;
      invalidate: ReturnType<typeof debounce<() => void>>;
      setScale(scale: number): void;
      destroy(): void;
    }

    abstract class AbstractFlow implements Flow {
      protected _cachedStartView: SectionView | null;
      protected _cachedStartRange: Range | null;
      protected _cachedStartCFI: ePubJS.EpubCFI | null;
      protected _cachedStartCFIOffsetY: number | null;
      protected _cachedEndView: SectionView | null;
      protected _sectionViews: SectionView[];
      protected _pageMapping: PageMapping;
      protected _iframe: HTMLIFrameElement;
      protected _iframeWindow: Window & typeof globalThis;
      protected _iframeDocument: Document;
      protected _scale: number;
      protected _onUpdateViewState: () => void;
      protected _onUpdateViewStats: () => void;
      protected _onViewUpdate: () => void;

      constructor(options: {
        sectionViews: SectionView[];
        pageMapping: PageMapping;
        iframe: HTMLIFrameElement;
        scale: number;
        onUpdateViewState: () => void;
        onUpdateViewStats: () => void;
        onViewUpdate: () => void;
      });

      readonly startView: SectionView | null;
      readonly startRange: Range | null;
      readonly startCFI: ePubJS.EpubCFI | null;
      readonly startCFIOffsetY: number | null;
      readonly startRangeIsBeforeFirstMapping: boolean;
      readonly endView: SectionView | null;
      readonly visibleViews: SectionView[];

      abstract scrollIntoView(
        target: Range | HTMLElement,
        options?: CustomScrollIntoViewOptions,
      ): void;
      abstract canNavigateToNextPage(): boolean;
      abstract canNavigateToPreviousPage(): boolean;
      abstract navigateToNextPage(): void;
      abstract navigateToPreviousPage(): void;
      abstract navigateToFirstPage(): void;
      abstract navigateToLastPage(): void;
      abstract destroy(): void;
      invalidate: ReturnType<typeof debounce<() => void>>;
      setScale(scale: number): void;
      protected abstract update(): void;
    }

    class ScrolledFlow extends AbstractFlow {
      static readonly SCROLL_PADDING_UNSCALED = 35;
      scrollIntoView(
        target: Range | HTMLElement,
        options?: CustomScrollIntoViewOptions,
      ): void;
      readonly scrollPadding: number;
      canNavigateToPreviousPage(): boolean;
      canNavigateToNextPage(): boolean;
      navigateToPreviousPage(): void;
      navigateToNextPage(): void;
      navigateToFirstPage(): void;
      navigateToLastPage(): void;
      update(): void;
      destroy(): void;
    }

    class PaginatedFlow extends AbstractFlow {
      private _sectionsContainer: HTMLElement;
      private _touchStartID: number | null;
      private _touchStartX: number;
      scrollIntoView(target: Range | HTMLElement): void;
      canNavigateToPreviousPage(): boolean;
      canNavigateToNextPage(): boolean;
      navigateToPreviousPage(): void;
      navigateToNextPage(): void;
      navigateToFirstPage(): void;
      navigateToLastPage(): void;
      private _handleKeyDown(event: KeyboardEvent): void;
      private _handleTouchStart(event: TouchEvent): void;
      private _handleTouchMove(event: TouchEvent): void;
      private _handleTouchEnd(event: TouchEvent): void;
      update(): void;
      destroy(): void;
    }
  }
}


declare namespace _ZoteroTypes {
  namespace Reader {
    class PageMapping {
      static readonly VERSION = 5;
      private _isPhysical: boolean;
      readonly length: number;
      readonly isPhysical: boolean;

      generate(views: SectionView[]): void;
      private _addPhysicalPages(views: Iterable<SectionView>): void;
      private _addEPUBLocations(views: Iterable<SectionView>): void;
      getPageIndex(range: Range): number | null;
      getPageLabel(range: Range): string | null;
      getRange(pageLabel: string): Range | null;
      save(view: EPUBView): string;
      load(saved: string, view: EPUBView): boolean;
    }
  }
}

declare namespace _ZoteroTypes {
  namespace Reader {
    type SheetMetadata = {
      sheet?: CSSStyleSheet;
      scopeClass: string;
    };
    class StyleScoper {
      private _document: Document;
      private _sheets: Map<string, SheetMetadata>;
      private _textCache: Map<string, string>;
      constructor(document: Document);

      /**
       * @param css CSS stylesheet code
       * @return A class to add to the scope element
       */
      add(css: string): Promise<string>;

      /**
       * @param url The URL of a CSS stylesheet
       * @return A class to add to the scope element
       */
      addByURL(url: string): Promise<string>;
    }
  }
}


declare namespace _ZoteroTypes {
  namespace Reader {
    class SectionView {
      readonly section: ePubJS.Section;
      readonly container: HTMLElement;
      body: HTMLElement;
      private readonly _window: Window & typeof globalThis;
      private readonly _document: Document;
      private readonly _styleScoper: StyleScoper;
      private _searchContext: SearchContext | null;
      constructor(options: {
        section: ePubJS.Section;
        container: HTMLElement;
        window: Window & typeof globalThis;
        document: Document;
        styleScoper: StyleScoper;
      });
      render(requestFn: Function): Promise<void>;
      getFirstVisibleRange(
        isHorizontal: boolean,
        textNodesOnly: boolean,
      ): Range | null;
      get searchContext(): SearchContext;
    }
  }
}





declare namespace _ZoteroTypes {
  namespace Reader {
    interface SnapshotViewState extends DOMViewState {
      scrollYPercent?: number;
    }

    interface SnapshotViewData {
      srcDoc?: string;
    }

    class SnapshotView extends DOMView<SnapshotViewState, SnapshotViewData> {
      private readonly _navStack: NavStack<[number, number]>;
      protected _find: DefaultFindProcessor | null;
      private _searchContext: SearchContext | null;
      private _scale: number;

      protected _getSrcDoc(): string;
      getData(): { srcDoc: string; baseURI?: string };
      protected _onInitialDisplay(
        viewState: Partial<Readonly<SnapshotViewState>>,
      ): void;
      protected _getAnnotationFromRange(
        range: Range,
        type: AnnotationType,
        color?: string,
      ): NewAnnotation<WADMAnnotation> | null;
      private _getSortIndex(range: Range): string;
      toSelector(range: Range): Selector | null;
      toDisplayedRange(selector: Selector): Range | null;
      private _getSearchContext(): SearchContext;

      // Popups:
      // - For each popup (except find popup) 'rect' bounding box has to be provided.
      // 	 The popup is then automatically positioned around this rect.
      // - If popup needs to be updated (i.e. its position), just reopen it.
      // - Popup has to be updated (reopened) each time when the view is scrolled or resized.
      // - annotation, selection and overlay popups are closed by calling this._onSetSomePopup()
      //   with no arguments
      _pushCurrentLocationToNavStack(): void;
      protected _navigateToSelector(
        selector: Selector,
        options?: NavigateOptions,
      ): void;
      protected override _updateViewState(): void;
      protected override _updateViewStats(): void;

      // ***
      // Event handlers
      // ***
      protected _handleInternalLinkClick(link: HTMLAnchorElement): void;
      protected override _handleScroll(): void;

      // ***
      // Setters that get called once there are changes in reader._state
      // ***
      /**
       * Unlike annotation, selection and overlay popups, find popup open state is determined
       * with .open property. All popup properties are preserved even when it's closed
       */
      setFindState(state: FindState): void;

      // ***
      // Public methods to control the view from the outside
      // ***
      findNext(): void;
      findPrevious(): void;
      zoomIn(): void;
      zoomOut(): void;
      zoomReset(): void;
      private _setScale(scale: number): void;
      override navigate(location: NavLocation, options?: NavigateOptions): void;
      navigateBack(): void;
      navigateForward(): void;
      print(): void;
      setSidebarOpen(_sidebarOpen: boolean): void;
    }
  }
}




declare namespace _ZoteroTypes {
  namespace Reader {
    class Page {
      constructor(layer: PDFView, originalPage: anyObj);
      layer: PDFView;
      originalPage: anyObj;
      pageIndex: number;
      overlays: anyObj[];
      chars: anyObj[];
      selectionColor: "#bad6fb";
      previouslyAffected: boolean;
      originalCanvas: HTMLCanvasElement;
      originalContext: CanvasRenderingContext2D;
      actualContext: CanvasRenderingContext2D;
      readonly transform: number[];

      redrawOriginalPage(): Promise<void>;
      drawNote(ctx: CanvasRenderingContext2D, color: string): void;
      drawCommentIndicators(annotations: Annotation[]): void;

      _renderInk(annotation: Annotation): void;
      _renderImage(annotation: Annotation): void;
      _renderHighlight(annotation: Annotation): void;
      _renderUnderline(annotation: Annotation): void;
      _renderNote(annotation: Annotation): void;

      render(): void;
      renderAnnotationOnCanvas(
        annotation: Annotation,
        canvas: HTMLCanvasElement,
      ): void;
    }
  }
}


declare namespace _ZoteroTypes {
  namespace Reader {
    interface PDFView {
      _iframe: HTMLIFrameElement;
      _iframeWindow?: Window & {
        PDFViewerApplication: PDFViewerApplication;
        PDFViewerApplicationConstants: anyObj;
        pdfjsLib: pdfjs;
      };
      initializedPromise: Promise<void>;
      focus(): void;
      findNext(): void;
      findPrevious(): void;
      zoomReset(): void;
      zoomIn(): void;
      zoomOut(): void;
      zoomPageWidth(): void;
      zoomPageHeight(): void;
      zoomAuto(): void;
      navigateBack(): void;
      navigateForward(): void;
      navigateToFirstPage(): void;
      navigateToLastPage(): void;
      navigateToNextPage(): void;
      navigateToPreviousPage(): void;
      getSelectedAnnotations(): anyObj[];
    }
  }
}


declare namespace _ZoteroTypes {
  namespace Reader {
    type pdfjs = typeof import("pdfjs-dist");
    type PromiseCapability = {
      promise: Promise<unknown>;
      resolve: (value: unknown) => void;
      reject: (reason?: any) => void;
      settled: boolean;
    };
    type PDFPageProxy = import("pdfjs-dist/types/src/display/api").PDFPageProxy;
    type PDFDocumentProxy =
      import("pdfjs-dist/types/src/display/api").PDFDocumentProxy;
    type PDFDocumentLoadingTask =
      import("pdfjs-dist/types/src/display/api").PDFDocumentLoadingTask;
    type PDFViewer = import("pdfjs-dist/types/web/pdf_viewer").PDFViewer;
    type PDFThumbnailViewer =
      import("pdfjs-dist/types/web/pdf_thumbnail_viewer").PDFThumbnailViewer;
    type PDFLinkService =
      import("pdfjs-dist/types/web/pdf_link_service").PDFLinkService;
    type PDFHistory = import("pdfjs-dist/types/web/pdf_history").PDFHistory;
    type PDFFindController =
      import("pdfjs-dist/types/web/pdf_find_controller").PDFFindController;
    type PDFRenderingQueue =
      import("pdfjs-dist/types/web/pdf_rendering_queue").PDFRenderingQueue;
    type PDFScriptingManager =
      import("pdfjs-dist/types/web/pdf_scripting_manager").PDFScriptingManager;
    type EventBus = import("pdfjs-dist/types/web/event_utils").EventBus;

    interface PDFViewerApplication extends anyObj {
      pdfDocument?: PDFDocumentProxy;
      pdfLoadingTask?: PDFDocumentLoadingTask;
      pdfViewer?: PDFViewer;
      pdfThumbnailViewer?: PDFThumbnailViewer;
      pdfLinkService?: PDFLinkService;
      pdfHistory?: PDFHistory;
      pdfScriptingManager?: PDFScriptingManager;
      findController?: PDFFindController;
      eventBus?: EventBus;
      url: string;
      baseUrl: string;
      _initializedCapability: PromiseCapability;
      readonly initialized: boolean;
      readonly initializedPromise: Promise<void>;
      zoomReset(): void;
      readonly pagesCount: number;
      page: number;
      readonly supportsPrinting: boolean;
      readonly supportsFullscreen: boolean;
      readonly supportsIntegratedFind: boolean;
      readonly supportsDocumentFonts: boolean;
      readonly supportsPinchToZoom: boolean;
      initPassiveLoading(): void;
      setTitleUsingUrl(url?: string, downloadUrl?: string): void;
      setTitle(title?: string): void;
      readonly _docFilename: string;
      _hideViewBookmark(): void;
      close(): Promise<void>;
      open(args?: anyObj): Promise<void>;
      _ensureDownloadComplete(): void;
      download(options?: anyObj): Promise<void>;
      save(options?: anyObj): Promise<void>;
      downloadOrSave(options?: anyObj): void;
      openInExternalApp(): void;
      _documentError(message: string, moreInfo?: anyObj): void;

      /**
       * Report the error; used for errors affecting e.g. only a single page.
       * @param {string} message - A message that is human readable.
       * @param {Object} [moreInfo] - Further information about the error that is
       *                              more technical. Should have a 'message' and
       *                              optionally a 'stack' property.
       */
      _otherError(message: string, moreInfo?: anyObj): void;

      progress(level: number): void;
      load(pdfDocument: PDFDocumentProxy): void;
      _scriptingDocProperties(pdfDocument: PDFDocumentProxy): Promise<anyObj>;
      _initializeMetadata(pdfDocument: PDFDocumentProxy): Promise<void>;
      _initializePageLabels(pdfDocument: PDFDocumentProxy): Promise<void>;
      _initializePdfHistory({
        fingerprint,
        viewOnLoad,
        initialDest,
      }: anyObj): void;
      _initializeAnnotationStorageCallbacks(
        pdfDocument: PDFDocumentProxy,
      ): void;
      _cleanup(): void;
      forceRendering(): void;
      beforePrint(): void;
      afterPrint(): void;
      rotatePages(delta: number): void;
      requestPresentationMode(): void;
      triggerPrinting(): void;
      bindEvents(): void;
      bindWindowEvents(): void;
      unbindEvents(): void;
      unbindWindowEvents(): void;

      /**
       * Used together with the integration-tests, to enable awaiting full
       * initialization of the scripting/sandbox.
       */
      readonly scriptingReady: boolean;
    }
  }
}


declare namespace _ZoteroTypes {
  namespace Annotations {
    type AnnotationType =
      | "highlight"
      | "image"
      | "ink"
      | "note"
      | "underline"
      | "text";
    interface AnnotationJson {
      id: string;
      text: string;
      libraryID: number;
      key: string;
      type: Annotations.AnnotationType;
      isExternal?: boolean;
      authorName?: string;
      lastModifiedByUser?: string;
      isAuthorNameAuthoritative?: boolean;
      readOnly: boolean;
      image?: string;
      comment?: string;
      pageLabel: string;
      color: string;
      sortIndex: string;
      position: { pageIndex: number; rects: number[][] } & anyObj;
      tags?: { name: string; color: string };
      dateModified: string;
      relations?: Record<RelationsPredicate, ZoteroObjectURI>;
    }
  }

  interface Annotations {
    [key: string]: unknown;
    ANNOTATION_POSITION_MAX_SIZE: 65000;
    ANNOTATION_TYPE_HIGHLIGHT: 1;
    ANNOTATION_TYPE_NOTE: 2;
    ANNOTATION_TYPE_IMAGE: 3;
    ANNOTATION_TYPE_INK: 4;
    ANNOTATION_TYPE_UNDERLINE: 5;
    ANNOTATION_TYPE_TEXT: 6;
    DEFAULT_COLOR: "#ffd400";
    readonly PROPS: [
      "type",
      "authorName",
      "text",
      "comment",
      "color",
      "pageLabel",
      "sortIndex",
      "position",
    ];

    getCacheImagePath(
      annotation: object & { libraryID: number; key: string },
    ): string;
    hasCacheImage(
      item: object & { libraryID: number; key: string },
    ): Promise<boolean>;
    saveCacheImage(
      annotation: object & { libraryID: number; key: string },
      blob: Blob,
    ): Promise<string>;
    removeCacheImage(
      annotation: object & { libraryID: number; key: string },
    ): Promise<void>;

    /**
     * Remove cache files that are no longer in use
     */
    removeOrphanedCacheFiles(): Promise<void>;

    /**
     * Remove all cache files for a given library
     */
    removeLibraryCacheFiles(libraryID: number): Promise<void>;

    _getLibraryCacheDirectory(libraryID: number): string;
    toJSON(item: Zotero.Item): Promise<Annotations.AnnotationJson>;

    /**
     * @param {Zotero.Item} attachment - Saved parent attachment item
     * @param {Object} json
     * @return {Promise<Zotero.Item>} - Promise for an annotation item
     */
    saveFromJSON(
      attachment: Zotero.Item,
      json: Annotations.AnnotationJson,
      saveOptions?: Zotero.DataObject.SaveOptions,
    ): Promise<Zotero.Item>;

    /**
     * Split annotation if position exceed the limit
     *
     * @param {Object} annotation
     * @returns {Array<Object>} annotations
     */
    splitAnnotationJSON(
      annotation: Zotero.Item | Annotations.AnnotationJson,
    ): Annotations.AnnotationJson[];

    /**
     * Split annotations
     *
     * @param {Zotero.Item[]} items
     * @returns {Promise<void>}
     */
    splitAnnotations(items: Zotero.Item[]): Promise<void>;
  }
}

declare namespace Zotero {
  const Annotations: _ZoteroTypes.Annotations;
}


declare namespace _ZoteroTypes {
  namespace Attachments {
    enum LinkMode {
      importedFile = 0,
      importedUrl,
      linkedFile,
      linkedUrl,
      embeddedImage,
    }

    interface OptionsFromFile {
      file: nsIFile | string;
      parentItemID?: number;
      title?: string;
      collections?: Array<string | number>;
      contentType?: string;
      charset?: string;
      saveOptions?: Zotero.DataObject.SaveOptions;
    }

    type AccessMethod = "doi" | "url" | "oa" | "custom";
    interface UrlResolver {
      pageURL?: string;
      url?: string;
      accessMethod: AccessMethod;
      articleVersion?: unknown;
      referrer?: string;
    }
  }
  interface Attachments {
    [key: string]: unknown;
    LINK_MODE_IMPORTED_FILE: 0;
    LINK_MODE_IMPORTED_URL: 1;
    LINK_MODE_LINKED_FILE: 2;
    LINK_MODE_LINKED_URL: 3;
    LINK_MODE_EMBEDDED_IMAGE: 4;
    BASE_PATH_PLACEHOLDER: "attachments:";

    /**
     * @param {Object} options
     * @param {nsIFile|String} [options.file] - File to add
     * @param {Integer} [options.libraryID]
     * @param {Integer[]|String[]} [options.parentItemID] - Parent item to add item to
     * @param {String} [options.title]
     * @param {Integer[]} [options.collections] - Collection keys or ids to add new item to
     * @param {String} [options.fileBaseName]
     * @param {String} [options.contentType]
     * @param {String} [options.charset]
     * @param {Object} [options.saveOptions] - Options to pass to Zotero.Item::save()
     * @return {Promise<Zotero.Item>}
     */
    importFromFile(
      options: Attachments.OptionsFromFile & {
        libraryID?: number;
        fileBaseName?: string;
      },
    ): Promise<Zotero.Item>;

    /**
     * @param {nsIFile|String} options.file - File to add
     * @param {Integer[]|String[]} [options.parentItemID] - Parent item to add item to
     * @param {String} [options.title]
     * @param {Integer[]} [options.collections] - Collection keys or ids to add new item to
     * @param {String} [options.contentType] - Content type
     * @param {String} [options.charset] - Character set
     * @param {Object} [options.saveOptions] - Options to pass to Zotero.Item::save()
     * @return {Promise<Zotero.Item>}
     */
    linkFromFile(options: Attachments.OptionsFromFile): Promise<Zotero.Item>;

    /**
     * @param {String} options.path - Relative path to file
     * @param {String} options.title
     * @param {String} options.contentType
     * @param {Integer[]|String[]} [options.parentItemID] - Parent item to add item to
     * @param {Integer[]} [options.collections] - Collection keys or ids to add new item to
     * @param {Object} [options.saveOptions] - Options to pass to Zotero.Item::save()
     * @return {Promise<Zotero.Item>}
     */
    linkFromFileWithRelativePath(
      options: Attachments.OptionsFromFile,
    ): Promise<Zotero.Item>;

    /**
     * Saves an image for a parent note or image annotation
     *
     * Emerging formats like WebP and AVIF are supported here,
     * but should be filtered on the calling logic for now
     *
     * @param {Object} params
     * @param {Blob} params.blob - Image to save
     * @param {Integer} params.parentItemID - Note or annotation item to add item to
     * @param {Object} [params.saveOptions] - Options to pass to Zotero.Item::save()
     * @return {Promise<Zotero.Item>}
     */
    importEmbeddedImage(params: {
      blob: Blob;
      parentItemID: number;
      saveOptions?: Zotero.DataObject.SaveOptions;
    }): Promise<Zotero.Item>;

    /**
     * Copy an image from one note to another
     *
     * @param {Object} params
     * @param {Zotero.Item} params.attachment - Image attachment to copy
     * @param {Zotero.Item} params.note - Note item to add attachment to
     * @param {Object} [params.saveOptions] - Options to pass to Zotero.Item::save()
     * @return {Promise<Zotero.Item>}
     */
    copyEmbeddedImage(params: {
      attachment: Zotero.Item;
      note: Zotero.Item;
      saveOptions?: Zotero.DataObject.SaveOptions;
    }): Promise<Zotero.Item>;

    /**
     * @param {Object} options
     * @param {Integer} options.libraryID
     * @param {String} options.url
     * @param {Integer} [options.parentItemID]
     * @param {Integer[]} [options.collections]
     * @param {String} [options.title]
     * @param {String} [options.fileBaseName]
     * @param {Boolean} [options.renameIfAllowedType=false]
     * @param {String} [options.contentType]
     * @param {String} [options.referrer]
     * @param {CookieSandbox} [options.cookieSandbox]
     * @param {Object} [options.saveOptions] - Options to pass to Zotero.Item::save()
     * @return {Promise<Zotero.Item>} - A promise for the created attachment item
     */
    importFromURL(options: {}): Promise<Zotero.Item>;

    /**
     * Create an imported-URL attachment using a file downloaded to a temporary directory
     * in 'storage', moving the directory into place
     *
     * We download files to temporary 'storage' directories rather than the normal temporary
     * directory because people might have their storage directory on another device, which
     * would make the move a copy.
     *
     * @param {Object} options
     * @param {String} options.directory
     * @param {Number} options.libraryID
     * @param {String} options.filename
     * @param {String} options.url
     * @param {Number} [options.parentItemID]
     * @param {String} [options.title]
     * @param {String} options.contentType
     * @param {String[]} [options.collections]
     * @param {Object} [options.saveOptions] - Options to pass to Zotero.Item::save()
     * @return {Zotero.Item}
     */
    createURLAttachmentFromTemporaryStorageDirectory(options: {}): Promise<Zotero.Item>;

    /**
     * Create a link attachment from a URL
     *
     * @param {Object} options - 'url', 'parentItemID', 'contentType', 'title', 'collections'
     * @param {Object} [options.saveOptions] - Options to pass to Zotero.Item::save()
     * @return {Promise<Zotero.Item>} - A promise for the created attachment item
     */
    linkFromURL(options: {}): Promise<Zotero.Item>;

    /**
     * TODO: what if called on file:// document?
     *
     * @param {Object} options - 'document', 'parentItemID', 'collections'
     * @param {Object} [options.saveOptions] - Options to pass to Zotero.Item::save()
     * @return {Promise<Zotero.Item>}
     */
    linkFromDocument(options: {}): Promise<Zotero.Item>;

    /**
     * Save a snapshot from a Document
     *
     * @param {Object} options - 'libraryID', 'document', 'parentItemID', 'forceTitle', 'collections'
     * @param {Object} [options.saveOptions] - Options to pass to Zotero.Item::save()
     * @return {Promise<Zotero.Item>} - A promise for the created attachment item
     */
    importFromDocument(options: {}): Promise<Zotero.Item>;

    /**
     * Save a snapshot from HTML page content given by SingleFile
     *
     * @param {Object} options
     * @param {String} options.url
     * @param {Object} options.snapshotContent - HTML content from SingleFile
     * @param {Integer} [options.parentItemID]
     * @param {Integer[]} [options.collections]
     * @param {String} [options.title]
     * @param {Object} [options.saveOptions] - Options to pass to Zotero.Item::save()
     * @return {Promise<Zotero.Item>} - A promise for the created attachment item
     */
    importFromSnapshotContent(options: {}): Promise<Zotero.Item>;

    /**
     * @param {String} url
     * @param {String} path
     * @param {Object} [options]
     * @param {Object} [options.cookieSandbox]
     * @param {String} [options.referrer]
     * @param {Boolean} [options.isPDF] - Delete file if not PDF
     */
    downloadFile(
      url: string,
      path: string,
      options?: { cookieSandbox?: object; referrer?: string },
    ): Promise<boolean>;

    /**
     * @param {String} url
     * @param {String} path
     * @param {Object} [options]
     * @param {Object} [options.cookieSandbox]
     */
    downloadPDFViaBrowser(
      url: string,
      path: string,
      options?: { cookieSandbox?: object },
    ): Promise<boolean>;

    InvalidPDFException: typeof Error & {
      message: "Downloaded PDF was not a PDF";
      stack: string;
    };

    canFindPDFForItem(item: Zotero.Item): boolean;

    /**
     * Get the PDF resolvers that can be used for a given item based on the available fields
     *
     * @param {Zotero.Item} item
     * @param {String[]} [methods=['doi', 'url', 'oa', 'custom']]
     * @param {Boolean} [automatic=false] - Only include custom resolvers with `automatic: true`
     * @return {Object[]} - An array of urlResolvers (see downloadFirstAvailableFile())
     */
    getPDFResolvers(
      item: Zotero.Item,
      methods?: Attachments.AccessMethod[],
      automatic?: boolean,
    ): Attachments.UrlResolver[];

    /**
     * Look for available PDFs for items and add as attachments
     *
     * @param {Zotero.Item[]} items
     * @param {Object} [options]
     * @param {String[]} [options.methods] - See getPDFResolvers()
     * @param {Number} [options.sameDomainRequestDelay=1000] - Minimum number of milliseconds
     *     between requests to the same domain (used in tests)
     * @return {Promise}
     */
    addAvailableFiles(
      items: Zotero.Item[],
      options?: {
        methods?: Attachments.AccessMethod[];
        sameDomainRequestDelay?: number;
      },
    ): Promise<void>;

    /**
     * @deprecated Use addAvailableFiles()
     */
    addAvailablePDFs(
      items: Zotero.Item[],
      options?: {
        methods?: Attachments.AccessMethod[];
        sameDomainRequestDelay?: number;
      },
    ): Promise<void>;

    /**
     * Look for an available PDF for an item and add it as an attachment
     *
     * @param {Zotero.Item} item
     * @param {Object} [options]
     * @param {String[]} [options.methods] - See getPDFResolvers()
     * @return {Zotero.Item|false} - New Zotero.Item, or false if unsuccessful
     */
    addAvailableFile(
      item: Zotero.Item,
      options?: { methods: Attachments.AccessMethod[] },
    ): Promise<Zotero.Item | false>;

    /**
     * @deprecated Use addAvailableFile()
     */
    addAvailablePDF(
      item: Zotero.Item,
      options?: { methods: Attachments.AccessMethod[] },
    ): Promise<Zotero.Item | false>;

    /**
     * Try to add a PDF to an item from a set of URL resolvers
     *
     * @param {Zotero.Item} item
     * @param {(String|Object|Function)[]} urlResolvers - See downloadFirstAvailableFile()
     * @param {Object} [options]
     * @param {Function} [options.onAccessMethodStart] - Function to run when a new access method
     *     is started, taking the access method name as an argument
     * @return {Zotero.Item|false} - New Zotero.Item, or false if unsuccessful
     */
    addPDFFromURLs(
      item: Zotero.Item,
      urlResolvers: Attachments.UrlResolver[],
      options?: { onAccessMethodStart: Function },
    ): Promise<Zotero.Item | false>;

    /**
     * Try to download a file from a set of URL resolvers, keeping the first one that succeeds
     *
     * URLs are only tried once.
     *
     * @param {(String|Object|Function)[]} urlResolvers - An array of URLs, objects, or functions
     *    that return arrays of objects. Objects should contain 'url' and/or 'pageURL' (the latter
     *    being a webpage that might contain a translatable PDF link), 'accessMethod' (which will
     *    be displayed in the save popup), and an optional 'articleVersion' ('submittedVersion',
     *    'acceptedVersion', or 'publishedVersion'). Functions that return promises are waited for,
     *    and functions aren't called unless a file hasn't yet been found from an earlier entry.
     * @param {String} path - Path to save file to
     * @param {Object} [options]
     * @param {Function} [options.onBeforeRequest] - Async function that runs before a request
     * @param {Function} [options.onAfterRequest] - Function that runs after a request
     * @param {Function} [options.onRequestError] - Function that runs when a request fails.
     *     Return true to retry request and false to skip.
     * @return {Object|false} - Object with successful 'url' and 'props' from the associated urlResolver,
     *     or false if no file could be downloaded
     */
    downloadFirstAvailableFile(
      urlResolvers: Array<
        | string
        | Attachments.UrlResolver
        | (() => Promise<Attachments.UrlResolver>)
      >,
      path: string,
      options: {
        onBeforeRequest: Function;
        onAfterRequest: Function;
        onRequestError: Function;
      },
    ): Promise<false | { url: string; props: unknown }>;

    /**
     * Returns a formatted string to use as the basename of an attachment
     * based on the metadata of the specified item and a format string
     *
     * (Optional) |formatString| specifies the format string -- otherwise
     * the 'attachmentRenameFormatString' pref is used
     *
     * Valid substitution markers:
     *
     * %c -- firstCreator
     * %y -- year (extracted from Date field)
     * %t -- title
     *
     * Fields can be truncated to a certain length by appending an integer
     * within curly brackets -- e.g. %t{50} truncates the title to 50 characters
     *
     * @param {Zotero.Item} item
     * @param {String} formatString
     */
    getFileBaseNameFromItem(item: Zotero.Item, formatString?: string): string;

    shouldAutoRenameFile(isLink: boolean): boolean;
    getRenamedFileTypes(): string[];
    getRenamedFileBaseNameIfAllowedType(
      parentItem: Zotero.Item,
      file: string,
    ): Promise<string>;

    /**
     * Create directory for attachment files within storage directory
     *
     * If a directory exists, delete and recreate
     *
     * @param {Number} itemID - Item id
     * @return {Promise<String>} - Path of new directory
     */
    createDirectoryForItem(item: Zotero.Item): Promise<string>;

    getStorageDirectory(item: Zotero.Item): nsIFile;
    getStorageDirectoryByID(itemID: number): nsIFile;
    getStorageDirectoryByLibraryAndKey(libraryID: number, key: string): nsIFile;
    createTemporaryStorageDirectory(): Promise<nsIFile>;

    /**
     * If path is within the attachment base directory, return a relative
     * path prefixed by BASE_PATH_PLACEHOLDER. Otherwise, return unchanged.
     */
    getBaseDirectoryRelativePath(path: string): string;

    /**
     * Get an absolute path from this base-dir relative path, if we can
     *
     * @param {String} path - Absolute path or relative path prefixed by BASE_PATH_PLACEHOLDER
     * @return {String|false} - Absolute path, or FALSE if no path
     */
    resolveRelativePath(path: string): string | false;

    fixPathSlashes(path: string): string;
    hasMultipleFiles(item: Zotero.Item): Promise<boolean>;

    /**
     * Returns the number of files in the attachment directory
     *
     * Only counts if MIME type is text/html
     *
     * @param	{Zotero.Item}	item	Attachment item
     */
    getNumFiles(item: Zotero.Item): Promise<number>;

    /**
     * @param {Zotero.Item} item
     * @param {Boolean} [skipHidden=true] - Don't count hidden files
     * @return {Promise<Integer>} - Promise for the total file size in bytes
     */
    getTotalFileSize(item: Zotero.Item, skipHidden?: boolean): Promise<number>;

    /**
     * Move attachment item, including file, to another library
     */
    moveAttachmentToLibrary(
      attachment: Zotero.Item,
      libraryID: number,
      parentItemID?: number,
    ): Promise<number>;

    /**
     * Copy attachment item, including file, to another library
     *
     * @return {Zotero.Item} - The new attachment
     */
    copyAttachmentToLibrary(
      attachment: Zotero.Item,
      libraryID: number,
      parentItemID?: number,
    ): Promise<Zotero.Item>;

    convertLinkedFileToStoredFile(
      item: Zotero.Item,
      options?: { move: boolean },
    ): Promise<Zotero.Item>;
    _getFileNameFromURL(url: string, contentType: string): string;
    _getExtensionFromURL(url: string, contentType: string): string;

    /**
     * Determines if a given document is an instance of PDFJS
     * @return {Boolean}
     */
    isPDFJS(doc: object): boolean;

    linkModeToName(linkMode: number): string;
    linkModeFromName(linkModeName: string): Attachments.LinkMode;
  }
}

declare namespace Zotero {
  const Attachments: _ZoteroTypes.Attachments;
}


declare namespace Zotero {
  interface CollectionTreeRow extends _ZoteroTypes.TreeRow {
    new (
      collectionTreeView: _ZoteroTypes.CollectionTree,
      type: _ZoteroTypes.CollectionTreeRow.Type,
      ref: unknown,
      level: number,
      isOpen: boolean,
    ): this;
    view: _ZoteroTypes.CollectionTree;
    type: _ZoteroTypes.CollectionTreeRow.Type;
    onUnload?: () => Promise<void>;
    ref: DataObject | _ZoteroTypes.anyObj;
    get id(): string;

    isLibrary(includeGlobal?: boolean): boolean;
    isCollection(): boolean;
    isSearch(): boolean;
    isDuplicates(): boolean;
    isUnfiled(): boolean;
    isRetracted(): boolean;
    isTrash(): boolean;
    isHeader(): boolean;
    isPublications(): boolean;
    isGroup(): boolean;
    isFeed(): boolean;
    isSeparator(): boolean;
    isBucket(): boolean;
    isShare(): boolean;
    isContainer(): boolean;
    isWithinGroup(): boolean;
    isWithinEditableGroup(): boolean;

    get editable(): boolean;
    get filesEditable(): boolean;
    get visibilityGroup(): "feed" | "feeds" | "default";
    getName(): string;
    getChildren(): Zotero.Collection | Zotero.Feed | undefined;
    getItems(): Promise<Array<Item | unknown>>; //
    getSearchResults(asTempTable?: false): Promise<number[]>;
    getSearchResults(asTempTable: true): Promise<string>;

    /*
     * Returns the search object for the currently display
     *
     * This accounts for the collection, saved search, quicksearch, tags, etc.
     */
    getSearchObject(): Promise<Zotero.Search>;

    /**
     * Returns all the tags used by items in the current view
     *
     * @return {Promise<Object[]>}
     */
    getTags(
      types: number[],
      tagIDs: number[],
    ): Promise<_ZoteroTypes.Tags.TagJson[]>;

    searchText?: string;
    setSearch(searchText: string): void;
    setTags(tags: Set<string>): void; //

    /*
     * Returns TRUE if saved search, quicksearch or tag filter
     */
    isSearchMode(): boolean;
  }

  const CollectionTreeCache: _ZoteroTypes.CollectionTreeCache;
}

declare namespace _ZoteroTypes {
  namespace CollectionTreeRow {
    type Type =
      | "library"
      | "group"
      | "feed"
      | "collection"
      | "search"
      | "duplicates"
      | "unfiled"
      | "retracted"
      | "publications"
      | "trash"
      | "feeds"
      | "header"
      | "separator"
      | "bucket"
      | "share";
  }

  interface CollectionTreeCache {
    lastTreeRow?: Zotero.CollectionTreeRow;
    lastSearch?: Zotero.Search;
    lastTempTable?: string;
    lastResults?: number[];
    error: boolean;
    clear(): void;
  }
}

declare namespace Zotero {
  /**
   * Manage cookies in a sandboxed fashion
   *
   * @constructor
   * @param {browser} [browser] Hidden browser object
   * @param {String|nsIURI} uri URI of page to manage cookies for (cookies for domains that are not
   *                     subdomains of this URI are ignored)
   * @param {String} cookieData Cookies with which to initiate the sandbox
   * @param {String} userAgent User agent to use for sandboxed requests
   */
  interface CookieSandbox {
    new (
      browser: unknown,
      uri: string | URL,
      cookieData: string,
      userAgent: string,
    ): this;

    /**
     * Normalizes the host string: lower-case, remove leading period, some more cleanup
     * @param {string} host
     * @returns {string}
     */
    normalizeHost(host: string): string;

    /**
     * Normalizes the path string
     * @param {string} path
     * @returns {string}
     */
    normalizePath(path: string): string;

    /**
     * Generates a semicolon-separated string of cookie values from a list of cookies
     * @param {Object} cookies Object containing key: value cookie pairs
     * @returns {string}
     */
    generateCookieString(cookies: { [key: string]: string }): string;
  }
}


declare namespace Zotero {
  /*
   * Base function for retrieving ids and names of static types stored in the DB
   * (e.g. creatorType, fileType, charset, itemType)
   *
   * Extend using the following code within a child constructor:
   *
   * 	Zotero.CachedTypes.apply(this, arguments);
   *  this.constructor.prototype = new Zotero.CachedTypes();
   *
   * And the following properties:
   *
   *	this._typeDesc = '';
   *	this._typeDescPlural = '';
   *	this._idCol = '';
   *	this._nameCol = '';
   *	this._table = '';
   *
   * Optional properties:
   *
   *  this._allowAdd: Allow new types to be added via .add(name)
   *	this._ignoreCase: Ignore case when looking for types, and add new types as lowercase
   *
   * And add .init() to zotero.js
   */
  interface CachedTypes {
    new (): this;
    _types: { [idOrName: string]: _ZoteroTypes.CachedTypes.Type };
    _typesArray: _ZoteroTypes.CachedTypes.Type[];
    _typeDesc: string;
    _idCol: string;
    _nameCol: string;
    _table: string;
    _allowAdd: boolean;
    _ignoreCase: boolean;
    _hasCustom: boolean;

    /**
     * Add a new type to the data and return its id. If the type already exists, return its id.
     *
     * @param {String} name - Type name to add
     * @return {Integer|False} - The type id (new or existing), or false if invalid type name
     */
    add(name: string): Promise<number | false>;

    init(): Promise<void>;
    getName(idOrName: number | string): string;
    getID(idOrName: number | string): number | false;
    getAll(): _ZoteroTypes.CachedTypes.Type[];
    getTypes(): _ZoteroTypes.CachedTypes.Type[];
    isCustom(idOrName: number | string): boolean; // Currently used only for item types
    _getTypesFromDB(where: string, params?: object): Promise<unknown>;
    _cacheTypeData(type: _ZoteroTypes.CachedTypes.Type): void;
  }

  const CreatorTypes: _ZoteroTypes.CreatorTypes;
  const ItemTypes: _ZoteroTypes.ItemTypes;
  const FileTypes: _ZoteroTypes.FileTypes;
  const CharacterSets: _ZoteroTypes.CharacterSets;
  const RelationPredicates: _ZoteroTypes.RelationPredicates;
}

declare namespace _ZoteroTypes {
  namespace CachedTypes {
    interface Type {
      custom?: boolean;
      id: number;
      name: string;
    }
  }

  interface CreatorTypes extends Zotero.CachedTypes {
    _typeDesc: "creator type";
    _typeDescPlural: "creator types";
    _idCol: "creatorTypeID";
    _nameCol: "creatorType";
    _table: "creatorTypes";
    getTypesForItemType(itemTypeID: number): _ZoteroTypes.CachedTypes.Type[];
    isValidForItemType(creatorTypeID: number, itemTypeID: number): boolean;
    getLocalizedString(idOrName: number | string): string;
    itemTypeHasCreators(itemTypeID: number): boolean;
    getPrimaryIDForType(itemTypeID: number): number | false;
  }

  namespace ItemTypes {
    type PrimaryTypeName =
      | "book"
      | "bookSection"
      | "journalArticle"
      | "newspaperArticle"
      | "document";
    type HiddenTypeName = "webpage" | "attachment" | "note" | "annotation";
  }

  interface ItemTypes extends Zotero.CachedTypes {
    customIDOffset: 10000;
    _typeDesc: "item type";
    _typeDescPlural: "item types";
    _idCol: "itemTypeID";
    _nameCol: "typeName";
    _table: "itemTypesCombined";
    _hasCustom: true;

    getPrimaryTypes(): _ZoteroTypes.CachedTypes.Type[];
    getSecondaryTypes(): _ZoteroTypes.CachedTypes.Type[];
    getHiddenTypes(): _ZoteroTypes.CachedTypes.Type[];
    getLocalizedString(idOrName: number | string): string;
    getImageSrc(itemType: _ZoteroTypes.Item.ItemType): _ZoteroTypes.IconURI;
  }

  interface FileTypes extends Zotero.CachedTypes {
    _typeDesc: "file type";
    _typeDescPlural: "file types";
    _idCol: "fileTypeID";
    _nameCol: "fileType";
    _table: "fileTypes";

    /**
     * @return {Promise<Integer>} fileTypeID
     */
    getIDFromMIMEType(mimeType: string): Promise<number>;
  }

  interface CharacterSets extends Zotero.CachedTypes {
    _typeDesc: "character set";
    _typeDescPlural: "character sets";
    _idCol: "charsetID";
    _nameCol: "charset";
    _table: "charsets";
    _ignoreCase: true;

    /**
     * Converts charset label to charset name
     * @link https://encoding.spec.whatwg.org/#names-and-labels
     * @param {String} charset
     * @return {String|Boolean} Normalized charset name or FALSE if not recognized
     */
    toCanonical(charset: string): string | false;

    /**
     * Normalizes charset label to conform to DOM standards
     * @link https://dom.spec.whatwg.org/#dom-document-characterset
     * @param {String} charset
     * @param {Boolean} mozCompat Whether to return a Mozilla-compatible label
     *   for use in Gecko internal APIs.
     *   https://developer.mozilla.org/en-US/docs/Gecko/Character_sets_supported_by_Gecko
     * @return {String|Boolean} Normalized label or FALSE is not recognized
     */
    toLabel(charset: string, mozCompat?: boolean): string | false;
  }

  interface RelationPredicates extends Zotero.CachedTypes {
    _typeDesc: "relation predicate";
    _typeDescPlural: "relation predicates";
    _idCol: "predicateID";
    _nameCol: "predicate";
    _table: "relationPredicates";
    _ignoreCase: false;
    _allowAdd: true;
  }
}

declare namespace _ZoteroTypes {
  namespace Collection {
    type DataType =
      | "primaryData"
      | "childCollections"
      | "childItems"
      | "relations";
    type DescendentType = "item" | "collection";
    interface Descendent {
      id: number;
      key: string;
      level: number;
      name: string;
      parent: number;
      type: Collection.DescendentType;
    }
  }
}

declare namespace Zotero {
  class Collection extends Zotero.DataObject {
    static prototype: Collection;
    constructor(params?: {
      name?: string;
      libraryID?: number;
      parentID?: number;
      parentKey?: string;
    });
    _childCollections: Set<number>;
    _childItems: Set<number>;
    _objectType: "collection";
    _dataTypes: Array<_ZoteroTypes.Collection.DataType>;
    ChildObjects: _ZoteroTypes.Items;
    name: string;
    version: number;
    synced: boolean;
    parentID: number;
    parentKey: string;
    treeViewID: string;
    treeViewImage: string;

    /*
     * Populate collection data from a database row
     */
    loadFromRow(row: object): void;

    hasChildCollections(includeTrashed?: boolean): boolean;
    hasChildItems(): boolean;

    /**
     * Returns subcollections of this collection
     *
     * @param {Boolean} [asIDs=false] Return as collectionIDs
     * @return {Zotero.Collection[]|Integer[]}
     */
    getChildCollections(
      asIDs?: false,
      includeTrashed?: boolean,
    ): Zotero.Collection[];
    getChildCollections(asIDs: true, includeTrashed?: boolean): number[];

    /**
     * Returns child items of this collection
     *
     * @param	{Boolean}	asIDs			Return as itemIDs
     * @param	{Boolean}	includeDeleted	Include items in Trash
     * @return {Zotero.Item[]|Integer[]} - Array of Zotero.Item instances or itemIDs
     */
    getChildItems(asIDs?: false, includeDeleted?: boolean): Zotero.Item[];
    getChildItems(asIDs: true, includeDeleted?: boolean): number[];

    _saveData(env: unknown): Promise<void>;

    /**
     * @param {Number} itemID
     * @return {Promise}
     */
    addItem(itemID: number, options?: DataObject.SaveOptions): Promise<void>; // do not require save

    /**
     * Add multiple items to the collection in batch
     *
     * Requires a transaction
     * Does not require a separate save()
     *
     * @param {Number[]} itemIDs
     * @return {Promise}
     */
    addItems(
      itemIDs: number[],
      options?: DataObject.SaveOptions,
    ): Promise<void>; // do not require save

    /**
     * Remove a item from the collection. The item is not deleted from the library.
     *
     * Requires a transaction
     * Does not require a separate save()
     *
     * @return {Promise}
     */
    removeItem(
      itemID: number,
      options?: DataObject.SaveOptions & { skipEditCheck?: boolean },
    ): Promise<void>;
    /**
     * Remove multiple items from the collection in batch.
     * The items are not deleted from the library.
     *
     * Does not require a separate save()
     */
    removeItems(
      itemIDs: number[],
      options?: DataObject.SaveOptions & { skipEditCheck?: boolean },
    ): Promise<void>;

    /**
     * Check if an item belongs to the collection
     *
     * @param {Zotero.Item|Number} item - Item or itemID
     */
    hasItem(item: number | Zotero.Item): boolean;

    hasDescendent(
      type: _ZoteroTypes.Collection.DescendentType,
      id: number,
    ): boolean;

    /**
     * Returns an unsaved copy of the collection without id and key
     *
     * Doesn't duplicate subcollections or items, because the collection isn't saved
     */
    clone(libraryID?: number): Zotero.Collection; // not saved

    /**
     * Deletes collection and all descendent collections (and optionally items)
     */
    _eraseData(env: unknown): Promise<void>;

    isCollection(): true;
    serialize(nested?: boolean): {
      primary: {
        collectionID: number;
        libraryID: number;
        key: string;
      };
      fields: {
        name: string;
        parentKey: string;
      };
      childCollections: number[];
      childItems: number[];
      descendents: _ZoteroTypes.Collection.Descendent[];
    };

    /**
     * Populate the object's data from an API JSON data object
     *
     * If this object is identified (has an id or library/key), loadAllData() must have been called.
     */
    fromJSON(json: object, options?: { strict: boolean }): void;
    toJSON(options?: object): {
      key: string;
      name: string;
      version: 68;
      parentCollection: string | false;
      relations: _ZoteroTypes.ObjectRelations;
    };

    /**
     * Returns an array of descendent collections and items
     *
     * @param	{Boolean}	[nested=false]		Return multidimensional array with 'children'
     *											nodes instead of flat array
     * @param	{String}	[type]				'item', 'collection', or NULL for both
     * @param	{Boolean}	[includeDeletedItems=false]		Include items in Trash
     * @param {Number}  [level=1]
     * @return	{Object[]} - An array of objects with 'id', 'key', 'type' ('item' or 'collection'),
     *     'parent', and, if collection, 'name' and the nesting 'level'
     */
    getDescendents(
      nested?: boolean,
      type?: _ZoteroTypes.Collection.DescendentType | null,
      includeDeletedItems?: boolean,
      level?: number,
    ): _ZoteroTypes.Collection.Descendent[];

    /**
     * Return a collection in the specified library equivalent to this collection
     *
     * @return {Promise<Zotero.Collection>}
     */
    getLinkedCollection(
      libraryID: number,
      bidrectional?: boolean,
    ): Promise<Zotero.Collection | false>;
    /**
     * Add a linked-object relation pointing to the given collection
     *
     * Does not require a separate save()
     */
    addLinkedCollection(collection: Zotero.Collection): Promise<boolean>;

    /**
     * Add a collection to the cached child collections list if loaded
     */
    _registerChildCollection(collectionID: number): void;

    /**
     * Remove a collection from the cached child collections list if loaded
     */
    _unregisterChildCollection(collectionID: number): void;

    /**
     * Add an item to the cached child items list if loaded
     */
    _registerChildItem(itemID: number): void;

    /**
     * Remove an item from the cached child items list if loaded
     */
    _unregisterChildItem(itemID: number): void;
  }
}


declare namespace _ZoteroTypes {
  /*
   * Primary interface for accessing Zotero collection
   */
  interface Collections extends DataObjects<Zotero.Collection> {
    _objectCache: { [i: number]: Zotero.Collection };
    ObjectClass: Zotero.Collection;
    _ZDO_object: "collection";
    _primaryDataSQLParts: {
      collectionID: "O.collectionID";
      name: "O.collectionName AS name";
      libraryID: "O.libraryID";
      key: "O.key";
      version: "O.version";
      synced: "O.synced";

      deleted: "DC.collectionID IS NOT NULL AS deleted";

      parentID: "O.parentCollectionID AS parentID";
      parentKey: "CP.key AS parentKey";

      hasChildCollections: "(SELECT COUNT(*) FROM collections WHERE parentCollectionID=O.collectionID) != 0 AS hasChildCollections";
      hasChildItems: "(SELECT COUNT(*) FROM collectionItems WHERE collectionID=O.collectionID) != 0 AS hasChildItems";
    };
    _primaryDataSQLFrom: string;
    _relationsTable: "collectionRelations";

    /**
     * Get collections within a library
     *
     * Either libraryID or parentID must be provided
     *
     * @param {Integer} libraryID
     * @param {Boolean} [recursive=false]
     * @return {Zotero.Collection[]}
     */
    getByLibrary(libraryID: number, recursive?: boolean): Zotero.Collection[];

    /**
     * Get collections that are subcollection of a given collection
     *
     * @param {Integer} parentCollectionID
     * @param {Boolean} [recursive=false]
     * @return {Zotero.Collection[]}
     */
    getByParent(
      parentCollectionID: number,
      recursive?: boolean,
    ): Zotero.Collection[];

    getCollectionsContainingItems(
      itemIDs: number[],
      asIDs?: false,
    ): Promise<Zotero.Item[]>;
    getCollectionsContainingItems(
      itemIDs: number[],
      asIDs: true,
    ): Promise<number[]>;
    _loadChildCollections(libraryID: number, ids: number[]): Promise<void>;
    _loadChildItems(
      libraryID: number,
      ids: number[],
      idSQL: string,
    ): Promise<void>;
    registerChildCollection(
      collectionID: number,
      childCollectionID: number,
    ): void;
    unregisterChildCollection(
      collectionID: number,
      childCollectionID: number,
    ): void;
    registerChildItem(collectionID: number, itemID: number): void;
    unregisterChildItem(collectionID: number, itemID: number): void;
  }
}

declare namespace Zotero {
  const Collections: _ZoteroTypes.Collections;
}


declare namespace _ZoteroTypes {
  interface Creators {
    fields: ["firstName", "lastName", "fieldMode"];
    totes: number;
    init(): Promise<void>;

    /*
     * Returns creator data in internal format for a given creatorID
     */
    get(creatorID: number): _ZoteroTypes.Item.Creator;

    getItemsWithCreator(creatorID: number): Promise<number[]>;
    countItemAssociations(creatorID: number): Promise<number>;

    /**
     * Returns the creatorID matching given fields, or creates a new creator and returns its id
     *
     * @requireTransaction
     * @param {Object} data  Creator data in API JSON format
     * @param {Boolean} [create=false]  If no matching creator, create one
     * @return {Promise<Integer>}  creatorID
     */
    getIDFromData(
      data: _ZoteroTypes.Item.CreatorJSON,
      create?: boolean,
    ): Promise<number | null>;

    updateCreator(
      creatorID: number,
      creatorData: _ZoteroTypes.Item.Creator,
    ): Promise<unknown>;

    /**
     * Delete obsolete creator rows from database and clear internal cache entries
     *
     * @return {Promise}
     */
    purge(): Promise<void>;

    equals(
      data1: _ZoteroTypes.Item.Creator,
      data2: _ZoteroTypes.Item.Creator,
    ): boolean;
    cleanData(
      data: _ZoteroTypes.Item.Creator,
      options?: { strict: boolean },
    ): _ZoteroTypes.Item.Creator;
    internalToJSON(
      fields: _ZoteroTypes.Item.Creator,
    ): _ZoteroTypes.Item.CreatorJSON;
  }
}

declare namespace Zotero {
  const Creators: _ZoteroTypes.Creators;
}


declare namespace Zotero {
  namespace DataObject {
    interface SaveOptions {
      /**
       * Don't save add new object to the cache; if set, object is disabled after save
       */
      skipCache?: boolean;

      skipDateModifiedUpdate?: boolean;
      skipClientDateModifiedUpdate?: boolean;

      /**
       * Don't trigger Zotero.Notifier events
       */
      skipNotifier?: boolean;

      /**
       * Don't select object automatically in trees
       */
      skipSelect?: boolean;

      /**
       * Don't automatically set 'synced' to false
       */
      skipSyncedUpdate?: boolean;

      /**
       * Pass along any 'notifierData' values, which become 'extraData' in notifier events
       */
      notifierData?: any;

      tx?: boolean;
    }
    interface EraseOptions {
      /**
       * Move descendant items to trash (Collection only)
       */
      deleteItems?: boolean;
      /**
       * Don't add to sync delete log
       */
      skipDeleteLog?: boolean;
      tx?: boolean;
    }
  }

  /**
   * @property {String} (readOnly) objectType
   * @property {String} (readOnly) libraryKey
   * @property {String|false|undefined} parentKey - False if no parent, or undefined if not
   *                                                applicable (e.g. search objects)
   * @property {Integer|false|undefined} parentID - False if no parent, or undefined if not
   *                                                applicable (e.g. search objects)
   */
  class DataObject {
    readonly objectType: string;
    readonly libraryKey: string;
    readonly id: number;
    readonly libraryID: number;
    readonly library: Zotero.Library;
    readonly key: string;
    deleted: boolean;

    /**
     *  @property {Integer|false|undefined} parentKey - False if no parent, or undefined if not
     *                                                 applicable (e.g. search objects)
     */
    parentKey: string | false | undefined;

    /**
     *  @property {Integer|false|undefined} parentID - False if no parent, or undefined if not
     *                                                 applicable (e.g. search objects)
     */
    parentID: number | false | undefined;

    readonly _canHaveParent: boolean;
    ObjectsClass: this extends Zotero.Item
      ? _ZoteroTypes.Items
      : this extends Zotero.Collection
        ? _ZoteroTypes.Collections
        : this extends Zotero.Search
          ? _ZoteroTypes.Searches
          : _ZoteroTypes.DataObjects;
    itemTypeID: number;

    /**
     * Returns all relations of the object
     * @return {Object} - Object with predicates as keys and arrays of values
     */
    getRelations(): _ZoteroTypes.ObjectRelations;

    /**
     * Returns all relations of the object with a given predicate
     * @return {String[]} - URIs linked to this object with the given predicate
     */
    getRelationsByPredicate(
      predicate: _ZoteroTypes.RelationsPredicate,
    ): _ZoteroTypes.ZoteroObjectURI[];

    /**
     * @return {Boolean} - True if the relation has been queued, false if it already exists
     */
    addRelation(
      predicate: _ZoteroTypes.RelationsPredicate,
      object: _ZoteroTypes.ZoteroObjectURI,
    ): boolean;

    hasRelation(
      predicate: _ZoteroTypes.RelationsPredicate,
      object: _ZoteroTypes.ZoteroObjectURI,
    ): boolean;
    removeRelation(
      predicate: _ZoteroTypes.RelationsPredicate,
      object: _ZoteroTypes.ZoteroObjectURI,
    ): boolean;

    /**
     * Updates the object's relations
     *
     * @param {Object} newRelations Object with predicates as keys and URI[] as values
     * @return {Boolean} True if changed, false if stayed the same
     */
    setRelations(newRelations: _ZoteroTypes.ObjectRelations): boolean;

    /**
     * Add a linked-item relation to a pair of objects
     *
     * A separate save() is not required.
     *
     * @param {Zotero.DataObject} object
     * @return {Promise<Boolean>}
     */
    _addLinkedObject(object: Zotero.DataObject): Promise<boolean>;

    /**
     * Bulk data loading functions
     * These are called by @function Zotero.DataObjects.prototype.loadDataType().
     */
    loadPrimaryData(reload: boolean, failOnMissing?: boolean): Promise<void>;

    /**
     * Reloads loaded, changed data
     *
     * @param {String[]} [dataTypes] - Data types to reload, or all loaded types if not provide
     * @param {Boolean} [reloadUnchanged=false] - Reload even data that hasn't changed internally.
     *                                            This should be set to true for data that was
     *                                            changed externally (e.g., globally renamed tags).
     */
    reload(dataTypes: string[], reloadUnchanged: boolean): Promise<void>;

    /**
     * Checks whether a given data type has been loaded
     *
     * @param {String} [dataType=primaryData] Data type to check
     * @throws {Zotero.DataObjects.UnloadedDataException} If not loaded, unless the
     *   data has not yet been "identified"
     */
    _requireData(dataType: string): void;

    /**
     * Loads data for a given data type
     * @param {String} dataType
     * @param {Boolean} reload
     * @param {Promise}
     */
    loadDataType(dataType: string): Promise<void>;

    loadAllData(): void;
    _markAllDataTypeLoadStates(loaded: boolean): void;
    _hasFieldChanged(field: string): boolean;
    _getChangedField(field: string): unknown;

    /**
     *  Get either the unsaved value of a field or the saved value if unchanged since the last save
     */
    _getLatestField(field: string): unknown; // any type of this._ properties

    /**
     * Save old version of data that's being changed, to pass to the notifier
     * @param {String} field
     * @param {} value - Old value for old-style 'changed' fields, and new value for 'changedData' fields
     */
    _markFieldChange(field: string, value: [] | {}): void;

    hasChanged(): boolean;

    /**
     * Clears log of changed values
     * @param {String} [dataType] data type/field to clear. Defaults to clearing everything
     */
    _clearChanged(dataType?: string): void;

    /**
     * Clears field change log
     * @param {String} field
     */
    _clearFieldChange(field: string): void;

    /**
     * Mark a data type as requiring a reload when the current save finishes. The changed state is cleared
     * before the new data is saved to the database (so that further updates during the save process don't
     * get lost), so we need to separately keep track of what changed.
     */
    _markForReload(dataType: string): void;

    /**
     * @param {String} [op='edit'] - Operation to check; if not provided, check edit privileges for
     *     library
     */
    isEditable(op?: string): boolean;

    /**
     * Save changes to database
     *
     * @param {Object} [options]
     * @param {Boolean} [options.skipCache] - Don't save add new object to the cache; if set, object
     *                                         is disabled after save
     * @param {Boolean} [options.skipDateModifiedUpdate]
     * @param {Boolean} [options.skipClientDateModifiedUpdate]
     * @param {Boolean} [options.skipNotifier] - Don't trigger Zotero.Notifier events
     * @param {Boolean} [options.skipSelect] - Don't select object automatically in trees
     * @param {Boolean} [options.skipSyncedUpdate] - Don't automatically set 'synced' to false
     * @return {Promise<Integer|Boolean>}  Promise for itemID of new item,
     *                                     TRUE on item update, or FALSE if item was unchanged
     */
    save(options?: DataObject.SaveOptions): Promise<boolean | number>;
    saveTx(options?: DataObject.SaveOptions): Promise<boolean | number>;
    _saveData(env: unknown): void;
    _finalizeSave(env: unknown): Promise<void>;
    /**
     * Actions to perform after DB transaction
     */
    _postSave(env: unknown): void;
    _recoverFromSaveError(): Promise<void>;

    /**
     * Update object version, efficiently
     *
     * Used by sync code
     *
     * @param {Integer} version
     * @param {Boolean} [skipDB=false]
     */
    updateVersion(version: number, skipDB?: false): void;

    /**
     * Update object sync status, efficiently
     *
     * Used by sync code
     *
     * @param {Boolean} synced
     * @param {Boolean} [skipDB=false]
     */
    updateSynced(synced: boolean, skipDB?: boolean): Promise<void>;

    eraseTx(options?: DataObject.EraseOptions): Promise<boolean>;
    /**
     * Delete object from database
     *
     * @param {Object} [options]
     * @param {Boolean} [options.deleteItems] - Move descendant items to trash (Collection only)
     * @param {Boolean} [options.skipDeleteLog] - Don't add to sync delete log
     */
    erase(options?: DataObject.EraseOptions): Promise<boolean>;

    _finalizeErase(env: unknown): Promise<void>;
    toResponseJSON(options?: {}): {
      key: string;
      version: number;
      meta: _ZoteroTypes.anyObj;
      data: _ZoteroTypes.anyObj;
    };

    /**
     * Generates data object key
     * @return {String} key
     */
    _generateKey(): string;

    _disabledCheck(): void;
  }
}


declare namespace _ZoteroTypes {
  interface DataObjects<T extends Zotero.DataObject = Zotero.DataObject> {
    idColumn: string;
    table: string;
    relationsTable: string;
    primaryFields: string[];
    _primaryDataSQLWhere: "WHERE 1";
    primaryDataSQLFrom: string;
    primaryDataSQL: string;

    init(): Promise<void>;
    _loadIDsAndKeys(): Promise<void>;
    isPrimaryField(field: string): boolean;

    /**
     * Retrieves one or more already-loaded items
     *
     * If an item hasn't been loaded, an error is thrown
     *
     * @param {Array|Integer} ids  An individual object id or an array of object ids
     * @return {Zotero.[Object]|Array<Zotero.[Object]>} A Zotero.[Object], if a scalar id was passed;
     *                                          otherwise, an array of Zotero.[Object]
     */
    get(id: number): T;
    get(ids: number[]): T[];

    /**
     * Retrieves (and loads, if necessary) one or more items
     *
     * @param {Array|Integer} ids  An individual object id or an array of object ids
     * @param {Object} [options]
     * @param {Boolean} [options.noCache=false] - Don't add object to cache after loading
     * @return {Promise<Zotero.DataObject|Zotero.DataObject[]>} - A promise for either a data object,
     *     if a scalar id was passed, or an array of data objects, if an array of ids was passed
     */
    getAsync(id: number, options?: { noCache: boolean }): Promise<T>;
    getAsync(ids: number[], options?: { noCache: boolean }): Promise<T[]>;

    /**
     * Get all loaded objects
     *
     * @return {Zotero.DataObject[]}
     */
    getLoaded(): T[];

    /**
     * Return objects in the trash
     *
     * @param {Integer} libraryID - Library to search
     * @param {Boolean} [asIDs] - Return object ids instead of objects
     * @param {Integer} [days]
     * @param {Integer} [limit]
     * @return {Promise<Zotero.DataObject[]|Integer[]>}
     */
    getDeleted(
      libraryID: number,
      asIDs?: boolean,
      days?: number,
      limit?: number,
    ): Promise<Array<number | T>>;

    getAllIDs(libraryID: number): Promise<number[]>;
    getAllKeys(libraryID: number): Promise<string[]>;
    parseLibraryKey(libraryKey: string): { libraryID: number; key: string };

    /**
     * Retrieves an object by its libraryID and key
     *
     * @param	{Integer}		libraryID
     * @param	{String}			key
     * @return	{Zotero.DataObject}			Zotero data object, or FALSE if not found
     */
    getByLibraryAndKey(
      libraryID: number,
      key: string,
      options?: unknown,
    ): T | false;

    /**
     * Asynchronously retrieves an object by its libraryID and key
     *
     * @param {Integer} libraryID
     * @param {String} key
     * @param {Object} [options]
     * @param {Boolean} [options.noCache=false] - Don't add object to cache after loading
     * @return {Promise<Zotero.DataObject>} - Promise for a data object, or FALSE if not found
     */
    getByLibraryAndKeyAsync(
      libraryID: number,
      key: string,
      options?: { noCache: boolean },
    ): Promise<T | false>;

    exists(id: number): boolean;

    /**
     * @return {Object} Object with 'libraryID' and 'key'
     */
    getLibraryAndKeyFromID(
      id: number,
    ): false | { libraryID: number; key: string };

    getIDFromLibraryAndKey(libraryID: number, key: string): number | false;

    /**
     * @returns Array of id of object
     */
    getOlder(libraryID: number, date: Date): Promise<number[]>;
    /**
     * @returns Array of id of object
     */
    getNewer(
      libraryID: number,
      date: Date,
      ignoreFutureDates?: boolean,
    ): Promise<number[]>;

    /**
     * Gets the latest version for each object of a given type in the given library
     *
     * @return {Promise<Object>} - A promise for an object with object keys as keys and versions
     *                             as properties
     */
    getObjectVersions(
      libraryID: number,
      keys?: string[],
    ): Promise<{ [key: string]: number }>;

    /**
     * Bulk-load data type(s) of given objects if not loaded
     *
     * This would generally be used to load necessary data for cross-library search results, since those
     * results might include objects in libraries that haven't yet been loaded.
     *
     * @param {Zotero.DataObject[]} objects
     * @param {String[]} [dataTypes] - Data types to load, defaulting to all types
     * @return {Promise}
     */
    loadDataTypes(objects: T[], dataTypes?: string[]): Promise<void>;

    /**
     * Loads data for a given data type
     * @param {String} dataType
     * @param {Integer} libraryID
     * @param {Integer[]} [ids]
     */
    _loadDataTypeInLibrary(
      dataType: string,
      libraryID: number,
      ids: number[],
    ): Promise<void>;

    loadAll(libraryID: number, ids?: number[]): Promise<void>;

    /**
     * Sort an array of collections or items from top-level to deepest, grouped by level
     *
     * All top-level objects are returned, followed by all second-level objects, followed by
     * third-level, etc. The order within each level is undefined.
     *
     * This is used to sort higher-level objects first in upload JSON, since otherwise the API would
     * reject lower-level objects for having missing parents.
     *
     * @param {Zotero.DataObject[]} objects - An array of objects
     * @return {Zotero.DataObject[]} - A sorted array of objects
     */
    sortByLevel<T>(objects: T[]): T[];

    /**
     * Sort an array of collections or items from top-level to deepest, grouped by parent
     *
     * Child objects are included before any sibling objects. The order within each level is undefined.
     *
     * This is used to sort higher-level objects first in upload JSON, since otherwise the API would
     * reject lower-level objects for having missing parents.
     *
     * @param {Zotero.DataObject[]} objects - An array of data objects
     * @return {Zotero.DataObject[]} - A sorted array of data objects
     */
    sortByParent<T>(objects: T[]): T[];

    /**
     * Flatten API JSON relations object into an array of unique predicate-object pairs
     *
     * @param {Object} relations - Relations object in API JSON format, with predicates as keys
     *                             and arrays of URIs as objects
     * @return {Array[]} - Predicate-object pairs
     */
    flattenRelations(
      relations: ObjectRelations,
    ): Array<[RelationsPredicate, ZoteroObjectURI]>;

    /**
     * Reload loaded data of loaded objects
     *
     * @param {Array|Number} ids - An id or array of ids
     * @param {Array} [dataTypes] - Data types to reload (e.g., 'primaryData'), or all loaded
     *                              types if not provided
     * @param {Boolean} [reloadUnchanged=false] - Reload even data that hasn't changed internally.
     *                                            This should be set to true for data that was
     *                                            changed externally (e.g., globally renamed tags).
     */
    reload(
      ids: number,
      dataTypes: string[],
      reloadUnchanged?: boolean,
    ): Promise<undefined | true>;

    reloadAll(libraryID: number): Promise<void>;
    registerObject(obj: T): void;
    dropDeadObjectsFromCache(): void;

    /**
     * Clear object from internal array
     *
     * @param	int[]	ids		objectIDs
     */
    unload(ids: number[]): void;

    /**
     * Set the version of objects, efficiently
     *
     * @param {Integer[]} ids - Ids of objects to update
     * @param {Boolean} version
     */
    updateVersion(ids: number[], version: number): Promise<void>;

    /**
     * Set the sync state of objects, efficiently
     *
     * @param {Integer[]} ids - Ids of objects to update
     * @param {Boolean} synced
     */
    updateSynced(ids: number[], synced?: boolean): Promise<void>;

    isEditable(obj: T): boolean;
    getPrimaryDataSQLPart(part: string): string;

    /**
     * Delete one or more objects from the database and caches
     *
     * @param {Integer|Integer[]} ids - Object ids
     * @param {Object} [options] - See Zotero.DataObject.prototype.erase
     * @param {Function} [options.onProgress] - f(progress, progressMax)
     * @return {Promise}
     */
    erase(
      ids: number | number[],
      options?: Zotero.DataObject.EraseOptions & {
        onProgress?: (progress: number, progressMax: number) => void;
      },
    ): Promise<void>;

    _loadIDsAndKeys(): Promise<void>;
  }

  type ObjectType = "collection" | "item" | "search";
}

declare namespace Zotero {
  const DataObjects: _ZoteroTypes.DataObjects;
}


declare namespace Zotero {
  /**
   * Zotero.Feed, extends Zotero.Library
   *
   * Custom parameters:
   * - name - name of the feed displayed in the collection tree
   * - url
   * - cleanupReadAfter - number of days after which read items should be removed
   * - cleanupUnreadAfter - number of days after which unread items should be removed
   * - refreshInterval - in terms of hours
   *
   * @param params
   * @returns Zotero.Feed
   * @constructor
   */
  class Feed extends Zotero.Library {
    constructor(params?: _ZoteroTypes.Feed.Params);
    static prototype: Zotero.Feed;
  }
}

declare namespace _ZoteroTypes {
  namespace Feed {
    interface Params extends _ZoteroTypes.Library.Params {
      name: string;
      url: string;
      refreshInterval: number;
      cleanupReadAfter: boolean;
      cleanupUnreadAfter: boolean;
    }
  }
}


declare namespace Zotero {
  class FeedItem extends Zotero.Item {
    constructor(
      itemTypeOrID?: _ZoteroTypes.Item.ItemType | number,
      params?: object,
    );
  }
}


declare namespace _ZoteroTypes {
  /**
   * Mimics Zotero.Libraries
   */
  interface Feeds extends anyObj {}
}

declare namespace Zotero {
  const Feeds: _ZoteroTypes.Feeds;
}

/**
    ***** BEGIN LICENSE BLOCK *****
    
    Copyright © 2009 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org
    
    This file is part of Zotero.
    
    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    
    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.
    
    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.
    
    ***** END LICENSE BLOCK *****
*/

declare namespace _ZoteroTypes {
  namespace Group {
    /**
     * A parameter object for constructing or updating a Zotero.Group.
     */
    interface GroupParams {
      groupID?: number;
      name?: string;
      description?: string;
      version?: number;
      libraryID?: number;
      /**
       * Will be set to 'group' internally. May be provided externally but not required.
       */
      libraryType?: string;
    }
  }
}

declare namespace Zotero {
  /**
   * A Zotero Group object, extending Zotero.Library, with additional group-specific
   * properties and methods.
   */
  class Group
    extends _ZoteroTypes.Library.LibraryAbstract
    implements _ZoteroTypes.Group.GroupParams
  {
    _childObjectTypes: ["item", "collection", "search"];
    fixedLibraries: ["user"];
    libraryType: "user" | "group" | "feed";
    groupID?: number;
    description?: string;
    version?: number;
    /**
     * Group constructor.
     *
     * @param params - Initial parameters for the group, such as name, description, etc.
     *                 `params.libraryType` will be forced to 'group'.
     */
    constructor(params?: _ZoteroTypes.Group.GroupParams);

    /**
     * Maps database columns to object properties.
     *
     * Non-prototype property:
     *
     * @example
     * Zotero.Group._dbColumns // ['name', 'description', 'version']
     */
    static readonly _dbColumns: ["name", "description", "version"];

    /**
     * A helper method to convert a column name into its corresponding property name.
     *
     * Non-prototype function:
     */
    static _colToProp(c: string): string;

    /**
     * A static definition for selecting columns in SQL.
     *
     * Non-prototype property:
     */
    static readonly _rowSQLSelect: string;

    /**
     * A static definition for the base SELECT SQL for groups.
     *
     * Non-prototype property:
     */
    static readonly _rowSQL: string;

    /**
     * A constant used to label the object type.
     */
    readonly _objectType: "group";

    /**
     * Extends the library types from the super class to include 'group'.
     */
    readonly libraryTypes: ["user", "group"];

    /**
     * Indicates whether this group allows linked files. Always false.
     */
    readonly allowsLinkedFiles: boolean;

    /**
     * Checks if a property name corresponds to a valid group property.
     *
     * @param prop - The property name
     * @returns True if valid group property; otherwise false.
     */
    _isValidGroupProp(prop: string): boolean;

    /**
     * Checks if a property name is valid for this group or its superclass.
     *
     * @param prop - The property name
     * @returns True if valid property; otherwise false.
     */
    _isValidProp(prop: string): boolean;

    /*
     * Populate group data from a database row
     */
    _loadDataFromRow(row: any): void;

    /**
     * Custom setter logic for internal group properties, such as version or name.
     *
     * @param prop - The property name (e.g. '_groupName')
     * @param val - The new value for that property
     * @throws Error on invalid values or disallowed decreases for version
     */
    _set(prop: string, val: any): any;

    /**
     * Reloads group data from the database.
     */
    _reloadFromDB(): Promise<void>;

    /**
     * Initializes a save operation. Checks required fields.
     *
     * @param env - Internal environment for the save operation
     * @returns true if valid for saving, otherwise throws an error
     */
    _initSave(env: any): Promise<boolean>;

    /**
     * Saves changes to the group into the database.
     *
     * @param env - Internal environment for the save operation
     */
    _saveData(env: any): Promise<void>;

    /**
     * Finalizes the save operation, e.g., registering new groups in Zotero.Groups.
     *
     * @param env - Internal environment for the save operation
     */
    _finalizeSave(env: any): Promise<void>;

    /**
     * Finalizes erasing/deleting the group, including unregistering from Zotero.Groups
     * and queueing a delete notification.
     *
     * @param env - Internal environment for the erase operation
     */
    _finalizeErase(env: any): Promise<void>;

    /**
     * Converts the group to a JSON object suitable for responses.
     *
     * @param options - Options object.
     *                  If `options.includeGroupDetails` is true, returns more detail
     */
    toResponseJSON(options?: any): any;

    /**
     * An async variation of `toResponseJSON`. When `options.includeGroupDetails` is set,
     * adds a `meta.numItems` value by querying the database.
     *
     * @param options - Options object
     * @returns A Promise that resolves to the response JSON
     */
    toResponseJSONAsync(options?: any): Promise<any>;

    /**
     * Updates this group from a JSON object, potentially including user-based editing checks.
     *
     * @param json - The JSON object containing updated fields like name or description
     * @param userID - The user attempting to update the group
     */
    fromJSON(json: any, userID?: number): void;

    /**
     * Preps a field for change, marking it as changed and optionally storing previous data.
     *
     * @param field - The internal field name to mark as changed
     */
    _prepFieldChange(field: string): void;
  }
}

declare namespace Zotero {
  /**
   * Contains logic for working with Zotero groups: registration, retrieval,
   * cache management, and permissions.
   */
  namespace Groups {
    /**
     * The URL where a user may add new groups
     */
    const addGroupURL: string;

    /**
     * Registers a new group in the Zotero.Groups cache.
     *
     * @param group - The group object to register
     * @throws Error if cache is not initialized
     */
    function register(group: Group): void;

    /**
     * Unregisters a group by its ID from the Zotero.Groups cache.
     *
     * @param groupID - The group ID
     * @throws Error if cache is not initialized
     */
    function unregister(groupID: number): void;

    /**
     * Initializes the Zotero.Groups cache. This is called from Zotero.Libraries.
     * Returns a Promise that resolves once initialization is complete.
     */
    function init(): Promise<void>;

    /**
     * @param id - Group id
     * @return {Zotero.Group} The group associated with the given ID
     */
    function get(id: number): Group;

    /**
     * Get all groups, sorted by name.
     *
     * @return {Zotero.Group[]} An array of all groups
     * @throws Error if cache is not initialized
     */
    function getAll(): Group[];

    /**
     * Gets a group by its library ID.
     *
     * @param libraryID - The library ID of the group
     * @return {Zotero.Group} The group object
     */
    function getByLibraryID(libraryID: number): Group;

    /**
     * Determines if a group exists in the cache.
     *
     * @param groupID - The group ID to check
     * @returns true if the group is registered; otherwise false
     * @throws Error if cache is not initialized
     */
    function exists(groupID: number): boolean;

    /**
     * Returns the group ID for the given library ID.
     *
     * @param libraryID - The library ID of the group
     * @returns The group ID
     * @throws Error if the group does not exist or cache is not initialized
     */
    function getGroupIDFromLibraryID(libraryID: number): number;

    /**
     * Returns the library ID for the given group ID.
     *
     * @param groupID - The group ID
     * @returns The library ID or false if the group isn't found
     * @throws Error if cache is not initialized
     */
    function getLibraryIDFromGroupID(groupID: number): number | false;

    /**
     * Calculates the permissions for a given group JSON and user.
     *
     * @param json - The JSON containing group data
     * @param userID - The userID to check permissions for
     * @returns An object indicating whether the user can edit the library and files
     * @throws Error if JSON is invalid or userID not provided
     */
    function getPermissionsFromJSON(
      json: _ZoteroTypes.Groups.GroupJSON,
      userID: number,
    ): { editable: boolean; filesEditable: boolean };
  }
}

declare namespace _ZoteroTypes {
  namespace Groups {
    /**
     * The JSON structure that contains group information for permissions.
     */
    interface GroupJSON {
      /**
       * The userID of the group's owner
       */
      owner: number;

      /**
       * Array of userIDs that are admins of this group
       */
      admins?: number[];

      /**
       * Array of userIDs that are members of this group
       */
      members?: number[];

      /**
       * Library editing setting (e.g., 'members', 'none')
       */
      libraryEditing?: string;

      /**
       * File editing setting (e.g., 'members', 'none')
       */
      fileEditing?: string;
    }
  }
}


declare namespace _ZoteroTypes {
  /*
   * Constructor for Item object
   */
  namespace Item {
    type DataType =
      | "primaryData"
      | "creators"
      | "itemData"
      | "note"
      | "annotation"
      | "annotationDeferred"
      | "childItems"
      | "tags"
      | "collections"
      | "relations";
    type ItemType =
      | "attachment-file"
      | "document"
      | "attachment-link"
      | "attachment-pdf"
      | "attachment-pdf-link"
      | "attachment-snapshot"
      | "attachment-web-link"
      | "artwork"
      | "audioRecording"
      | "bill"
      | "blogPost"
      | "book"
      | "bookSection"
      | "case"
      | "computerProgram"
      | "conferencePaper"
      | "dictionaryEntry"
      | "email"
      | "encyclopediaArticle"
      | "film"
      | "forumPost"
      | "hearing"
      | "instantMessage"
      | "interview"
      | "journalArticle"
      | "letter"
      | "magazineArticle"
      | "manuscript"
      | "newspaperArticle"
      | "note"
      | "patent"
      | "preprint"
      | "presentation"
      | "report"
      | "statute"
      | "thesis"
      | "webpage"
      | "map"
      | "podcast"
      | "radioBroadcast"
      | "tvBroadcast"
      | "videoRecording";
    type PrimaryField =
      | "itemID"
      | "itemTypeID"
      | "dateAdded"
      | "dateModified"
      | "libraryID"
      | "key"
      | "version"
      | "synced"
      | "createdByUserID"
      | "lastModifiedByUserID"
      | "firstCreator"
      | "sortCreator"
      | "deleted"
      | "inPublications"
      | "parentID"
      | "parentKey"
      | "attachmentCharset"
      | "attachmentLinkMode"
      | "attachmentContentType"
      | "attachmentPath"
      | "attachmentSyncState"
      | "attachmentSyncedModificationTime"
      | "attachmentSyncedHash"
      | "attachmentLastProcessedModificationTime"
      | "feedItemGUID"
      | "feedItemReadTime"
      | "feedItemTranslatedTime";
    type ItemField =
      | "title"
      | "firstCreator"
      | "abstractNote"
      | "artworkMedium"
      | "medium"
      | "artworkSize"
      | "date"
      | "language"
      | "shortTitle"
      | "archive"
      | "archiveLocation"
      | "libraryCatalog"
      | "callNumber"
      | "url"
      | "accessDate"
      | "rights"
      | "extra"
      | "audioRecordingFormat"
      | "seriesTitle"
      | "volume"
      | "numberOfVolumes"
      | "place"
      | "label"
      | "publisher"
      | "runningTime"
      | "ISBN"
      | "billNumber"
      | "number"
      | "code"
      | "codeVolume"
      | "section"
      | "codePages"
      | "pages"
      | "legislativeBody"
      | "session"
      | "history"
      | "blogTitle"
      | "publicationTitle"
      | "websiteType"
      | "type"
      | "series"
      | "seriesNumber"
      | "edition"
      | "numPages"
      | "bookTitle"
      | "caseName"
      | "court"
      | "dateDecided"
      | "docketNumber"
      | "reporter"
      | "reporterVolume"
      | "firstPage"
      | "versionNumber"
      | "system"
      | "company"
      | "programmingLanguage"
      | "proceedingsTitle"
      | "conferenceName"
      | "DOI"
      | "dictionaryTitle"
      | "subject"
      | "encyclopediaTitle"
      | "distributor"
      | "genre"
      | "videoRecordingFormat"
      | "forumTitle"
      | "postType"
      | "committee"
      | "documentNumber"
      | "interviewMedium"
      | "issue"
      | "seriesText"
      | "journalAbbreviation"
      | "ISSN"
      | "letterType"
      | "manuscriptType"
      | "mapType"
      | "scale"
      | "country"
      | "assignee"
      | "issuingAuthority"
      | "patentNumber"
      | "filingDate"
      | "applicationNumber"
      | "priorityNumbers"
      | "issueDate"
      | "references"
      | "legalStatus"
      | "episodeNumber"
      | "audioFileType"
      | "repository"
      | "archiveID"
      | "citationKey"
      | "presentationType"
      | "meetingName"
      | "programTitle"
      | "network"
      | "reportNumber"
      | "reportType"
      | "institution"
      | "nameOfAct"
      | "codeNumber"
      | "publicLawNumber"
      | "dateEnacted"
      | "thesisType"
      | "university"
      | "studio"
      | "websiteTitle";

    // [...new Set(Object.values(Zotero.ItemTypes._types).map(t => `${t.id}: "${t.name}"`))].join(';\n')
    type ItemTypeMapping = {
      1: "annotation";
      2: "artwork";
      3: "attachment";
      4: "audioRecording";
      5: "bill";
      6: "blogPost";
      7: "book";
      8: "bookSection";
      9: "case";
      10: "computerProgram";
      11: "conferencePaper";
      12: "dictionaryEntry";
      13: "document";
      14: "email";
      15: "encyclopediaArticle";
      16: "film";
      17: "forumPost";
      18: "hearing";
      19: "instantMessage";
      20: "interview";
      21: "journalArticle";
      22: "letter";
      23: "magazineArticle";
      24: "manuscript";
      25: "map";
      26: "newspaperArticle";
      27: "note";
      28: "patent";
      29: "podcast";
      30: "preprint";
      31: "presentation";
      32: "radioBroadcast";
      33: "report";
      34: "statute";
      35: "thesis";
      36: "tvBroadcast";
      37: "videoRecording";
      38: "webpage";
      39: "dataset";
      40: "standard";
    };

    type CreatorTypeMapping = {
      1: "artist";
      2: "contributor";
      3: "performer";
      4: "composer";
      5: "wordsBy";
      6: "sponsor";
      7: "cosponsor";
      8: "author";
      9: "commenter";
      10: "editor";
      11: "translator";
      12: "seriesEditor";
      13: "bookAuthor";
      14: "counsel";
      15: "programmer";
      16: "reviewedAuthor";
      17: "recipient";
      18: "director";
      19: "scriptwriter";
      20: "producer";
      21: "interviewee";
      22: "interviewer";
      23: "cartographer";
      24: "inventor";
      25: "attorneyAgent";
      26: "podcaster";
      27: "guest";
      28: "presenter";
      29: "castMember";
    };

    type CreatorTypeID = keyof CreatorTypeMapping;
    type CreatorType = CreatorTypeMapping[keyof CreatorTypeMapping];

    /**
     * Creator json for API
     * When Creator.fieldMode == 1, CreatorJSON.name == string,
     * else CreatosJSON.firstName and Creator.lastName == string
     */
    interface CreatorJSON {
      creatorType: CreatorTypeMapping[keyof CreatorTypeMapping];
      firstName?: string;
      name?: string;
      lastName?: string;
    }
    interface Creator {
      creatorTypeID: keyof CreatorTypeMapping;
      fieldMode: 0 | 1;
      firstName: string;
      lastName: string;
    }
  }
}

declare namespace Zotero {
  class Item extends Zotero.DataObject {
    static prototype: Zotero.Item;
    constructor(
      itemTypeOrID?:
        | keyof _ZoteroTypes.Item.ItemTypeMapping
        | _ZoteroTypes.Item.ItemTypeMapping[keyof _ZoteroTypes.Item.ItemTypeMapping],
    );
    _objectType: "item";
    readonly ContainerObjectsClass: Zotero.Collection;
    id: number;
    key: string;
    libraryID: number;
    dateAdded: string;
    dateModified: string;
    version: number;
    synced: boolean;
    inPublications: boolean;
    createdByUserID?: number;
    lastModifiedByUserID?: number;
    readonly itemTypeID: number;
    readonly itemType: _ZoteroTypes.Item.ItemType;
    parentItemID?: number | false;
    parentItemKey?: string | false;
    readonly parentItem?: Zotero.Item;
    readonly topLevelItem: Zotero.Item;
    readonly firstCreator: string;
    readonly sortCreator: string;
    readonly relatedItems: string[];
    readonly treeViewID: number;
    readonly note: string;
    isFeedItem: boolean;

    loadAllData(reload?: boolean): Promise<void>;

    isRegularItem(): boolean;
    isTopLevelItem(): boolean;

    ////////////////////////////////////////////////////////
    //
    //
    // Attachment methods
    //
    // save() is not required for attachment functions
    //
    //
    ///////////////////////////////////////////////////////

    /**
     * Determine if an item is an attachment
     **/
    isAttachment(): boolean;

    /**
     * Determine if an item is an annotation
     *
     * @return {Boolean}
     **/
    isAnnotation(): boolean;

    /**
     * @return {Boolean} - Returns true if item is a snapshot
     */
    isSnapshotAttachment(): boolean;

    /**
     * @return {Boolean} - Returns true if item is a stored or linked PDF attachment
     */
    isPDFAttachment(): boolean;

    isEmbeddedImageAttachment(): boolean;
    isImportedAttachment(): boolean;
    isStoredFileAttachment(): boolean;
    isWebAttachment(): boolean;
    isFileAttachment(): boolean;
    isLinkedFileAttachment(): boolean;

    /**
     * @return {Boolean} - Returns true if item is a stored or linked EPUB attachment
     */
    isEPUBAttachment(): boolean;

    /**
     * @return {Boolean} - Returns true if item is a stored or linked image attachment
     */
    isImageAttachment(): boolean;

    /**
     * @return {Boolean} - Returns true if item is a stored or linked video attachment
     */
    isVideoAttachment(): boolean;

    /**
     * Returns number of child attachments of item
     *
     * @param	{Boolean}	includeTrashed		Include trashed child items in count
     * @return	<Integer>
     */
    numAttachments(includeTrashed?: boolean): number;

    /**
     * Returns the number of file attachments of an item
     *
     * @return <Integer>
     */
    numFileAttachments(): number;

    addTag(name: string, type: number): boolean;
    removeTag(tag: string): boolean;
    // Only regular item
    addToCollection(id: number): void;
    getCollections(): number[];
    numChildren(includeTrashed?: boolean): number;
    numNonHTMLFileAttachments(): number;
    numPDFAttachments(): number;
    numAnnotations(includeTrashed?: boolean): number;

    /**
     * Returns number of child attachments of item
     *
     * @param	{Boolean}	includeTrashed		Include trashed child items in count
     * @return	<Integer>
     */
    numAttachments(includeTrashed?: boolean): number;

    isFieldOfBase(
      field: _ZoteroTypes.Item.ItemField | number,
      baseField: _ZoteroTypes.Item.ItemField | number,
    ): boolean;

    /**
     * Retrieves an itemData field value
     *
     * @param {String|Integer} field fieldID or fieldName
     * @param {Boolean} [unformatted] Skip any special processing of DB value
     *   (e.g. multipart date field)
     * @param {Boolean} includeBaseMapped If true and field is a base field, returns
     *   value of type-specific field instead
     *   (e.g. 'label' for 'publisher' in 'audioRecording')
     * @return {String} Value as string or empty string if value is not present
     */
    getField(
      field: _ZoteroTypes.Item.ItemField | number,
      unformatted?: boolean,
      includeBaseMapped?: boolean,
    ): string;
    getField(
      field: string,
      unformatted?: boolean,
      includeBaseMapped?: boolean,
    ): string;

    getExtraField(fieldName: string): string;

    /**
     * @param	{Boolean} asNames
     * @return	{Integer[]|String[]}
     */
    getUsedFields(asNames?: false): number[];
    getUsedFields(asNames: true): string[];

    /*
     * Populate basic item data from a database row
     */
    loadFromRow(
      row: { [col in _ZoteroTypes.Item.PrimaryField]?: unknown },
      reload?: boolean,
    ): void;

    /*
     * Set or change the item's type
     */
    setType(itemTypeID: number, loadIn?: boolean): boolean;

    /*
     * Find existing fields from current type that aren't in another
     *
     * If _allowBaseConversion_, don't return fields that can be converted
     * via base fields (e.g. label => publisher => studio)
     */
    getFieldsNotInType(
      itemTypeID: number,
      allowBaseConversion?: boolean,
    ): number[];

    /*
     * Set a field value, loading existing itemData first if necessary
     *
     * Field can be passed as fieldID or fieldName
     */
    setField(
      field: _ZoteroTypes.Item.ItemField | number,
      value: string | number | boolean,
      loadIn?: boolean,
    ): void;
    setField(
      field: string,
      value: string | number | boolean,
      loadIn?: boolean,
    ): void;

    /*
     * Get the title for an item for display in the interface
     *
     * This is the same as the standard title field (with includeBaseMapped on)
     * except for letters and interviews, which get placeholder titles in
     * square braces (e.g. "[Letter to Thoreau]"), and cases
     */
    getDisplayTitle(): string;

    /**
     * Update the generated display title from the loaded data
     */
    updateDisplayTitle(): void;

    /*
     * Returns the number of creators for this item
     */
    numCreators(): number;

    hasCreatorAt(pos: number): boolean;

    /**
     * @param  {Integer} pos
     * @return {Object|Boolean} The internal creator data object at the given position, or FALSE if none
     */
    getCreator(pos: number): _ZoteroTypes.Item.Creator | false;

    /**
     * @param  {Integer} pos
     * @return {Object|Boolean} The API JSON creator data at the given position, or FALSE if none
     */
    getCreatorJSON(pos: number): _ZoteroTypes.Item.CreatorJSON;

    /**
     * Returns creator data in internal format
     *
     * @return {Array<Object>}  An array of internal creator data objects
     *                          ('firstName', 'lastName', 'fieldMode', 'creatorTypeID')
     */
    getCreators(): _ZoteroTypes.Item.Creator[];

    /**
     * @return {Array<Object>} An array of creator data objects in API JSON format
     *                         ('firstName'/'lastName' or 'name', 'creatorType')
     */
    getCreatorsJSON(): _ZoteroTypes.Item.CreatorJSON[];

    /**
     * Set or update the creator at the specified position
     *
     * @param {Integer} orderIndex
     * @param {Object} Creator data in internal or API JSON format:
     *                   <ul>
     *                     <li>'name' or 'firstName'/'lastName', or 'firstName'/'lastName'/'fieldMode'</li>
     *                     <li>'creatorType' (can be name or id) or 'creatorTypeID'</li>
     *                   </ul>
     * @param {Object} [options]
     * @param {Boolean} [options.strict] - Throw on invalid creator type
     */
    setCreator(
      orderIndex: number,
      data: _ZoteroTypes.Item.CreatorJSON | _ZoteroTypes.Item.Creator,
      options?: { strict: boolean },
    ): boolean;

    /**
     * @param {Object[]} data - An array of creator data in internal or API JSON format
     */
    setCreators(
      data: Array<_ZoteroTypes.Item.CreatorJSON | _ZoteroTypes.Item.Creator>,
      options?: { strict: boolean },
    ): void;

    /*
     * Remove a creator and shift others down
     */
    removeCreator(orderIndex: number, allowMissing?: boolean): never | true;

    /**
     * Relate this item to another. A separate save is required.
     *
     * @param {Zotero.Item} item
     * @return {Boolean}
     */
    addRelatedItem(item: Zotero.Item): boolean;

    removeRelatedItem(item: Zotero.Item): Promise<boolean>;

    /**
     * @param {String} [op='edit'] - Operation to check; if not provided, check edit privileges for
     *     library
     */
    isEditable(op?: "edit" | "erase"): boolean;

    /**
     * Returns child attachments of this item
     *
     * @param	{Boolean}	includeTrashed		Include trashed child items
     * @return	{Integer[]}						Array of itemIDs
     */
    getAttachments(includeTrashed?: boolean): number[];

    /**
     * Looks for attachment in the following order: oldest PDF attachment matching parent URL,
     * oldest non-PDF attachment matching parent URL, oldest PDF attachment not matching URL,
     * old non-PDF attachment not matching URL
     *
     * @return {Promise<Zotero.Item|FALSE>} - A promise for attachment item or FALSE if none
     */
    getBestAttachment(): Promise<Zotero.Item | false>;

    /**
     * Looks for attachment in the following order: oldest PDF attachment matching parent URL,
     * oldest PDF attachment not matching parent URL, oldest non-PDF attachment matching parent URL,
     * old non-PDF attachment not matching parent URL
     *
     * @return {Promise<Zotero.Item[]>} - A promise for an array of Zotero items
     */
    getBestAttachments(): Promise<Zotero.Item[]>;

    /**
     * Return state of best attachment (or this item if it's a standalone attachment)
     *
     * @return {Promise<Object>} - Promise for object with string 'type' ('none'|'pdf'|'snapshot'|'other')
     *     and boolean 'exists'
     */
    getBestAttachmentState(): Promise<{
      type: "none" | "pdf" | "snapshot" | "other";
      exists: boolean;
    }>;

    /**
     * Return cached state of best attachment for use in items view
     *
     * @return {Object|null} - Resolved value from getBestAttachmentState() or { type: null } if
     *     unavailable
     */
    getBestAttachmentStateCached():
      | { type: "none" | "pdf" | "snapshot" | "other"; exists: boolean }
      | { type: null };

    clearBestAttachmentState(): void;

    // Only image annotation & attachment item
    isImportedAttachment(): boolean;
    isStoredFileAttachment(): boolean;
    isWebAttachment(): boolean;
    isFileAttachment(): boolean;
    isLinkedFileAttachment(): boolean;
    isEmbeddedImageAttachment(): boolean;

    /**
     * @return {Boolean} - Returns true if item is a snapshot
     */
    isSnapshotAttachment(): boolean;

    /**
     * @return {Boolean} - Returns true if item is a stored or linked PDF attachment
     */
    isPDFAttachment(): boolean;

    /**
     * Get the absolute file path for the attachment
     *
     * @return {string|false} - The absolute file path of the attachment, or false for invalid paths
     */
    getFilePath(): string | false;

    /**
     * Get the absolute path for the attachment, if the file exists
     *
     * @return {Promise<String|false>} - A promise for either the absolute path of the attachment
     *                                   or false for invalid paths or if the file doesn't exist
     */
    getFilePathAsync(): Promise<string | false>;

    /**
     * Update file existence state of this item and best attachment state of parent item
     */
    _updateAttachmentStates(exists: boolean): void;

    /**
     * Asynchronous check for file existence
     */
    fileExists(): Promise<boolean>;

    /**
     * Rename file associated with an attachment
     *
     * @param {String} newName
     * @param {Boolean} [overwrite=false] - Overwrite file if one exists
     * @param {Boolean} [unique=false] - Add suffix to create unique filename if necessary
     * @return {Number|false} -- true - Rename successful
     *                           -1 - Destination file exists; use _force_ to overwrite
     *                           -2 - Error renaming
     *                           false - Attachment file not found
     */
    renameAttachmentFile(
      newName: string,
      overwrite?: boolean,
      unique?: boolean,
    ): Promise<boolean | -1 | -2>;

    /**
     * @param {string} path  File path
     * @param {Boolean} [skipItemUpdate] Don't update attachment item mod time, so that item doesn't
     *     sync. Used when a file needs to be renamed to be accessible but the user doesn't have
     *     access to modify the attachment metadata. This also allows a save when the library is
     *     read-only.
     */
    relinkAttachmentFile(
      path: string,
      skipItemUpdate?: boolean,
    ): Promise<boolean>;

    deleteAttachmentFile(): Promise<boolean>;

    /*
     * Return a file:/// URL path to files and snapshots
     */
    getLocalFileURL(): string;

    readonly attachmentReaderType: keyof _ZoteroTypes.Reader.ViewTypeMap;

    /**
     * Link mode of an attachment
     *
     * Possible values specified as constants in Zotero.Attachments
     * (e.g. Zotero.Attachments.LINK_MODE_LINKED_FILE)
     */
    attachmentLinkMode: _ZoteroTypes.Attachments.LinkMode;

    /**
     * Content type of an attachment (e.g. 'text/plain')
     */
    attachmentContentType: string;

    /**
     * Character set of an attachment
     */
    attachmentCharset: string;

    /**
     * Get or set the filename of file attachments
     *
     * This will return the filename for all file attachments, but the filename can only be set
     * for stored file attachments. Linked file attachments should be set using .attachmentPath.
     */
    attachmentFilename: string;

    /**
     * Returns raw attachment path string as stored in DB
     * (e.g., "storage:foo.pdf", "attachments:foo/bar.pdf", "/Users/foo/Desktop/bar.pdf")
     *
     * Can be set as absolute path or prefixed string ("storage:foo.pdf")
     */
    attachmentPath: string;

    attachmentSyncState:
      | number
      | (
          | "to_upload"
          | "to_download"
          | "in_sync"
          | "force_upload"
          | "force_download"
          | "in_conflict"
        );
    attachmentSyncedModificationTime: number;
    attachmentSyncedHash: string;
    attachmentLastProcessedModificationTime: number;
    getAttachmentLastPageIndex(): number;
    setAttachmentLastPageIndex(val: number): Promise<boolean>;

    /**
     * Get the key for the item's pageIndex synced setting
     *
     * E.g., 'lastPageIndex_u_ABCD2345' or 'lastPageIndex_g123_ABCD2345'
     */
    _getLastPageIndexSettingKey(ignoreInvalid?: boolean): string;

    /**
     * Modification time of an attachment file
     *
     * Note: This is the mod time of the file itself, not the last-known mod time
     * of the file on the storage server as stored in the database
     *
     * @return {Promise<Number|undefined>} File modification time as timestamp in milliseconds,
     *                                     or undefined if no file
     */
    readonly attachmentModificationTime: Promise<number | undefined>;

    /**
     * MD5 hash of an attachment file
     *
     * Note: This is the hash of the file itself, not the last-known hash
     * of the file on the storage server as stored in the database
     *
     * @return {Promise<String>} - MD5 hash of file as hex string
     */
    readonly attachmentHash: Promise<string>;

    /**
     * Return plain text of attachment content
     *
     * - Currently works on HTML, PDF and plaintext attachments
     * - Paragraph breaks will be lost in PDF content
     *
     * @return {Promise<String>} - A promise for attachment text or empty string if unavailable
     */
    readonly attachmentText: Promise<string>;

    /**
     * Return dataURI of attachment content
     *
     * @return {Promise<String>} - A promise for attachment dataURI or empty string if unavailable
     */
    readonly attachmentDataURI: Promise<string>;

    // Only notes
    /**
     * Set an item note
     *
     * Note: This can only be called on notes and attachments
     */
    setNote(content: string): boolean;

    getNoteTitle(): string;

    /**
     * Determine if an item is a note
     */
    isNote(): boolean;

    /**
     * Returns number of child notes of item
     *
     * @param	{Boolean}	includeTrashed		Include trashed child items in count
     * @param	{Boolean}	includeEmbedded		Include notes embedded in attachments
     * @return	{Integer}
     */
    numNotes(includeTrashed?: boolean, includeEmbedded?: boolean): number;

    /**
     * Get the first line of the note for display in the items list
     *
     * @return	{String}
     */
    getNoteTitle(): string;

    /**
     * Get the text of an item note
     **/
    getNote(): string;

    /**
     * Returns child notes of this item
     *
     * @param	{Boolean}	includeTrashed		Include trashed child items
     * @param	{Boolean}	includeEmbedded		Include embedded attachment notes
     * @return	{Integer[]}						Array of itemIDs
     */
    getNotes(includeTrashed?: boolean): number[];

    hasNote(): Promise<boolean>;

    // Only Annotation
    getAnnotations(
      /**
       * Include trashed items.
       * @default true
       */
      includeTrashed?: boolean,
    ): Zotero.Item[];

    annotationType: _ZoteroTypes.Annotations.AnnotationType;
    annotationAuthorName: string;
    annotationComment: string;
    annotationText: string;
    annotationPosition: string;
    annotationColor: string;
    annotationPageLabel: string;
    annotationSortIndex: number;
    annotationIsExternal: boolean;

    isAnnotationSupportingImage(): boolean;

    /**
     * Returns child annotations for an attachment item
     *
     * @param {Boolean} [includeTrashed=false] - Include annotations in trash
     * @return {Zotero.Item[]}
     */
    getAnnotations(includeTrashed?: boolean): Zotero.Item[];

    /**
     * Determine if the item is a PDF attachment that exists on disk and contains
     * embedded markup annotations.
     *
     * @return {Promise<Boolean>}
     */
    hasEmbeddedAnnotations(): Promise<boolean>;

    //
    // Methods dealing with item tags
    //

    /**
     * Returns all tags assigned to an item
     *
     * @return {Array} Array of tag data in API JSON format
     */
    getTags(): Array<{ tag: string; type?: number }>;

    /**
     * Check if the item has a given tag
     *
     * @param {String} tagName
     * @return {Boolean}
     */
    hasTag(tagName: string): boolean;

    /**
     * Get the assigned type for a given tag of the item
     */
    getTagType(tagName: string): number | null;

    /**
     * Set the item's tags
     *
     * A separate save() is required to update the database.
     *
     * @param {String[]|Object[]} tags - Array of strings or object in API JSON format
     *                                   (e.g., [{tag: 'tag', type: 1}])
     */
    setTags(tags: Array<string | { tag: string; type: number }>): void;

    /**
     * Add a single tag to the item. If type is 1 and an automatic tag with the same name already
     * exists, replace it with a manual one.
     *
     * A separate save() is required to update the database.
     *
     * @param {String} name
     * @param {Number} [type=0]
     * @return {Boolean} - True if the tag was added; false if the item already had the tag
     */
    addTag(name: string, type?: number): boolean;

    /**
     * Replace an existing tag with a new manual tag
     *
     * A separate save() is required to update the database.
     *
     * @param {String} oldTag
     * @param {String} newTag
     */
    replaceTag(oldTag: string, newTag: string): boolean;

    /**
     * Remove a tag from the item
     *
     * A separate save() is required to update the database.
     *
     * @param {String} tagName
     * @return {Boolean} - True if the tag was removed; false if the item didn't have the tag
     */
    removeTag(tagName: string): boolean;

    /**
     * Remove all tags from the item
     *
     * A separate save() is required to update the database.
     */
    removeAllTags(): void;

    //
    // Methods dealing with collections
    //

    /**
     * Gets the collections the item is in
     *
     * @return {Array<Integer>}  An array of collectionIDs for all collections the item belongs to
     */
    getCollections(): number[];

    /**
     * Sets the collections the item is in
     *
     * A separate save() (with options.skipDateModifiedUpdate, possibly) is required to save changes.
     *
     * @param {Array<String|Integer>} collectionIDsOrKeys Collection ids or keys
     */
    setCollections(collectionIDsOrKeys: Array<string | number>): void;

    /**
     * Add this item to a collection
     *
     * A separate save() (with options.skipDateModifiedUpdate, possibly) is required to save changes.
     *
     * @param {Number} collectionID
     */
    addToCollection(collectionIDOrKey: number | string): void;

    /**
     * Remove this item from a collection
     *
     * A separate save() (with options.skipDateModifiedUpdate, possibly) is required to save changes.
     *
     * @param {Number} collectionID
     */
    removeFromCollection(collectionIDOrKey: number | string): void;

    /**
     * Determine whether the item belongs to a given collectionID
     */
    inCollection(collectionID: number): boolean;

    /**
     * Update item deleted (i.e., trash) state without marking as changed or modifying DB
     *
     * This is used by Zotero.Items.trash().
     *
     * Database state must be set separately!
     *
     * @param {Boolean} deleted
     */
    setDeleted(deleted?: boolean): void;

    /**
     * Update item publications state without marking as changed or modifying DB
     *
     * This is used by Zotero.Items.addToPublications()/removeFromPublications()
     *
     * Database state must be set separately!
     *
     * @param {Boolean} inPublications
     */
    setPublications(inPublications: boolean): void;

    getItemTypeIconName(): _ZoteroTypes.Item.ItemType;
    getImageSrc(): _ZoteroTypes.IconURI;

    /**
     * Return tags and colors
     *
     * @return {Object[]} - Array of object with 'tag' and 'color' properties
     */
    getColoredTags(): { tag: string; color: string };

    /**
     * Compare multiple items against this item and return fields that differ
     *
     * Currently compares only item data, not primary fields
     */
    multiDiff(
      otherItems: Zotero.Item[],
      ignoreFields?: string[],
    ):
      | false
      | {
          [field in _ZoteroTypes.Item.ItemField]?: Array<
            string | _ZoteroTypes.anyObj
          >;
        };

    /**
     * Returns an unsaved copy of the item without itemID and key
     *
     * This is used to duplicate items and copy them between libraries.
     *
     * @param {Number} [libraryID] - libraryID of the new item, or the same as original if omitted
     * @param {Boolean} [options.skipTags=false] - Skip tags
     * @param {Boolean} [options.includeCollections=false] - Add new item to all collections
     * @return {Zotero.Item}
     */
    clone(
      libraryID: number,
      options?: { skipTags?: boolean; includeCollections?: boolean },
    ): Zotero.Item;

    /**
     * @param {Integer} libraryID
     * @return {Zotero.Item} - New item
     */
    moveToLibrary(
      libraryID: number,
      onSkippedAttachment?: boolean,
    ): Promise<Zotero.Item>;

    isCollection(): false;

    /**
     * Populate the object's data from an API JSON data object
     *
     * @param {Object} json
     * @param {Object} [options]
     * @param {Boolean} [options.strict = false] - Throw on unknown field or invalid field for type
     */
    fromJSON(json: object, options?: { strict: boolean }): void;

    toJSON(options?: object): {
      [field in _ZoteroTypes.Item.ItemField]: string | unknown;
    };

    /**
     * Migrate valid fields in Extra to real fields
     *
     * A separate save is required
     */
    migrateExtraFields(): boolean;

    /**
     * Return an item in the specified library equivalent to this item
     *
     * @return {Promise<Zotero.Item>}
     */
    getLinkedItem(
      libraryID: number,
      bidirectional?: boolean,
    ): Promise<Zotero.Item | false>;

    /**
     * Add a linked-object relation pointing to the given item
     *
     * Does not require a separate save()
     *
     * @return {Promise}
     */
    addLinkedItem(item: Zotero.Item): Promise<boolean>;

    /**
     * Update createdByUserID/lastModifiedByUserID, efficiently
     *
     * Used by sync code
     */
    updateCreatedByUser(
      createdByUserID: number,
      lastModifiedByUserID: number,
    ): Promise<void>;
  }
}


declare namespace _ZoteroTypes {
  /*
   * Primary interface for accessing Zotero items
   */
  interface Items extends DataObjects<Zotero.Item> {
    [attr: string]: any;
    _ZDO_object: "item";
    _objectCache: { [i: number]: Zotero.Item };
    ObjectClass: Zotero.Item;

    /**
     * This needs to wait until all Zotero components are loaded to initialize,
     * but otherwise it can be just a simple property
     */
    _primaryDataSQLParts: {
      itemID: "O.itemID";
      itemTypeID: "O.itemTypeID";
      dateAdded: "O.dateAdded";
      dateModified: "O.dateModified";
      libraryID: "O.libraryID";
      key: "O.key";
      version: "O.version";
      synced: "O.synced";

      createdByUserID: "createdByUserID";
      lastModifiedByUserID: "lastModifiedByUserID";

      firstCreator: string;
      sortCreator: string;

      deleted: "DI.itemID IS NOT NULL AS deleted";
      inPublications: "PI.itemID IS NOT NULL AS inPublications";

      parentID: string;

      attachmentCharset: "CS.charset AS attachmentCharset";
      attachmentLinkMode: "IA.linkMode AS attachmentLinkMode";
      attachmentContentType: "IA.contentType AS attachmentContentType";
      attachmentPath: "IA.path AS attachmentPath";
      attachmentSyncState: "IA.syncState AS attachmentSyncState";
      attachmentSyncedModificationTime: "IA.storageModTime AS attachmentSyncedModificationTime";
      attachmentSyncedHash: "IA.storageHash AS attachmentSyncedHash";
      attachmentLastProcessedModificationTime: "IA.lastProcessedModificationTime AS attachmentLastProcessedModificationTime";
    };

    _relationsTable: "itemRelations";

    /**
     * @param {Integer} libraryID
     * @return {Promise<Boolean>} - True if library has items in trash, false otherwise
     */
    hasDeleted(libraryID: number): Promise<boolean>;

    get(ids: number | string): Zotero.Item;
    get(ids: number[] | string[]): Zotero.Item[];

    getAsync(ids: number | string): Promise<Zotero.Item>;
    getAsync(ids: number[] | string[]): Promise<Zotero.Item[]>;

    /**
     * Returns all items in a given library
     *
     * @param  {Integer}  libraryID
     * @param  {Boolean}  [onlyTopLevel=false]   If true, don't include child items
     * @param  {Boolean}  [includeDeleted=false] If true, include deleted items
     * @param  {Boolean}  [asIDs=false] 		 If true, resolves only with IDs
     * @return {Promise<Array<Zotero.Item|Integer>>}
     */
    getAll(
      libraryID: number,
      onlyTopLevel?: boolean,
      includeDeleted?: boolean,
      asIDs?: false,
    ): Promise<Zotero.Item[]>;
    getAll(
      libraryID: number,
      onlyTopLevel: boolean,
      includeDeleted: boolean,
      asIDs: true,
    ): Promise<number[]>;

    /**
     * Zotero.Utilities.Internal.getAsyncInputStream-compatible generator that yields item data
     * in web API format as strings
     *
     * @param {Object} params - Request parameters from Zotero.API.parsePath()
     */
    apiDataGenerator(params: object): Promise<string>;

    /**
     * Copy child items from one item to another (e.g., in another library)
     *
     * Requires a transaction
     */
    copyChildItems(fromItem: Zotero.Item, toItem: Zotero.Item): Promise<void>;

    /**
     * Move child items from one item to another
     *
     * Requires a transaction
     *
     * @param {Zotero.Item} fromItem
     * @param {Zotero.Item} toItem
     * @param {Boolean} [includeTrashed=false]
     * @return {Promise}
     */
    moveChildItems(
      fromItem: Zotero.Item,
      toItem: Zotero.Item,
      includeTrashed?: boolean,
    ): Promise<void>;

    merge(item: Zotero.Item, otherItems: Zotero.Item[]): Promise<any>;

    /**
     * Hash each attachment of the provided item. Return a map from hashes to
     * attachment IDs.
     *
     * @param {Zotero.Item} item
     * @param {String} hashType 'bytes' or 'text'
     * @return {Promise<Map<String, String>>}
     */
    _hashItem(
      item: Zotero.Item,
      hashType: "bytes" | "text",
    ): Promise<Map<string, string>>;

    /**
     * Hash an attachment by the most common words in its text.
     * @param {Zotero.Item} attachment
     * @return {Promise<String>}
     */
    _hashAttachmentText(attachment: Zotero.Item): Promise<string>;

    /**
     * Get the n most common words in s in descending order of frequency.
     * If s contains fewer than n unique words, the size of the returned array
     * will be less than n.
     *
     * @param {String} s
     * @param {Number} n
     * @return {String[]}
     */
    _getMostCommonWords(s: string, n: number): string[];

    /**
     * Move fromItem's embedded note, if it has one, to toItem.
     * If toItem already has an embedded note, the note will be added as a new
     * child note item on toItem's parent.
     * Requires a transaction.
     */
    _moveEmbeddedNote(
      fromItem: Zotero.Item,
      toItem: Zotero.Item,
    ): Promise<void>;

    /**
     * Move fromItem's relations to toItem as part of a merge.
     * Requires a transaction.
     *
     * @param {Zotero.Item} fromItem
     * @param {Zotero.Item} toItem
     * @return {Promise}
     */
    _moveRelations(fromItem: Zotero.Item, toItem: Zotero.Item): Promise<void>;

    trash(ids: number | number[]): Promise<void>;
    trashTx(ids: number | number[]): Promise<void>;

    /**
     * @param {Integer} libraryID - Library to delete from
     * @param {Object} [options]
     * @param {Function} [options.onProgress] - fn(progress, progressMax)
     * @param {Integer} [options.days] - Only delete items deleted more than this many days ago
     * @param {Integer} [options.limit] - Number of items to delete
     * @returns deleted items count
     */
    emptyTrash(
      libraryID: number,
      options?: {
        onProgress?: (progress: number, progressMax: number) => void;
        days?: number;
        limit?: number;
      },
    ): Promise<number>;

    addToPublications(items: Zotero.Item[], options?: object): Promise<void>;
    removeFromPublications(items: Zotero.Item[]): Promise<void>;
    purge(): Promise<void>; // Purge unused data values

    /**
     * Return a firstCreator string from internal creators data (from Zotero.Item::getCreators()).
     *
     * Used in Zotero.Item::getField() for unsaved items
     *
     * @param {Integer} itemTypeID
     * @param {Object} creatorsData
     * @return {String}
     */
    getFirstCreatorFromData(
      itemTypeID: number,
      creatorsData: _ZoteroTypes.Item.Creator[],
    ): string;

    /**
     * Get the top-level items of all passed items
     *
     * @param {Zotero.Item[]} items
     * @return {Zotero.Item[]}
     */
    getTopLevel(items: Zotero.Item[]): Zotero.Item[];

    /**
     * Return an array of items with descendants of selected top-level items removed
     *
     * Non-top-level items that aren't descendents of selected items are kept.
     *
     * @param {Zotero.Item[]}
     * @return {Zotero.Item[]}
     */
    keepTopLevel(items: Zotero.Item[]): Zotero.Item[];

    getSortTitle(title: string | number): string;

    /**
     * Find attachment items whose paths begin with the passed `pathPrefix` and don't exist on disk
     *
     * @param {Number} libraryID
     * @param {String} pathPrefix
     * @return {Zotero.Item[]}
     */
    findMissingLinkedFiles(
      libraryID: number,
      pathPrefix: string,
    ): Promise<Zotero.Item[]>;
  }
}

declare namespace Zotero {
  const Items: _ZoteroTypes.Items;
}


declare namespace _ZoteroTypes {
  interface Libraries {
    readonly userLibraryID: number;
    readonly userLibrary: Zotero.Library;
    _cache?: { [i: number]: Library.LibraryLike };
    register(library: Library.LibraryLike): void;
    unregister(libraryID: number): void;
    _addToCache(
      cache: { [i: number]: Library.LibraryLike },
      library: Library.LibraryLike,
    ): void;

    /**
     * Loads all libraries from DB. Groups, Feeds, etc. should not maintain an
     * independent cache.
     */
    init(): Promise<void>;

    /**
     * @param {Integer} libraryID
     * @return {Boolean}
     */
    exists(libraryID: number): boolean;

    _ensureExists(libraryID: number): void | never;

    /**
     * @return {Array<Zotero.Library | Zotero.Group | Zotero.Feed>} - All libraries
     */
    getAll(): Library.LibraryLike[];

    /**
     * Get an existing library
     *
     * @param {Integer} libraryID
     * @return {Library.LibraryLike[] | Library.LibraryLike}
     */
    get(libraryID: number): Library.LibraryLike | false;

    getName(libraryID: number): string;
    getType(libraryID: number): "group" | "user" | "feed";
    getLastSyncTime(libraryID: number): Date;
    getVersion(libraryID: number): number;
    hasTrash(libraryID: number): boolean;
    isEditable(libraryID: number): boolean;
    isFilesEditable(libraryID: number): boolean;
    isGroupLibrary(libraryID: number): boolean;
  }
}

declare namespace Zotero {
  const Libraries: _ZoteroTypes.Libraries;
}


declare namespace _ZoteroTypes {
  namespace Library {
    interface Params {
      libraryType?: string;
      editable?: boolean;
      filesEditable?: boolean;
      libraryVersion?: number;
      storageVersion?: number;
      lastSync?: Date;
      archived?: boolean;
    }

    abstract class LibraryAbstract {
      abstract _objectType: string;
      abstract readonly _childObjectTypes: ["item", "collection", "search"];

      // Immutable libraries
      abstract readonly fixedLibraries: ["user"];

      // Valid library types
      abstract readonly libraryTypes: string[];

      abstract libraryType: "user" | "group" | "feed";

      // Converts DB column name to (internal) object property
      static _colToProp(c: string): string;

      static readonly _dbColumns: string[];

      // Select all columns in a unique manner, so we can JOIN tables with same column names (e.g. version)
      static readonly _rowSQLSelect: string;

      // The actual select statement for above columns
      static readonly _rowSQL: string;

      static prototype: Zotero.Library;

      constructor(params?: _ZoteroTypes.Library.Params);

      readonly libraryID: number;
      id: number;

      /**
       * Get the library-type-specific id for the library (e.g., userID for user library,
       * groupID for group library)
       *
       * @property
       */
      readonly libraryTypeID: number;

      readonly isGroup: boolean;
      libraryVersion: number;
      readonly syncable: boolean;
      readonly lastSync: Date;
      readonly name: string;
      readonly treeViewID: string;
      readonly treeViewImage: _ZoteroTypes.IconURI;
      readonly hasTrash: boolean;
      readonly allowsLinkedFiles: boolean;
      editable: boolean;
      filesEditable: boolean;
      storageVersion: number;
      archived: boolean;
      storageDownloadNeeded: boolean;
      _isValidProp(prop: string): boolean;
      _loadDataFromRow(row: object): void;
      _reloadFromDB(): Promise<void>;

      /**
       * Load object data in this library
       */
      loadAllDataTypes(): Promise<void>;

      getDataLoaded(objectType: _ZoteroTypes.ObjectType): boolean;
      setDataLoading(objectType: _ZoteroTypes.ObjectType): void;
      getDataLoadedPromise(
        objectType: _ZoteroTypes.ObjectType,
      ): Promise<unknown> | null;
      setDataLoaded(objectType: _ZoteroTypes.ObjectType): void;

      /**
       * Wait for a given data type to load, loading it now if necessary
       */
      waitForDataLoad(objectType: _ZoteroTypes.ObjectType): Promise<void>;

      isChildObjectAllowed(type: _ZoteroTypes.ObjectType): boolean;
      updateLastSyncTime(): void;
      save(options?: object): Promise<false | void>;
      saveTx(options?: object): Promise<false | void>;
      eraseTx(options?: object): Promise<false | void>;
      erase(options?: object): Promise<false | void>;
      hasCollections(): boolean;
      updateCollections(): Promise<void>;
      hasSearches(): boolean;
      updateSearches(): Promise<void>;
      hasItems(): Promise<boolean>;
      hasItem(item: Zotero.Item): boolean;
    }

    type LibraryLike = Zotero.Library | Zotero.Group | Zotero.Feed;
  }
}
declare namespace Zotero {
  class Library extends _ZoteroTypes.Library.LibraryAbstract {
    _objectType: "library";
    _childObjectTypes: ["item", "collection", "search"];
    fixedLibraries: ["user"];
    libraryTypes: ["user"];
    libraryType: "user" | "group" | "feed";

    static readonly _dbColumns: [
      "type",
      "editable",
      "filesEditable",
      "version",
      "storageVersion",
      "lastSync",
      "archived",
    ];
  }
}


declare namespace _ZoteroTypes {
  // chrome/content/zotero/xpcom/data/notes.js
  interface Notes {
    [attr: string]: any;
    AUTO_SYNC_DELAY: 15;
    MAX_TITLE_LENGTH: 120;
    defaultNote: '<div class="zotero-note znv1"></div>';
    notePrefix: '<div class="zotero-note znv1">';
    noteSuffix: "</div>";
    _editorInstances: Zotero.EditorInstance[];
    _downloadInProgressPromise: Promise<void> | null;
    registerEditorInstance(instance: Zotero.EditorInstance): void;
    unregisterEditorInstance(instance: Zotero.EditorInstance): Promise<void>;

    /**
     * Replace local URIs for citations and highlights
     * in all notes. Cut-off note saving for the opened
     * notes and then trigger notification to refresh
     *
     * @param {Number} fromUserID
     * @param {Number} toUserID
     * @returns {Promise<void>}
     */
    updateUser(fromUserID: number, toUserID: number): Promise<void>;

    /**
     * Update item key URLs in the item's note, replacing all instances of each
     * key in itemKeyMap with the associated value.
     * Passed item should have an embedded note or be a note item.
     *
     * @param {Zotero.Item} item
     * @param {Map<String, String>} itemKeyMap
     */
    replaceAllItemKeys(
      item: Zotero.Item,
      itemKeyMap: Map<string, string>,
    ): void;

    /**
     * Convenience function to call replaceAllItemKeys with a single key-value pair.
     *
     * @param {Zotero.Item} item
     * @param {String} fromItemKey
     * @param {String} toItemKey
     */
    replaceItemKey(
      item: Zotero.Item,
      fromItemKey: string,
      toItemKey: string,
    ): void;

    getExportableNote(item: Zotero.Item): Promise<string>;

    /**
     * Download embedded images if they don't exist locally
     *
     * @param {Zotero.Item} item
     * @returns {Promise<boolean>}
     */
    ensureEmbeddedImagesAreAvailable(item: Zotero.Item): Promise<boolean>;

    /**
     * Copy embedded images from one note to another and update
     * item keys in note HTML.
     *
     * Must be called after copying a note
     *
     * @param {Zotero.Item} fromNote
     * @param {Zotero.Item} toNote
     * @returns {Promise}
     */
    copyEmbeddedImages(
      fromNote: Zotero.Item,
      toNote: Zotero.Item,
    ): Promise<void>;

    promptToIgnoreMissingImage(): boolean;
    deleteUnusedEmbeddedImages(item: Zotero.Item): Promise<void>;
    hasSchemaVersion(note: string): boolean;

    /**
     * Upgrade v1 notes:
     * - Pull itemData from citations, highlights, images into metadata container
     * - For `data-annotation` keep only the following fields:
     *    - uri
     *    - text
     *    - color
     *    - pageLabel
     *    - position
     *    - citationItem
     * - Increase schema version number
     *
     * @param {Zotero.Item} item
     * @returns {Promise<boolean>}
     */
    upgradeSchemaV1(item: Zotero.Item): Promise<boolean>;
  }
}

declare namespace Zotero {
  const Notes: _ZoteroTypes.Notes;
}



declare namespace Zotero {
  class Search extends Zotero.DataObject {
    static prototype: Search;
    constructor(params?: { name?: string; libraryID?: number });
    _name: string | null;
    _scope?: Search;
    _scopeIncludeChildren?: boolean;
    _sql: string;
    _sqlParams: object[];
    _maxSearchConditionID: number;
    _conditions: {};
    _hasPrimaryConditions: boolean;
    _objectType: "search";
    _dataTypes: _ZoteroTypes.Search.DataType;
    name: string;
    version: string | null;
    synced: boolean;
    conditions: { [id: number]: _ZoteroTypes.Search.ConditionType };
    readonly treeViewID: string;
    readonly treeViewImage: string;

    loadFromRow(row: object): void;
    _initSave(env: _ZoteroTypes.Search.EnvType): Promise<void>;

    // _finalizeSave(env: Search.EnvType): Promise<boolean | number>;

    clone(libraryID: number): Search;

    _eraseData(env: _ZoteroTypes.Search.EnvType): Promise<void>;

    addCondition(
      condition: _ZoteroTypes.Search.Conditions,
      operator: _ZoteroTypes.Search.Operator,
      value: string | number,
      required?: boolean,
    ): number;
    addCondition(
      condition: string,
      operator: _ZoteroTypes.Search.Operator,
      value?: string | number,
      required?: boolean,
    ): number;
    addCondition(condition: "blockStart" | "blockEnd"): number;

    /**
     * Sets scope of search to the results of the passed Search object
     */
    setScope(searchObj: Search, includeChildren: boolean): void;

    /**
     * @param {Number} searchConditionID
     * @param {String} condition
     * @param {String} operator
     * @param {String} value
     * @param {Boolean} [required]
     * @return {Promise}
     */
    updateCondition(
      searchConditionID: number,
      condition: string,
      operator: string,
      value: string,
      required: boolean,
    ): void;

    removeCondition(searchConditionID: number): void;

    /**
     * Returns an array with 'condition', 'operator', 'value', 'required'
     * for the given searchConditionID
     */
    getCondition(searchConditionID: number): _ZoteroTypes.Search.ConditionType;

    /**
     * Returns an object of conditions/operator/value sets used in the search,
     * indexed by searchConditionID
     */
    getConditions(): { [id: number]: _ZoteroTypes.Search.ConditionType };

    hasPostSearchFilter(): boolean;

    /**
     * Run the search and return an array of item ids for results
     *
     * @param {Boolean} [asTempTable=false]
     * @return {Promise}
     */
    search(asTempTable?: false): Promise<number[]>;
    search(asTempTable: true): Promise<string>;

    /**
     * Populate the object's data from an API JSON data object
     *
     * If this object is identified (has an id or library/key), loadAll() must have been called.
     *
     * @param {Object} json
     * @param {Object} [options]
     * @param {Boolean} [options.strict = false] - Throw on unknown property
     */
    fromJSON(json: object, options?: { strict: boolean }): void;

    toJSON(option: object): object;
  }
}

declare namespace _ZoteroTypes {
  namespace Search {
    type DataType = ["primaryData", "conditions"];
    type ConditionType = {
      id: number;
      condition: Conditions;
      mode: boolean;
      operator: Operator;
      value: string;
      required: boolean;
    };
    type EnvType = {
      options: Zotero.DataObject.SaveOptions;
      transactionOptions: object;
      isNew: boolean;
    };
    type Operator =
      | "is"
      | "isNot"
      | "true"
      | "false"
      | "isInTheLast"
      | "isBefore"
      | "isAfter"
      | "contains"
      | "doesNotContain"
      | "beginsWith"
      | "isLessThan"
      | "isGreaterThan"
      | "any"
      | "all"
      | "true"
      | "false";
    // Zotero.SearchConditions.getStandardConditions().map((c) => `'${c.name}'`).join(" | ");
    type Conditions =
      | "numPages"
      | "numberOfVolumes"
      | "abstractNote"
      | "anyField"
      | "accessDate"
      | "applicationNumber"
      | "archive"
      | "artworkSize"
      | "assignee"
      | "fulltextContent"
      | "fileTypeID"
      | "author"
      | "authority"
      | "bookAuthor"
      | "callNumber"
      | "childNote"
      | "citationKey"
      | "code"
      | "codeNumber"
      | "collection"
      | "committee"
      | "conferenceName"
      | "country"
      | "creator"
      | "date"
      | "dateAdded"
      | "dateModified"
      | "DOI"
      | "edition"
      | "editor"
      | "extra"
      | "filingDate"
      | "history"
      | "ISBN"
      | "ISSN"
      | "issue"
      | "itemType"
      | "journalAbbreviation"
      | "language"
      | "libraryCatalog"
      | "archiveLocation"
      | "medium"
      | "meetingName"
      | "note"
      | "number"
      | "pages"
      | "place"
      | "priorityNumbers"
      | "programmingLanguage"
      | "publicationTitle"
      | "publisher"
      | "references"
      | "reporter"
      | "rights"
      | "runningTime"
      | "scale"
      | "section"
      | "series"
      | "seriesNumber"
      | "seriesText"
      | "seriesTitle"
      | "session"
      | "shortTitle"
      | "status"
      | "system"
      | "tag"
      | "title"
      | "type"
      | "url"
      | "versionNumber"
      | "volume"
      | "deleted"
      | "noChildren"
      | "unfiled"
      | "retracted"
      | "publications"
      | "feed"
      | "includeParentsAndChildren"
      | "includeParents"
      | "includeChildren"
      | "recursive"
      | "joinMode"
      | "quicksearch-titleCreatorYear"
      | "quicksearch-titleCreatorYearNote"
      | "quicksearch-fields"
      | "quicksearch-everything"
      | "quicksearch"
      | "blockStart"
      | "blockEnd"
      | "collectionID"
      | "savedSearchID"
      | "savedSearch"
      | "itemTypeID"
      | "tagID"
      | "lastName"
      | "field"
      | "datefield"
      | "year"
      | "numberfield"
      | "libraryID"
      | "key"
      | "itemID"
      | "annotationText"
      | "annotationComment"
      | "fulltextWord"
      | "tempTable";
  }
}


declare namespace _ZoteroTypes {
  interface Searches extends DataObjects<Zotero.Search> {
    readonly ObjectClass: Zotero.Search;
    readonly primaryFields: [
      "savedSearchID",
      "name",
      "libraryID",
      "key",
      "version",
      "synced",
      "deleted",
    ];
  }
}

declare namespace Zotero {
  const Searches: _ZoteroTypes.Searches;
}


declare namespace _ZoteroTypes {
  namespace Tags {
    interface TagJson {
      tag: string;
      type?: 0 | 1;
    }
  }

  interface Tags {
    [attr: string]: any;
    MAX_COLORED_TAGS: number;
    MAX_SYNC_LENGTH: number;
    init(): Promise<void>;

    /**
     * Returns a tag for a given tagID
     *
     * @param {Integer} tagID
     * @return {Promise<String|false>} - A tag name, or false if tag with id not found
     */
    getName(tagID: number): string | false;

    /**
     * Returns the tagID matching given fields, or false if none
     *
     * @param {String} name - Tag data in API JSON format
     * @return {Integer} tagID
     */
    getID(name: string): number | false;

    /**
     * Returns the tagID matching given fields, or creates one and returns its id
     *
     * Requires a wrapping transaction
     *
     * @param {String} name - Tag data in API JSON format
     * @return {Promise<Integer>} tagID
     */
    create(name: string): Promise<number>;

    getLongTagsInLibrary(libraryID: number): Promise<number[]>;

    /**
     * Get all tags in library
     *
     * @param {Number} libraryID
     * @param {Number[]} [types] - Tag types to fetch
     * @return {Promise<Array>}   A promise for an array containing tag objects in API JSON format
     *                            [{ tag: "foo" }, { tag: "bar", type: 1 }]
     */
    getAll(libraryID: number, types?: number[]): Promise<Tags.TagJson[]>;

    /**
     * Get all tags within the items of a temporary table of search results
     *
     * @param {Object}
     * @param {Object.Number} libraryID
     * @param {Object.String} tmpTable - Temporary table with items to use
     * @param {Object.Number[]} [types] - Array of tag types to fetch
     * @param {Object.Number[]} [tagIDs] - Array of tagIDs to limit the result to
     * @return {Promise<Array[]>} - Promise for an array of tag objects in API JSON format
     */
    getAllWithin(object: {
      libraryID: number;
      tmpTable?: string;
      types?: number[];
      tagIDs?: number[];
    }): Promise<Tags.TagJson[]>;

    /**
     * Get the items associated with the given tag
     *
     * @param  {Number} tagID
     * @return {Promise<Number[]>}  A promise for an array of itemIDs
     */
    getTagItems(libraryID: number, tagID: number): Promise<number[]>;

    search(str: string): Promise<{ tag: string; type: number }[]>;

    /**
     * Rename a tag and update the tag colors setting accordingly if necessary
     *
     * @param {Number} tagID
     * @param {String} newName
     * @return {Promise}
     */
    rename(libraryID: number, oldName: string, newName: string): Promise<void>;

    /**
     * @param {Integer} libraryID
     * @param {Integer[]} tagIDs
     * @param {Function} [onProgress]
     * @param {Integer[]} [types]
     * @return {Promise}
     */
    removeFromLibrary(
      libraryID: number,
      tagIDs: number[],
      onProgress: Function,
      types: number[],
    ): Promise<void>;

    /**
     * @param {Integer} libraryID
     * @return {Integer[]} - An array of tagIDs
     */
    getAutomaticInLibrary(libraryID: number): Promise<number[]>;

    /**
     * Remove all automatic tags in the given library
     */
    removeAutomaticFromLibrary(
      libraryID: number,
      onProgress: Function,
    ): Promise<void>;

    /**
     * Delete obsolete tags from database
     *
     * @param {Number|Number[]} [tagIDs] - tagID or array of tagIDs to purge
     * @return {Promise}
     */
    purge(tagIDs: number[]): Promise<void>;

    /**
     *
     * @param {Integer} libraryID
     * @param {String} name Tag name
     * @return {Object|false} An object containing 'color' as a hex string (e.g., '#990000') and
     *     'position', or false if no colored tag with that name
     */
    getColor(libraryID: number, name: string): Tags.TagJson | false;

    /**
     * Get color data by position (number key - 1)
     *
     * @param {Integer} libraryID
     * @param {Integer} position The position of the tag, starting at 0
     * @return {Object|false} An object containing 'name' and 'color', or false if no color at
     *     the given position
     */
    getColorByPosition(
      libraryID: number,
      position: number,
    ): { name: string; color: string } | false;

    /**
     * Get colored tags within a given library
     *
     * @param {Integer} libraryID
     * @return {Map} - A Map with tag names as keys and objects containing 'color' and 'position'
     *     as values
     */
    getColors(
      libraryID: number,
    ): Map<string, { color: string; position: number }>;

    /**
     * Assign a color to a tag
     *
     * @return {Promise}
     */
    setColor(
      libraryID: number,
      name: string,
      color: string,
      position: number,
    ): Promise<void>;

    /**
     * Update caches and trigger redrawing of items in the items list
     * when a 'tagColors' setting is modified
     */
    notify(
      event: string,
      type: string,
      ids: string[],
      extraData: { [key: string]: any },
    ): Promise<void>;

    toggleItemsListTags(items: Zotero.Item[], tagName: string): Promise<void>;

    /**
     * @param {Zotero.Item[]}
     * @return {Promise}
     */
    removeColoredTagsFromItems(items: Zotero.Item[]): Promise<void>;

    /**
     * A tree cell can show only one image, and (as of Fx19) it can't be an SVG,
     * so we need to generate a composite image containing the existing item type
     * icon and one or more tag color swatches.
     *
     * @params {String[]} colors - Array of swatch colors
     * @params {String} extraImage - chrome:// URL of image to add to final image
     * @params {Boolean} [retracted = false] - If true, show an icon indicating the item was retracted
     * @return {Promise<String>} - A promise for a data: URL for a PNG
     */
    generateItemsListImage(
      colors: string[],
      extraImage: string,
      retracted?: boolean,
    ): Promise<string>;

    /**
     * From http://js-bits.blogspot.com/2010/07/canvas-rounded-corner-rectangles.html
     *
     * Draws a rounded rectangle using the current state of the canvas.
     * If you omit the last three params, it will draw a rectangle
     * outline with a 5 pixel border radius
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} x The top left x coordinate
     * @param {Number} y The top left y coordinate
     * @param {Number} width The width of the rectangle
     * @param {Number} height The height of the rectangle
     * @param {Number} radius The corner radius. Defaults to 5;
     * @param {Boolean} fill Whether to fill the rectangle. Defaults to false.
     * @param {Boolean} stroke Whether to stroke the rectangle. Defaults to true.
     */
    _canvasRoundRect(
      ctx: number,
      x: number,
      y: number,
      width: number,
      height: number,
      radius: number,
      fill: boolean,
      stroke: boolean,
    ): void;

    /**
     * Compare two API JSON tag objects
     */
    equals(data1: object, data2: object, option: {}): boolean;

    cleanData(data: object): object;

    purge(tagIDs?: number[]): Promise<void>;
  }
}

declare namespace Zotero {
  const Tags: _ZoteroTypes.Tags;
}

declare namespace Zotero {
  namespace DataDirectory {
    let dir: string;
  }
}


declare namespace _ZoteroTypes {
  namespace DB {
    type QueryParams = MaybeArray<string | number | object | null | undefined>;
  }

  interface DB {
    DB_CORRUPTION_STRINGS: string[];
    MAX_BOUND_PARAMETERS: number;
    Sqlite: object;

    get path(): string;

    /**
     * Test a read-only connection to the database, throwing any errors that occur
     *
     * @return	void
     */
    test(): Promise<void>;

    parseQueryAndParams(
      sql: string,
      params: DB.QueryParams,
    ): [string, DB.QueryParams];

    addCallback(
      type: "begin" | "commit" | "rollback",
      cb: (id: string) => void,
    ): number;

    addCurrentCallback(
      type: "commit" | "rollback",
      cb: (id: string) => void,
    ): void;

    removeCallback(type: "begin" | "commit" | "rollback", id: number): void;

    /*
     * Used on shutdown to rollback all open transactions
     *
     * TODO: update or remove
     */
    rollbackAllTransactions(): number | boolean;

    getColumns(table: string): Promise<object[] | false>;

    /**
     * Find the next lowest numeric suffix for a value in table column
     *
     * For example, if "Untitled" and "Untitled 2" and "Untitled 4",
     * returns "Untitled 3"
     *
     * If _name_ alone is available, returns that
     **/
    getNextName(
      libraryID: number,
      table: string,
      field: string,
      name: string,
    ): Promise<string>;

    /**
     * @param {Function} func - Async function containing `await Zotero.DB.queryAsync()` and similar
     * @param {object} [options]
     * @param {Boolean} [options.disableForeignKeys] - Disable foreign key constraints before
     *    transaction and re-enable after. (`PRAGMA foreign_keys=0|1` is a no-op during a transaction.)
     * @return {Promise} - Promise for result of generator function
     */
    executeTransaction<T = anyObj>(
      func: () => T | Promise<T>,
      options?: {
        disbledForeignKeys: boolean;
        timeout: number;
        vacuumOnCommit: boolean;
        inBackup: boolean;
        onCommit: (id: string) => void;
        onRollback: (id: string) => void;
      },
    ): Promise<T>;

    inTransaction(): boolean;

    waitForTransaction(id: number): Promise<void>;

    requireTransaction(): void;

    /**
     * @param {String} sql SQL statement to run
     * @param {Array|String|Integer} [params] SQL parameters to bind
     * @return {Promise|Array} A promise for an array of rows. The individual
     *                         rows are Proxy objects that return values from the
     *                         underlying mozIStorageRows based on column names.
     */
    queryAsync(
      sql: string,
      params?: DB.QueryParams,
      options?: {
        inBackup?: boolean;
        noParseParams?: boolean;
        onRow?: (row: unknown, cancel: unknown) => void;
        noCache?: boolean;
      },
    ): Promise<anyObj[] | undefined>;

    queryTx(
      sql: string,
      params?: DB.QueryParams,
      options?: {
        inBackup?: boolean;
        noParseParams?: boolean;
        onRow?: (row: unknown, cancel: unknown) => void;
        noCache?: boolean;
      },
    ): Promise<anyObj[] | undefined>;

    /**
     * @param {String} sql  SQL statement to run
     * @param {Array|String|Integer} [params]  SQL parameters to bind
     * @return {Promise<Array|Boolean>}  A promise for either the value or FALSE if no result
     */
    valueQueryAsync<T = anyObj>(
      sql: string,
      params?: DB.QueryParams,
      options?: { inBackup?: boolean; noCache?: boolean },
    ): Promise<T | boolean>;

    /**
     * @param {String} sql SQL statement to run
     * @param {Array|String|Integer} [params] SQL parameters to bind
     * @return {Promise<object>}  A promise for a proxied storage row
     */
    rowQueryAsync(
      sql: string,
      params?: DB.QueryParams,
    ): Promise<object | boolean>;

    /**
     * @param {String} sql SQL statement to run
     * @param {Array|String|Integer} [params] SQL parameters to bind
     * @return {Promise<Array>}  A promise for an array of values in the column
     */
    columnQueryAsync<T = anyObj>(
      sql: string,
      params?: DB.QueryParams,
      options?: {
        inBackup?: boolean;
        noCache?: boolean;
        debug?: boolean;
        debugParams?: boolean;
      },
    ): Promise<T[]>;

    logQuery(
      sql: string,
      params?: DB.QueryParams,
      options?: { debug?: boolean; debugParams?: boolean },
    ): void;

    tableExists(table: string, db?: string): Promise<boolean>;

    columnExists(table: string, column: string): Promise<boolean>;

    indexExists(index: string, db?: string): Promise<boolean>;

    parseSQLFile(sql: string): string[];

    /**
     * Parse SQL string and execute transaction with all statements
     *
     * @return {Promise}
     */
    executeSQLFile(sql: string): Promise<void>;

    /*
     * Implements nsIObserver
     */
    observe(subject: unknown, topic: "idle", data: unknown): void;

    numCachedStatements(): number;

    getCachedStatements(): string[];

    // TEMP
    vacuum(): Promise<void>;

    // TEMP
    info(): Promise<{
      auto_vaccum: number;
      cache_size: number;
      "main.locking_mode": string;
      page_size: number;
    }>;

    quickCheck(): Promise<boolean>;

    integrityCheck(): Promise<boolean>;

    isCorruptionError(e: Error): boolean;

    /**
     * Close the database
     * @param {Boolean} [permanent] If true, throw an error instead of
     *     allowing code to re-open the database again
     */
    closeDatabase(permanent: boolean): Promise<void>;

    backupDatabase(suffix: boolean | string, force: boolean): boolean;

    /**
     * Escape '_', '%', and '\' in an SQL LIKE expression so that it can be used with ESCAPE '\' to
     * prevent the wildcards from having special meaning
     */
    escapeSQLExpression(expr: string): string;

    /////////////////////////////////////////////////////////////////
    //
    // Private methods
    //
    /////////////////////////////////////////////////////////////////

    _getConnection(options?: { inBackup: boolean }): object | boolean;

    /*
     * Retrieve a link to the data store asynchronously
     */
    _getConnectionAsync(options?: { inBackup: boolean }): Promise<object>;

    _checkException(e: Error): Promise<boolean>;

    /**
     * @return {Boolean} - True if recovered, false if not
     */
    _handleCorruptionMarker(): Promise<void>;

    _debug(str: string, level?: number): void;
  }

  interface DBConnection extends DB {
    new (dbNameOrPath: string): this;
  }
}

declare namespace Zotero {
  const DB: _ZoteroTypes.DB;
  const DBConnection: _ZoteroTypes.DBConnection;
}


declare namespace Zotero {
  // chrome/content/zotero/xpcom/editorInstance.js
  interface EditorInstance {
    [attr: string]: any;
    new (): this;
    init: (options: {
      onNavigate?: Function;
      item?: Zotero.Item;
      reloaded?: boolean;
      viewMode?: string;
      readOnly?: boolean;
      disableUI?: boolean;
      onReturn?: Function;
      iframeWindow?: Window;
      popup?: any;
      state?: any;
      placeholder?: any;
    }) => Promise<void>;
    uninit(): Promise<void>;
    focus(): void;
    notify: _ZoteroTypes.Notifier.Notify;
    saveSync(): void;
    insertAnnotations(annotations: any): Promise<void>;
    _postMessage(message: any): void;
    _isReadOnly(): boolean;
    _getFont(): { fontSize: number; fontFamily: string };
    _handleFontChange(): void;
    _handleStyleChange(): void;
    _handleSpellCheckChange(): void;
    _showInLibrary(ids: number | number[]): void;
    importImages(annotations: any): Promise<void>;
    _digestItems(ids: number[]): string | null;
    _messageHandler(e: MessageEvent): Promise<void>;
    _updateCitationItems(citationItemsList: object[]): Promise<void>;
    _feedSubscription(subscription: object): Promise<void>;
    _importImage(src: string, download: boolean): Promise<string>;
    _openPopup: (
      x: number,
      y: number,
      pos: any,
      itemGroups: any,
    ) => Promise<void>;
    _getSpellChecker(): any;
    _ensureNoteCreated(): Promise<void>;
    _save(noteData: object, skipDateModifiedUpdate: boolean): Promise<void>;
    _arrayBufferToBase64: (buffer: BufferSource) => string;
    _dataURLtoBlob(dataurl: string): Blob | null;
    _getDataURL(item: Zotero.Item): Promise<string>;
    _openQuickFormatDialog: (
      nodeID: number,
      citationData: any,
      filterLibraryIDs: any,
      openedEmpty: any,
    ) => Promise<void>;
    getItemFromURIs(uris: string[]): Promise<Zotero.Item>;
    createNoteFromAnnotations: (
      annotations: Zotero.Item[],
      parentID: number,
    ) => Promise<Zotero.Item>;
    _iframeWindow: Window;
    _item: Zotero.Item;
    _initPromise: Promise<any>;
    _viewMode: string;
    _reloaded: boolean;
    _readOnly: boolean;
    _filesReadOnly: boolean;
    _disableUI: boolean;
    _onReturn: Function;
    _popup: any;
    _state: any;
    _disableSaving: boolean;
    _subscriptions: [];
    _quickFormatWindow: any;
    _citationItemsList: any;
    _prefObserverIDs: any[];
  }

  const EditorInstanceUtilities: _ZoteroTypes.EditorInstanceUtilities;
}

declare namespace _ZoteroTypes {
  interface EditorInstanceUtilities {
    serializeAnnotations: (
      annotations: object[],
      skipEmbeddingItemData?: boolean,
    ) => { html: string; citationItems: Zotero.Item[] };
    _transformTextToHTML(text: string): string;
    _formatCitationItemPreview(citationItem: Zotero.Item): string;
    formatCitation(citation: object): string;
  }
}


declare namespace _ZoteroTypes {
  interface File {
    pathToFile(pathOrFile: string | nsIFile): nsIFile;
    pathToFileURI(path: string): string;
    encodeFilePath(path: string): string;
    getExtension(file: string | nsIFile): string;
    getClosestDirectory(file: string): string | false;
    getSample: (
      file: nsIFile | string,
    ) =>
      | string
      | Promise<string>
      | Uint8Array
      | Promise<Uint8Array>
      | Promise<BufferSource>;
    getBinaryContentsAsync: (
      source: string | nsIFile,
      maxLength?: number,
    ) => Promise<string>;
    getContentsAsync: (
      source: string | nsIFile | nsIInputStream,
      charset?: string,
      maxLength?: number,
    ) =>
      | string
      | Promise<string>
      | Uint8Array
      | Promise<Uint8Array>
      | Promise<BufferSource>
      | Promise<void>;
    getContentsFromURL(url: string): string;
    getContentsFromURLAsync(url: string, options?: any): Promise<string>;
    getResource(url: string): string;
    getResourceAsync(url: string): Promise<string>;
    putContents(file: nsIFile, str: string): void;
    putContentsAsync: (
      path: string | nsIFile,
      data: string | nsIInputStream | ArrayBuffer,
      charset?: string,
    ) => Promise<void>;
    download(uri: string, path: string): Promise<void>;
    rename: (
      file: string,
      newName: string,
      options?: { overwrite?: boolean; unique: boolean },
    ) => Promise<string | false>;
    removeIfExists(path: string): Promise<void>;
    directoryIsEmpty(path: string): Promise<boolean>;
    iterateDirectory(
      path: string,
      onEntry: (entry: OS.File.Entry) => void,
    ): Promise<void>;
    canMoveDirectoryWithCommand(): boolean;
    canMoveDirectoryWithFunction(): boolean;
    moveDirectory: (
      oldDir: string,
      newDir: string,
      options?: object,
    ) => Promise<void | Error[]>;
    generateDataURI(file: string, contentType: string): string;
    setNormalFilePermissions(file: string): void | Promise<void>;
    createShortened: (
      file: string,
      type: any,
      mode: any,
      maxBytes: number,
    ) => string;
    moveToUnique(file: string, newFile: string): Promise<string>;
    copyToUnique(file: string, newFile: string): Promise<OS.File.Entry>;
    copyDirectory: (
      source: string | nsIFile,
      target: string | nsIFile,
    ) => Promise<void>;
    createDirectoryIfMissing(dir: string): void;
    createDirectoryIfMissingAsync(path: string, options?: any): Promise<void>;
    normalizeToUnix(path: string): string;
    directoryContains(dir: string, file: string): boolean;
    zipDirectory: (
      dirPath: string,
      zipPath: string,
      observer: any,
    ) => Promise<void | false>;
    truncateFileName(fileName: string, maxLength: number): string;
    getCharsetFromFile: (
      file: typeof OS.File,
      mimeType: string,
      callback: Function,
      args: any,
    ) => void;
    checkFileAccessError: (
      e: Error | any,
      file: string | nsIFile,
      operation: "create" | "delete" | any,
    ) => void;
    getEvictedICloudPath(path: string): string;
    isCloudStorageFolder(path: string): boolean;
    reveal(file: string): Promise<void>;
  }

  class Zotero_File_Interface {
    exportItemsToClipboard(items: Zotero.Item[], translatorID: string): void;
    importFile(options: {
      file: nsIFile | string | null;
      createNewCollection?: boolean;
    }): Promise<void>;
  }
}

declare const Zotero_File_Interface: _ZoteroTypes.Zotero_File_Interface;

declare namespace Zotero {
  const File: _ZoteroTypes.File;
}


declare namespace _ZoteroTypes {
  namespace FileHandlers {
    interface Location {
      annotationID?: string;
      pageIndex?: number;
      position?: { value: string };
    }

    interface OpenParams {
      location?: Location;
      openInWindow?: boolean;
    }

    interface FileHandlerOpenOptions {
      filePath: string;
      location?: Location;
      page?: number;
    }

    interface FileHandler {
      name: RegExp;
      fallback?: boolean;
      open(
        appPath: string | null,
        options: FileHandlerOpenOptions,
      ): Promise<void>;
    }

    interface Platform {
      pdf: FileHandler[];
      epub: FileHandler[];
    }
  }

  interface FileHandlers {
    open(item: Zotero.Item, params?: FileHandlers.OpenParams): Promise<boolean>;
    _handlersMac: FileHandlers.Platform;
    _handlersWin: FileHandlers.Platform;
    _handlersLinux: FileHandlers.Platform;
    _getSystemHandler(mimeType: string): string | false;
    _getSystemHandlerWin(mimeType: string): string | false;
    _getSystemHandlerPOSIX(mimeType: string): string | false;
    _checkAndExecWithoutBlocking(
      command: string,
      args: string[],
    ): Promise<void>;
  }
}

declare namespace Zotero {
  const FileHandlers: _ZoteroTypes.FileHandlers;

  namespace OpenPDF {
    /**
     * @deprecated - use Zotero.FileHandlers.open
     */
    function openToPage(
      item: Zotero.Item,
      page: number,
      annotationKey?: string,
    ): Promise<void>;
  }
}


declare namespace _ZoteroTypes {
  interface FullText {
    readonly fulltextCacheFile: ".zotero-ft-cache";

    readonly INDEX_STATE_UNAVAILABLE: 0;
    readonly INDEX_STATE_UNINDEXED: 1;
    readonly INDEX_STATE_PARTIAL: 2;
    readonly INDEX_STATE_INDEXED: 3;
    readonly INDEX_STATE_QUEUED: 4;

    readonly SYNC_STATE_UNSYNCED: 0;
    readonly SYNC_STATE_IN_SYNC: 1;
    readonly SYNC_STATE_TO_PROCESS: 2;
    readonly SYNC_STATE_TO_DOWNLOAD: 3;
    readonly SYNC_STATE_MISSING: 4;

    init(): Promise<void>;
    setPDFConverterPath(path: string): void;
    setPDFInfoPath(path: string): void;
    setPDFDataPath(path: string): void;
    getLibraryVersion(libraryID: number): Promise<number>;
    setLibraryVersion(libraryID: number, version: number): Promise<void>;
    clearLibraryVersion(libraryID: number): Promise<void>;
    getItemVersion(itemID: number): Promise<number>;
    setItemSynced(itemID: number, version: number): Promise<void>;
    getPDFConverterExecAndArgs(): { exec: string; args: string[] };
    isCachedMIMEType(mimeType: string): boolean;
    indexItems(
      itemIDs: number[],
      options?: { complete?: boolean; ignoreErrors?: boolean },
    ): Promise<void>;
    rebuildIndex(unindexedOnly: boolean): Promise<void>;
    clearIndex(skipLinkedURLs?: boolean): Promise<void>;
    purgeUnusedWords(): Promise<void>;
    canIndex(item: Zotero.Item): boolean;
    canReindex(item: Zotero.Item): Promise<boolean>;
    getIndexedState(item: Zotero.Item): Promise<number>;
    isFullyIndexed(item: Zotero.Item): Promise<boolean>;
    getIndexStats(): Promise<{
      indexed: number;
      partial: number;
      unindexed: number;
      words: number;
    }>;
    getItemCacheFile(item: Zotero.Item): nsIFile;
    getItemProcessorCacheFile(item: Zotero.Item): nsIFile;
    transferItemIndex(
      fromItem: Zotero.Item,
      toItem: Zotero.Item,
    ): Promise<void>;
    getPages(itemID: number): Promise<false | { total: number }>;
    indexDocument(document: Document, itemID: number): Promise<boolean | void>;
    indexPDF(
      filePath: string,
      itemID: number,
      allPages?: boolean,
    ): Promise<boolean>;
    indexEPUB(
      filePath: string,
      itemID: number,
      allText?: boolean,
    ): Promise<boolean>;
    indexItems(
      itemIDs: number | number[],
      options?: { complete?: boolean; ignoreErrors?: boolean },
    ): Promise<void>;
    indexFromProcessorCache(itemID: number): Promise<boolean>;
    clearItemWords(itemID: number, force?: boolean): Promise<void>;
    semanticSplitter(text: string, charset?: string): string[];
  }
}
declare namespace Zotero {
  const Fulltext: _ZoteroTypes.FullText;
  const FullText: _ZoteroTypes.FullText;
}


declare namespace _ZoteroTypes {
  /**
   * Functions for performing HTTP requests, both via XMLHTTPRequest and using a hidden browser
   * @namespace
   */
  interface HTTP {
    /**
     * Get a promise for a HTTP request
     *
     * @param {String} method - The method of the request ("GET", "POST", etc.)
     * @param {nsIURI|String} url - URL to request
     * @param {Object} [options] Options for HTTP request:
     * @param {String} [options.body] - The body of a POST request
     * @param {Object | Headers} [options.headers] - HTTP headers to send with the request
     * @param {Boolean} [options.followRedirects = true] - Object of HTTP headers to send with the
     *     request
     * @param {Zotero.CookieSandbox} [options.cookieSandbox] - The sandbox from which cookies should
     *     be taken
     * @param {Boolean} [options.debug] - Log response text and status code
     * @param {Boolean} [options.noCache] - If set, specifies that the request should not be
     *     fulfilled from the cache
     * @param {Boolean} [options.dontCache] - Deprecated
     * @param {Boolean} [options.foreground] - Make a foreground request, showing
     *     certificate/authentication dialogs if necessary
     * @param {Number} [options.logBodyLength=1024] - Length of request body to log
     * @param {Function} [options.requestObserver] - Callback to receive XMLHttpRequest after open()
     * @param {Function} [options.cancellerReceiver] - Callback to receive a function to cancel
     *     the operation
     * @param {String} [options.responseType] - The type of the response. See XHR 2 documentation
     *     for legal values
     * @param {String} [options.responseCharset] - The charset the response should be interpreted as
     * @param {Number[]|false} [options.successCodes] - HTTP status codes that are considered
     *     successful, or FALSE to allow all
     * @param {Zotero.CookieSandbox} [options.cookieSandbox] - Cookie sandbox object
     * @param {Number} [options.timeout = 30000] - Request timeout specified in milliseconds, or 0
     *     for no timeout
     * @param {Number[]} [options.errorDelayIntervals] - Array of milliseconds to wait before
     *     retrying after 5xx error; if unspecified, a default set is used
     * @param {Number} [options.errorDelayMax = 3600000] - Milliseconds to wait before stopping
     *     5xx retries; set to 0 to disable retrying
     * @return {Promise<XMLHttpRequest>} - A promise resolved with the XMLHttpRequest object if the
     *     request succeeds or rejected if the browser is offline or a non-2XX status response
     *     code is received (or a code not in options.successCodes if provided).
     */
    request(
      method: string,
      url: string,
      options?: {
        body?: string | Uint8Array;
        headers?: any;
        followRedirects?: boolean;
        cookieSandbox?: Zotero.CookieSandbox;
        debug?: boolean;
        noCache?: boolean;
        dontCache?: boolean;
        foreground?: boolean;
        logBodyLength?: number;
        requestObserver?: Function;
        cancellerReceiver?: Function;
        responseType?: string;
        responseCharset?: string;
        successCodes?: number[] | false;
        timeout?: number;
        errorDelayIntervals?: number[];
        errorDelayMax?: number;
      },
    ): Promise<XMLHttpRequest>;

    /**
     * Send an HTTP GET request via XMLHTTPRequest
     *
     * @param {nsIURI|String}	url				URL to request
     * @param {Function} 		onDone			Callback to be executed upon request completion
     * @param {String} 		responseCharset	Character set to force on the response
     * @param {Zotero.CookieSandbox} [cookieSandbox] Cookie sandbox object
     * @param {Object} requestHeaders HTTP headers to include with request
     * @return {XMLHttpRequest} The XMLHttpRequest object if the request was sent, or
     *     false if the browser is offline
     * @deprecated Use {@link Zotero.HTTP.request}
     */
    doGet(
      url: string | URL,
      onDone: (xhr: XMLHttpRequest) => void | Promise<void>,
      responseCharset: string,
      cookieSandbox?: Zotero.CookieSandbox,
      requestHeaders?: Record<string, string>,
    ): XMLHttpRequest;

    /**
     * Send an HTTP POST request via XMLHTTPRequest
     *
     * @param {String} url URL to request
     * @param {String} body Request body
     * @param {Function} onDone Callback to be executed upon request completion
     * @param {String} headers Request HTTP headers
     * @param {String} responseCharset Character set to force on the response
     * @param {Zotero.CookieSandbox} [cookieSandbox] Cookie sandbox object
     * @return {XMLHttpRequest} The XMLHttpRequest object if the request was sent, or
     *     false if the browser is offline
     * @deprecated Use {@link Zotero.HTTP.request}
     */
    doPost(
      url: string | URL,
      body: string,
      onDone: (xhr: XMLHttpRequest) => void | Promise<void>,
      headers: Record<string, string>,
      responseCharset: string,
      cookieSandbox?: Zotero.CookieSandbox,
    ): XMLHttpRequest;

    /**
     * Send an HTTP HEAD request via XMLHTTPRequest
     *
     * @param {String} url URL to request
     * @param {Function} onDone Callback to be executed upon request completion
     * @param {Object} requestHeaders HTTP headers to include with request
     * @param {Zotero.CookieSandbox} [cookieSandbox] Cookie sandbox object
     * @return {XMLHttpRequest} The XMLHttpRequest object if the request was sent, or
     *     false if the browser is offline
     * @deprecated Use {@link Zotero.HTTP.request}
     */
    doHead(
      url: string | URL,
      onDone: (xhr: XMLHttpRequest) => void | Promise<void>,
      requestHeaders: Record<string, string>,
      cookieSandbox?: Zotero.CookieSandbox,
    ): XMLHttpRequest;

    /**
     * Send an HTTP OPTIONS request via XMLHTTPRequest
     *
     * @param	{nsIURI}		url
     * @param	{Function}	onDone
     * @return	{XMLHTTPRequest}
     * @deprecated Use {@link Zotero.HTTP.request}
     */
    doOptions(
      url: string | URL,
      onDone: (xhr: XMLHttpRequest) => void | Promise<void>,
    ): XMLHttpRequest;

    /**
     * Make a foreground HTTP request in order to trigger a proxy authentication dialog
     *
     * Other Zotero.HTTP requests are background requests by default, and
     * background requests don't trigger a proxy auth prompt, so we make a
     * foreground request on startup and resolve the promise
     * Zotero.proxyAuthComplete when we're done. Any network requests that want
     * to wait for proxy authentication can wait for that promise.
     */
    triggerProxyAuth(): false | undefined;

    /**
     * Checks if the browser is currently in "Offline" mode
     *
     * @type Boolean
     */
    browserIsOffline(): boolean;

    /**
     * Load one or more documents using XMLHttpRequest
     *
     * This should stay in sync with the equivalent function in the connector
     *
     * @param {String|String[]} urls URL(s) of documents to load
     * @param {Function} processor - Callback to be executed for each document loaded; if function returns
     *     a promise, it's waited for before continuing
     * @param {Object} [options]
     * @param {Zotero.CookieSandbox} [options.cookieSandbox] - Cookie sandbox object
     * @param {Object} [options.headers] - Headers to include in the request
     * @return {Promise<Array>} - A promise for an array of results from the processor runs
     */
    processDocuments<T>(
      urls: string | string[],
      processor: (doc: Document, responseURL: string) => T | Promise<T>,
      options?: {
        cookieSandbox?: Zotero.CookieSandbox;
        headers?: Record<string, string>;
      },
    ): Promise<T[]>;

    /**
     * Wraps an HTMLDocument object returned by XMLHttpRequest DOMParser to make it look more like it belongs
     * to a browser. This is necessary if the document is to be passed to Zotero.Translate.
     * @param {HTMLDocument} doc Document returned by
     * @param {nsIURL|String} url
     */
    wrapDocument(doc: Document, url: string | URL): Document;

    Location: (url: URL) => Location;
    Window: (url: URL) => Window;
  }
}

declare namespace Zotero {
  const HTTP: _ZoteroTypes.HTTP;
}


declare namespace Zotero {
  /**
   * The MIME namespace provides various utility functions for determining
   * MIME types based on file data, file extensions, and HTTP metadata.
   */
  namespace MIME {
    /**
     * Checks if the given MIME type is a text type.
     *
     * @param mimeType
     * @returns true if the MIME type is a text type; otherwise false.
     */
    function isTextType(mimeType: string): boolean;

    /**
     * Checks if the given MIME type is considered a web page type.
     *
     * @param mimeType
     * @returns true if the MIME type is a web page type; otherwise false.
     */
    function isWebPageType(mimeType: string): boolean;

    /*
     * Our own wrapper around the MIME service's getPrimaryExtension() that
     * works a little better
     */
    function getPrimaryExtension(mimeType: string, ext: string): string;

    /*
     * Searches string for embedded nulls
     *
     * Returns 'application/octet-stream' or 'text/plain'
     */
    function sniffForBinary(str: string): string;

    /*
     * Searches string for magic numbers
     */
    function sniffForMIMEType(str: string): string | false;

    /*
     * Try to determine the MIME type of a string, using a few different
     * techniques
     *
     * ext is an optional file extension hint if data sniffing is unsuccessful
     */
    function getMIMETypeFromData(str: string, ext?: string): string;

    /**
     * Try to find a MIME type associated with a given file extension.
     *
     * @param ext The file extension without the leading dot.
     * @returns The resolved MIME type or false if not found.
     */
    function getMIMETypeFromExtension(ext: string): string | false;

    /*
     * Try to determine the MIME type of the file, using a few different
     * techniques
     */
    function getMIMETypeFromFile(file: any): Promise<string>;

    /**
     * @param {String} url
     * @param {Zotero.CookieSandbox} [cookieSandbox]
     * @return {Promise<[string, boolean]>} Resolves with [mimeType, hasNativeHandler]
     */
    function getMIMETypeFromURL(
      url: string,
      cookieSandbox?: any,
    ): Promise<[string, boolean]>;

    /*
     * Determine if a MIME type can be handled natively
     * or if it needs to be passed off to a plugin or external helper app
     *
     * ext is an optional extension hint (only needed for text files
     * that should be forced to open externally)
     *
     * Note: it certainly seems there should be a more native way of doing this
     * without replicating all the Mozilla functionality
     *
     * Note: nsIMIMEInfo provides a hasDefaultHandler() method, but it doesn't
     * do what we need
     */
    function hasNativeHandler(mimeType: string, ext?: string): boolean;
  }
}


declare namespace _ZoteroTypes {
  namespace Notifier {
    type Event =
      | "add"
      | "modify"
      | "delete"
      | "move"
      | "remove"
      | "refresh"
      | "redraw"
      | "trash"
      | "unreadCountUpdated"
      | "index"
      | "open"
      | "close"
      | "select";
    type Type =
      | "collection"
      | "search"
      | "share"
      | "share-items"
      | "item"
      | "file"
      | "collection-item"
      | "item-tag"
      | "tag"
      | "setting"
      | "group"
      | "trash"
      | "bucket"
      | "relation"
      | "feed"
      | "feedItem"
      | "sync"
      | "api-key"
      | "tab"
      | "itemtree"
      | "itempane";
    type Notify = (
      event: Event,
      type: Type,
      ids: string[] | number[],
      extraData: anyObj,
    ) => void | Promise<void>;
    interface Queue {
      id: string;
      _queue: { [type in Type]: Array<{ ids: string[]; data: anyObj }> };
      size: number;
      options: object;
      new (options?: object): this;
    }
  }
  interface Notifier {
    readonly EVENT_LEVEL_OPTIONS: ["autoSyncDelay", "skipAutoSync"];

    /**
     * @param {Object} [ref] signature {notify: function(event, type, ids, extraData) {}}
     * @param {Array} [types] a list of types of events observer should be triggered on
     * @param {String} [id] an id of the observer used in debug output
     * @param {Integer} [priority] lower numbers correspond to higher priority of observer execution
     * @returns {string}
     */
    registerObserver(
      ref: { notify: Notifier.Notify },
      types?: Notifier.Type[],
      id?: string,
      priority?: number,
    ): string;

    unregisterObserver(id: string): void;

    /**
     * Trigger a notification to the appropriate observers
     *
     * Possible values:
     *
     * 	event: 'add', 'modify', 'delete', 'move' ('c', for changing parent),
     *		'remove' (ci, it), 'refresh', 'redraw', 'trash', 'unreadCountUpdated', 'index'
     * 	type - 'collection', 'search', 'item', 'collection-item', 'item-tag', 'tag',
     *		'group', 'relation', 'feed', 'feedItem'
     * 	ids - single id or array of ids
     *
     * Notes:
     *
     * - If event queuing is on, events will not fire until commit() is called
     * unless _force_ is true.
     *
     * - New events and types should be added to the order arrays in commit()
     **/
    trigger(
      event: Notifier.Event,
      type: Notifier.Type,
      ids: number | number[],
      extraData?: anyObj,
      force?: boolean,
    ): Promise<void | true>;

    /**
     * Queue an event until the end of the current notifier transaction
     *
     * Takes the same parameters as trigger()
     *
     * @throws If a notifier transaction isn't currently open
     */
    queue(
      event: Notifier.Event,
      type: Notifier.Type,
      ids: string[],
      extraData: { [option in "autoSyncDelay" | "skipAutoSync"]: unknown },
      queue: Notifier.Queue,
    ): void;

    /**
     * Begin queueing event notifications (i.e. don't notify the observers)
     *
     * Note: Be sure the matching commit() gets called (e.g. in a finally{...} block) or
     * notifications will break until Firefox is restarted or commit(true)/reset() is called manually
     *
     * @param {String} [transactionID]
     */
    begin(transactionID?: boolean): void;

    /**
     * Send notifications for ids in the event queue
     *
     * @param {Zotero.Notifier.Queue|Zotero.Notifier.Queue[]} [queues] - One or more queues to use
     *     instead of the internal queue
     * @param {String} [transactionID]
     */
    commit(
      queues?: Notifier.Queue | Notifier.Queue[],
      transactionID?: boolean,
    ): Promise<void>;

    /*
     * Reset the event queue
     */
    reset(transactionID?: boolean): void;
  }
}

declare namespace Zotero {
  const Notifier: _ZoteroTypes.Notifier;
}


declare namespace _ZoteroTypes {
  interface ItemPaneManager {
    registerSection<T extends string>(
      options: ItemPaneManagerSection.ItemDetailsSectionOptions<T>,
    ): false | string;

    unregisterSection(key: string): boolean;

    registerInfoRow<T extends string>(
      options: ItemPaneManagerInfoRow.InfoRowOptions<T>,
    ): false | string;

    unregisterInfoRow(key: string): boolean;

    refreshInfoRow(rowID: string): void;
  }
  namespace ItemPaneManagerSection {
    type Icon16px = string | IconURI;
    type Icon20px = string | IconURI;

    type BuiltInPaneID =
      | "info"
      | "abstract"
      | "attachments"
      | "notes"
      | "attachment-info"
      | "attachment-annotations"
      | "libraries-collections"
      | "tags"
      | "related";
    type ExcludeBuiltInIDs<T extends string> = T extends BuiltInPaneID
      ? never
      : T;

    type ValidDOMString<T extends string> =
      T extends `${infer _Prefix},${infer _Suffix}` ? never : T;

    interface SectionHook {
      init(props: SectionInitHookArgs): void;
      destroy(props: BasicHookArgs): void;
      render(props: SectionHookArgs): void;
      itemChange(props: SectionHookArgs): void;
      asyncRender(props: SectionHookArgs): MaybePromise<void>;
      toggle(props: SectionEventHookArgs): void;
    }

    interface SectionButton {
      /** Button type, must be valid DOMString and without "," */
      type: ValidDOMString<string>; // TODO
      /** 16*16 Icon URI for section button in light mode */
      icon: Icon16px;
      /** 16*16 Icon URI for section button in dark mode. If not set, use icon */
      darkIcon?: Icon16px;
      /** data-l10n-id for localization of button tooltip text */
      l10nID?: string;
      /** Button click callback */
      onClick(props: SectionEventHookArgs): void;
    }

    interface BasicHookArgs {
      /** Registered pane id */
      paneID: string;
      /** Document of section */
      doc: Document;
      /** Section body */
      body: HTMLDivElement;
    }

    interface UIHookArgs {
      item: Zotero.Item;
      tabType: "library" | "reader";
      editable: boolean;

      /** Set l10n args for section header */
      setL10nArgs(l10nArgs: string): void;
      /** Set pane enabled state */
      setEnabled<T extends boolean>(enabled: T): T extends true ? false : true;
      /** Set summary in header */
      setSectionSummary<T extends string>(summary: T): T;
      /** Set the status of buttons */
      setSectionButtonStatus(
        buttonType: string,
        status: {
          disabled?: boolean;
          hidden?: boolean;
        },
      ): void;
    }

    interface SectionHookArgs
      extends Readonly<BasicHookArgs>,
        Readonly<UIHookArgs> {}

    interface SectionInitHookArgs extends SectionHookArgs {
      /** A `refresh` is exposed to plugins to allows plugins to refresh the section when necessary */
      refresh(): Promise<void>;
    }

    type SectionEventHookArgs = SectionHookArgs & { readonly event: Event };

    interface UIOptions {
      /** Icon URI in light mode */
      icon: string;
      darkIcon?: string;
      /** Pane data-l10n-id for localization of section head `label` or Sidenav data-l10n-id for localization of sidenav `tooltiptext` */
      l10nID: string;
      l10nArgs?: string;
    }

    interface ItemDetailsSectionOptions<T extends string> {
      /** Unique pane ID */
      paneID: ExcludeBuiltInIDs<T>;
      /** Set plugin ID to auto remove section when plugin is disabled/removed */
      pluginID: string;
      sidenav: UIOptions;
      header: UIOptions;
      onRender?: SectionHook["render"];
      onAsyncRender?: SectionHook["asyncRender"];
      onInit?: SectionHook["init"];
      onDestroy?: SectionHook["destroy"];
      onItemChange?: SectionHook["itemChange"];
      onToggle?: SectionHook["toggle"];

      /** Pane fragment as string */
      bodyXHTML?: string;
      sectionButtons?: SectionButton[];
    }
  }

  namespace ItemPaneManagerInfoRow {
    type ExcludeBuiltFields<T extends string> =
      T extends _ZoteroTypes.Item.ItemField ? never : T;

    interface BasicHookArgs {
      rowID: string;
      item: Zotero.Item;
      tabType: "library" | "reader";
      editable: boolean;
    }

    interface SetDataHookArgs extends BasicHookArgs {
      value: string;
    }

    interface ItemChangeHookArgs extends BasicHookArgs {
      setEnabled: (enabled: boolean) => void;
      setEditable: (editable: boolean) => void;
    }

    interface InfoRowOptions<T extends string> {
      rowID: ExcludeBuiltFields<T>;
      pluginID: string;
      label: {
        l10nID: string;
      };
      position?: "start" | "afterCreators" | "end";
      multiline?: boolean;
      nowrap?: boolean;
      editable?: boolean;
      onGetData: (options: BasicHookArgs) => string;
      onSetData?: (options: SetDataHookArgs) => void;
      onItemChange?: (options: ItemChangeHookArgs) => void;
    }
  }
}

declare namespace Zotero {
  const ItemPaneManager: _ZoteroTypes.ItemPaneManager;
}


declare namespace _ZoteroTypes {
  namespace ItemTreeManager {
    /**
     * @type {object}
     * @property {string} dataKey - Required, see use in ItemTree#_getRowData()
     * @property {string} label - The column label. Either a string or the id to an i18n string.
     * @property {string} [pluginID] - Set plugin ID to auto remove column when plugin is removed.
     * @property {string[]} [enabledTreeIDs=[]] - Which tree ids the column should be enabled in. If undefined, enabled in main tree. If ["*"], enabled in all trees.
     * @property {string[]} [defaultIn] - Will be deprecated. Types of trees the column is default in. Can be [default, feed];
     * @property {string[]} [disabledIn] - Will be deprecated. Types of trees where the column is not available
     * @property {boolean} [sortReverse=false] - Default: false. Set to true to reverse the sort order
     * @property {number} [flex=1] - Default: 1. When the column is added to the tree how much space it should occupy as a flex ratio
     * @property {string} [width] - A column width instead of flex ratio. See above.
     * @property {boolean} [fixedWidth] - Default: false. Set to true to disable column resizing
     * @property {boolean} [staticWidth] - Default: false. Set to true to prevent columns from changing width when the width of the tree increases or decreases
     * @property {number} [minWidth] - Override the default [20px] column min-width for resizing
     * @property {React.Component} [iconLabel] - Set an Icon label instead of a text-based one
     * @property {string} [iconPath] - Set an Icon path, overrides {iconLabel}
     * @property {string | React.Component} [htmlLabel] - Set an HTML label, overrides {iconLabel} and {label}. Can be a HTML string or a React component.
     * @property {boolean} [showInColumnPicker=true] - Default: true. Set to true to show in column picker.
     * @property {boolean} [columnPickerSubMenu=false] - Default: false. Set to true to display the column in "More Columns" submenu of column picker.
     * @property {boolean} [primary] - Should only be one column at the time. Title is the primary column
     * @property {(item: Zotero.Item, dataKey: string) => string} [dataProvider] - Custom data provider that is called when rendering cells
     * @property {(index: number, data: string, column: ItemTreeColumnOptions & {className: string}, isFirstColumn: boolean, doc: Document) => HTMLElement} [renderCell] - The cell renderer function
     * @property {string[]} [zoteroPersist] - Which column properties should be persisted between zotero close
     */
    interface ItemTreeColumnOptions {
      dataKey: string;
      label: string;
      pluginID?: string;
      enabledTreeIDs?: string[];
      defaultIn?: string[];
      disabledIn?: string[];
      sortReverse?: boolean;
      flex?: number;
      width?: string;
      fixedWidth?: boolean;
      staticWidth?: boolean;
      minWidth?: number;
      iconLabel?: React.ReactElement;
      iconPath?: string;
      htmlLabel?: string | React.ReactElement;
      showInColumnPicker?: boolean;
      columnPickerSubMenu?: boolean;
      primary?: boolean;
      custom?: boolean;
      dataProvider?: (item: Zotero.Item, dataKey: string) => string;
      renderCell?: (
        index: number,
        data: string,
        column: ItemTreeColumnOptions & { className: string },
        isFirstColumn: boolean,
        doc: Document,
      ) => HTMLElement;
      zoteroPersist?: string[];
    }

    type RequiredCustomColumnOptionKeys = "dataKey" | "label" | "pluginID";
    type RequiredCustomColumnOptionsPartial = Required<
      Pick<ItemTreeColumnOptions, RequiredCustomColumnOptionKeys>
    >;
    type CustomColumnOptionsPartial = Omit<
      ItemTreeColumnOptions,
      RequiredCustomColumnOptionKeys
    >;
    type ItemTreeCustomColumnOptions = RequiredCustomColumnOptionsPartial &
      CustomColumnOptionsPartial;
    type ItemTreeCustomColumnFilters = Partial<
      Omit<ItemTreeCustomColumnOptions, "enabledTreeIDs">
    >;
  }
  interface ItemTreeManager {
    _observerAdded: boolean;
    _customColumns: Record<string, ItemTreeManager.ItemTreeCustomColumnOptions>;

    /**
     * Register a custom column. All registered columns must be valid, and must have a unique dataKey.
     * Although it's async, resolving does not promise the item trees are updated.
     *
     * Note that the `dataKey` you use here may be different from the one returned by the function.
     * This is because the `dataKey` is prefixed with the `pluginID` to avoid conflicts after the column is registered.
     * @param {ItemTreeCustomColumnOptions} options - An option to register
     * @returns {string | false} - The dataKey(s) of the added column(s) or false if no columns were added
     * @example
     * A minimal custom column:
     * ```js
     * // You can unregister the column later with Zotero.ItemTreeManager.unregisterColumns(registeredDataKey);
     * const registeredDataKey = await Zotero.ItemTreeManager.registerColumn(
     * {
     *     dataKey: 'rtitle',
     *     label: 'Reversed Title',
     *     pluginID: 'make-it-red@zotero.org', // Replace with your plugin ID
     *     dataProvider: (item, dataKey) => {
     *         return item.getField('title').split('').reverse().join('');
     *     },
     * });
     * ```
     * @example
     * A custom column using all available options.
     * Note that the column will only be shown in the main item tree.
     * ```js
     * const registeredDataKey = await Zotero.ItemTreeManager.registerColumn(
     * {
     *     dataKey: 'rtitle',
     *     label: 'Reversed Title',
     *     enabledTreeIDs: ['main'], // only show in the main item tree
     *     sortReverse: true, // sort by increasing order
     *     flex: 0, // don't take up all available space
     *     width: 100, // assign fixed width in pixels
     *     fixedWidth: true, // don't allow user to resize
     *     staticWidth: true, // don't allow column to be resized when the tree is resized
     *     minWidth: 50, // minimum width in pixels
     *     iconPath: 'chrome://zotero/skin/tick.png', // icon to show in the column header
     *     htmlLabel: '<span style="color: red;">reversed title</span>', // use HTML in the label. This will override the label and iconPath property
     *     showInColumnPicker: true, // show in the column picker
     *     columnPickerSubMenu: true, // show in the column picker submenu
     *     pluginID: 'make-it-red@zotero.org', // plugin ID, which will be used to unregister the column when the plugin is unloaded
     *     dataProvider: (item, dataKey) => {
     *         // item: the current item in the row
     *         // dataKey: the dataKey of the column
     *         // return: the data to display in the column
     *         return item.getField('title').split('').reverse().join('');
     *     },
     * 	   renderCell: (index, data, column) => {
     *         // index: the index of the row
     *         // data: the data to display in the column, return of `dataProvider`
     *         // column: the column options
     *         // return: the HTML to display in the cell
     *         const cell = document.createElement('span');
     *         cell.className = `cell ${column.className}`;
     *         cell.textContent = data;
     *         cell.style.color = 'red';
     *         return cell;
     *     },
     *     zoteroPersist: ['width', 'hidden', 'sortDirection'], // persist the column properties
     * });
     * ```
     */
    registerColumn(
      options: ItemTreeManager.ItemTreeCustomColumnOptions,
    ): string | false;

    /**
     * @deprecated Use `registerColumn` instead
     */
    registerColumns(
      options: ItemTreeManager.ItemTreeCustomColumnOptions,
    ): Promise<string | false>;

    /**
     * @deprecated Use `registerColumn` instead
     */
    registerColumns(
      options: ItemTreeManager.ItemTreeCustomColumnOptions[],
    ): Promise<string[] | false>;

    /**
     * Unregister a custom column.
     * Although it's async, resolving does not promise the item trees are updated.
     * @param {string} dataKeys - The dataKey of the column to unregister
     * @returns {boolean} true if the column are unregistered
     * @example
     * ```js
     * Zotero.ItemTreeManager.unregisterColumn(registeredDataKey);
     * ```
     */
    unregisterColumn(dataKey: string): boolean;

    /**
     * @deprecated Use `unregisterColumn` instead
     */
    unregisterColumns(dataKeys: string | string[]): Promise<boolean>;

    /**
     * Check if a column is registered as a custom column
     * @param {string} dataKey - The dataKey of the column
     * @returns {boolean} true if the column is registered as a custom column
     */
    isCustomColumn(dataKey: string): boolean;

    /**
     * A centralized data source for custom columns. This is used by the ItemTreeRow to get data.
     * @param {Zotero.Item} item - The item to get data from
     * @param {string} dataKey - The dataKey of the column
     * @returns {string}
     */
    getCustomCellData(item: Zotero.Item, dataKey: string): string;

    refreshColumns(): void;
  }
}

declare namespace Zotero {
  const ItemTreeManager: _ZoteroTypes.ItemTreeManager;
}

declare namespace _ZoteroTypes {
  interface Plugins {
    init(): Promise<void>;
    getRootURI(id: string): Promise<string>;
    resolveURI(id: string, uri: string | URL): Promise<string>;
    getName(id: string): Promise<string>;
    getIconURI(id: string, idealSize: number): Promise<string | null>;
    addObserver(observer: Plugins.observer): void;
    removeObserver(observer: Plugins.observer): void;
  }

  namespace Plugins {
    type _observerFunction = (
      params: { id: string; version: string; rootURI: string },
      reason: number,
    ) => void;

    type observer = {
      install?: _observerFunction;
      startup?: _observerFunction;
      shutdown?: _observerFunction;
      uninstall?: _observerFunction;
    };
  }
}

declare namespace Zotero {
  const Plugins: _ZoteroTypes.Plugins;
}

declare namespace _ZoteroTypes {
  interface PreferencePanes {
    builtInPanes: _ZoteroTypes._PreferencePaneOption[];
    pluginPanes: _ZoteroTypes._PreferencePaneOption[];

    /**
     * Register a pane to be displayed in the preferences. The pane XHTML (`src`)
     * is loaded as a fragment, not a full document, with XUL as the default
     * namespace and (X)HTML tags available under `html:`.
     *
     * The pane will be unregistered automatically when the registering plugin
     * shuts down.
     *
     * @param {Object} options
     * @param {String} options.pluginID ID of the plugin registering the pane
     * @param {String} options.src URI of an XHTML fragment, optionally relative to the plugin's root
     * @param {String} [options.id] Represents the pane and must be unique. Automatically generated if not provided
     * @param {String} [options.parent] ID of parent pane (if provided, pane is hidden from the sidebar)
     * @param {String} [options.label] Displayed as the pane's label in the sidebar.
     * 		If not provided, the plugin's name is used
     * @param {String} [options.image] URI of an icon to be displayed in the navigation sidebar, optionally relative to
     * 		the plugin's root. If not provided, the plugin's icon (from manifest.json) is used.
     * @param {String[]} [options.scripts] Array of URIs of scripts to load along with the pane, optionally relative to
     * 		the plugin's root
     * @param {String[]} [options.stylesheets] Array of URIs of CSS stylesheets to load along with the pane, optionally
     * 		relative to the plugin's root
     * @param {String} [options.helpURL] If provided, a help button will be displayed under the pane
     * 		and the provided URL will open when it is clicked
     * @return {Promise<String>} Resolves to the ID of the pane if successfully added
     */
    register(options: _ZoteroTypes._PreferencePaneOption): Promise<string>;

    /**
     * Called automatically on plugin shutdown.
     *
     * @param {String} id
     */
    unregister(id: string): void;

    _refreshPreferences(): void;

    _ensureObserverAdded(): void;
  }

  type _PreferencePaneOption = {
    pluginID: string;
    src: string;
    id?: string;
    parent?: string;
    label?: string;
    image?: string;
    scripts?: string[];
    stylesheets?: string[];
    helpURL?: string;
    defaultXUL?: boolean;
  };
}

declare namespace Zotero {
  const PreferencePanes: _ZoteroTypes.PreferencePanes;
}


declare namespace Zotero {
  namespace Prefs {
    /**
     * Retrieve a preference
     */
    function get(
      pref: string,
      global?: boolean,
    ): boolean | string | number | undefined;

    /**
     * Set a preference
     */
    function set(
      pref: string,
      value: boolean | string | number,
      global?: boolean,
    ): any;

    function clear(pref: string, global?: boolean): void;

    function resetBranch(exclude?: string[], branch?: string): void;

    /**
     * @param {String} name - Preference name; if not global, this is on the extensions.zotero branch
     * @param {Function} handler
     * @param {Boolean} [global]
     * @return {Symbol} - Symbol to pass to unregisterObserver()
     */
    function registerObserver(
      name: string,
      handler: Function,
      global?: boolean,
    ): symbol;

    /**
     * @param {Symbol} symbol - Symbol returned from registerObserver()
     */
    function unregisterObserver(symbol: symbol): void;

    const rootBranch: nsIPrefBranch;
  }
}


declare namespace Zotero {
  class ProgressWindow {
    constructor(options?: { window?: Window; closeOnClick?: boolean });

    /**
     * Shows the progress window
     */
    show(): boolean;

    /**
     * Changes the "headline" shown at the top of the progress window
     */
    changeHeadline(text: string, icon?: string, postText?: string): void;

    /**
     * Adds a line to the progress window with the specified icon
     */
    addLines(
      labels: string | { [key: string | number | symbol]: string },
      icons: string | { [key: string | number | symbol]: string },
    ): void;

    /**
     * Add a description to the progress window
     *
     * <a> elements are turned into XUL links
     */
    addDescription(text: string): void;

    /**
     * Sets a timer to close the progress window. If a previous close timer was set,
     * clears it.
     * @param {Integer} ms The number of milliseconds to wait before closing the progress
     *     window.
     * @param {Boolean} [requireMouseOver] If true, wait until the mouse has touched the
     *     window before closing.
     */
    startCloseTimer(ms: number, requireMouseOver?: boolean): void;

    /**
     * Immediately closes the progress window if it is open.
     */
    close(): void;

    ItemProgress: _ZoteroTypes.ItemProgress;
  }

  const ProgressWindowSet: {
    closeAll(): void;
  };
}

declare namespace _ZoteroTypes {
  type ItemProgress = {
    /**
     * Creates a new object representing a line in the progressWindow. This is the OO
     * version of addLines() above.
     */
    new (
      iconSrc: string,
      text: string,
      parentItemProgress?: ItemProgress,
    ): ItemProgress;

    /**
     * Sets the current save progress for this item.
     * @param {Integer} percent A percentage from 0 to 100.
     */
    setProgress(percent: number): void;

    /**
     * Sets the icon for this item.
     * @param {String} iconSrc
     */
    setIcon(iconSrc: string): void;

    setText(text: string): void;

    /**
     * Indicates that an error occurred saving this item.
     */
    setError(): void;

    Translation: {
      operationInProgress(): void;
      cannotEditCollection(): void;
      cannotAddToPublications(): void;
      cannotAddToFeed(): void;
      scrapingTo(libraryID?: number, collection?: Zotero.Collection): void;
      doneHandler(obj?: any, returnValue?: boolean): void;
      _scrapeError(description: string): void;
    };
  };
}


// chrome/content/zotero/xpcom/reader.js

declare namespace _ZoteroTypes {
  namespace Reader {
    interface State {
      pageIndex: number;
      scale: number | "auto" | "page-width" | "page-fit";
      top: number;
      left: number;
      scrollMode: number;
      spreadMode: 0 | 1 | 2;
    }

    interface SecondViewState {
      splitSize: string;
      splitType: string;
      pageIndex: number;
      scale: number;
      top: number;
      left: number;
    }

    interface Location {
      annotationKey?: string;
      id?: string;
      pageIndex?: number;
      pageLabel?: string;
      position?: {
        pageIndex?: number;
        rects?: Array<number[]>;
        paths?: unknown;
      };
    }

    interface OpenOptions {
      title?: string;
      tabIndex?: number;
      tabID?: string;
      openInBackground?: boolean;
      openInWindow?: boolean;
      allowDuplicate?: boolean;
    }

    /**
     * @deprecated Use `EventHandler` instead.
     * @see EventHandler
     */
    type ReaderEventHandler<
      ParamsType = {},
      AppendType = () => void,
      EventType = "",
    > = (event: {
      reader: _ZoteroTypes.ReaderInstance;
      doc: Document;
      params: ParamsType;
      append: AppendType;
      type: EventType;
    }) => void | Promise<void>;
    type _EventKey = keyof _ZoteroTypes.Reader.ReaderEventMap; // internal type
    type EventParams<T extends _EventKey> = {
      reader: ReaderInstance;
      doc: Document;
      params: _ZoteroTypes.Reader.ReaderEventMap[T];
      append: _ZoteroTypes.Reader.ReaderAppendMap[T];
      type: T;
    };
    type EventHandler<T extends _EventKey> = (
      event: EventParams<T>,
    ) => void | Promise<void>;

    interface ReaderEventMap {
      renderTextSelectionPopup: {
        annotation: _ZoteroTypes.Annotations.AnnotationJson;
      };
      renderSidebarAnnotationHeader: {
        annotation: _ZoteroTypes.Annotations.AnnotationJson;
      };
      renderToolbar: {};
      createColorContextMenu: { x: number; y: number };
      createViewContextMenu: { x: number; y: number };
      createAnnotationContextMenu: {
        ids: string[];
        currentID: string;
        x: number;
        y: number;
      };
      createThumbnailContextMenu: {
        x: number;
        y: number;
        pageIndexes: number[];
      };
      createSelectorContextMenu: { x: number; y: number };
    }

    interface ReaderAppendType {
      appendDOM: (...node: Array<Node | string>) => void;
      appendMenu: (params: {
        slider?: boolean;
        size?: number;
        label: string;
        disabled?: boolean;
        persistent?: boolean;
        onCommand: (width?: number) => void;
      }) => void;
    }

    interface ReaderAppendMap {
      renderTextSelectionPopup: ReaderAppendType["appendDOM"];
      renderSidebarAnnotationHeader: ReaderAppendType["appendDOM"];
      renderToolbar: ReaderAppendType["appendDOM"];
      createColorContextMenu: ReaderAppendType["appendMenu"];
      createViewContextMenu: ReaderAppendType["appendMenu"];
      createAnnotationContextMenu: ReaderAppendType["appendMenu"];
      createThumbnailContextMenu: ReaderAppendType["appendMenu"];
      createSelectorContextMenu: ReaderAppendType["appendMenu"];
    }
  }

  interface ReaderInstance<
    T extends keyof Reader.ViewTypeMap = "pdf" | "epub" | "snapshot",
  > extends Reader.InternalReader<T> {
    pdfStateFileName: string;
    annotationItemIDs: number[];
    itemID?: number;
    state: Reader.State;
    _instanceID: string;
    _window?: Window;
    _iframe?: XUL.Element & _ZoteroTypes.anyObj;
    _iframeWindow?: Window;
    _title: string;
    _isReaderInitialized: boolean;
    _showItemPaneToggle: boolean;
    _initPromise: Promise<any>;
    _internalReader: Reader.InternalReader<T>;
    _item: Zotero.Item;
    _bottomPlaceholderHeight: number;
    _sidebarOpen: boolean;
    _sidebarWidth: number;
    _tabContainer: XUL.Box;
    readonly type: T;
    stateFileName: string;
    tabID: string;
    focus(): void;
    getSecondViewState(): Reader.SecondViewState | undefined;
    migrateMendeleyColors(
      libraryID: number,
      annotations: Array<{ id: string; color: string }>,
    ): Promise<boolean>;
    open(options: {
      itemID: number;
      state: Reader.State;
      location?: Reader.Location;
      secondViewState?: Reader.SecondViewState;
    }): Promise<boolean>;
    uninit(): void;
    updateTitle(): void;
    setAnnotations(items: Zotero.Item[]): void;
    unsetAnnotations(keys: readonly number[] | string[]): void;
    navigate(location: Reader.Location): Promise<void>;
    enableAddToNote(enable: boolean): void;
    setSidebarWidth(width: number): void;
    setSidebarOpen(open: boolean): void;
    focusLastToolbarButton(): void;
    tabToolbar(reverse: boolean): void;
    focusFirst(): void;
    setBottomPlaceholderHeight(height: number): Promise<void>;
    setToolbarPlaceholderWidth(height: number): Promise<void>;
    isHandToolActive(): boolean;
    isZoomAutoActive(): boolean;
    isZoomPageWidthActive(): boolean;
    isZoomPageHeightActive(): boolean;
    isSplitVerticallyActive(): boolean;
    isSplitHorizontallyActive(): boolean;
    allowNavigateFirstPage(): boolean;
    allowNavigateLastPage(): boolean;
    allowNavigateBack(): boolean;
    allowNavigateForward(): boolean;
    promptToTransferAnnotations(): boolean;
    promptToDeletePages(num: number): boolean;
    reload(data: { rotatedPageIndexes: number[] }): Promise<void>;
    menuCmd(
      cmd:
        | "transferFromPDF"
        | "export"
        | "showInLibrary"
        | "rotateLeft"
        | "rotateRight"
        | "rotate180"
        | "splitVertically"
        | "splitHorizontally",
    ): Promise<void>;
    _initIframeWindow(): boolean;
    _setState(state: Reader.State): Promise<void>;
    _getState(): Promise<Reader.State | null>;
    _isReadOnly(): boolean;
    _dataURLtoBlob(dataurl: string): Blob;
    _getColorIcon(color: string, selected: boolean): string;
    _rotateCurrentPage(degrees: number): Promise<void>;
    _splitVertically(): void;
    _splitHorizontally(): void;
    _openTagsPopup(item: Zotero.Item, selector: string): void;
    _openPagePopup(data: unknown, secondView?: boolean): void;
    _openAnnotationPopup(data: unknown): void;
    _openColorPopup(data: unknown): void;
    _openThumbnailPopup(data: unknown): void;
    _openSelectorPopup(data: unknown): void;
    _postMessage(
      message: object,
      transfer?: unknown[],
      secondView?: boolean,
    ): Promise<void>;
    _handleMessage(event: MessageEvent): Promise<void>;
    _updateSecondViewState(): void;
    _waitForReader(): Promise<void>;

    /**
     * Return item JSON in the pdf-reader ready format
     *
     * @param {Zotero.Item} item
     * @returns {Object|null}
     */
    _getAnnotation(item: Zotero.Item): _ZoteroTypes.anyObj | null;
  }

  interface ReaderTab extends ReaderInstance {
    new (options: {
      itemID: number;
      title: string;
      sidebarWidth: number;
      sidebarOpen: boolean;
      bottomPlaceholderHeight: number;
      index: number;
      tabID: string;
      background: boolean;
    }): this;
    close(): void;
    _toggleNoteSidebar(isToggled?: boolean): void;
    _setTitleValue(title: string): void;
    _addToNote(annotations: unknown): void;
  }

  interface ReaderWindow extends ReaderInstance {
    new (options: {
      sidebarWidth: number;
      sidebarOpen: boolean;
      bottomPlaceholderHeigh?: number;
    }): this;
    init(): void;
    close(): void;
    _setTitleValue(title: string): void;
    _handleKeyPress(event: KeyboardEvent): void;
    _onViewMenuOpen(): void;
    _onGoMenuOpen(): void;
  }
  class Reader {
    [attr: string]: any;
    constructor();
    _readers: _ZoteroTypes.ReaderInstance[];
    _sidebarWidth: number;
    _sidebarOpen: boolean;
    _bottomPlaceholderHeight: number;
    _notifierID: string;
    onChangeSidebarWidth(width: number): void;
    onChangeSidebarOpen(open: boolean): void;
    getSidebarWidth(): number;
    init(): Promise<void>;
    _loadSidebarState(): void;
    _setSidebarState(): void;
    getSidebarOpen(): boolean;
    setSidebarWidth(width: number): void;
    setSidebarOpen(open: boolean): void;
    setBottomPlaceholderHeight(height: number): void;
    notify: _ZoteroTypes.Notifier.Notify;
    getByTabID(tabID: string): _ZoteroTypes.ReaderInstance;
    getWindowStates(): {
      type: "reader";
      itemID: number;
      title: string;
      secondViewState: Reader.SecondViewState;
    }[];
    openURI: (
      itemURI: _ZoteroTypes.ZoteroObjectURI,
      location?: _ZoteroTypes.Reader.Location,
      options?: Reader.OpenOptions,
    ) => Promise<void | ReaderInstance>;
    open: (
      itemID: number,
      location?: _ZoteroTypes.Reader.Location,
      options?: Reader.OpenOptions,
    ) => Promise<void | ReaderInstance>;

    /**
     * Trigger annotations import
     *
     * @param {Integer} itemID Attachment item id
     * @returns {Promise}
     */
    triggerAnnotationsImportCheck(itemID: number): Promise<void>;

    /**
     * Inject DOM nodes to reader UI parts:
     * - renderTextSelectionPopup
     * - renderSidebarAnnotationHeader
     * - renderToolbar
     *
     * Zotero.Reader.registerEventListener('renderTextSelectionPopup', (event) => {
     * 	let { reader, doc, params, append } = event;
     * 	let container = doc.createElement('div');
     * 	container.append('Loading…');
     * 	append(container);
     * 	setTimeout(() => container.replaceChildren('Translated text: ' + params.annotation.text), 1000);
     * });
     *
     *
     * Add options to context menus:
     * - createColorContextMenu
     * - createViewContextMenu
     * - createAnnotationContextMenu
     * - createThumbnailContextMenu
     * - createSelectorContextMenu
     *
     * Zotero.Reader.registerEventListener('createAnnotationContextMenu', (event) => {
     * 	let { reader, params, append } = event;
     * 	append({
     * 		label: 'Test',
     * 		onCommand(){ reader._iframeWindow.alert('Selected annotations: ' + params.ids.join(', ')); }
     * 	});
     * });
     */
    registerEventListener<T extends Reader._EventKey>(
      type: T,
      handler: Reader.EventHandler<T>,
      pluginID?: string,
    ): void;

    unregisterEventListener<T extends Reader._EventKey>(
      type: T,
      handler: Reader.EventHandler<T>,
    ): void;
  }
}

declare namespace Zotero {
  const Reader: _ZoteroTypes.Reader;
}


declare namespace _ZoteroTypes {
  interface Server {
    responseCodes: {
      200: "OK";
      201: "Created";
      204: "No Content";
      300: "Multiple Choices";
      400: "Bad Request";
      403: "Forbidden";
      404: "Not Found";
      409: "Conflict";
      412: "Precondition Failed";
      500: "Internal Server Error";
      501: "Not Implemented";
      503: "Service Unavailable";
      504: "Gateway Timeout";
    };

    close(): void;

    /**
     * Parses a query string into a key => value object
     * @param {String} queryString Query string
     */
    decodeQueryString(queryString: string): Record<string, string>;

    /**
     * Endpoints for the HTTP server
     *
     * Each endpoint should take the form of an object. The init() method of this object will be passed:
     *     method - the method of the request ("GET" or "POST")
     *     data - the query string (for a "GET" request) or POST data (for a "POST" request)
     *     sendResponseCallback - a function to send a response to the HTTP request. This can be passed
     *                            a response code alone (e.g., sendResponseCallback(404)) or a response
     *                            code, MIME type, and response body
     *                            (e.g., sendResponseCallback(200, "text/plain", "Hello World!"))
     *
     * See connector/server_connector.js for examples
     */
    Endpoints: Record<string, typeof Server.Endpoint | Function>;
  }

  namespace Server {
    class Endpoint {
      supportedMethods?: string[];
      supportedDataTypes?: Array<
        | "application/json"
        | "application/x-www-form-urlencoded"
        | "multipart/form-data"
        | string
      >;
      permitBookmarklet?: boolean;

      init: initMethodEvent | initMethodPromise;
    }

    type initMethodPromise = (options: {
      method: "GET" | "POST";
      pathname: string;
      query: Record<string, string>;
      headers: Record<string, string>;
      data: any;
    }) => MaybePromise<
      | number
      | [
          code: number,
          contentTypeOrHeaders?: string | Record<string, string>,
          body?: string,
        ]
    >;

    type initMethodEvent = (
      data: string,
      sendResponseCallback: (
        code: number,
        contentTypeOrHeaders?: string | Record<string, string>,
        body?: string,
      ) => void,
    ) => void;
  }
}

declare namespace Zotero {
  const Server: _ZoteroTypes.Server;
}

declare namespace Zotero {
  namespace Session {
    const state: Record<string, any>;

    function init(): Promise<void>;
    function save(): Promise<void>;
    function debounceSave(): Promise<void>;
    function setLastClosedZoteroPaneState(): void;
  }
}

declare namespace Zotero {
  namespace UIProperties {
    function registerRoot(root: Element): void;
    function setAll(): void;
    function set(root: Element): void;
  }
}


declare namespace _ZoteroTypes {
  interface URI {
    defaultPrefix: {
      value: "http://zotero.org/";
    };
    getLocalUserURI(): _ZoteroTypes.ZoteroObjectURI;
    getCurrentUserURI(): _ZoteroTypes.ZoteroObjectURI;
    getCurrentUserLibraryURI(): _ZoteroTypes.ZoteroObjectURI;
    getLibraryURI(libraryID: number): _ZoteroTypes.ZoteroObjectURI;
    /**
     * Get path portion of library URI (e.g., users/6 or groups/1)
     */
    getLibraryPath(libraryID: number): string;
    /**
     * Get library from path (e.g., users/6 or groups/1)
     */
    getPathLibrary(path: string): Zotero.Library | false;
    /**
     * Return URI of item, which might be a local URI if user hasn't synced
     */
    getItemURI(item: Zotero.Item): _ZoteroTypes.ZoteroObjectURI;
    /**
     * Get path portion of item URI (e.g., users/6/items/ABCD1234 or groups/1/items/ABCD1234)
     */
    getItemPath(item: Zotero.Item): string;
    getFeedItemURI(feedItem: Zotero.Item): _ZoteroTypes.ZoteroObjectURI;
    getFeedItemPath(feedItem: Zotero.Item): string;
    /**
     * Return URI of collection, which might be a local URI if user hasn't synced
     */
    getCollectionURI(feedItem: Zotero.Collection): _ZoteroTypes.ZoteroObjectURI;
    /**
     * Get path portion of collection URI (e.g., users/6/collections/ABCD1234 or groups/1/collections/ABCD1234)
     */
    getCollectionPath(feedItem: Zotero.Collection): string;
    getFeedURI(feed: Zotero.DataObject): _ZoteroTypes.ZoteroObjectURI;
    getFeedPath(feed: Zotero.DataObject): string;
    getGroupsURL(): string;
    getGroupURI(group: Zotero.Collection): _ZoteroTypes.ZoteroObjectURI;
    _getObjectPath: (
      obj: Zotero.Library | Zotero.Collection | Zotero.Item,
    ) => string;
    _getObjectURI: (
      obj: Zotero.Library | Zotero.Collection | Zotero.Item,
    ) => _ZoteroTypes.ZoteroObjectURI;
    /**
     * Convert an item URI into an item
     */
    getURIItem(itemURI: _ZoteroTypes.ZoteroObjectURI): Promise<Zotero.Item>;
    getURIItemLibraryKey: (
      itemURI: _ZoteroTypes.ZoteroObjectURI,
    ) => { libraryID: number; key?: string; objectType?: string } | false;
    /**
     * Convert an item URI into a libraryID and key from the database, without relying on global state
     *
     * Note that while the URI must point to a valid library, the item doesn't need to exist
     */
    getURIItemLibraryKeyFromDB(itemURI: _ZoteroTypes.ZoteroObjectURI): any;
    getURIItemID(itemURI: _ZoteroTypes.ZoteroObjectURI): number | false;
    /**
     * Convert a collection URI into a collection
     */
    getURICollection: (
      collectionURI: _ZoteroTypes.ZoteroObjectURI,
    ) => Promise<Zotero.Collection | false>;
    getURICollectionLibraryKey: (
      collectionURI: _ZoteroTypes.ZoteroObjectURI,
    ) => { libraryID: number; key?: string; objectType?: string } | false;
    getURICollectionID(
      collectionURI: _ZoteroTypes.ZoteroObjectURI,
    ): number | false;
    getURILibrary(libraryURI: _ZoteroTypes.ZoteroObjectURI): number | false;
    getURIFeed(feedURI: _ZoteroTypes.ZoteroObjectURI): Zotero.Library | false;
    /**
     * Convert an object URI into an object containing libraryID and key
     */
    _getURIObject: (
      objectURI: _ZoteroTypes.ZoteroObjectURI,
      type: string,
    ) => { libraryID: number; key?: string; objectType?: string } | false;
    /**
     * Convert an object URI into a Zotero.Library that the object is in
     */
    _getURIObjectLibrary(
      objectURI: _ZoteroTypes.ZoteroObjectURI,
    ): Zotero.Library | false;
    /**
     * Convert an object URI into a libraryID from the database, without relying on global state
     */
    _getURIObjectLibraryID(
      objectURI: _ZoteroTypes.ZoteroObjectURI,
    ): Promise<number | false>;
    /**
     * Convert an object URI into a libraryID and key from the database, without relying on global state
     *
     * Note that while the URI must point to a valid library, the object doesn't need to exist
     */
    _getURIObjectLibraryKeyFromDB: (
      objectURI: _ZoteroTypes.ZoteroObjectURI,
      type: string,
    ) => Promise<
      { libraryID: number; key?: string; objectType?: string } | false
    >;
  }
}

declare namespace Zotero {
  const URI: _ZoteroTypes.URI;
}

declare namespace _ZoteroTypes {
  interface Users {
    init(): Promise<void>;
    getCurrentUserID(): number;
    setCurrentUserID(val: number): Promise<void>;
    getCurrentUsername(): string;
    setCurrentUsername(val: string): Promise<void>;
    getCurrentName(): string;
    setCurrentName(name: string): Promise<void>;
    getLocalUserKey(): string;
    getName(userID: number | string): string;
    setName(userID: number, name: string): Promise<void>;
  }
}

declare namespace Zotero {
  const Users: _ZoteroTypes.Users;
}

declare namespace _ZoteroTypes {
  interface Utilities_Date {
    /**
     * Initializes localized months for strToDate month parsing
     * @param dateFormatsJSON {Object} the JSON from resource/dateFormats.json
     */
    init(dateFormatsJSON: object): void;

    /**
     * @param {Boolean} [withEnglish = false] - Include English months
     * @return {Object} - Object with 'short' and 'long' arrays
     */
    getMonths(withEnglish: boolean): {
      short: string[];
      long: string[];
    };

    /**
     * Convert an SQL date in the form '2006-06-13 11:03:05' into a JS Date object
     *
     * Can also accept just the date part (e.g. '2006-06-13')
     **/
    sqlToDate(sqldate: string, isUTC?: boolean): Date | false;

    /**
     * Convert a JS Date object to an SQL date in the form '2006-06-13 11:03:05'
     *
     * If _toUTC_ is true, creates a UTC date
     **/
    dateToSQL(date: Date, toUTC?: boolean): string;

    /**
     * Convert a JS Date object to an ISO 8601 UTC date/time
     *
     * @param	{Date}		date		JS Date object
     * @return	{String}				ISO 8601 UTC date/time
     *									e.g. 2008-08-15T20:00:00Z
     */
    dateToISO(date: Date): string;

    /**
     * @return {Boolean} - True if string is an ISO 8601 date, false if not
     */
    isISODate(str: string): boolean;

    /**
     * Convert an ISO 8601–formatted date/time to a JS Date
     *
     * @param	{String}		isoDate		ISO 8601 date
     * @return {Date|False} - JS Date, or false if not a valid date
     */
    isoToDate(isoDate: string): Date | false;

    isoToSQL(isoDate: string): string;

    /*
     * converts a string to an object containing:
     *    day: integer form of the day
     *    month: integer form of the month (indexed from 0, not 1)
     *    year: 4 digit year (or, year + BC/AD/etc.)
     *    part: anything that does not fall under any of the above categories
     *          (e.g., "Summer," etc.)
     *
     * Note: the returned object is *not* a JS Date object
     */
    strToDate(string: string): Utilities_Date.Date;

    isHTTPDate(str: string): boolean;

    /**
     * does pretty formatting of a date object returned by strToDate()
     *
     * @param {Object} date A date object, as returned from strToDate()
     * @param {Boolean} shortFormat Whether to return a short (12/1/95) date
     * @return A formatted date string
     * @type String
     **/
    formatDate(date: Utilities_Date.Date, shortFormat: boolean): string;

    strToISO(str: string): string | false;

    sqlToISO8601(sqlDate: string): string;

    strToMultipart(str: string): string;

    /**
     * Tests if a string is a multipart date string
     * e.g. '2006-11-03 November 3rd, 2006'
     */
    isMultipart(str: string): boolean;

    /**
     * Returns the SQL part of a multipart date string
     * (e.g. '2006-11-03 November 3rd, 2006' returns '2006-11-03')
     */
    multipartToSQL(multi: string): string;

    /**
     * Returns the user part of a multipart date string
     * (e.g. '2006-11-03 November 3rd, 2006' returns 'November 3rd, 2006')
     */
    multipartToStr(multi: string): string;

    /**
     * Convert 'yesterday'/'today'/'tomorrow' to SQL date, or else return original string
     *
     * @param {String} str
     * @return {String}
     */
    parseDescriptiveString(str: string): string;

    isSQLDate(str: string, allowZeroes?: boolean): boolean;

    isSQLDateTime(str: string): boolean;

    isSQLDateTimeWithoutSeconds(str: string): boolean;

    sqlHasYear(sqldate: string): boolean;

    sqlHasMonth(sqldate: string): boolean;

    sqlHasDay(sqldate: string): boolean;

    getUnixTimestamp(): number;

    toUnixTimestamp(date: string): number;

    /**
     * Convert a JS Date to a relative date (e.g., "5 minutes ago")
     *
     * Adapted from http://snipplr.com/view/10290/javascript-parse-relative-date/
     *
     * @param	{Date}	date
     * @return	{String}
     */
    toRelativeDate(date: Date): string;

    toFriendlyDate(date: Date): string;

    // The following three methods exist in the source code but are not exposed in `Zotero.Date`
    // isToday();
    // isThisWeek();
    // getWeekNumber();

    getFileDateString(file: nsIFile): string;
    getFileTimeString(file: nsIFile): string;
    /**
     * Get the order of the date components based on the current locale
     *
     * Returns a string with y, m, and d (e.g. 'ymd', 'mdy')
     */
    getLocaleDateOrder(): "mdy" | "ymd" | "dmy";
  }

  namespace Utilities_Date {
    interface Date {
      year?: string;
      month?: number;
      day?: number;
      part?: string;
      order?: string;
    }
  }
}

declare namespace Zotero {
  const Date: _ZoteroTypes.Utilities_Date;
}


declare namespace _ZoteroTypes {
  interface Utilities {
    Internal: Utilities.Internal;

    XRegExp: any;
    Item: anyObj;

    /**
     * Returns a function which will execute `fn` with provided arguments after `delay` milliseconds and not more
     * than once, if called multiple times. See
     * http://stackoverflow.com/questions/24004791/can-someone-explain-the-debounce-function-in-javascript
     * @param fn {Function} function to debounce
     * @param delay {Integer} number of milliseconds to delay the function execution
     * @returns {Function}
     */
    debounce<F extends Function>(fn: F, delay?: number): F;

    /**
     *  Creates and returns a new, throttled version of the
     *  passed function, that, when invoked repeatedly,
     *  will only actually call the original function at most
     *  once per every wait milliseconds
     *
     *  By default, throttle will execute the function as soon
     *  as you call it for the first time, and, if you call it
     *  again any number of times during the wait period, as soon
     *  as that period is over. If you'd like to disable the
     *  leading-edge call, pass {leading: false}, and if you'd
     *  like to disable the execution on the trailing-edge,
     *  pass {trailing: false}. See
     *  https://underscorejs.org/#throttle
     *  https://github.com/jashkenas/underscore/blob/master/underscore.js
     *  (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     *  Underscore may be freely distributed under the MIT license.
     *
     *  @param {Function} func Function to throttle
     *  @param {Integer} wait Wait period in milliseconds
     *  @param {Boolean} [options.leading] Call at the beginning of the wait period
     *  @param {Boolean} [options.trailing] Call at the end of the wait period
     */
    throttle(
      func: Function,
      wait: number,
      options?: { leading: boolean; trailing: boolean },
    ): Function;

    sentenceCase(str: string): string;

    /**
     * Fixes author name capitalization.
     * Currently for all uppercase names only
     *
     * JOHN -> John
     * GUTIÉRREZ-ALBILLA -> Gutiérrez-Albilla
     * O'NEAL -> O'Neal
     *
     * @param {String} string Uppercase author name
     * @return {String} Title-cased author name
     */
    capitalizeName(str: string): string;

    /**
     * Cleans extraneous punctuation off a creator name and parse into first and last name
     *
     * @param {String} author Creator string
     * @param {String} type Creator type string (e.g., "author" or "editor")
     * @param {Boolean} useComma Whether the creator string is in inverted (Last, First) format
     * @return {Object} firstName, lastName, and creatorType
     */
    cleanAuthor(
      author: string,
      type: string,
      useComma?: boolean,
    ): { firstName: string; lastName: string; creatorType: string };

    /**
     * Removes leading and trailing whitespace from a string
     * @type String
     */
    trim(s: string): string;

    /**
     * Cleans whitespace off a string and replaces multiple spaces with one
     * @type String
     */
    trimInternal(s: string): string;

    /**
     * Cleans any non-word non-parenthesis characters off the ends of a string
     * @type String
     */
    superCleanString(x: string): string;

    isHTTPURL(url: string, allowNoScheme?: boolean): boolean;

    /**
     * Cleans a http url string
     * @param {String} url
     * @param {Boolean} tryHttp Attempt prepending 'http://' to the url
     * @returns {String}
     */
    cleanURL(url: string, tryHttp?: boolean): string;

    /**
     * Eliminates HTML tags, replacing &lt;br&gt;s with newlines
     * @type String
     */
    cleanTags(x: string): string;

    /**
     * Extract item identifiers (DOI, ISBN, arXiv, ADS Bibcode, PMID) from a string.
     * @type String
     */
    extractIdentifiers(
      text: string,
    ): (
      | { DOI: string }
      | { ISBN: string }
      | { arXiv: string }
      | { adsBibcode: string }
      | { PMID: string }
    )[];

    /**
     * Strip info:doi prefix and any suffixes from a DOI
     * @type String
     */
    cleanDOI(x: string): null | string;

    /**
     * Clean and validate ISBN.
     * Return isbn if valid, otherwise return false
     * @param {String} isbn
     * @param {Boolean} [dontValidate=false] Do not validate check digit
     * @return {String|Boolean} Valid ISBN or false
     */
    cleanISBN(isbn: string, dontValidate?: boolean): string | false;

    /**
     * Convert ISBN 10 to ISBN 13
     * @param {String} isbn ISBN 10 or ISBN 13 cleanISBN
     * @return {String} ISBN-13
     */
    toISBN13(isbnStr: string): string;

    /**
     * Clean and validate ISSN.
     * Return issn if valid, otherwise return false
     */
    cleanISSN(issnStr: string): string | false;

    /**
     * Convert plain text to HTML by replacing special characters and replacing newlines with BRs or
     * P tags
     * @param {String} str Plain text string
     * @param {Boolean} singleNewlineIsParagraph Whether single newlines should be considered as
     *     paragraphs. If true, each newline is replaced with a P tag. If false, double newlines
     *     are replaced with P tags, while single newlines are replaced with BR tags.
     * @type String
     */
    text2html(str: string, singleNewlineIsParagraph?: boolean): string;

    /**
     * Encode special XML/HTML characters
     * Certain entities can be inserted manually:
     *   <ZOTEROBREAK/> => <br/>
     *   <ZOTEROHELLIP/> => &#8230;
     *
     * @param {String} str
     * @return {String}
     */
    htmlSpecialChars(str: string): string;

    /**
     * Wrap URLs and DOIs in <a href=""> links in plain text
     *
     * Ignore URLs preceded by '>', just in case there are already links
     * @type String
     */
    autoLink(str: string): string;

    /**
     * Parses a text string for HTML/XUL markup and returns an array of parts. Currently only finds
     * HTML links (&lt;a&gt; tags)
     *
     * @return {Array} An array of objects with the following form:<br>
     * <pre>   {
     *         type: 'text'|'link',
     *         text: "text content",
     *         [ attributes: { key1: val [ , key2: val, ...] }
     *    }</pre>
     */
    parseMarkup(str: string): {
      type: "text" | "link";
      text: string;
      attributes?: { [attr: string]: unknown };
    };

    /**
     * Calculates the Levenshtein distance between two strings
     * @type Number
     */
    levenshtein(a: string, b: string): number;

    /**
     * Test if an object is empty
     *
     * @param {Object} obj
     * @type Boolean
     */
    isEmpty(obj: object): boolean;

    /**
     * Compares an array with another and returns an array with
     *	the values from array1 that don't exist in array2
     *
     * @param	{Array}		array1
     * @param	{Array}		array2
     * @param	{Boolean}	useIndex		If true, return an array containing just
     *										the index of array2's elements;
     *										otherwise return the values
     */
    arrayDiff<T>(array1: T[], array2: T[], useIndex?: false): T[];
    arrayDiff(array1: [], array2: [], useIndex: true): number[];

    /**
     * Determine whether two arrays are identical
     *
     * Modified from http://stackoverflow.com/a/14853974
     *
     * @return {Boolean}
     */
    arrayEquals(array1: [], array2: []): boolean;

    /**
     * Return new array with values shuffled
     *
     * From http://stackoverflow.com/a/6274398
     *
     * @param {Array} arr
     * @return {Array}
     */
    arrayShuffle<T>(arr: T[]): T[];

    /**
     * Return new array with duplicate values removed
     *
     * @param	{Array}		array
     * @return	{Array}
     */
    arrayUnique<T>(array: T[]): T[];

    /**
     * Generate a random integer between min and max inclusive
     *
     * @param	{Integer}	min
     * @param	{Integer}	max
     * @return	{Integer}
     */
    rand(min: number, max: number): number;

    /**
     * Parse a page range
     *
     * @param {String} Page range to parse
     * @return {Integer[]} Start and end pages
     */
    getPageRange(pages: string): [start: number, end: number];

    /**
     * Pads a number or other string with a given string on the left
     *
     * @param {String} string String to pad
     * @param {String} pad String to use as padding
     * @length {Integer} length Length of new padded string
     * @type String
     */
    lpad(str: string, pad: string, length: number): string;

    /**
     * Shorten and add an ellipsis to a string if necessary
     *
     * @param {String}	str
     * @param {Integer}	len
     * @param {Boolean} [wordBoundary=false]
     * @param {Boolean} [countChars=false]
     */
    ellipsize(
      str: string,
      len: number,
      wordBoundary?: boolean,
      countChars?: boolean,
    ): string;

    /**
     * Return the proper plural form of a string
     *
     * For now, this is only used for debug output in English.
     *
     * @param {Integer} num
     * @param {String[]|String} forms - If an array, an array of plural forms (e.g., ['object', 'objects']);
     *     currently only the two English forms are supported, for 1 and 0/many. If a single string,
     *     's' is added automatically for 0/many.
     * @return {String}
     */
    pluralize(num: number, forms: string | string[]): string;

    /**
     * Port of PHP's number_format()
     *
     * MIT Licensed
     *
     * From http://kevin.vanzonneveld.net
     * +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
     * +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
     * +     bugfix by: Michael White (http://getsprink.com)
     * +     bugfix by: Benjamin Lupton
     * +     bugfix by: Allan Jensen (http://www.winternet.no)
     * +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
     * +     bugfix by: Howard Yeend
     * *     example 1: number_format(1234.5678, 2, '.', '');
     * *     returns 1: 1234.57
     */
    numberFormat(
      number: number,
      decimals: number,
      dec_point?: string,
      thousands_sep?: string,
    ): string;

    /**
     * Cleans a title, converting it to title case and replacing " :" with ":"
     *
     * @param {String} string
     * @param {Boolean} force Forces title case conversion, even if the capitalizeTitles pref is off
     * @type String
     */
    capitalizeTitle(str: string, force?: boolean): string;

    capitalize(str: string): string;

    /**
     * Replaces accented characters in a string with ASCII equivalents
     *
     * @param {String} str
     * @param {Boolean} [lowercaseOnly]  Limit conversions to lowercase characters
     *                                   (for improved performance on lowercase input)
     * @return {String}
     *
     * From http://lehelk.com/2011/05/06/script-to-remove-diacritics/
     */
    removeDiacritics(str: string, lowercaseOnly?: boolean): string;

    /**
     * Performs a deep copy of a JavaScript object
     * @param {Object} obj
     * @return {Object}
     */
    deepCopy(obj: object): _ZoteroTypes.anyObj;

    /**
     * Find valid creator types for a given item type
     *
     * @param {String} type Item type
     * @return {String[]} Creator types
     */
    getCreatorsForType(type: _ZoteroTypes.Item.ItemType): string[];

    /**
     * Determine whether a given field is valid for a given item type
     *
     * @param {String} field Field name
     * @param {String} type Item type
     * @type Boolean
     */
    fieldIsValidForType(
      field: string,
      type: _ZoteroTypes.Item.ItemType,
    ): boolean;

    /**
     * Gets a creator type name, localized to the current locale
     *
     * @param {String} type Creator type
     * @param {String} Localized creator type
     * @type Boolean
     */
    getLocalizedCreatorType(type: string): string | false;

    /**
     * Escapes metacharacters in a literal so that it may be used in a regular expression
     */
    quotemeta(literal: string): string;

    /**
     * Generate a random string of length 'len' (defaults to 8)
     **/
    randomString(len?: number, chars?: string): string;

    /**
     * Adds a string to a given array at a given offset, converted to UTF-8
     * @param {String} string The string to convert to UTF-8
     * @param {Array|Uint8Array} array The array to which to add the string
     * @param {Integer} [offset] Offset at which to add the string
     */
    stringToUTF8Array(str: string, array: Uint8Array, offset?: number): void;

    /**
     * Gets the byte length of the UTF-8 representation of a given string
     * @param {String} string
     * @return {Integer}
     */
    getStringByteLength(str: string): number;

    semverCompare(a: string, b: string): number;
    allowedKeyChars: "23456789ABCDEFGHIJKLMNPQRSTUVWXYZ";

    /**
     * Generates a valid object key for the server API
     */
    generateObjectKey(): string;

    /**
     * Check if an object key is in a valid format
     */
    isValidObjectKey(key: string): boolean;

    /**
     * Walk the DOM and the contents of JSON data attributes in the HTML representation
     * of a note, calling visitor functions that might modify it and returning
     * the resulting HTML.
     *
     * Elements are visited in depth-first order. First the element itself is visited,
     * then its data attributes, then the URIs in its JSON attributes, then its subtree.
     *
     * @param {String} note Note HTML
     * @param {Object} visitors
     * @param {Function} [visitors.visitContainer]
     * @param {Function} [visitors.visitAnnotation]
     * @param {Function} [visitors.visitCitation]
     * @param {Function} [visitors.visitOtherElement]
     * @param {Function} [visitors.visitDataAttribute]
     * @param {Function} [visitors.visitURI] Return a replacement for the passed URI
     * @return {String} Potentially modified note HTML
     */
    walkNoteDOM(
      note: string,
      visitors: {
        visitContainer?: Function;
        visitAnnotation?: Function;
        visitCitation?: Function;
        visitOtherElement?: Function;
        visitDataAttribute?: Function;
        visitURI?: Function;
      },
    ): string;

    /**
     * Evaluate an XPath
     *
     * @param {element|element[]} node The element(s) to use as the context for the XPath
     * @param {String} xstring The XPath expression
     * @param {Object} [namespaces] An object whose keys represent namespace prefixes, and whose
     *                              values represent their URIs
     * @return {element[]} DOM elements matching XPath
     */
    xpath(
      node: HTMLElement | Document,
      xstring: string,
      namespaces?: any,
    ): HTMLElement[] | [];

    /**
     * Input xpath string, find corresponding HTML elements value/textContent/innerText/text/nodeValue.
     * When node is an array of element, the returned output is obtained by concatenating
     * the string of each element, and the default separator is ', '.
     *
     * @param node The node representing the document and context
     * @param xstring, xpath The XPath expression
     * @param namespaces An object whose keys represent namespace prefixes, and whose values represent their URIs
     * @param delimiter The string with which to join multiple matching nodes
     * @returns DOM elements matching XPath, or null if no elements exist
     */
    xpathText(
      node: HTMLElement | Document,
      xstring: string,
      namespaces?: any,
      delimiter?: undefined | string,
    ): string | null;
  }
}

declare namespace Zotero {
  const Utilities: _ZoteroTypes.Utilities;
}


declare namespace _ZoteroTypes {
  namespace Utilities {
    /**
     * @class Utility functions not made available to translators
     */
    interface Internal {
      SNAPSHOT_SAVE_TIMEOUT: 30000;

      /**
       * Copy a text string to the clipboard
       */
      copyTextToClipboard(str: string): void;

      /**
       * Adapted from http://developer.mozilla.org/en/docs/nsICryptoHash
       *
       * @param	{String|nsIFile}	strOrFile
       * @param	{Boolean}			[base64=false]	Return as base-64-encoded string rather than hex string
       * @return	{String}
       */
      md5(strOrFile: string | nsIFile, base64?: boolean): string;

      /**
       * @param {OS.File|nsIFile|String} file  File or file path
       * @param {Boolean} [base64=FALSE]  Return as base-64-encoded string
       *                                  rather than hex string
       */
      md5Async(
        file: typeof OS.File | nsIFile | string,
        base64?: boolean,
      ): Promise<string>;

      /**
       * Adapted from http://developer.mozilla.org/en/docs/nsICryptoHash
       *
       * @param {String} str
       * @return	{String}
       */
      sha1(str: string): string;

      /**
       * Decode a binary string into a typed Uint8Array
       *
       * @param {String} data - Binary string to decode
       * @return {Uint8Array} Typed array holding data
       */
      _decodeToUint8Array(data: string): Uint8Array;

      /**
       * Decode a binary string to UTF-8 string
       *
       * @param {String} data - Binary string to decode
       * @return {String} UTF-8 encoded string
       */
      decodeUTF8(data: string): string;

      /**
       * Return the byte length of a UTF-8 string
       *
       * http://stackoverflow.com/a/23329386
       */
      byteLength(str: string): number;

      isOnlyEmoji(str: string): string;

      /**
       * Display a prompt from an error with custom buttons and a callback
       */
      errorPrompt(title: string, e: Error): void;

      saveDocument(doc: Document, destFile: string): Promise<void>;

      /**
       * Takes in a document, creates a JS Sandbox and executes the SingleFile
       * extension to save the page as one single file without JavaScript.
       *
       * @param {Object} document
       * @return {String} Snapshot of the page as a single file
       */
      snapshotDocument(doc: Document): string;

      createSnapshotSandbox(view: Window): unknown;

      /**
       * Launch a process
       * @param {nsIFile|String} cmd Path to command to launch
       * @param {String[]} args Arguments given
       * @return {Promise} Promise resolved to true if command succeeds, or an error otherwise
       */
      exec(cmd: string | nsIFile, args: string[]): Promise<true | Error>;

      /**
       * Get string data from the clipboard
       * @param {String[]} mimeType MIME type of data to get
       * @return {String|null} Clipboard data, or null if none was available
       */
      getClipboard(mimeType: string): string | null;

      /**
       * Determine if one Window is a descendant of another Window
       * @param {DOMWindow} suspected child window
       * @param {DOMWindow} suspected parent window
       * @return {boolean}
       */
      isIframeOf(childWindow: Window, parentWindow: Window): boolean;

      /**
       * Returns a DOMDocument object not attached to any window
       */
      getDOMDocument(): Document;

      /**
       * Update HTML links within XUL
       *
       * @param {HTMLElement} elem - HTML element to modify
       * @param {Object} [options] - Properties:
       *                                 .linkEvent - An object to pass to ZoteroPane.loadURI() to
       *                                 simulate modifier keys for link clicks. For example, to
       *                                 force links to open in new windows, pass with
       *                                 .shiftKey = true. If not provided, the actual event will
       *                                 be used instead.
       *                                 .callback - Function to call after launching URL
       */
      updateHTMLInXUL(
        elem: HTMLElement,
        options?: {
          updateHTMLInXUL?: unknown;
          shiftKey?: boolean;
          callback?: Function;
        },
      ): void;

      /**
       * Parse a Blob (e.g., as received from Zotero.HTTP.request()) into an HTML Document
       */
      blobToHTMLDocument(blob: Blob, url: string): Document;

      blobToText(blob: Blob, charset?: string): Promise<string>;

      /**
       * Converts Zotero.Item to a format expected by translators
       * This is mostly the Zotero web API item JSON format, but with an attachments
       * and notes arrays and optional compatibility mappings for older translators.
       *
       * @param {Zotero.Item} zoteroItem
       * @param {Boolean} legacy Add mappings for legacy (pre-4.0.27) translators
       * @return {Object}
       */
      itemToExportFormat(
        zoteroItem: Zotero.Item,
        legacy?: boolean,
        skipChildItems?: boolean,
      ): _ZoteroTypes.anyObj;

      /**
       * Find valid item fields in Extra field text
       *
       * There are a couple differences from citeproc-js behavior:
       *
       * 1) Key-value pairs can appear at the beginning of any line in Extra, not just the first two.
       * 2) For fields, the first occurrence of a valid field is used, not the last.
       *
       * @param {String} extra
       * @param {Zotero.Item} [item = null]
       * @param {String[]} [additionalFields] - Additional fields to skip other than those already
       *     on the provided item
       * @return {Object} - An object with 1) 'itemType', which may be null, 2) 'fields', a Map of
       *     field name to value, 3) 'creators', in API JSON syntax, and 4) 'extra', the remaining
       *     Extra string after removing the extracted values
       */
      extractExtraFields(
        extra: string,
        item?: Zotero.Item,
        additionalFields?: string[],
      ): {
        itemType?: _ZoteroTypes.Item.ItemType;
        fields: Map<keyof _ZoteroTypes.Item.ItemField, unknown>;
        creators: object;
        extra: string;
      };

      /**
       * @param {String} extra
       * @param {Map} fieldMap
       * @return {String}
       */
      combineExtraFields(
        extra: string,
        fieldMap: Map<keyof _ZoteroTypes.Item.ItemField, unknown>,
      ): string;

      _normalizeExtraKey(key: string): string;

      /**
       * Look for open-access PDFs for a given DOI using Zotero's Unpaywall mirror
       *
       * Note: This uses a private API. Please use Unpaywall directly for non-Zotero projects.
       *
       * @param {String} doi
       * @param {Object} [options]
       * @param {Number} [options.timeout] - Request timeout in milliseconds
       * @return {Object[]} - An array of objects with 'url' and/or 'pageURL' and 'version'
       *     ('submittedVersion', 'acceptedVersion', 'publishedVersion')
       */
      getOpenAccessPDFURLs(
        doi: string,
        options?: { timeout: number },
      ): Array<{
        url?: string;
        pageURL?: string;
        version: string;
      }>;

      /**
       * Run translation on a Document to try to find a PDF URL
       *
       * @param {doc} Document
       * @return {String|false} - PDF URL, or false if none found
       */
      getPDFFromDocument(doc: Document): string | false;

      /**
       * Hyphenate an ISBN based on the registrant table available from
       * https://www.isbn-international.org/range_file_generation
       * See isbn.js
       *
       * @param {String} isbn ISBN-10 or ISBN-13
       * @param {Boolean} dontValidate Do not attempt to validate check digit
       * @return {String} Hyphenated ISBN or empty string if invalid ISBN is supplied
       */
      hyphenateISBN(isbn: string, dontValidate?: boolean): string;

      camelToTitleCase(str: string): string;

      /**
       * Adds a localized colon to a string (which is usually just a colon, but, e.g., in French
       * there's a space before it)
       *
       * @param {String}
       * @return {String}
       */
      stringWithColon(str: string): string;

      resolveLocale(
        locale: _ZoteroTypes.AvailableLocales,
        locales: _ZoteroTypes.AvailableLocales[],
      ): _ZoteroTypes.AvailableLocales;

      /**
       * Get the next available numbered name that matches a base name, for use when duplicating
       *
       * - Given 'Foo' and ['Foo'], returns 'Foo 1'.
       * - Given 'Foo' and ['Foo', 'Foo 1'], returns 'Foo 2'.
       * - Given 'Foo' and ['Foo', 'Foo 1'], returns 'Foo 2'.
       * - Given 'Foo 1', ['Foo', 'Foo 1'], and trim=true, returns 'Foo 2'
       * - Given 'Foo' and ['Foo', 'Foo 2'], returns 'Foo 1'
       */
      getNextName(
        name: string,
        existingNames: string[],
        trim?: boolean,
      ): string;

      /**
       * Create a libraryOrCollection DOM tree to place in <menupopup> element.
       * If has no children, returns a <menuitem> element, otherwise <menu>.
       *
       * @param {Library|Collection} libraryOrCollection
       * @param {Node<menupopup>} elem Parent element
       * @param {Zotero.Library|Zotero.Collection} currentTarget Currently selected item (displays as checked)
       * @param {Function} clickAction function to execute on clicking the menuitem.
       * 		Receives the event and libraryOrCollection for given item.
       * @param {Function} disabledPred If provided, called on each library/collection
       * 		to determine whether disabled
       *
       * @return {Node<menuitem>|Node<menu>} appended node
       */
      createMenuForTarget(
        libraryOrCollection: Zotero.Library | Zotero.Collection,
        elem: XUL.MenuPopup,
        currentTarget: Zotero.Library | Zotero.Collection,
        clickAction: Function,
        disabledPred?: Function,
      ): XUL.MenuItem | XUL.Menu;

      openPreferences(paneID: string, options?: object): Window | null;
      filterStack(str: string): string;

      /**
       * Generate a function that produces a static output
       *
       * Zotero.lazy(fn) returns a function. The first time this function
       * is called, it calls fn() and returns its output. Subsequent
       * calls return the same output as the first without calling fn()
       * again.
       */
      lazy(fn: Function): Function;

      serial(fn: Function): Function;

      spawn(generator: GeneratorFunction, thisObj: object): Function;

      /**
       * Defines property on the object
       * More compact way to do Object.defineProperty
       *
       * @param {Object} obj Target object
       * @param {String} prop Property to be defined
       * @param {Object} desc Property descriptor. If not overridden, "enumerable" is true
       * @param {Object} opts Options:
       *   lazy {Boolean} If true, the _getter_ is intended for late
       *     initialization of the property. The getter is replaced with a simple
       *     property once initialized.
       */
      defineProperty(
        obj: object,
        prop: string,
        desc: object,
        opts?: { lazy: boolean },
      ): void;

      extendClass(superClass: object, newClass: object): void;

      /*
       * Flattens mixed arrays/values in a passed _arguments_ object and returns
       * an array of values -- allows for functions to accept both arrays of
       * values and/or an arbitrary number of individual values
       */
      flattenArguments(args: unknown[]): unknown[];

      /*
       * Sets font size based on prefs -- intended for use on root element
       *  (zotero-pane, note window, etc.)
       */
      setFontSize(rootElement: Element): void;

      getAncestorByTagName(elem: Element, tagName: string): Element | null;

      /**
       * Quits the program, optionally restarting.
       * @param {Boolean} [restart=false]
       */
      quit(restart?: boolean): void;

      /**
       * Assign properties to an object
       *
       * @param {Object} target
       * @param {Object} source
       * @param {String[]} [props] Properties to assign. Assign all otherwise
       */
      assignProps(target: object, source: object, props?: string[]): void;

      /**
       * Get the real target URL from an intermediate URL
       */
      resolveIntermediateURL(str: string): string;

      /**
       * Gets the icon for a JSON-style attachment
       */
      determineAttachmentIcon(
        attachment: object & { linkMode: string; mimeType: string },
      ): string;

      /**
       * A basic templating engine
       *
       * - 'if' statement does case-insensitive string comparison
       * - Spaces around '==' are necessary in 'if' statement
       *
       * Vars example:
       *  {
       * 	  color: '#ff6666',
       * 	  highlight: '<span class="highlight">This is a highlight</span>,
       *    comment: 'This is a comment',
       *    citation: '<span class="citation">(Author, 1900)</citation>',
       *    image: '<img src="…"/>',
       *    tags: (attrs) => ['tag1', 'tag2'].map(tag => tag.name).join(attrs.join || ' ')
       *  }
       *
       * Template example:
       *  {{if color == '#ff6666'}}
       *    <h2>{{highlight}}</h2>
       *  {{elseif color == '#2ea8e5'}}
       *    {{if comment}}<p>{{comment}}:</p>{{endif}}<blockquote>{{highlight}}</blockquote><p>{{citation}}</p>
       *  {{else}}
       *    <p>{{highlight}} {{citation}} {{comment}} {{if tags}} #{{tags join=' #'}}{{endif}}</p>
       *  {{endif}}
       *
       * @param {String} template
       * @param {Object} vars
       * @returns {String} HTML
       */
      generateHTMLFromTemplate(template: string, vars: object): string;

      sendToBack(): void;
      getProcessID: number;
      Base64: {
        encode(input: string): string;
        decode(input: string): string;
      };
      OpenURL: {
        /**
         * Returns a URL to look up an item in the OpenURL resolver
         */
        resolve(item: object): string | false;

        /**
         * Fetch list of resolvers from the Zotero wiki
         *
         * https://www.zotero.org/support/locate/openurl_resolvers
         */
        getResolvers(): Promise<
          Array<{
            continent: string;
            country: string;
            name: string;
            url: string;
            version: "1.0";
          }>
        >;
      };
    }
  }
}


/** @deprecated - use XUL element interfaces directly */
declare namespace XUL {
  interface IDisabled {
    disabled: boolean;
  }
  interface ICrop {
    crop: "start" | "end" | "center" | "none";
  }
  interface IValue {
    value: string;
  }
  interface ILabel {
    label: string;
  }
  interface ISelectedIndex {
    selectedIndex: number;
  }
  interface IProperties {
    properties: string;
  }

  /** @deprecated - use XULElement */
  interface Element extends XULElement {}

  /** @deprecated - use XULDescriptionElement */
  interface Description extends XULDescriptionElement {}

  /** @deprecated - use XULLabelElement */
  interface Label extends XULLabelElement {}

  /** @deprecated - use XULTextBoxElement */
  interface Textbox extends XULTextBoxElement {}

  /** @deprecated - use XULCheckboxElement */
  interface Checkbox extends XULCheckboxElement {}

  /** @deprecated - use XULRadioElement */
  interface Radio extends XULRadioElement {}

  /** @deprecated - use XULRadioGroupElement */
  interface RadioGroup extends XULRadioGroupElement {}

  /** @deprecated - use XULGroupBoxElement */
  interface GroupBox extends XULGroupBoxElement {}

  /** @deprecated - use XULStatusBarElement */
  interface StatusBar extends XULStatusBarElement {}

  /** @deprecated - use XULStatusBarPanelElement */
  interface StatusBarPanel extends XULStatusBarPanelElement {}

  /** @deprecated - use XULSeparatorElement */
  interface Separator extends XULSeparatorElement {}

  /** @deprecated - use XULSpacerElement */
  interface Spacer extends XULSpacerElement {}

  /** @deprecated - use XULProgressMeterElement */
  interface ProgressMeter extends XULProgressMeterElement {}

  /** @deprecated - use XULMenuBarElement */
  interface MenuBar extends XULMenuBarElement {}

  /** @deprecated - use XULMenuElement */
  interface Menu extends XULMenuElement {}

  /** @deprecated - use XULMenuPopupElement */
  interface MenuPopup extends XULMenuPopupElement {}

  /** @deprecated - use XULMenuItemElement */
  interface MenuItem extends XULMenuItemElement {}

  /** @deprecated - use XULMenuListElement */
  interface MenuList extends XULMenuListElement {}

  /** @deprecated - use XULMenuSeparatorElement */
  interface MenuSeparator extends XULMenuSeparatorElement {}

  /** @deprecated - use XULTooltipElement */
  interface Tooltip extends XULTooltipElement {}

  /** @deprecated - use XULToolBoxElement */
  interface ToolBox extends XULToolBoxElement {}

  /** @deprecated - use XULToolBarElement */
  interface ToolBar extends XULToolBarElement {}

  /** @deprecated - use XULToolBarPaletteElement */
  interface ToolBarPalette extends XULToolBarPaletteElement {}

  /** @deprecated - use XULToolBarSetElement */
  interface ToolBarSet extends XULToolBarSetElement {}

  /** @deprecated - use XULToolBarButtonElement */
  interface ToolBarButton extends XULToolBarButtonElement {}

  /** @deprecated - use XULToolBarItemElement */
  interface ToolBarItem extends XULToolBarItemElement {}

  /** @deprecated - use XULToolBarSeparatorElement */
  interface ToolBarSeparator extends XULToolBarSeparatorElement {}

  /** @deprecated - use XULToolBarSpacerElement */
  interface ToolBarSpacer extends XULToolBarSpacerElement {}

  /** @deprecated - use XULToolBarSpringElement */
  interface ToolBarSpring extends XULToolBarSpringElement {}

  /** @deprecated - use XULToolBarGrippyElement */
  interface ToolBarGrippy extends XULToolBarGrippyElement {}

  /** @deprecated - use XULBoxElement */
  interface Box extends XULBoxElement {}

  /** @deprecated - use XULDeckElement */
  interface Deck extends XULDeckElement {}

  /** @deprecated - use XULTabElement */
  interface Tab extends XULTabElement {}

  /** @deprecated - use XULTabsElement */
  interface Tabs extends XULTabsElement {}

  /** @deprecated - use XULTabPanelElement */
  interface TabPanel extends XULTabPanelElement {}

  /** @deprecated - use XULTabPanelsElement */
  interface TabPanels extends XULTabPanelsElement {}

  /** @deprecated - use XULTabBoxElement */
  interface TabBox extends XULTabBoxElement {}

  /** @deprecated - use XULButtonElement */
  interface Button extends XULButtonElement {}

  /** @deprecated - use XULListItemElement */
  interface ListItem extends XULListItemElement {}

  /** @deprecated - use XULTreeSeparatorElement */
  interface TreeSeparator extends XULTreeSeparatorElement {}

  /** @deprecated - use XULTreeRowElement */
  interface TreeRow extends XULTreeRowElement {}

  /** @deprecated - use XULTreeCellElement */
  interface TreeCell extends XULTreeCellElement {}

  /** @deprecated - use XULTreeItemElement */
  interface TreeItem extends XULTreeItemElement {}

  /** @deprecated - use XULTreeChildrenElement */
  interface TreeChildren extends XULTreeChildrenElement {}

  /** @deprecated - use XULTreeColElement */
  interface TreeCol extends XULTreeColElement {}

  /** @deprecated - use XULTreeColsElement */
  interface TreeCols extends XULTreeColsElement {}

  /** @deprecated - use XULTreeElement */
  interface Tree extends XULTreeElement {}

  /** @deprecated - use XULScrollBarElement */
  interface ScrollBar extends XULScrollBarElement {}

  /** @deprecated - use XULGrippyElement */
  interface Grippy extends XULGrippyElement {}

  /** @deprecated - use XULSplitterElement */
  interface Splitter extends XULSplitterElement {}

  /** @deprecated - use XULColorPickerElement */
  interface ColorPicker extends XULColorPickerElement {}

  /** @deprecated - use XULCommandElement */
  interface Command extends XULCommandElement {}

  /** @deprecated - use XULWindowElement */
  interface XULWindow extends XULWindowElement {}

  /** @deprecated - use Event */
  interface XULEvent extends Event {}
}

declare interface XULElement
  extends Element,
    ElementCSSInlineStyle,
    GlobalEventHandlers,
    HTMLOrForeignElement,
    OnErrorEventHandlerForNodes,
    TouchEventHandlers {
  width: number | string;
  height: number | string;
  top: number | string;
  left: number | string;
  flex: number | string;
  align: "start" | "center" | "end" | "baseline" | "stretch";
}

declare interface XULDescriptionElement
  extends XULElement,
    XUL.IDisabled,
    XUL.ICrop,
    XUL.IValue {
  control: string;
}

declare interface XULLabelElement extends XULElement, XUL.Description {}

declare interface XULTextBoxElement
  extends XULElement,
    XUL.IValue,
    XUL.ILabel,
    XUL.IDisabled {
  readOnly: boolean;
  maxLength: number;
  clickSelectsAll: boolean;
  defaultValue: string;
  selectionStart: number;
  selectionEnd: number;
  type: "autocomplete" | "number" | "password" | "search";
  placeholder: string;
  size: number;
  readonly inputField: HTMLInputElement;
  reset(): void;
  select(): void;
  setSelectionRange(start: number, end: number): void;
}

declare interface XULCheckboxElement
  extends XULElement,
    XUL.ILabel,
    XUL.IDisabled {
  checked: boolean;
}

declare interface XULRadioElement
  extends XULElement,
    XUL.ILabel,
    XUL.IDisabled {
  selected: boolean;
  command: XUL.Command;
}

declare interface XULRadioGroupElement
  extends XULElement,
    XUL.IDisabled,
    XUL.IValue,
    XUL.ISelectedIndex {
  selectedIndex: number;
  selectedItem: XULRadioElement;
  appendItem(label: string, value?: string): XULRadioElement;
  insertItemAt(index: number, label: string, value?: string): XULRadioElement;
  removeItemAt(index: number): XULRadioElement;
}

declare interface XULGroupBoxElement
  extends XULElement,
    XUL.ICrop,
    XUL.ILabel {}

declare interface XULStatusBarElement extends XULElement {}

declare interface XULStatusBarPanelElement extends XULElement, XUL.ILabel {}

declare interface XULSeparatorElement extends XULElement {}

declare interface XULSpacerElement extends XULElement {}

declare interface XULProgressMeterElement extends XULElement {
  mode: "determined" | "undetermined";
  value: number;
}

declare interface XULMenuBarElement extends XULElement {}

declare interface XULMenuElement extends XULElement, XUL.IValue {}

declare interface XULPopupElement extends XULElement {
  // @ts-ignore - Override XULElement open property
  position:
    | "after_start"
    | "after_end"
    | "before_start"
    | "before_end"
    | "end_after"
    | "end_before"
    | "start_after"
    | "start_before"
    | "overlap"
    | "at_pointer"
    | "after_pointer";

  /**
   * This read only property indicates whether the popup is open or not. Four values are possible:
   * - closed: The popup is closed and not visible.
   * - open: The popup is open and visible on screen.
   * - showing: A request has been made to open the popup, but it has not yet been shown. This state will occur during the popupshowing event.
   * - hiding: The popup is about to be hidden. This state will occur during the popuphiding event.
   */
  // @ts-ignore - Override XULElement state property
  readonly state: "closed" | "open" | "showing" | "hiding";
}

declare interface XULMenuPopupElement extends XULPopupElement {}

declare interface XULMenuItemElement
  extends XULElement,
    XUL.ICrop,
    XUL.IValue,
    XUL.ILabel,
    XUL.IDisabled {
  command: string | XUL.Command;
  allowEvents: boolean;
  selected: boolean;
}

declare interface XULMenuListElement
  extends XULElement,
    XUL.ICrop,
    XUL.IValue,
    XUL.IDisabled,
    XUL.ILabel,
    XUL.ISelectedIndex {
  selectedItem: XULMenuItemElement;
  itemCount: number;
  description: string;
  open: false;
  readonly inputField: XULTextBoxElement;

  getItemAtIndex(i: number): XUL.MenuItem;
  appendItem: (
    label: string,
    value?: string,
    description?: string,
  ) => XUL.MenuItem;
  insertItemAt: (
    index: number,
    label: string,
    value?: string,
    description?: string,
  ) => XUL.MenuItem;
}

declare interface XULMenuSeparatorElement extends XULElement {}

declare interface XULTooltipElement extends XULPopupElement, XUL.ILabel {}

declare interface XULToolBoxElement extends XULElement {}

declare interface XULToolBarElement extends XULElement {}

declare interface XULToolBarPaletteElement extends XULElement {}

declare interface XULToolBarSetElement extends XULElement {}

declare interface XULToolBarButtonElement extends XULButtonElement {}

declare interface XULToolBarItemElement extends XULElement {}

declare interface XULToolBarSeparatorElement extends XULElement {}

declare interface XULToolBarSpacerElement extends XULSpacerElement {}

declare interface XULToolBarSpringElement extends XULElement {}

declare interface XULToolBarGrippyElement extends XULGrippyElement {}

declare interface XULBoxElement extends XULElement, XUL.ICrop {
  orient: "horizontal" | "vertical";
  pack: "start" | "center" | "end";
  maxHeight: number;
  minHeight: number;
  maxWidth: number;
  minWidth: number;
}

declare interface XULDeckElement extends XULElement, XUL.ISelectedIndex {
  selectedPanel: XULElement;
  selectedIndex: number;
}

declare interface XULTabElement extends XULElement {
  readonly selected: boolean;
  readonly control: XULTabsElement;
}

declare interface XULTabsElement extends XULElement, XUL.ISelectedIndex {
  itemCount: number;
  selectedItem: XULTabElement;

  /**
   * @param dir
   * If the argument dir is set to 1, the currently selected tab changes to the next tab.
   * If the argument dir is set to -1, the currently selected tab changes to the previous tab.
   * @param wrap
   * If the wrap argument is true, the adjustment will wrap around when the first or last tab is reached.
   */
  advanceSelectedTab(dir: number, wrap: boolean): void;

  /**
   * Creates a new item and adds it to the end of the existing list of items.
   * You may optionally set a value.
   * @returns The function returns the newly created element.
   */
  appendItem(label: string, value: string): XULTabElement;

  /**
   * This method creates a new item and inserts it at the specified position.
   * You may optionally set a value.
   * @returns The new item element is returned.
   */
  insertItemAt(index: number, label: string, value: string): XULTabElement;

  /**
   * Removes the child item in the element at the specified index.
   * @returns The method returns the removed item.
   */
  removeItemAt(index: number): XULTabElement;
}

declare interface XULTabPanelElement extends XULElement {}

declare interface XULTabPanelsElement extends XULElement, XUL.ISelectedIndex {
  selectedPanel: XULElement;
}

declare interface XULTabBoxElement extends XULElement, XUL.ISelectedIndex {
  handleCtrlPageUpDown: boolean;
  handleCtrlTab: boolean;
  accessibleType: number;
  selectedPanel: Element;
  selectedTab: XULTabElement;
  tabs: XULTabsElement;
  tabpanels: XULTabPanelsElement;
}

declare interface XULButtonElement
  extends XULElement,
    XUL.IDisabled,
    XUL.ICrop,
    XUL.ILabel {
  checked: boolean;
  type: string;
  tooltiptext: string;
  autoCheck: boolean;
  checkState: number;
  dlgType: string;
  group: string;
  open: boolean;
}

declare interface XULListItemElement extends XULElement {
  selectedItem: XULElement;
}

/**
 * Used to place a seperator row in a tree.
 */
declare interface XULTreeSeparatorElement extends XULElement, XUL.IProperties {}

/**
 * A single row in a tree. It should be placed inside a treeitem element.
 * Children of the treerow should be treecell elements.
 * If child rows are necessary, they should be placed in a treechildren element inside the parent treeitem.
 */
declare interface XULTreeRowElement extends XULElement, XUL.IProperties {}

/**
 * A single cell in a tree. This element should be placed inside a treerow.
 * You can set the text for the cell using the label attribute.
 */
declare interface XULTreeCellElement
  extends XULElement,
    XUL.IProperties,
    XUL.ILabel {
  mode: "none" | "normal" | "undetermined";
}

/**
 * A treeitem should be placed inside a treechildren element and should contain treerow elements.
 * The treeitem can be clicked by the user to select the row of the tree.
 * The treeitem contains a single row and all of what appear to the user as that row's descendants.
 */
declare interface XULTreeItemElement extends XULElement, XUL.ILabel {
  open: boolean;
}

/**
 * This element is the body of the tree. For content trees, the content will be placed inside this element.
 * This element is also used to define container rows in the tree.
 */
declare interface XULTreeChildrenElement extends XULElement {
  alternatingbackground: boolean;
}

/**
 * A column of a tree.
 * It displays the column header and holds the size and other information about the column.
 * You can also place splitter elements between the columns to allow column resizing.
 * You should always place an id attribute on a treecol element to ensure that the column positioning is handled properly.
 */
declare interface XULTreeColElement extends XULElement, XUL.ICrop, XUL.ILabel {
  cycler: boolean;
  dragging: boolean;
  fixed: boolean;
  hideheader: boolean;
  ignoreincolumnpicker: boolean;
  primary: boolean;
  src: string;
  type: "checkbox" | "progressmeter" | "text";
}

/**
 * A group of treecol elements. There should one and only one treecols element in a tree.
 */
declare interface XULTreeColsElement extends XULElement, XUL.ILabel {
  pickertooltiptext: string;
}

declare interface XULTreeElement extends XULElement {
  disableKeyNavigation: boolean;
  enableColumnDrag: boolean;
  hidecolumnpicker: boolean;
  rows: number;
  selstyle: string;
  seltype: "single" | "multiple";
  currentIndex: number;
  firstOrdinalColumn: XULTreeColElement;
}

declare interface XULScrollBarElement extends XULElement {}

declare interface XULGrippyElement extends XULElement {}

declare interface XULSplitterElement extends XULElement {}

declare interface XULColorPickerElement extends XULElement, XUL.IDisabled {
  color: string;
}

declare interface XULCommandElement extends XULElement, XUL.ILabel {}

// @ts-ignore - Allow extending native Window
declare interface XULWindowElement extends XULElement, Window {
  arguments: any;
  title: string;
  onclose(): any;
}

declare interface GlobalEventHandlers {
  oncommand: ((this: GlobalEventHandlers, ev: Event) => any) | null;
}


declare namespace Zotero {
  /**
   * Debug logging function
   *
   * Uses prefs e.z.debug.log and e.z.debug.level (restart required)
   *
   * @param {} message
   * @param {Integer} [level=3]
   * @param {Integer} [maxDepth]
   * @param {Boolean|Integer} [stack] Whether to display the calling stack.
   *   If true, stack is displayed starting from the caller. If an integer,
   *   that many stack levels will be omitted starting from the caller.
   */
  function debug(
    message: any,
    level?: number,
    maxDepth?: number,
    stack?: number | boolean,
  ): void;

  /**
   * Log a message to the Mozilla JS error console
   *
   * |type| is a string with one of the flag types in nsIScriptError:
   *    'error', 'warning', 'exception', 'strict'
   */
  function log(
    message: any,
    type?: "error" | "warning" | "exception" | "strict",
    sourceName?: string,
    sourceLine?: string | number,
    lineNumber?: number,
    columnNumber?: number,
  ): void;

  /**
   * Log a JS error to the Mozilla error console and debug output
   * @param {Exception} err
   */
  function logError(err: Error): void;

  function warn(err: Error): void;

  /**
   * Display an alert in a given window
   *
   * @param {Window}
   * @param {String} title
   * @param {String} msg
   */
  function alert(window: Window, title: string, msg: string): void;

  function getMainWindow(): _ZoteroTypes.MainWindow;
  function getMainWindows(): _ZoteroTypes.MainWindow[];
  function getZoteroPanes(): _ZoteroTypes.ZoteroPane[];
  function getActiveZoteroPane(): _ZoteroTypes.ZoteroPane;
  function getStorageDirectory(): nsIFile;
  const setFontSize: typeof Utilities.Internal.setFontSize;
  const flattenArguments: typeof Utilities.Internal.flattenArguments;
  const getAncestorByTagName: typeof Utilities.Internal.getAncestorByTagName;
  const startupErrorHandler: () => void | undefined;
  const appName: string;
  const clientName: string;
  const resourcesDir: string;
  const locale: keyof _ZoteroTypes.AvailableLocales;
  const dir: "ltr" | "rtl";
  const platform: string;
  const platformMajorVersion: number;
  const version: string;
  const isMac: boolean;
  const isWin: boolean;
  const isLinux: boolean;
  const initialized: boolean;
  const skipLoading: boolean;
  const hiDPISuffix: string;
  const hiDPI: boolean;

  const initializationPromise: Promise<void>;
  const unlockPromise: Promise<void>;
  const uiReadyPromise: Promise<void>;
  const proxyAuthComplete: Promise<void>;

  /**
   * @property {Boolean} crashed - True if the application needs to be restarted
   */
  const crashed: boolean;

  /**
   * @property	{Boolean}	closing		True if the application is closing.
   */
  const closing: boolean;

  /**
   * @property	{Boolean}	locked		Whether all Zotero panes are locked
   *										with an overlay
   */
  const locked: boolean;

  /**
   * Initialize the extension
   *
   * @return {Promise<Boolean>}
   */
  function init(options?: object): Promise<boolean>;

  /**
   * Shuts down Zotero, calls a callback (that may return a promise),
   * then reinitializes Zotero. Returns a promise that is resolved
   * when this process completes.
   */
  function reinit(cbk: Function, options?: object): void | Promise<void>;

  /**
   * Triggers events when initialization finishes
   */
  function initComplete(): void;

  function uiIsReady(): void;
  function shutdown(): Promise<void>;
  function getProfileDirectory(): nsIFile;
  function getZoteroDirectory(): nsIFile;
  function getZoteroDatabase(): nsIFile;
  function getStylesDirectory(): nsIFile;
  function getTranslatorsDirectory(): nsIFile;
  function getTempDirectory(): nsIFile;
  function removeTempDirectory(): Promise<boolean>;

  function openMainWindow(): void;
  function openCheckForUpdatesWindow(): void;

  /**
   * Launch a file, the best way we can
   */
  function launchFile(file: string): void;

  /**
   * Launch a file with the given application
   */
  function launchFileWithApplication(
    filePath: string,
    applicationPath: string,
  ): void;

  /**
   * Launch a URL externally, the best way we can
   */
  function launchURL(url: string): void;

  /**
   * Opens a URL in the basic viewer, and optionally run a callback on load
   *
   * @param {String} uri
   * @param {Object} [options]
   * @param {Function} [options.onLoad] - Function to run once URI is loaded; passed the loaded document
   * @param {Object} [options.cookieSandbox] - Attach a cookie sandbox to the browser
   * @param {Boolean} [options.allowJavaScript] - Set to false to disable JavaScript
   */
  function openInViewer(
    uri: string,
    options?: {
      onLoad?: (doc: Document) => void;
      cookieSandbox?: Zotero.CookieSandbox;
      allowJavaScript?: boolean;
    },
  ): void;

  /**
   * Display an error message saying that an error has occurred and Zotero needs to be restarted.
   *
   * If |popup| is TRUE, display in popup progress window; otherwise, display as items pane message
   */
  function crash(popup?: boolean): void;

  function getErrors(asStrings?: false): unknown[];
  function getErrors(asStrings: true): string[];

  function isWin64EmulatedOnArm(): boolean;

  /**
   * Get versions, platform, etc.
   */
  function getSystemInfo(): Promise<string>;

  function getOSVersion(): Promise<string>;

  /**
   * @return {Promise<String[]>} - Promise for an array of extension names and versions
   */
  function getInstalledExtensions(): Promise<string[]>;

  const getString: typeof Intl.getString;

  function defineProperty(
    obj: object,
    prop: string,
    desc: object,
    opts?: { lazy: boolean },
  ): void;
  function extendClass(superClass: object, newClass: object): void;

  function getLocaleCollation(): Intl.Collator;
  function localeCompare(a: string, b: string): number;
  function randomString(len?: number, chars?: string): string;
  const lazy: typeof Utilities.Internal.lazy;
  const serial: typeof Utilities.Internal.serial;
  /**
   * @deprecated Removed in fx140 (Zotero 8.0)
   */
  const spawn: typeof Utilities.Internal.spawn;

  /**
   * Emulates the behavior of window.setTimeout
   *
   * @param {Function} func			The function to be called
   * @param {Integer} ms				The number of milliseconds to wait before calling func
   * @return {Integer} - ID of timer to be passed to clearTimeout()
   */
  function setTimeout(func: Function, ms: number): number;

  function clearTimeout(id: number): void;

  /**
   * Show Zotero pane overlay and progress bar in all windows
   *
   * @param {String} msg
   * @param {Boolean} [determinate=false]
   * @param {Boolean} [modalOnly=false] - Don't use popup if Zotero pane isn't showing
   * @return	{void}
   */
  function showZoteroPaneProgressMeter(
    msg: string,
    determinate?: boolean,
    modalOnly?: boolean,
  ): void;

  /**
   * @param	{Number}	percentage		Percentage complete as integer or float
   */
  function updateZoteroPaneProgressMeter(percentage: number): void;

  /**
   * Hide Zotero pane overlay in all windows
   */
  function hideZoteroPaneOverlays(): void;

  /**
   * Adds a listener to be called when Zotero shuts down (even if Firefox is not shut down)
   */
  function addShutdownListener(listener: Function): void;

  function updateQuickSearchBox(doc: Document): void;

  /**
   * Clear entries that no longer exist from various tables
   */
  function purgeDataObjects(): Promise<void>;

  function reloadDataObjects(): Promise<void>;

  /**
   * Brings Zotero Standalone to the foreground
   */
  function activateStandalone(): void;

  const Locale: {
    readonly availableLocales: _ZoteroTypes.AvailableLocales;
    defaultScriptDirection(
      locale: _ZoteroTypes.AvailableLocales,
    ): "ltr" | "rtl";
  };

  const Intl: {
    strings: {
      [key: string]: string;
    };

    collation: {
      compareString: (_: number, a: string, b: string) => number;
    };

    /**
     * @param {String} name
     * @param {String[]} [params=[]] - Strings to substitute for placeholders
     * @param {Number} [num] - Number (also appearing in `params`) to use when determining which plural
     *     form of the string to use; localized strings should include all forms in the order specified
     *     in https://developer.mozilla.org/en-US/docs/Mozilla/Localization/Localization_and_Plurals,
     *     separated by semicolons
     */
    getString: (
      name: string,
      params?: string | string[],
      num?: number,
    ) => string;
  };
}

// Below are not implemented types
declare namespace Zotero {
  let API: any;
  let Cite: any;
  let Debug: any;
  let Integration: any;
  let ItemFields: any;
  let PDFWorker: any;
  let QuickCopy: any;
  let Schema: any;
  let SearchConditions: any;
  let Styles: any;
  let Sync: any;
  let Translate: any;
  let Translators: any;
}

declare namespace _ZoteroTypes {
  /**
   * @example
   * var Zotero: _ZoteroConstructable = Components.classes[
   *  "@zotero.org/Zotero;1"
   * ].getService(Components.interfaces.nsISupports).wrappedJSObject;
   */
  type _ZoteroConstructable = typeof Zotero;
  type Zotero = _ZoteroConstructable;

  interface AvailableLocales {
    ar: "عربي";
    "bg-BG": "Български";
    br: "brezhoneg";
    "ca-AD": "Català";
    "cs-CZ": "Čeština";
    "da-DK": "Dansk";
    de: "Deutsch";
    "el-GR": "Ελληνικά";
    "en-AU": "English (Australian)";
    "en-CA": "English (Canada)";
    "en-US": "English";
    "en-GB": "English (UK)";
    "en-NZ": "English (New Zealand)";
    "es-ES": "Español";
    "et-EE": "Eesti keel";
    "eu-ES": "Euskara";
    fa: "فارسی";
    "fi-FI": "suomi";
    "fr-FR": "Français";
    "gl-ES": "Galego";
    "hu-HU": "magyar";
    "id-ID": "Bahasa Indonesia";
    "is-IS": "íslenska";
    "it-IT": "Italiano";
    "ja-JP": "日本語";
    km: "ខ្មែរ";
    "ko-KR": "한국어";
    "lt-LT": "Lietuvių";
    "nl-NL": "Nederlands";
    "nb-NO": "Norsk bokmål";
    "pl-PL": "Polski";
    "pt-BR": "Português (do Brasil)";
    "pt-PT": "Português (Europeu)";
    "ro-RO": "Română";
    "ru-RU": "Русский";
    "sk-SK": "slovenčina";
    "sl-SI": "Slovenščina";
    "sr-RS": "Српски";
    "sv-SE": "Svenska";
    "th-TH": "ไทย";
    "tr-TR": "Türkçe";
    "uk-UA": "Українська";
    "vi-VN": "Tiếng Việt";
    "zh-CN": "中文 (简体)";
    "zh-TW": "正體中文 (繁體)";
  }
}


declare namespace _ZoteroTypes {
  class ZoteroContextPane {
    readonly activeEditor?: Zotero.EditorInstance;
    readonly sidenav: XULElement;
    readonly splitter: XULElement;
    showLoadingMessage(isShow: boolean): void;
    init(): void;
    destroy(): void;
    update(): void;
    focus(): void;
    togglePane(): void;
    updateAddToNote(): void;
  }
}


// chrome/content/zotero/zoteroPane.js

declare namespace _ZoteroTypes {
  class ZoteroPane {
    [attr: string]: any;
    document: Document & { body: null; head: null };
    collectionsView: CollectionTree | false;
    itemsView: ItemTree | false;
    itemPane: ItemPane | false;
    progressWindow: Zotero.ProgressWindow | false;

    newCollection(parentKey: string): Promise<undefined | Zotero.Collection>;
    openAdvancedSearchWindow(): void;
    updateTagFilter(): Promise<undefined>;
    toggleTagSelector(): void;
    tagSelectorShown(): undefined | boolean;
    getSelectedLibraryID(): number;
    getSelectedGroup(): Zotero.Collection;
    getSelectedGroup(asID: boolean): Zotero.Collection | number;
    getSelectedSavedSearch(): Zotero.Collection;
    getSelectedSavedSearch(asID: boolean): Zotero.Collection | number;
    getSelectedCollection(asID?: false): Zotero.Collection | undefined;
    getSelectedCollection(asID: true): number | undefined;
    selectItem(itemID: number, inLibraryRoot?: boolean): undefined | boolean;
    selectItems: (
      itemIDs: Array<number>,
      inLibraryRoot?: boolean,
    ) => Promise<undefined | boolean>;
    copySelectedItemsToClipboard(asCitations: boolean): void;
    refreshFeed(): undefined | Promise<any>;
    emptyTrash(): Promise<void>;
    mergeSelectedItems(): void;
    deleteSelectedCollection(deleteItems: boolean): void | Promise<void>;
    duplicateSelectedItem(): Promise<Zotero.Item>;
    duplicateAndConvertSelectedItem(): Promise<Zotero.Item | boolean>;
    restoreSelectedItems(): Promise<void>;
    updateNoteButtonMenu(): Promise<void>;
    getCollectionTreeRow(): undefined | CollectionTree;
    showOriginalItem(): void;
    search(runAdvanced: boolean): Promise<void>;
    sync(): void;
    showSetUpSyncReminder(): void;
    showAutoSyncReminder(): void;
    displayCannotEditLibraryMessage(): void;
    displayCannotEditLibraryFilesMessage(): void;
    displayCannotAddToMyPublicationsMessage(): void;
    displayCannotAddShortcutMessage(path?: string): void;
    recognizeSelected(): void;
    unrecognizeSelected(): Promise<void>;
    createParentItemsFromSelected(): Promise<void | false>;
    addNoteFromAnnotationsForAttachment: (
      attachment: Zotero.Item,
      opt?: { skipSelect?: boolean },
    ) => Promise<Zotero.Item>;
    createStandaloneNoteFromAnnotationsFromSelected(): Promise<void>;
    createEmptyParent(item: Zotero.Item): Promise<void>;
    exportPDF(itemID: number): Promise<void>;
    exportSelectedFiles(): Promise<void>;
    renameSelectedAttachmentsFromParents(): Promise<boolean>;
    convertLinkedFilesToStoredFiles(): Promise<void>;
    relinkAttachment(itemID: number): Promise<void>;
    updateReadLabel(): void;
    reportErrors(): void;
    displayStartupError(): void;
    hideRetractionBanner(): void;
    getState(): { type: "pane"; tabs: _ZoteroTypes.TabInstance[] };
    updateWindow(): void;
    openAboutDialog(): void;
    setItemPaneMessage(content: XUL.Element | string): void;
    addSelectedItemsToCollection: (
      collection: Zotero.Collection | null,
      createNew?: boolean,
    ) => Promise<void>;
    attachmentsWithExtractableAnnotations: (
      item: Zotero.Item,
    ) => Array<Zotero.Item>;
    isAttachmentWithExtractableAnnotations(item: Zotero.Item): boolean;
    openNoteWindow(itemID: number, col?: number, parentKey?: string): void;
    viewPDF(
      itemID: number,
      location: _ZoteroTypes.Reader.Location,
    ): Promise<void>;
    showAttachmentInFilesystem: (
      itemID: number,
      noLocateOnMissing?: boolean,
    ) => Promise<void>;
    getSortField(): false | string;
    getSortDirection(): false | 1 | -1;

    /**
     * Set the tags scope to the items in the current view
     * Passed to the items tree to trigger on changes
     */
    setTagScope(): void;

    /**
     * @return {Promise<Boolean>} - Promise that resolves to true if an item was selected,
     *                              or false if not (used for tests, though there could possibly
     *                              be a better test for whether the item pane changed)
     */
    itemSelected(): Promise<boolean>;

    /**
     * Update the <command> elements that control the shortcut keys and the enabled state of the
     * "Copy Citation"/"Copy Bibliography"/"Copy as"/"Copy Note" menu options. When disabled, the shortcuts are
     * still caught in handleKeyPress so that we can show an alert about not having references selected.
     */
    updateQuickCopyCommands(selectedItems: Array<Zotero.Item>): void;

    /**
     * Return whether every selected item can be deleted from the current
     * collection context (library, trash, collection, etc.).
     *
     * @return {Boolean}
     */
    canDeleteSelectedItems(): boolean;

    /**
     * Check whether every selected item can be restored from trash
     *
     * @return {Boolean}
     */
    canRestoreSelectedItems(): boolean;

    /*
     * Remove, trash, or delete item(s), depending on context
     *
     * @param  {Boolean}  [force=false]     Trash or delete even if in a collection or search,
     *                                      or trash without prompt in library
     * @param  {Boolean}  [fromMenu=false]  If triggered from context menu, which always prompts for deletes
     */
    deleteSelectedItems(force?: boolean, fromMenu?: boolean): void;

    /**
     * Currently only works on searches
     */
    duplicateSelectedCollection(): Promise<void>;

    /**
     * Configure the UI and show the sync reminder panel for a given type of reminder
     *
     * @param {String} reminderType - Possible values: 'setUp' or 'autoSync'
     * @param {Object} [options]
     * @param {String} [options.learnMoreURL] - Show "Learn More" link to this URL
     */
    showSyncReminder: (
      reminderType: string,
      options?: { learnMoreURL: string },
    ) => void;

    /**
     * Hide the currently displayed sync reminder and update its associated
     * lastDisplayed time.
     */
    hideSyncReminder(): void;

    /**
     * Adds or removes a function to be called when Zotero is reloaded by switching into or out of
     * the connector
     */
    addReloadListener(func: Function): void;

    /**
     * Adds or removes a function to be called just before Zotero is reloaded by switching into or
     * out of the connector
     */
    addBeforeReloadListener(func: Function): void;

    /**
     * Moves around the toolbar when the user moves around the pane
     */
    updateToolbarPosition(): void;

    /**
     * Unserializes zotero-persist elements from preferences
     */
    unserializePersist(): void;

    /**
     * Serializes zotero-persist elements to preferences
     */
    serializePersist(): void;

    /**
     * Sets the layout to either a three-vertical-pane layout and a layout where itemsPane is above itemPane
     */
    updateLayout(): void;

    /**
     * Attempt to find a file in the LABD matching the passed attachment
     * by searching successive subdirectories. Prompt the user if a match is
     * found and offer to relink one or all matching files in the directory.
     * The user can also choose to relink manually, which opens a file picker.
     *
     * If the synced path is 'C:\Users\user\Documents\Dissertation\Files\Paper.pdf',
     * the LABD is '/Users/user/Documents', and the (not yet known) correct local
     * path is '/Users/user/Documents/Dissertation/Files/Paper.pdf', check:
     *
     * 1. /Users/user/Documents/Users/user/Documents/Dissertation/Files/Paper.pdf
     * 2. /Users/user/Documents/user/Documents/Dissertation/Files/Paper.pdf
     * 3. /Users/user/Documents/Documents/Dissertation/Files/Paper.pdf
     * 4. /Users/user/Documents/Dissertation/Files/Paper.pdf
     *
     * If line 4 had not been the correct local path (in other words, if no file
     * existed at that path), we would have continued on to check
     * '/Users/user/Documents/Dissertation/Paper.pdf'. If that did not match,
     * with no more segments in the synced path to drop, we would have given up.
     *
     * Once we find the file, check for other linked files beginning with
     * C:\Users\user\Documents\Dissertation\Files and see if they exist relative
     * to /Users/user/Documents/Dissertation/Files, and prompt to relink them
     * all if so.
     *
     * @param {Zotero.Item} item
     * @return {Promise<Boolean>} True if relinked successfully or canceled
     */
    checkForLinkedFilesToRelink(item: Zotero.Item): Promise<boolean>;

    /**
     * Add a single child note with the annotations from all selected items, including from all
     * child attachments of a selected regular item
     *
     * Selected items must all have the same top-level item
     */
    addNoteFromAnnotationsFromSelected(): Promise<void>;

    /**
     * Create separate child notes for each selected item, including all child attachments of
     * selected regular items
     *
     * No longer exposed via UI
     */
    addNotesFromAnnotationsFromSelected(): Promise<void>;

    /**
     * Prompt the user to relink one or all of the attachment files found in
     * the LABD.
     *
     * @param {Zotero.Item} item
     * @param {String} path Path to the file matching `item`
     * @param {Number} numOthers If zero, "Relink All" option is not offered
     * @return {'one' | 'all' | 'manual' | 'cancel'}
     */
    showLinkedFileFoundAutomaticallyDialog: (
      item: Zotero.Item,
      path: string,
      numOthers: number,
    ) => "one" | "all" | "manual" | "cancel";

    /**
     * Return an array of Item objects for selected items
     * If asIDs is true, return an array of itemIDs instead
     * @param {boolean} [asIDs = false]
     */
    getSelectedItems(asIDs?: false): Array<Zotero.Item>;
    getSelectedItems(asIDs: true): Array<number>;

    /**
     * Returns an array of Zotero.Item objects of visible items in current sort order
     *
     * If asIDs is true, return an array of itemIDs instead
     */
    getSortedItems(asIDs?: false): Array<Zotero.Item>;
    getSortedItems(asIDs: true): Array<number>;

    /**
     * Loads a URL following the standard modifier key behavior
     *  (e.g. meta-click == new background tab, meta-shift-click == new front tab,
     *  shift-click == new window, no modifier == frontmost tab
     */
    loadURI(uris: string | Array<string>): void;

    /**
     * @return {Promise<Integer|null|false>} - The id of the new note in non-popup mode, null in
     *     popup mode (where a note isn't created immediately), or false if library isn't editable
     */
    newNote: (
      popup?: boolean,
      parentKey?: string,
      text?: string,
      citeURI?: string,
    ) => Promise<number>;

    /**
     * Creates a child note for the selected item or the selected item's parent
     *
     * @return {Promise}
     */
    newChildNote(popup?: boolean): void;

    /**
     * @param	{Document} doc
     * @param	{String|Integer} [itemType='webpage']	Item type id or name
     * @param	{Boolean} [saveSnapshot] Force saving or non-saving of a snapshot,
     * regardless of automaticSnapshots pref
     * @return {Promise<Zotero.Item>|false}
     */
    addItemFromDocument: (
      doc: Document,
      itemType?: _ZoteroTypes.Item.ItemType,
      saveSnapshot?: boolean,
      row?: Zotero.Collection,
    ) => Promise<Zotero.Item> | false;

    /**
     * @param	{String|Integer} [itemType='webpage']	Item type id or name
     * @param	{Boolean} [saveSnapshot] Force saving or non-saving of a snapshot,
     * regardless of automaticSnapshots pref
     * @return {Zotero.Item|false} - The saved item, or false if item can't be saved
     */
    addItemFromURL: (
      url: string,
      itemType?: _ZoteroTypes.Item.ItemType,
      saveSnapshot?: boolean,
      row?: Zotero.Collection,
    ) => Promise<Zotero.Item> | false;

    /**
     * Test if the user can edit the currently selected view
     *
     * @param {Integer}	[row]
     *
     * @return  {Boolean}		TRUE if user can edit, FALSE if not
     */
    canEdit(row?: number): boolean;

    /**
     * Test if the user can edit the parent library of the selected view
     *
     * @param	{Integer}	[row]
     * @return	{Boolean}		TRUE if user can edit, FALSE if not
     */
    canEditLibrary(row?: number): boolean;

    /**
     * Test if the user can edit the currently selected library/collection
     *
     * @param	{Integer}	[row]
     *
     * @return	{Boolean}		TRUE if user can edit, FALSE if not
     */
    canEditFiles(row?: number): boolean;
  }
}


// chrome/content/zotero/tabs.js

declare namespace _ZoteroTypes {
  interface TabInstance {
    id: string;
    type: string;
    title: string;
    data?: any;
    selected?: boolean;
  }

  class Zotero_Tabs {
    readonly selectedID: string;
    readonly selectedType: string;
    readonly selectedIndex: number;
    readonly deck: XUL.Element;
    readonly numTabs: number;
    readonly tabsMenuList: XUL.Box;
    readonly tabsMenuPanel: XUL.Element;
    _tabsMenuFilter: string;
    _tabs: _ZoteroTypes.TabInstance[];

    _getTab(tabId: string): { tab: _ZoteroTypes.TabInstance; tabIndex: number };
    _update(): void;
    getTabIDByItemID(itemID: number): string;
    init(): void;
    getState(): _ZoteroTypes.TabInstance[];
    restoreState(tabs: _ZoteroTypes.TabInstance[]): void;
    add: (options: {
      id?: string;
      type: string;
      title: string;
      data?: any;
      index?: number;
      select?: boolean;
      onClose?: Function;
    }) => { id: string; container: XUL.Box };
    rename(id: string, title: string): void;
    updateLibraryTabIcon(): void;
    close(ids: string | string[]): void;
    closeAll(): void;
    undoClose(): void;
    move(id: string, newIndex: number): void;
    select(id: string, reopening?: boolean, options?: any): void;
    unload(id: string): void;
    unloadUnusedTabs(): void;
    selectPrev(): void;
    selectNext(): void;
    selectLast(): void;
    jump(index: number): void;
    _openMenu(x: number, y: number, id: string): void;
    _updateTabBar(): void;
    _showTabBar(): void;
    _hideTabBar(): void;

    /**
     * Create the list of opened tabs in tabs menu.
     */
    refreshTabsMenuList(): void;

    isTabsMenuVisible(): boolean;
  }
}

/**
 * Template-specific global variables for Better Notes templates
 * Based on the note template documentation
 */

// Shared environment variable for all templates
declare const _env: {
  /** True in preview mode (template editor), false during actual template execution */
  dryRun: boolean;
};

// === Item Template Variables ===

// Variables available in beforeloop stage
declare const items: Zotero.Item[];
declare const targetNoteItem: Zotero.Item | undefined;
declare const copyNoteImage: (noteItem: Zotero.Item) => void;
declare const sharedObj: Record<string, any>;

// Variables available in default stage (item loop)
declare const topItem: Zotero.Item;
declare const item: Zotero.Item;
/** @deprecated Use topItem instead */
declare const itemNotes: Zotero.Item[];

// Variables available in afterloop stage
// items, targetNoteItem, copyNoteImage, sharedObj (already declared above)

// === Text Template Variables ===
// targetNoteItem, sharedObj (already declared above)

// === Builtin Template Variables ===

// QuickInsertV3 template variables
declare const link: string;
declare const linkText: string;
declare const subNoteItem: Zotero.Item;
declare const noteItem: Zotero.Item;
declare const lineIndex: number;
declare const sectionName: string;

// QuickImportV2 template variables
// link, noteItem (already declared above)

// QuickNoteV5 template variables
declare const annotationItem: Zotero.Item;
// topItem, noteItem (already declared above)

// ExportMDFileNameV2 template variables
// noteItem (already declared above)

// ExportMDFileHeaderV2 template variables
// noteItem (already declared above)

// ExportMDFileContent template variables
declare const mdContent: string;
// noteItem (already declared above)

// ExportLatexFileContent template variables
declare const latexContent: string;
// noteItem (already declared above)
